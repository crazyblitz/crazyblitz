<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring AOP切点表达式用法总结</title>
      <link href="/2019/09/20/Spring-AOP%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2019/09/20/Spring-AOP%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>切点决定感兴趣的连接点。<strong>Spring框架通常最小粒度支持方法级别执行Spring Beans连接点通知(即作用于方法)，引介通知可以支持到字段级别的。</strong></p><ol><li><code>execution</code>:用于匹配方法连接点,是Spring AOP使用<strong><code>主要切入点指示符</code></strong>。支持<code>Ant表达式</code>风格。</li></ol><p><strong><code>execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)</code></strong></p><ul><li>modifiers-pattern：方法的可见性。如public,protected。</li><li>ret-type-pattern：方法的返回值类型。如int,void等。</li><li>declaring-type-pattern：方法所在类的全路径名。如com.spring.Aspect。</li><li>name-pattern:方法名类型。如buisinessService()。</li><li>param-pattern:方法的参数类型。如java.lang.String。</li><li>throws-pattern:方法抛出的异常类型,如java.lang.Exception。</li></ul><p>通配符:</p><ul><li><p><code>*</code>通配符：表示匹配单个任意单词。</p></li><li><p><code>..</code>通配符：表示匹配0个或者多个项。<code>主要用于declaring-type-pattern和param-pattern中</code>,如果用于<code>declaring-type-pattern中,则表示匹配当前包及其子包,如果用于param-pattern中</code>,<code>则表示匹配0个或多个参数.</code>  </p></li><li><blockquote><p>常用示例:execution(* com.ley.springboot.aop.service..*.*(..))</p></blockquote></li></ul><ol start="2"><li><strong><code>within</code>:表达式的粒度为类,其参数为全路径的类名(可使用通配符)。只能指定类级别。</strong></li></ol><p><code>within(declaring-type-pattern)</code>。</p><blockquote><ul><li>within(com.spring.service.BusinessObject)：匹配BusinessObject下所有方法。</li><li>within(com.spring.service.*)：匹配com.spring.service下所有类，不包含子包中的类。</li><li>within(com.spring.service..*)：匹配com.spring.service及其子包下所有类。</li></ul></blockquote><ol start="3"><li><strong><code>args</code>:匹配指定参数类型和指定参数数量的方法，无论其类路径或者方法名是什么。<code>args指定的参数必须是全路径的</code>。</strong>个人觉得不是很常用。</li></ol><p><code>args(param-pattern)</code>。参数表达式可以使用通配符<code>..</code>，不能使用<code>*</code>。</p><blockquote><p>args(java.lang.String,..,java.lang.Integer)：匹配第一个参数为java.lang.String，最后一个参数为java.lang.Integer，中间参数任意个数和类型。</p></blockquote><ol start="4"><li><strong><code>this和target</code></strong></li></ol><p>this和target表达式<code>都只能指定类或者接口</code>。<code>this</code>表示匹配<code>当前切点表达式所指代方法对象</code>,<code>target</code>匹配</p><p><code>表达式指定类型的对象</code>。</p><p>Spring中,对<code>this</code>语义是<code>如果当前对象生成代理对象符合this指定类型</code>,将其织入切面逻辑<strong>。<code>this</code>匹配代理</strong></p><p><strong>对象为指定类型的类。<code>target</code>匹配业务对象为指定类型的类。</strong></p><ul><li>如果目标对象被代理的方法是实现某个接口方法,将默认被JDK代理生成代理对象。此时代理对象和目标</li></ul><p>对象是两个对象,并且都实现了该接口。</p><ul><li>如果目标对象是一个类,并且其没有实现任意接口,那么将会使用Cglib代理生成代理对象,并且只会生成一个对象,即Cglib生成的代理类的对象。</li></ul><p><strong><code>this</code>和<code>target</code>区别:</strong></p><ul><li>this(SomeInterface)或target(SomeInterface)：这种情况下，无论是对于Jdk代理还是Cglib代理，其目标对象和代理对象都是实现SomeInterface接口的（Cglib生成的目标对象的子类也是实现了SomeInterface接口的），因而this和target语义都是符合的，此时这两个表达式的效果一样；</li><li>this(SomeObject)或target(SomeObject)，这里SomeObject没实现任何接口：这种情况下，Spring会使用Cglib代理生成SomeObject的代理类对象，由于代理类是SomeObject的子类，子类的对象也是符合SomeObject类型的，因而this将会被匹配，而对于target，由于目标对象本身就是SomeObject类型，因而这两个表达式的效果一样；</li><li>this(SomeObject)或target(SomeObject)，这里SomeObject实现了某个接口：对于这种情况，虽然表达式中指定的是一种具体的对象类型，但由于其实现了某个接口，因而Spring默认会使用Jdk代理为其生成代理对象，Jdk代理生成的代理对象与目标对象实现的是同一个接口，但代理对象与目标对象还是不同的对象，由于代理对象不是SomeObject类型的，因而此时是不符合this语义的，而由于目标对象就是SomeObject类型，因而target语义是符合的，此时this和target的效果就产生了区别；这里如果强制Spring使用Cglib代理，因而生成的代理对象都是SomeObject子类的对象，其是SomeObject类型的，因而this和target的语义都符合，其效果就是一致的。</li></ul><ol start="5"><li><strong><code>@annotation:表示匹配使用@annotation指定注解标注的方法将会环绕。</code></strong></li></ol><p><code>@annotation(annotation-type)</code></p><ol start="6"><li><strong><code>@within:匹配带有指定注解的类。</code></strong></li></ol><p><code>@within(annotation-type)</code></p><ol start="7"><li><p><strong><code>@args:表示使用指定注解标注的类作为某个方法的参数时该方法将会被匹配</code></strong></p><p><code>@args(annotation-type)</code></p></li><li><p><code>@DeclareParents</code>：引介增强，表示为指定的目标类引入新的属性和方法。</p></li></ol><p><strong>注意:</strong></p><p>由于Spring AOP框架基于代理模式设计的,<code>对于JDK代理,仅public interface方法会被代理拦截</code>。对于CGLIB,</p><p><code>仅public和protected方法会被代理拦截</code>。<code>目标对象方法调用的自身方法默认不会被拦截</code>,需要声明<code>exposeProxy=true，借助AopContext进行实现</code>。</p><p>Spring AOP支持额外的<code>Bean PCD</code>(?PCD是什么)。<code>Bean PCD可以使用&amp;&amp;,||,!</code>操作符。</p><blockquote><p>Bean PCD仅在Spring AOP中受支持，而在本机AspectJ编织中不受支持。 它是AspectJ定义的标准PCD的Spring特定扩展，因此不适用于@Aspect模型中声明的方面。</p><p>bean PCD在实例级别（基于Spring bean名称概念）而不是仅在类型级别（基于编织的AOP受限）上运行。 基于实例的切入点指示符是Spring基于代理的AOP框架的一种特殊功能，它与Spring bean工厂紧密集成，通过名称可以自然而直接地识别特定的bean。</p></blockquote><p><strong>切点书写规则</strong></p><blockquote><p>切点指示符包含:类型,范围,上下文。</p><ul><li>类型指示符:<code>execution</code>, <code>get</code>, <code>set</code>, <code>call</code>, and <code>handler</code>. </li><li>范围指示符:<code>within</code> and <code>withincode</code> </li><li>上下文指示符:<code>this</code>, <code>target</code>, and <code>@annotation</code> </li></ul><p><code>一个写得很好的切入点应至少包括前两种类型（kinded和scoping)。您可以包含上下文指示符以基于连接点上下文进行匹配，或者绑定该上下文以在建议中使用。</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合详解</title>
      <link href="/2019/09/17/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/09/17/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP概念</title>
      <link href="/2019/09/17/Spring-AOP%E6%A6%82%E5%BF%B5/"/>
      <url>/2019/09/17/Spring-AOP%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>横切</code>的技术，是将那些<strong>影响了多个类的公共行为封装到一个可重用模块</strong>，并将其命名为<code>Aspect(切面)</code>。</p><p>使用<code>切面</code>解释，AOP把软件系统分为两个部分：<code>核心关注点和横切关注点</code>。<strong>业务处理的主要流程核心关注点</strong>，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常<strong>发生在核心关注点多处，而且各处基本类似</strong>。比如<code>权限认证，日志，事务等</code>。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>权限认证(Authentication)。例如场景的权限框架：<code>Shiro</code>和<code>Spring Security</code>。</li><li>缓存(Caching)。例如Spring提供的<code>EnableCaching</code>缓存注解。</li><li>错误处理(Error handling)。例如Spring提供<code>RestControllerAdvice</code>全局异常控制通知。</li><li>事务(Transactions)。例如Spring提供的事务注解<code>Transactional</code>。</li><li>同步(Synchronization)</li><li>持久化(Persistence)</li><li>记录(logging)，跟踪(tacing)，优化(profiling)，监控(monitor)。</li><li>校验(validation)</li><li>性能优化(Performance optimization)</li><li>懒加载(Lazy loading)</li><li>内容传递(Context passing)</li><li>资源池(Resource pooling)</li></ol><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><h4 id="1：切面-Aspect-，Spring我觉得就是Advisor抽象。"><a href="#1：切面-Aspect-，Spring我觉得就是Advisor抽象。" class="headerlink" title="1：切面(Aspect)，Spring我觉得就是Advisor抽象。"></a>1：切面(Aspect)，Spring我觉得就是<code>Advisor</code>抽象。</h4><p>切面是对横切关注点的抽象。在Spring可以理解为<strong><code>Advisor</code></strong>。<code>Advisor</code>是由一个<code>Advice(通知)</code>和一个<code>Pointcut(切点)</code>构成。常使用的<code>Advisor</code>如下：</p><ul><li><p><code>StaticMethodMatcherPointcutAdvisor</code>：<code>Advisor</code>静态基类，是静态切入点，方便子类实现MethodMatcher的matches方法自定义检查目标方法是否符合<code>Advice</code>条件，默认匹配所有方法。<strong><code>该类就是让子类实现的。最主要实现的方法是boolean matches(Method method,Class&lt;?&gt; targetClass);</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodMatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isRuntime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass, Object... args)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Canonical instance that matches all methods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MethodMatcher TRUE = TrueMethodMatcher.INSTANCE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticMethodMatcherPointcut</span> <span class="keyword">extends</span> <span class="title">StaticMethodMatcher</span> <span class="keyword">implements</span> <span class="title">Pointcut</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ClassFilter classFilter = ClassFilter.TRUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClassFilter</span><span class="params">(ClassFilter classFilter)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.classFilter = classFilter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClassFilter <span class="title">getClassFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.classFilter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> MethodMatcher <span class="title">getMethodMatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>DefaultPointcutAdvisor</code>：便利的切点驱动<code>Advisor</code>实现。最常用的<code>Advisor</code>。它可以与任何切入点和建议类型一起使用，除了<code>DefaultIntroductionAdvisor(引介切面)</code>。</p></li><li><p><code>RegexpMethodPointcutAdvisor</code>：<code>jdk regex</code>表达式<code>Advisor</code>。</p></li><li><p><code>NameMatchMethodPointcutAdvisor</code>：存放建议的名称匹配方法切入点的便捷类。</p></li></ul><h4 id="2：切入点-Pointcut"><a href="#2：切入点-Pointcut" class="headerlink" title="2：切入点(Pointcut)"></a>2：切入点(Pointcut)</h4><p><strong>对连接点的定义。</strong></p><ol><li><code>ClassFilter</code>：过滤器限制切入点或引介与给定目标类集的匹配。</li><li><code>MethodMatcher</code>：过滤器限制切入点或引介与给定方法目标方法集的匹配。</li><li>横切关注点工具类集合<ul><li>Pointcuts：提供切点的集合操作(集合交，集合并操作)。</li><li>ClassFilters：提供目标类过滤器的集合操作(同上)。</li><li>MethodMatchers：提供目标方法过滤器的集合操作(同上)。</li></ul></li><li>实现类<ul><li>StaticMethodMatcherPointcut：静态方法表达式切点</li><li>AspectJExpressionPointcut：AspectJ表达式切点</li><li>AnnotationMatchingPointcut：注解匹配切点</li><li>DynamicMethodMatcherPointcut：动态方法匹配切点</li><li>JdkRegexpMethodPointcut：jdk正则表达式切点</li><li>NameMatchMethodPointcut：替代JdkRegexpMethodPointcut。匹配方法<code>*xxx,xxx*,*xxx*</code>。</li></ul></li></ol><h4 id="3：连接点-Joinpoint"><a href="#3：连接点-Joinpoint" class="headerlink" title="3：连接点(Joinpoint)"></a>3：连接点(Joinpoint)</h4><p>被拦截的点，由于Spring只支持方法级别的连接点，所以在Spring中连接点指的就是<code>被拦截的方法</code>。由于Spring还提供了<code>引介增强</code>，也可以是<code>字段或者构造器</code>。</p><ul><li><code>JoinPoint</code>：用来支持其他4种类型通知。</li><li><code>ProceedingJoinPoint</code>：用来支持<code>环绕通知(AroundAdvice)</code>连接点。</li></ul><h4 id="4：通知-Advice"><a href="#4：通知-Advice" class="headerlink" title="4：通知(Advice)"></a>4：通知(Advice)</h4><p>指拦截到连接点之后要执行的代码，通知分为前置、后置、 异常、最终、环绕通知五类。</p><ol><li><p>前置通知：方法返回前调用</p><ul><li><code>BeforeAdvice</code>：标记接口</li><li><code>MethodBeforeAdvice</code>：前置通知</li><li><code>AspectJMethodBeforeAdvice</code></li></ul></li><li><p>后置通知：方法返回后调用</p><ul><li><code>AfterAdvice</code></li><li><code>AspectJAfterAdvice</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJAfterAdvice</span> <span class="keyword">extends</span> <span class="title">AbstractAspectJAdvice</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">AfterAdvice</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AspectJAfterAdvice</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Method aspectJBeforeAdviceMethod, AspectJExpressionPointcut pointcut, AspectInstanceFactory aif)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(aspectJBeforeAdviceMethod, pointcut, aif);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mi.proceed();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">invokeAdviceMethod(getJoinPointMatch(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBeforeAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAfterAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>环绕通知：方法前后调用</p><ul><li>AspectJAroundAdvice</li></ul></li><li><p>最终通知：返回后的建议仅在正常方法返回时调用，能看到返回值，但是不能改变。</p><ul><li>AfterReturningAdvice</li><li>AspectJAfterReturningAdvice</li></ul></li><li><p>异常通知：异常后调用</p><ul><li>AspectJAfterThrowingAdvice</li></ul></li><li><p>引介通知：可以在运行期间不改变原始类增加其他的方法。</p></li></ol><p>总结Spring实现包装Aspect的5种通知实现</p><ul><li>AspectJMethodBeforeAdvice</li><li>AspectJAroundAdvice</li><li>AspectJAfterAdvice</li><li>AspectJAfterReturningAdvice</li><li>AspectJAfterThrowingAdvice</li></ul><h4 id="目标对象"><a href="#目标对象" class="headerlink" title="目标对象"></a>目标对象</h4><p>代理的原始对象。</p><h4 id="织入"><a href="#织入" class="headerlink" title="织入"></a>织入</h4><p>将切面应用到目标对象并导致代理对象创建的过程</p><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段。在Spring中提供了</p><p>@DeclareParents注解来实现引介通知。</p><h3 id="Spring-AOP代理方式"><a href="#Spring-AOP代理方式" class="headerlink" title="Spring AOP代理方式"></a>Spring AOP代理方式</h3><p>Spring 提供了两种方式来生成代理对象: JDKProxy 和 Cglib，具体使用哪种方式生成由 </p><p>AopProxyFactory 根据 AdvisedSupport 对象的配置来决定。默认的策略是如果目标类是接口， </p><p>则使用 JDK 动态代理技术，否则使用 Cglib 来生成代理。实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line"><span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line"><span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine whether the supplied &#123;<span class="doctag">@link</span> AdvisedSupport&#125; has only the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.aop.SpringProxy&#125; interface specified</span></span><br><span class="line"><span class="comment"> * (or no proxy interfaces specified at all).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNoUserSuppliedProxyInterfaces</span><span class="params">(AdvisedSupport config)</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt;[] ifcs = config.getProxiedInterfaces();</span><br><span class="line"><span class="keyword">return</span> (ifcs.length == <span class="number">0</span> || (ifcs.length == <span class="number">1</span> &amp;&amp; SpringProxy.class.isAssignableFrom(ifcs[<span class="number">0</span>])));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>JDK</em></strong> <strong><em>动态接口代理</em></strong> </p><ol><li>JDK 动态代理主要涉及到 java.lang.reflect 包中的两个类：<code>Proxy 和 InvocationHandler</code>。 </li></ol><p>InvocationHandler是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类 </p><p>的代码，动态将横切逻辑和业务逻辑编制在一起。Proxy 利用 InvocationHandler 动态创建 </p><p>一个符合某一接口的实例，生成目标类的代理对象。</p><p><strong><em>CGLib</em></strong> <strong><em>动态代理</em></strong> </p><ol start="2"><li>CGLib 全称为 Code Generation Library，是一个强大的高性能，高质量的代码生成类库， </li></ol><p>可以在运行期扩展 Java 类与实现 Java 接口，CGLib 封装了 asm，可以再运行期动态生成新 </p><p>的 class。和 JDK 动态代理相比较：JDK 创建代理有一个限制，就是只能为接口创建代理实例， </p><p>而对于没有通过接口定义业务方法的类，则可以通过 CGLib 创建动态代理。</p>]]></content>
      
      
      <categories>
          
          <category> Spring AOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Environment环境抽象源码分析篇</title>
      <link href="/2019/09/16/Spring-Environment%E7%8E%AF%E5%A2%83%E6%8A%BD%E8%B1%A1%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%AF%87/"/>
      <url>/2019/09/16/Spring-Environment%E7%8E%AF%E5%A2%83%E6%8A%BD%E8%B1%A1%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%AF%87/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring ApplicationContext refresh函数源码分析篇</title>
      <link href="/2019/09/16/Spring-ApplicationContext-refresh%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%AF%87/"/>
      <url>/2019/09/16/Spring-ApplicationContext-refresh%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%AF%87/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring IOC源码分析篇</title>
      <link href="/2019/09/16/Spring-IOC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%AF%87/"/>
      <url>/2019/09/16/Spring-IOC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%AF%87/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP源码分析篇</title>
      <link href="/2019/09/16/Spring-AOP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%AF%87/"/>
      <url>/2019/09/16/Spring-AOP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong>AOP(Aspect-oriented Programming)面向切面编程</strong>。Spring AOP在Spring架构中的地位举足轻重。最具有代表性的<code>事务(spring-tx模块)</code>，<code>缓存(spring-context-support模块)</code>等功能。本篇主要对Spring AOP源码实现进行深度解析。以<code>AnnotationAwareAspectJAutoProxyCreator</code>类为例，看Spring AOP是如何实现的。如果不熟悉AOP一些概念的，<a href="https://crazyblitz.github.io/2019/09/17/Spring-AOP%E6%A6%82%E5%BF%B5/">请看我的这篇文章：Spring AOP概念</a>。讲解主要分为以下两个模块：</p><ul><li>Spring AOP如何为一个Bean找寻合适的切面(<code>Advisor</code>拦截器列表，即<code>Advisor</code>。常见的拦截器有<code>Advise</code>，<code>MethodInterceptor</code>，<code>Advisor</code>。最后统统转换为<code>Advisor</code>。</li><li>Spring AOP如何为一个Bean创建代理对象的。</li></ul><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>业务接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CodeService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeServiceImpl</span> <span class="keyword">implements</span> <span class="title">CodeService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不要出现"自调用"的情况:这是Spring文档中推荐的“最佳”方案;</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志切面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.ley.springboot.aop.code.service..*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Method method = AopUtils.getMethodFromTarget(joinPoint);</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        log.info(<span class="string">"method: &#123;&#125;,args: &#123;&#125;"</span>, method, args);</span><br><span class="line">        <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AopUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AopUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"It's prohibited to create instances of the class."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a &#123;<span class="doctag">@link</span> Method&#125; object from target object (not proxy class).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint the &#123;<span class="doctag">@link</span> JoinPoint&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@link</span> Method&#125; object or null if method doesn't exist or if the signature at a join point</span></span><br><span class="line"><span class="comment">     * isn't sub-type of &#123;<span class="doctag">@link</span> MethodSignature&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Method <span class="title">getMethodFromTarget</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        Method method = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//必须是MethodSignature对象或者子类</span></span><br><span class="line">        <span class="keyword">if</span> (joinPoint.getSignature() <span class="keyword">instanceof</span> MethodSignature) &#123;</span><br><span class="line">            MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">            method = getDeclaredMethod(joinPoint.getTarget().getClass(), signature.getName(),</span><br><span class="line">                    getParameterTypes(joinPoint));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a &#123;<span class="doctag">@link</span> Method&#125; object from target object by specified method name.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint  the &#123;<span class="doctag">@link</span> JoinPoint&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName the method name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@link</span> Method&#125; object or null if method with specified &lt;code&gt;methodName&lt;/code&gt; doesn't exist</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Method <span class="title">getMethodFromTarget</span><span class="params">(JoinPoint joinPoint, String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDeclaredMethod(joinPoint.getTarget().getClass(), methodName,</span><br><span class="line">                getParameterTypes(joinPoint));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets parameter types of the join point.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint the join point</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the parameter types for the method this object</span></span><br><span class="line"><span class="comment">     * represents</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class[] getParameterTypes(JoinPoint joinPoint) &#123;</span><br><span class="line">        MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        Method method = signature.getMethod();</span><br><span class="line">        <span class="keyword">return</span> method.getParameterTypes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets declared method from specified type by mame and parameters types.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type           the type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName     the name of the method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameterTypes the parameter array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@link</span> Method&#125; object or null if method doesn't exist</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Method <span class="title">getDeclaredMethod</span><span class="params">(Class&lt;?&gt; type, String methodName, Class&lt;?&gt;... parameterTypes)</span> </span>&#123;</span><br><span class="line">        Method method = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method = type.getDeclaredMethod(methodName, parameterTypes);</span><br><span class="line">            <span class="keyword">if</span> (method.isBridge()) &#123;</span><br><span class="line">                method = MethodProvider.getInstance().unBride(method, type);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            Class&lt;?&gt; superclass = type.getSuperclass();</span><br><span class="line">            <span class="keyword">if</span> (superclass != <span class="keyword">null</span>) &#123;</span><br><span class="line">                method = getDeclaredMethod(superclass, methodName, parameterTypes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            Throwables.throwIfUnchecked(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            Throwables.throwIfUnchecked(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取切点上(类上)执行对象注解</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Annotation&gt; <span class="function">Optional&lt;T&gt; <span class="title">getAnnotation</span><span class="params">(JoinPoint joinPoint, Class&lt;T&gt; annotation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getAnnotation(joinPoint.getTarget().getClass(), annotation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取类型上的注解</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Annotation&gt; <span class="function">Optional&lt;T&gt; <span class="title">getAnnotation</span><span class="params">(Class&lt;?&gt; type, Class&lt;T&gt; annotation)</span> </span>&#123;</span><br><span class="line">        Validate.notNull(annotation, <span class="string">"config cannot be null"</span>);</span><br><span class="line">        Validate.notNull(type, <span class="string">"type cannot be null"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Annotation ann : type.getDeclaredAnnotations()) &#123;</span><br><span class="line">            <span class="comment">//迫使调用者思考返回的引用缺失的情形(Optional)</span></span><br><span class="line">            <span class="keyword">if</span> (ann.annotationType().equals(annotation)) &#123;</span><br><span class="line">                <span class="keyword">return</span> Optional.of((T) ann);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; superType = type.getSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (superType != <span class="keyword">null</span> &amp;&amp; !superType.equals(Object.class)) &#123;</span><br><span class="line">            <span class="keyword">return</span> getAnnotation(superType, annotation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Optional.absent();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取方法的信息</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMethodInfo</span><span class="params">(Method m)</span> </span>&#123;</span><br><span class="line">        StringBuilder info = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        info.append(<span class="string">"Method signature:"</span>).append(<span class="string">"\n"</span>);</span><br><span class="line">        info.append(m.toGenericString()).append(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        info.append(<span class="string">"Declaring class:\n"</span>);</span><br><span class="line">        info.append(m.getDeclaringClass().getCanonicalName()).append(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        info.append(<span class="string">"\nFlags:"</span>).append(<span class="string">"\n"</span>);</span><br><span class="line">        info.append(<span class="string">"Bridge="</span>).append(m.isBridge()).append(<span class="string">"\n"</span>);</span><br><span class="line">        info.append(<span class="string">"Synthetic="</span>).append(m.isSynthetic()).append(<span class="string">"\n"</span>);</span><br><span class="line">        info.append(<span class="string">"Final="</span>).append(Modifier.isFinal(m.getModifiers())).append(<span class="string">"\n"</span>);</span><br><span class="line">        info.append(<span class="string">"Native="</span>).append(Modifier.isNative(m.getModifiers())).append(<span class="string">"\n"</span>);</span><br><span class="line">        info.append(<span class="string">"Synchronized="</span>).append(Modifier.isSynchronized(m.getModifiers())).append(<span class="string">"\n"</span>);</span><br><span class="line">        info.append(<span class="string">"Abstract="</span>).append(Modifier.isAbstract(m.getModifiers())).append(<span class="string">"\n"</span>);</span><br><span class="line">        info.append(<span class="string">"AccessLevel="</span>).append(getAccessLevel(m.getModifiers())).append(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        info.append(<span class="string">"\nReturn Type: \n"</span>);</span><br><span class="line">        info.append(<span class="string">"ReturnType="</span>).append(m.getReturnType()).append(<span class="string">"\n"</span>);</span><br><span class="line">        info.append(<span class="string">"GenericReturnType="</span>).append(m.getGenericReturnType()).append(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        info.append(<span class="string">"\nParameters:"</span>);</span><br><span class="line">        Class&lt;?&gt;[] pType = m.getParameterTypes();</span><br><span class="line">        Type[] gpType = m.getGenericParameterTypes();</span><br><span class="line">        <span class="keyword">if</span> (pType.length != <span class="number">0</span>) &#123;</span><br><span class="line">            info.append(<span class="string">"\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            info.append(<span class="string">"empty\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pType.length; i++) &#123;</span><br><span class="line">            info.append(<span class="string">"parameter ["</span>).append(i).append(<span class="string">"]:\n"</span>);</span><br><span class="line">            info.append(<span class="string">"ParameterType="</span>).append(pType[i]).append(<span class="string">"\n"</span>);</span><br><span class="line">            info.append(<span class="string">"GenericParameterType="</span>).append(gpType[i]).append(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        info.append(<span class="string">"\nExceptions:"</span>);</span><br><span class="line">        Class&lt;?&gt;[] xType = m.getExceptionTypes();</span><br><span class="line">        Type[] gxType = m.getGenericExceptionTypes();</span><br><span class="line">        <span class="keyword">if</span> (xType.length != <span class="number">0</span>) &#123;</span><br><span class="line">            info.append(<span class="string">"\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            info.append(<span class="string">"empty\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; xType.length; i++) &#123;</span><br><span class="line">            info.append(<span class="string">"exception ["</span>).append(i).append(<span class="string">"]:\n"</span>);</span><br><span class="line">            info.append(<span class="string">"ExceptionType="</span>).append(xType[i]).append(<span class="string">"\n"</span>);</span><br><span class="line">            info.append(<span class="string">"GenericExceptionType="</span>).append(gxType[i]).append(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        info.append(<span class="string">"\nAnnotations:"</span>);</span><br><span class="line">        <span class="keyword">if</span> (m.getAnnotations().length != <span class="number">0</span>) &#123;</span><br><span class="line">            info.append(<span class="string">"\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            info.append(<span class="string">"empty\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m.getAnnotations().length; i++) &#123;</span><br><span class="line">            info.append(<span class="string">"config["</span>).append(i).append(<span class="string">"]="</span>).append(m.getAnnotations()[i]).append(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> info.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getAccessLevel</span><span class="params">(<span class="keyword">int</span> modifiers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Modifier.isPublic(modifiers)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"public"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Modifier.isProtected(modifiers)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"protected"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Modifier.isPrivate(modifiers)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"private"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"default"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(LogApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的流程是项目<code>最常见的AOP实现形式</code>。我们可以从<code>@EnableAspectJAutoProxy</code>注解为切入点。该注解是Spring的<code>Enable模块驱动实现</code>。详细请看我的<a href="https://crazyblitz.github.io/2019/08/05/Enable%E6%A8%A1%E5%9D%97%E9%A9%B1%E5%8A%A8%E5%8E%9F%E7%90%86/#2-%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B">@Enable模块驱动实现源码分析</a>。</p><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><h4 id="注册AnnotationAwareAspectJAutoProxyCreator-bean"><a href="#注册AnnotationAwareAspectJAutoProxyCreator-bean" class="headerlink" title="注册AnnotationAwareAspectJAutoProxyCreator bean"></a>注册AnnotationAwareAspectJAutoProxyCreator bean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register, escalate, and configure the AspectJ auto proxy creator based on the value</span></span><br><span class="line"><span class="comment"> * of the @&#123;<span class="doctag">@link</span> EnableAspectJAutoProxy#proxyTargetClass()&#125; attribute on the importing</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注入Spring AOP注解实现类：AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line">AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"></span><br><span class="line">AnnotationAttributes enableAspectJAutoProxy =</span><br><span class="line">AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);</span><br><span class="line"><span class="keyword">if</span> (enableAspectJAutoProxy != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">"proxyTargetClass"</span>)) &#123;</span><br><span class="line">AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">"exposeProxy"</span>)) &#123;</span><br><span class="line">AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="寻找bean上合适的Advisor列表"><a href="#寻找bean上合适的Advisor列表" class="headerlink" title="寻找bean上合适的Advisor列表"></a>寻找bean上合适的<code>Advisor</code>列表</h4><p><strong>实现逻辑具体在<code>AbstractAdvisorAutoProxyCreator的getAdvicesAndAdvisorsForBean方法中</code>。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(</span><br><span class="line">Class&lt;?&gt; beanClass, String beanName, <span class="meta">@Nullable</span> TargetSource targetSource) &#123;</span><br><span class="line"><span class="comment">// 找寻符合条件的advisor bean 列表</span></span><br><span class="line">List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> DO_NOT_PROXY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> advisors.toArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 找寻候选的advisor列表,实现逻辑委托给BeanFactoryAdvisorRetrievalHelper(advisor检索助手)</span></span><br><span class="line">List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">       <span class="comment">// 找寻该bean上的advisor列表</span></span><br><span class="line">List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">extendAdvisors(eligibleAdvisors);</span><br><span class="line"><span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">           <span class="comment">// 排序</span></span><br><span class="line">eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>找寻spring容器中<code>Advisor</code> bean</strong></p><p>实现逻辑委托给BeanFactoryAdvisorRetrievalHelper(advisor检索助手)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">findAdvisorBeans</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Determine list of advisor bean names, if not cached already.</span></span><br><span class="line">String[] advisorNames = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">advisorNames = <span class="keyword">this</span>.cachedAdvisorBeanNames;</span><br><span class="line"><span class="keyword">if</span> (advisorNames == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line"><span class="comment">// uninitialized to let the auto-proxy creator apply to them!</span></span><br><span class="line">               <span class="comment">// 使用BeanFactoryUtils找寻Advisor bean,包含非单例,没有延迟加载的</span></span><br><span class="line">advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line"><span class="keyword">this</span>.beanFactory, Advisor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">this</span>.cachedAdvisorBeanNames = advisorNames;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (advisorNames.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Advisor&gt; advisors = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String name : advisorNames) &#123;</span><br><span class="line">           <span class="comment">// 是否符合条件bean,默认实现true</span></span><br><span class="line"><span class="keyword">if</span> (isEligibleBean(name)) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isCurrentlyInCreation(name)) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="comment">// 获取advisor bean,可能提前触发advisor内部引用bean</span></span><br><span class="line">advisors.add(<span class="keyword">this</span>.beanFactory.getBean(name, Advisor.class));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">Throwable rootCause = ex.getMostSpecificCause();</span><br><span class="line"><span class="keyword">if</span> (rootCause <span class="keyword">instanceof</span> BeanCurrentlyInCreationException) &#123;</span><br><span class="line">BeanCreationException bce = (BeanCreationException) rootCause;</span><br><span class="line">String bceBeanName = bce.getBeanName();</span><br><span class="line"><span class="keyword">if</span> (bceBeanName != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.beanFactory.isCurrentlyInCreation(bceBeanName)) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// Ignore: indicates a reference back to the bean we're trying to advise.</span></span><br><span class="line"><span class="comment">// We want to find advisors other than the currently created bean itself.</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为bean找寻符合条件的advisor列表</strong></p><p>实现逻辑在AopUtils#findAdvisorsThatCanApply(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz)中，具体判断这个切面是否应用在bean在AopUtils#canApply(Pointcut pc, Class&lt;?&gt; targetClass, boolean hasIntroductions)中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (candidateAdvisors.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> candidateAdvisors;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;Advisor&gt; eligibleAdvisors = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       <span class="comment">// 先处理引介增强</span></span><br><span class="line"><span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123;</span><br><span class="line">eligibleAdvisors.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">boolean</span> hasIntroductions = !eligibleAdvisors.isEmpty();</span><br><span class="line">       <span class="comment">// 再处理普通增强</span></span><br><span class="line"><span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line"><span class="comment">// already processed</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (canApply(candidate, clazz, hasIntroductions)) &#123;</span><br><span class="line">eligibleAdvisors.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Advisor advisor, Class&lt;?&gt; targetClass, <span class="keyword">boolean</span> hasIntroductions)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line"><span class="keyword">return</span> ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123;</span><br><span class="line">PointcutAdvisor pca = (PointcutAdvisor) advisor;</span><br><span class="line"><span class="keyword">return</span> canApply(pca.getPointcut(), targetClass, hasIntroductions);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// It doesn't have a pointcut so we assume it applies.</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Pointcut pc, Class&lt;?&gt; targetClass, <span class="keyword">boolean</span> hasIntroductions)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">       <span class="comment">// 先判断切点的classFilter是否匹配targetClass</span></span><br><span class="line"><span class="keyword">if</span> (!pc.getClassFilter().matches(targetClass)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 然后在获取切点的方法匹配器匹配方法</span></span><br><span class="line">MethodMatcher methodMatcher = pc.getMethodMatcher();</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (methodMatcher == MethodMatcher.TRUE) &#123;</span><br><span class="line"><span class="comment">// No need to iterate the methods if we're matching any method anyway...</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 是否为引介匹配器</span></span><br><span class="line">IntroductionAwareMethodMatcher introductionAwareMethodMatcher = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (methodMatcher <span class="keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;</span><br><span class="line">introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 如果不是接口代理类,则用户类</span></span><br><span class="line"><span class="keyword">if</span> (!Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">classes.add(ClassUtils.getUserClass(targetClass));</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 获取目标类所有接口,使用递归的方式</span></span><br><span class="line">classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class="line">           <span class="comment">// 逐一判断接口上所有方法是否符合切点方法匹配器</span></span><br><span class="line">           <span class="comment">// 因为是Spring AOP是方法级别的,如果一个匹配则该类会被代理</span></span><br><span class="line">Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);</span><br><span class="line"><span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line"><span class="keyword">if</span> (introductionAwareMethodMatcher != <span class="keyword">null</span> ?</span><br><span class="line">introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) :</span><br><span class="line">methodMatcher.matches(method, targetClass)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="处理bean代理"><a href="#处理bean代理" class="headerlink" title="处理bean代理"></a>处理bean代理</h4><p>这部分逻辑在<code>AbstractAutoProxyCreator</code>,该类是Spring AOP实现AOP的重要类。该类实现了<code>SmartInstantiationAwareBeanPostProcessor</code>接口，<strong>在bean实例化前和初始化后为bean创建代理以及。bean引用创建上</strong></p><p><strong>由于引用创建的bean代理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line"><span class="keyword">this</span>.earlyProxyReferences.add(cacheKey);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>bean实例化前的处理代理的逻辑</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">       <span class="comment">// 获取缓存的key</span></span><br><span class="line">Object cacheKey = getCacheKey(beanClass, beanName);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 判断bean是否可以创建代理</span></span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(beanName) || !<span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">           <span class="comment">// 不应代理的spring aop基础设施</span></span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create proxy here if we have a custom TargetSource.</span></span><br><span class="line"><span class="comment">// Suppresses unnecessary default instantiation of the target bean:</span></span><br><span class="line"><span class="comment">// The TargetSource will handle target instances in a custom fashion.</span></span><br><span class="line">TargetSource targetSource = getCustomTargetSource(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (targetSource != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(beanName)) &#123;</span><br><span class="line"><span class="keyword">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">&#125;</span><br><span class="line">           <span class="comment">// 获取bean上拦截器,都被包装成了advisor</span></span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line">           <span class="comment">// 创建代理</span></span><br><span class="line">Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line"><span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不应该代理的aop基础设施</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isInfrastructureClass</span><span class="params">(Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> retVal = Advice.class.isAssignableFrom(beanClass) ||</span><br><span class="line">Pointcut.class.isAssignableFrom(beanClass) ||</span><br><span class="line">Advisor.class.isAssignableFrom(beanClass) ||</span><br><span class="line">AopInfrastructureBean.class.isAssignableFrom(beanClass);</span><br><span class="line">       ...</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>bean实例化后逻辑</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(@Nullable Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">           <span class="comment">// 先看由于早期代理引用集合是否含有缓存</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">               <span class="comment">// 包装代理</span></span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包装代理逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">           <span class="comment">// 创建bean代理</span></span><br><span class="line">Object proxy = createProxy(</span><br><span class="line">bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line"><span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生成bean的代理"><a href="#生成bean的代理" class="headerlink" title="生成bean的代理"></a>生成bean的代理</h4><p>创建bean代理,在AbstractAutoProxyCreator#createProxy()函数中</p><ul><li>specificInterceptors：bean上应用的拦截器，都被包装成<code>Advisor</code>。例如<code>Advise</code>,<code>MethodInterceptor</code>。</li><li>targetSource：目标对象源。被包装成SingletonTargetSource。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, @Nullable String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">@Nullable Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 使用代理工程创建代理对象</span></span><br><span class="line">ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line"><span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将拦截器包装成Advisor</span></span><br><span class="line">Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">       <span class="comment">// 设置代理对象的拦截器链</span></span><br><span class="line">proxyFactory.addAdvisors(advisors);</span><br><span class="line">       <span class="comment">// 设置代理目标对象</span></span><br><span class="line">proxyFactory.setTargetSource(targetSource);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 子类可以定制化ProxyFactory</span></span><br><span class="line">customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line"><span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 获取代理对象</span></span><br><span class="line"><span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用AdvisorAdapterRegistry#wrap函数进行包装,默认实现DefaultAdvisorAdapterRegistry</span></span><br><span class="line"><span class="keyword">protected</span> Advisor[] buildAdvisors(<span class="meta">@Nullable</span> String beanName, <span class="meta">@Nullable</span> Object[] specificInterceptors) &#123;</span><br><span class="line"><span class="comment">// Handle prototypes correctly...</span></span><br><span class="line">Advisor[] commonInterceptors = resolveInterceptorNames();</span><br><span class="line"></span><br><span class="line">List&lt;Object&gt; allInterceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (specificInterceptors != <span class="keyword">null</span>) &#123;</span><br><span class="line">allInterceptors.addAll(Arrays.asList(specificInterceptors));</span><br><span class="line"><span class="keyword">if</span> (commonInterceptors.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.applyCommonInterceptorsFirst) &#123;</span><br><span class="line">allInterceptors.addAll(<span class="number">0</span>, Arrays.asList(commonInterceptors));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">allInterceptors.addAll(Arrays.asList(commonInterceptors));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">Advisor[] advisors = <span class="keyword">new</span> Advisor[allInterceptors.size()];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; allInterceptors.size(); i++) &#123;</span><br><span class="line">advisors[i] = <span class="keyword">this</span>.advisorAdapterRegistry.wrap(allInterceptors.get(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ProxyFactory创建bean代理"><a href="#ProxyFactory创建bean代理" class="headerlink" title="ProxyFactory创建bean代理"></a>ProxyFactory创建bean代理</h5><ol><li><p>先看ProxyFactory获取代理对象getProxy()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建代理对象是使用AopProxyFactory创建</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> createAopProxy().getProxy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>ProxyCreatorSupport</code>类主要配置AopProxyFactory实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new ProxyCreatorSupport instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProxyCreatorSupport</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.aopProxyFactory = <span class="keyword">new</span> DefaultAopProxyFactory();</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 线程安全</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</span><br><span class="line">activate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用AopProxyFactory创建AopProxy</p><ul><li>optimize参数：设置代理是否应执行积极的优化，默认为false。</li><li>proxyTargetClass参数：springboot aop starter中默认为true，是否使用cglib目标类代理。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">      </span><br><span class="line"><span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">...</span><br><span class="line">               <span class="comment">//如果代理目标是接口或者Proxy类型,则走JDK代理类型</span></span><br><span class="line"><span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line">               <span class="comment">// 反之走cglib代理</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine whether the supplied &#123;<span class="doctag">@link</span> AdvisedSupport&#125; has only the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.aop.SpringProxy&#125; interface specified</span></span><br><span class="line"><span class="comment"> * (or no proxy interfaces specified at all).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNoUserSuppliedProxyInterfaces</span><span class="params">(AdvisedSupport config)</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt;[] ifcs = config.getProxiedInterfaces();</span><br><span class="line"><span class="keyword">return</span> (ifcs.length == <span class="number">0</span> || (ifcs.length == <span class="number">1</span> &amp;&amp; SpringProxy.class.isAssignableFrom(ifcs[<span class="number">0</span>])));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AdvisedSupport类是AOP代理配置管理基类，子类继承该类从中获取AOP代理实例工厂。</p><ul><li>配置了<code>AdvisorChainFactory</code>切面拦截器链工厂<code>DefaultAdvisorChainFactory</code>。<strong>为真正的代理创建类获取代理对象(方法)的拦截器链。</strong></li><li>主要源码属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvisedSupport</span> <span class="keyword">extends</span> <span class="title">ProxyConfig</span> <span class="keyword">implements</span> <span class="title">Advised</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/** Whether the Advisors are already filtered for the specific target class */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> preFiltered = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The AdvisorChainFactory to use */</span></span><br><span class="line">AdvisorChainFactory advisorChainFactory = <span class="keyword">new</span> DefaultAdvisorChainFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache with Method as key and advisor chain List as value */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Map&lt;MethodCacheKey, List&lt;Object&gt;&gt; methodCache;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Interfaces to be implemented by the proxy. Held in List to keep the order</span></span><br><span class="line"><span class="comment"> * of registration, to create JDK proxy with specified order of interfaces.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Class&lt;?&gt;&gt; interfaces = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * List of Advisors. If an Advice is added, it will be wrapped</span></span><br><span class="line"><span class="comment"> * in an Advisor before being added to this List.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Advisor&gt; advisors = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="JdkDynamicAopProxy创建代理分析"><a href="#JdkDynamicAopProxy创建代理分析" class="headerlink" title="JdkDynamicAopProxy创建代理分析"></a>JdkDynamicAopProxy创建代理分析</h5><ol><li>该类最主要是invoke方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span>, <span class="title">InvocationHandler</span>, <span class="title">Serializable</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/** Config used to configure this proxy */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AdvisedSupport advised;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// invoke方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">MethodInvocation invocation;</span><br><span class="line">Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取代理目标对象</span></span><br><span class="line">TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</span><br><span class="line">Object target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// equals()方法不代理,直接使用代理类的equals方法</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line"><span class="comment">// The target does not implement the equals(Object) method itself.</span></span><br><span class="line"><span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// hashCode()方法不代理</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line"><span class="comment">// The target does not implement the hashCode() method itself.</span></span><br><span class="line"><span class="keyword">return</span> hashCode();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (method.getDeclaringClass() == DecoratingProxy.class) &#123;</span><br><span class="line"><span class="comment">// There is only getDecoratedClass() declared -&gt; dispatch to proxy config.</span></span><br><span class="line"><span class="keyword">return</span> AopProxyUtils.ultimateTargetClass(<span class="keyword">this</span>.advised);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 如果一个类接口是Advised类,不会进行增强,代表该类是ProxyConfig实现类,主要用来配置代理类</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line"><span class="comment">// Service invocations on ProxyConfig with the proxy config...</span></span><br><span class="line"><span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised, method, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object retVal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line"><span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get as late as possible to minimize the time we "own" the target,</span></span><br><span class="line"><span class="comment">// in case it comes from a pool.</span></span><br><span class="line">target = targetSource.getTarget();</span><br><span class="line">Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the interception chain for this method.(获取该方法的拦截器链)</span></span><br><span class="line">List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check whether we have any advice. If we don't, we can fallback on direct</span></span><br><span class="line"><span class="comment">// reflective invocation of the target, and avoid creating a MethodInvocation.</span></span><br><span class="line"><span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line"><span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly</span></span><br><span class="line"><span class="comment">// Note that the final invoker must be an InvokerInterceptor so we know it does</span></span><br><span class="line"><span class="comment">// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span></span><br><span class="line">Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// We need to create a method invocation...</span></span><br><span class="line">invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line"><span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></span><br><span class="line">retVal = invocation.proceed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Massage return value if necessary.</span></span><br><span class="line">Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line"><span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;&amp; retVal == target &amp;&amp;</span><br><span class="line">returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</span><br><span class="line">!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line"><span class="comment">// Special case: it returned "this" and the return type of the method</span></span><br><span class="line"><span class="comment">// is type-compatible. Note that we can't help if the target sets</span></span><br><span class="line"><span class="comment">// a reference to itself in another returned object.</span></span><br><span class="line">retVal = proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (retVal == <span class="keyword">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(</span><br><span class="line"><span class="string">"Null return value from advice does not match primitive return type for: "</span> + method);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line"><span class="comment">// Must have come from TargetSource.</span></span><br><span class="line">targetSource.releaseTarget(target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line"><span class="comment">// Restore old proxy.</span></span><br><span class="line">AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>获取目标对象方法的拦截器链<code>Advisors</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAdvisorChainFactory</span> <span class="keyword">implements</span> <span class="title">AdvisorChainFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Advised config, Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取存放的advisor集合</span></span><br><span class="line">List&lt;Object&gt; interceptorList = <span class="keyword">new</span> ArrayList&lt;&gt;(config.getAdvisors().length);</span><br><span class="line">Class&lt;?&gt; actualClass = (targetClass != <span class="keyword">null</span> ? targetClass : method.getDeclaringClass());</span><br><span class="line">          <span class="comment">// 是否是引介增强</span></span><br><span class="line"><span class="keyword">boolean</span> hasIntroductions = hasMatchingIntroductions(config, actualClass);</span><br><span class="line">         <span class="comment">// 获取Advisor适配器注册表</span></span><br><span class="line">AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Advisor advisor : config.getAdvisors()) &#123;</span><br><span class="line"><span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123;</span><br><span class="line"><span class="comment">// Add it conditionally.</span></span><br><span class="line">PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;</span><br><span class="line"><span class="keyword">if</span> (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">                    <span class="comment">// 获取advisor转换为MethodInterceptor</span></span><br><span class="line">MethodInterceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">                    <span class="comment">// 获取切点匹配</span></span><br><span class="line">MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();</span><br><span class="line"><span class="keyword">if</span> (MethodMatchers.matches(mm, method, actualClass, hasIntroductions)) &#123;</span><br><span class="line"><span class="keyword">if</span> (mm.isRuntime()) &#123;</span><br><span class="line"><span class="comment">// Creating a new object instance in the getInterceptors() method</span></span><br><span class="line"><span class="comment">// isn't a problem as we normally cache created chains.</span></span><br><span class="line"><span class="keyword">for</span> (MethodInterceptor interceptor : interceptors) &#123;</span><br><span class="line">interceptorList.add(<span class="keyword">new</span> InterceptorAndDynamicMethodMatcher(interceptor, mm));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">IntroductionAdvisor ia = (IntroductionAdvisor) advisor;</span><br><span class="line"><span class="keyword">if</span> (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> interceptorList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ReflectiveMethodInvocation proceed()方法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*proceed()方法用来处理拦截器链的下一个拦截器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">//如果拦截器链为空，则直接通过反射进行方法调用</span></span><br><span class="line">    <span class="comment">//调用真正的被代理对象的方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历拦截器集合</span></span><br><span class="line">    Object interceptorOrInterceptionAdvice =</span><br><span class="line">    <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">    <span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line"></span><br><span class="line">        InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">                (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">        <span class="comment">//如果方法匹配,则进行增强</span></span><br><span class="line">        <span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, <span class="keyword">this</span>.targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">           <span class="comment">//增强.并进行相应的递归调用</span></span><br><span class="line">            <span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//方法跟拦截器不匹配。则进行递归调用。处理下一个拦截器</span></span><br><span class="line">            <span class="keyword">return</span> proceed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//对Introduction进行增强处理。并进行递归调用</span></span><br><span class="line">        <span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>AnnotationAwareAspectJAutoProxyCreator UML图</p><p><img src="https://img-blog.csdnimg.cn/20190919120932404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70" alt="AnnotationAwareAspectJAutoProxyCreator UML图"></p></li><li><p>ProxyFactory UML图</p><p><img src="https://img-blog.csdnimg.cn/20190919120956667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70" alt="ProxyFactory UML图"></p></li><li><p>设计模式的使用</p><ul><li><p>工厂设计模式：分为工厂和工厂产生对象</p><ul><li><code>AopProxyFactory</code>创建<code>AopProxy</code></li></ul></li><li><p>代理设计模式</p><ul><li>JdkDynamicProxyFactory</li></ul></li><li><p>责任链设计模式</p><ul><li>DefaultAdvisorChainFactory和ReflectiveMethodInvocation的proceed()方法</li></ul></li><li><p>单例设计模式</p><ul><li>GlobalAdvisorAdapterRegistry获取AdvisorAdapterRegistry实现</li></ul></li><li><p>装饰器设计模式</p><ul><li>DefaultAdvisorAdapterRegistry的wrap方法</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring AOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring AOP </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux统计文件夹下的文件数目</title>
      <link href="/2019/09/15/Linux%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E7%9B%AE/"/>
      <url>/2019/09/15/Linux%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Shiro常见异常</title>
      <link href="/2019/09/15/Shiro%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8/"/>
      <url>/2019/09/15/Shiro%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<ol><li><p>验证异常</p><ul><li><code>AuthenticationException</code>：Shiro在登录认证中，认证失败需要抛出异常。<ul><li><code>CredentitalsException</code>：凭证异常<ul><li><code>IncorrectCredentialsException</code>：输入密码错误</li><li><code>ExpiredCredentialsException</code>：凭证过期 </li></ul></li><li><code>AccountException</code>：账号异常<ul><li><code>UnknownAccountException</code>：账号不存在</li><li><code>ExcessiveAttemptsException</code>：认证次数超过限制</li><li><code>DisabledAccountException</code>：禁用账号</li><li><code>LockedAccountException</code>：账号被锁定</li><li><code>ConcurrentAccessException</code>：并发访问异常(多个用户同时访问)</li></ul></li><li><code>UnsupportedTokenException</code>：使用了不支持的Token</li></ul></li></ul></li><li><p>授权异常</p><p><strong>(授权只能在成功的认证之后执行，因为授权数据（角色、权限等）必须总是与已知的标识相关联。这样的已知身份只能在成功登录时获得。)</strong></p><ul><li><code>AuthorizationException</code>：Shiro在授权过程，授权异常。<ul><li><code>UnauthenticatedException</code>：<strong>当尚未完成成功认证时，尝试执行授权操作时引发异常</strong></li><li><code>UnauthorizedException</code>：抛出以指示请求的操作或对请求的资源的访问是不允许的。</li><li><code>HostUnauthorizedException</code>：主机未经验证异常。</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Shiro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shiro权限注解AOP实现原理分析</title>
      <link href="/2019/09/15/Shiro%E6%9D%83%E9%99%90%E6%B3%A8%E8%A7%A3AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
      <url>/2019/09/15/Shiro%E6%9D%83%E9%99%90%E6%B3%A8%E8%A7%A3AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>前不久学习了Shiro 1.4.0提供的权限注解实现权限拦截。最开始猜测实现方式是基于AspectJ方式，即基于<code>@Apsect</code>配合<code>@Pointcut和@After,@AfterReturning,@AfterThrowing,@Around,@Before</code>实现。具体Spring基于Aspect，AOP实现类可以查看<code>AnnotationAwareAspectJAutoProxyCreator</code>。在此提供该类的UML图：</p><p><img src="https://img-blog.csdnimg.cn/20190915155105740.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70" alt="Spring基于AspectJ实现的AOP实现类UML图"></p><p>你可以看到Spring AOP实现继承类大致为ProxyConfig-&gt;ProxyProcessorSupport-&gt;AbstractAutoProxyCreator</p><p>-&gt;AbstractAdvisorAutoProxyCreator这条路线。其中Spring常见AOP实现类有3个。</p><ul><li><code>DefaultAdvisorAutoProxyCreator</code>：寻找当前BeanFactory中所有的候选<code>Advisor(有一个切点和一个通知构成)</code>，将这些Advisor应用到所有符合切点的Bean中。基于Advisor 匹配规则。</li><li><code>BeanNameAutoProxyCreator</code>：基于Bean配置名规则</li><li><code>AnnotationAwareAspectJAutoProxyCreator</code>：基于Bean中@AspectJ注解匹配规则。</li></ul><p>而Shiro权限注解实现原理是基于<code>DefaultAdvisorAutoProxyCreator</code>实现的。其权限注解处理Advisor实现类是<code>AuthorizationAttributeSourceAdvisor</code>。该类继承了<code>StaticMethodMatcherPointcutAdvisor</code>，内部只对Shiro提供的5个权限注解标注的方法或者类进行切面增强。<code>StaticMethodMatcherPointcutAdvisor</code>是静态方法切点基类，默认匹配所有的的类。<code>StaticMethodMatcherPointcut</code>包括两个主要的子类分别是</p><p><code>JdkRegexpMethodPointcut</code>和<code>NameMatchMethodPointcut</code>。前者提供正则表达式匹配方法切面，而后者<strong>作为正则表达式的替代，不处理重载方法，默认实现检测xxx*, *xxx 和*xxx*</strong>。</p><h3 id="AuthorizationAttributeSourceAdvisor"><a href="#AuthorizationAttributeSourceAdvisor" class="headerlink" title="AuthorizationAttributeSourceAdvisor"></a>AuthorizationAttributeSourceAdvisor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationAttributeSourceAdvisor</span> <span class="keyword">extends</span> <span class="title">StaticMethodMatcherPointcutAdvisor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;? extends Annotation&gt;[] AUTHZ_ANNOTATION_CLASSES =</span><br><span class="line">            <span class="keyword">new</span> Class[] &#123;</span><br><span class="line">                    RequiresPermissions.class, RequiresRoles.class,</span><br><span class="line">                    RequiresUser.class, RequiresGuest.class, RequiresAuthentication.class</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> SecurityManager securityManager = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new AuthorizationAttributeSourceAdvisor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuthorizationAttributeSourceAdvisor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setAdvice(<span class="keyword">new</span> AopAllianceAnnotationsAuthorizingMethodInterceptor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SecurityManager <span class="title">getSecurityManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecurityManager</span><span class="params">(org.apache.shiro.mgt.SecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.securityManager = securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class targetClass)</span> </span>&#123;</span><br><span class="line">        Method m = method;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( isAuthzAnnotationPresent(m) ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//The 'method' parameter could be from an interface that doesn't have the annotation.</span></span><br><span class="line">        <span class="comment">//Check to see if the implementation has it.</span></span><br><span class="line">        <span class="keyword">if</span> ( targetClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                m = targetClass.getMethod(m.getName(), m.getParameterTypes());</span><br><span class="line">                <span class="keyword">return</span> isAuthzAnnotationPresent(m) || isAuthzAnnotationPresent(targetClass);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException ignored) &#123;</span><br><span class="line">                <span class="comment">//default return value is false.  If we can't find the method, then obviously</span></span><br><span class="line">                <span class="comment">//there is no annotation, so just use the default return value.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测类上是否存在权限验证注解</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAuthzAnnotationPresent</span><span class="params">(Class&lt;?&gt; targetClazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>( Class&lt;? extends Annotation&gt; annClass : AUTHZ_ANNOTATION_CLASSES ) &#123;</span><br><span class="line">            Annotation a = AnnotationUtils.findAnnotation(targetClazz, annClass);</span><br><span class="line">            <span class="keyword">if</span> ( a != <span class="keyword">null</span> ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测方法上是否存在权限验证注解</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAuthzAnnotationPresent</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>( Class&lt;? extends Annotation&gt; annClass : AUTHZ_ANNOTATION_CLASSES ) &#123;</span><br><span class="line">            Annotation a = AnnotationUtils.findAnnotation(method, annClass);</span><br><span class="line">            <span class="keyword">if</span> ( a != <span class="keyword">null</span> ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Shiro注解权限验证MethodInterceptor"><a href="#Shiro注解权限验证MethodInterceptor" class="headerlink" title="Shiro注解权限验证MethodInterceptor"></a>Shiro注解权限验证MethodInterceptor</h3><p>该类是Shiro权限注解拦截器。初始化时，<code>interceptors</code>添加了5个方法拦截器，分别对5种权限验证方法进行拦截。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopAllianceAnnotationsAuthorizingMethodInterceptor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AnnotationsAuthorizingMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AopAllianceAnnotationsAuthorizingMethodInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;AuthorizingAnnotationMethodInterceptor&gt; interceptors =</span><br><span class="line">                <span class="keyword">new</span> ArrayList&lt;AuthorizingAnnotationMethodInterceptor&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//use a Spring-specific Annotation resolver - Spring's AnnotationUtils is nicer than the</span></span><br><span class="line">        <span class="comment">//raw JDK resolution process.</span></span><br><span class="line">        AnnotationResolver resolver = <span class="keyword">new</span> SpringAnnotationResolver();</span><br><span class="line">        <span class="comment">//we can re-use the same resolver instance - it does not retain state:</span></span><br><span class="line">        interceptors.add(<span class="keyword">new</span> RoleAnnotationMethodInterceptor(resolver));</span><br><span class="line">        interceptors.add(<span class="keyword">new</span> PermissionAnnotationMethodInterceptor(resolver));</span><br><span class="line">        interceptors.add(<span class="keyword">new</span> AuthenticatedAnnotationMethodInterceptor(resolver));</span><br><span class="line">        interceptors.add(<span class="keyword">new</span> UserAnnotationMethodInterceptor(resolver));</span><br><span class="line">        interceptors.add(<span class="keyword">new</span> GuestAnnotationMethodInterceptor(resolver));</span><br><span class="line"></span><br><span class="line">        setMethodInterceptors(interceptors);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation methodInvocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        org.apache.shiro.aop.MethodInvocation mi = createMethodInvocation(methodInvocation);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.invoke(mi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类通过调用invoke方法，进而调用超级父类<code>AuthorizingMethodInterceptor</code>的invoke方法，在该方法中会先执行<code>assertAuthorized</code>方法，进行权限校验，校验不通过抛出<code>AuthorizationException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizingMethodInterceptor</span> <span class="keyword">extends</span> <span class="title">MethodInterceptorSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation methodInvocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        assertAuthorized(methodInvocation);</span><br><span class="line">        <span class="keyword">return</span> methodInvocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">assertAuthorized</span><span class="params">(MethodInvocation methodInvocation)</span> <span class="keyword">throws</span> AuthorizationException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>assertAuthorized</code>方法最终执行还是<code>AnnotationsAuthorizingMethodInterceptor</code>。而<code>AuthorizingMethodInterceptor</code>有5个具体的实现类。如下：</p><ul><li>RoleAnnotationMethodInterceptor</li><li>PermissionAnnotationMethodInterceptor</li><li>AuthenticatedAnnotationMethodInterceptor</li><li>UserAnnotationMethodInterceptor</li><li>GuestAnnotationMethodInterceptor</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationsAuthorizingMethodInterceptor</span> <span class="keyword">extends</span> <span class="title">AuthorizingMethodInterceptor</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">assertAuthorized</span><span class="params">(MethodInvocation methodInvocation)</span> <span class="keyword">throws</span> AuthorizationException </span>&#123;</span><br><span class="line">        <span class="comment">//default implementation just ensures no deny votes are cast:</span></span><br><span class="line">        Collection&lt;AuthorizingAnnotationMethodInterceptor&gt; aamis = getMethodInterceptors();</span><br><span class="line">        <span class="keyword">if</span> (aamis != <span class="keyword">null</span> &amp;&amp; !aamis.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (AuthorizingAnnotationMethodInterceptor aami : aamis) &#123;</span><br><span class="line">                <span class="keyword">if</span> (aami.supports(methodInvocation)) &#123;</span><br><span class="line">                    aami.assertAuthorized(methodInvocation);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AuthorizingAnnotationMethodInterceptor</code>首先从子类获取<code>AuthorizingAnnotationHandler</code>，再调用该实现类的<code>assertAuthorized</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizingAnnotationMethodInterceptor</span> <span class="keyword">extends</span> <span class="title">AnnotationMethodInterceptor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuthorizingAnnotationMethodInterceptor</span><span class="params">( AuthorizingAnnotationHandler handler )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuthorizingAnnotationMethodInterceptor</span><span class="params">( AuthorizingAnnotationHandler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   AnnotationResolver resolver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(handler, resolver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation methodInvocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        assertAuthorized(methodInvocation);</span><br><span class="line">        <span class="keyword">return</span> methodInvocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assertAuthorized</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> AuthorizationException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((AuthorizingAnnotationHandler)getHandler()).assertAuthorized(getAnnotation(mi));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(AuthorizationException ae) &#123;</span><br><span class="line">            <span class="comment">// Annotation handler doesn't know why it was called, so add the information here if possible. </span></span><br><span class="line">            <span class="comment">// Don't wrap the exception here since we don't want to mask the specific exception, such as </span></span><br><span class="line">            <span class="comment">// UnauthenticatedException etc. </span></span><br><span class="line">            <span class="keyword">if</span> (ae.getCause() == <span class="keyword">null</span>) ae.initCause(<span class="keyword">new</span> AuthorizationException(<span class="string">"Not authorized to invoke method: "</span> + mi.getMethod()));</span><br><span class="line">            <span class="keyword">throw</span> ae;</span><br><span class="line">        &#125;         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RoleAnnotationMethodInterceptor"><a href="#RoleAnnotationMethodInterceptor" class="headerlink" title="RoleAnnotationMethodInterceptor"></a>RoleAnnotationMethodInterceptor</h3><p>下面分析一下RoleAnnotationMethodInterceptor。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleAnnotationMethodInterceptor</span> <span class="keyword">extends</span> <span class="title">AuthorizingAnnotationMethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RoleAnnotationMethodInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>( <span class="keyword">new</span> RoleAnnotationHandler() );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体校验逻辑交给RoleAnnotationHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RoleAnnotationMethodInterceptor</span><span class="params">(AnnotationResolver resolver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> RoleAnnotationHandler(), resolver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RoleAnnotationHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleAnnotationHandler</span> <span class="keyword">extends</span> <span class="title">AuthorizingAnnotationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assertAuthorized</span><span class="params">(Annotation a)</span> <span class="keyword">throws</span> AuthorizationException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(a <span class="keyword">instanceof</span> RequiresRoles)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        RequiresRoles rrAnnotation = (RequiresRoles) a;</span><br><span class="line">        String[] roles = rrAnnotation.value();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (roles.length == <span class="number">1</span>) &#123;</span><br><span class="line">            getSubject().checkRole(roles[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Logical.AND.equals(rrAnnotation.logical())) &#123;</span><br><span class="line">            getSubject().checkRoles(Arrays.asList(roles));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Logical.OR.equals(rrAnnotation.logical())) &#123;</span><br><span class="line">            <span class="comment">// Avoid processing exceptions unnecessarily - "delay" throwing the exception by calling hasRole first</span></span><br><span class="line">            <span class="keyword">boolean</span> hasAtLeastOneRole = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (String role : roles) <span class="keyword">if</span> (getSubject().hasRole(role)) hasAtLeastOneRole = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// Cause the exception if none of the role match, note that the exception message will be a bit misleading</span></span><br><span class="line">            <span class="keyword">if</span> (!hasAtLeastOneRole) getSubject().checkRole(roles[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现类似编程式AOP"><a href="#实现类似编程式AOP" class="headerlink" title="实现类似编程式AOP"></a>实现类似编程式AOP</h3><ol><li>定义一个注解<code>LogPrinter</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LogPrinter &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>继承StaticMethodMatcherPointcutAdvisor</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogPrinterAdvisor</span> <span class="keyword">extends</span> <span class="title">StaticMethodMatcherPointcutAdvisor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogPrinterAdvisor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setAdvice(<span class="keyword">new</span> LogPrinterMethodInterceptor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(@NonNull Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">        Method m = method;</span><br><span class="line">        <span class="keyword">if</span> (isAnnotationPresent(m)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (targetClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                m = targetClass.getMethod(m.getName(), m.getParameterTypes());</span><br><span class="line">                <span class="keyword">return</span> isAnnotationPresent(m);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException ignored) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAnnotationPresent</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        Annotation a = AnnotationUtils.findAnnotation(method, LogPrinter.class);</span><br><span class="line">        <span class="keyword">return</span> a != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>实现<code>MethodInterceptor</code>接口，定义切面处理逻辑</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogPrinterMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        LogPrinter logPrinter = invocation.getMethod().getAnnotation(LogPrinter.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"log printer: "</span>+logPrinter.value());</span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>定义测试类，并添加LogPrinter注解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LogPrinter</span>(<span class="string">"hello world"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>启动类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAdvisorApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultAdvisorAutoProxyCreator <span class="title">defaultAdvisorAutoProxyCreator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator = <span class="keyword">new</span> DefaultAdvisorAutoProxyCreator();</span><br><span class="line">        defaultAdvisorAutoProxyCreator.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> defaultAdvisorAutoProxyCreator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LogPrinterAdvisor <span class="title">logPrinterAdvisor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LogPrinterAdvisor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(LogAdvisorApplication.class, args);</span><br><span class="line">        HelloWorld helloWorld = context.getBean(HelloWorld.class);</span><br><span class="line">        helloWorld.hello();</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结与思考"><a href="#总结与思考" class="headerlink" title="总结与思考"></a>总结与思考</h3><p>Shiro的注解式权限，核心配置是一个<code>DefaultAdvisorAutoProxyCreator</code>和继承静态方法顾问<code>StaticMethodMatcherPointcutAdvisor</code>。其中5种权限注解，使用了统一的代码架构，用到了模板</p><p>设计模式。在架构实现上要好于<code>AspectJ注解实现</code>。</p><p><img src="https://img-blog.csdnimg.cn/20190915155201485.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70" alt="Shiro角色权限注解UML示意图"></p><p><img src="https://img-blog.csdnimg.cn/20190915155130196.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70" alt="Shiro权限注解AOP实现类UML图"></p>]]></content>
      
      
      <categories>
          
          <category> Spring AOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shiro </tag>
            
            <tag> Spring AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈互联网后端基础设施</title>
      <link href="/2019/09/14/%E8%B0%88%E8%B0%88%E4%BA%92%E8%81%94%E7%BD%91%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/"/>
      <url>/2019/09/14/%E8%B0%88%E8%B0%88%E4%BA%92%E8%81%94%E7%BD%91%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="转载：谈谈互联网后端基础设施"><a href="#转载：谈谈互联网后端基础设施" class="headerlink" title="转载：谈谈互联网后端基础设施"></a>转载：<a href="https://www.rowkey.me/blog/2016/08/27/server-basic-tech-stack/" target="_blank" rel="noopener">谈谈互联网后端基础设施</a></h3><p><strong>本文更新于2018.09.14, 更新了后端基础设施框图，增加了负载均衡、Web服务器以及大数据存储和多维数据分析等部分</strong></p><p>对于一个互联网企业，后端服务是必不可少的一个组成部分。抛开业务应用来说，往下的基础服务设施做到哪些才能够保证业务的稳定可靠、易维护、高可用呢？纵观整个互联网技术体系再结合公司的目前状况，个人认为必不可少或者非常关键的后端基础技术/设施如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20190914170030455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70" alt="后端基础设施"></p><p>这里的后端基础设施主要指的是应用在线上稳定运行需要依赖的关键组件/服务等。开发或者搭建好以上的后端基础设施，一般情况下是能够支撑很长一段时间内的业务的。此外，对于一个完整的架构来说，还有很多应用感知不到的系统基础服务，如负载均衡、自动化部署、系统安全等，并没有包含在本文的描述范围内。</p><h2 id="Api网关"><a href="#Api网关" class="headerlink" title="Api网关"></a>Api网关</h2><p>在移动app的开发过程中，通常后端提供的接口需要以下功能的支持：</p><ul><li>负载均衡</li><li>api访问权限控制</li><li>用户鉴权</li></ul><p>一般的做法，使用nginx做负载均衡，然后在每个业务应用里做api接口的访问权限控制和用户鉴权，更优化一点的方式则是把后两者做成公共类库供所有业务调用。但从总体上来看，这三种特性都属于业务的公共需求，更可取的方式则是集成到一起作为一个服务，既可以动态地修改权限控制和鉴权机制，也可以减少每个业务集成这些机制的成本。这种服务就是Api网关(<a href="http://blog.csdn.net/pzxwhc/article/details/49873623)，可以选择自己实现，也可以使用开源软件实现，如[Kong](https://getkong.org/)。如下图所示：" target="_blank" rel="noopener">http://blog.csdn.net/pzxwhc/article/details/49873623)，可以选择自己实现，也可以使用开源软件实现，如[Kong](https://getkong.org/)。如下图所示：</a></p><p><img src="https://img-blog.csdnimg.cn/20190914170547823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70" alt="API网关"></p><p>但是以上方案的一个问题是由于所有api请求都要经过网关，它很容易成为系统的性能瓶颈。因此，可以采取的方案是：去掉api网关，让业务应用直接对接统一认证中心，在基础框架层面保证每个api调用都需要先通过统一认证中心的认证，这里可以采取缓存认证结果的方式避免对统一认证中心产生过大的请求压力。</p><h2 id="业务应用和后端基础框架"><a href="#业务应用和后端基础框架" class="headerlink" title="业务应用和后端基础框架"></a>业务应用和后端基础框架</h2><p>业务应用分为：在线业务应用和内部业务应用。</p><ul><li>在线业务应用：直接面向互联网用户的应用、接口等，典型的特点就是：请求量大、高并发、高可用、对故障的容忍度低。</li><li>内部业务应用：这个是面向公司内部的应用。比如，内部数据管理平台、广告投放平台等。相比起在线业务应用，其特点: 数据保密性高、压力小、并发量小、允许故障的发生。</li></ul><p>业务应用基于后端的基础框架开发，针对Java后端来说，应该有的几个框架如下：</p><ul><li>MVC框架：从十年前流行的Struts1、2到现在最为推崇的SpringMVC、Jersey以及国人开发的JFinal、阿里的WebX等等，这些框架尤其是后面流行的这些都是各有千秋的。选型的主要因素是看你的团队是否有一个对某框架能够做二次开发、定制的人在。很多时候，针对这些通用的框架，你是需要做一些特定的开发才能满足特定的需求的。比如，很多团队传递参数使用的都是UnderScore的命名法(下划线连接单词)，但是Java中确是使用LowCamel命名的。对于SpringMVC，可以通过注解的alias来指定，但这样需要对每一个参数都要指定alias有点效率太低，此外ModelAttribute也不支持别名，更好的方式是在框架层面统一对参数做Camel命名的转换达到目的。</li><li>IOC框架：ioc带来的好处无须多言。目前Java中最为流行的Spring自诞生就天然支持IOC。</li><li>ORM框架：MyBatis是目前最为流行的orm框架。此外，Spring ORM中提供的JdbcTemplate也很不错。当然，对于分库分表、主从分离这些需求，一般就需要实现自己的ORM框架来支持了，像阿里的tddl、当当的<a href="https://github.com/dangdangdotcom/sharding-jdbc" target="_blank" rel="noopener">sharding-jdbc</a>(从datasource层面解决了分库分表、读写分离的问题，对应用透明、零侵入)。此外，为了在服务层面统一解决分库分表、主从分离、主备切换、缓存、故障恢复等问题，很多公司都是有自己的数据库中间件的，比如阿里的Cobar、360的Atlas、网易的DDB，还有官方提供的<a href="http://downloads.mysql.com/archives/proxy/" target="_blank" rel="noopener">MySQL Proxy</a>以及开源的<a href="https://github.com/MyCATApache/Mycat-Server" target="_blank" rel="noopener">MyCat</a>、<a href="https://github.com/flike/kingshard" target="_blank" rel="noopener">kingshard</a>和收费的<a href="http://www.onexsoft.com/?page_id=3391" target="_blank" rel="noopener">oneproxy</a>。目前，线上有一定规模使用的应该是kingshard，当然如果不缺钱也可以上oneproxy。</li><li>缓存框架：缓存框架主要指的是对redis、memcached这些缓存服务器的操作统一封装，一般使用Spring的RedisTemplate即可，也可以使用jedis做自己的封装，支持客户端分布式方案、主从等。</li><li>JavaEE应用性能检测框架：对于线上的JavaEE应用，需要有一个统一的框架集成到每一个业务中检测每一个请求、方法调用、jdbc连接、redis连接等的耗时、状态等。<a href="http://www.oschina.net/p/jwebap" target="_blank" rel="noopener">jwebap</a>是一个可以使用的性能检测工具，但由于其已经很多年没有更新，有可能的话建议基于此项目做二次开发。</li></ul><p>一般来说，以上几个框架即可以完成一个后端应用的雏形。</p><p>对于这些框架来说，最为关键的是根据团队技术构成选择最合适的，有能力开发自己的框架则更好。此外，这里需要提供一个后端应用的模板或生成工具(如maven的archetype)给团队成员使用，可以让大家在开发新的应用的时候，迅速的生成雏形应用，而无需再做一些框架搭建的重复性劳动。</p><h2 id="基础服务软件"><a href="#基础服务软件" class="headerlink" title="基础服务软件"></a>基础服务软件</h2><p>负载均衡器、Web/应用服务器缓存、数据库、搜索引擎、消息队列这些都是应用依赖的后端基础服务软件，他们的性能直接影响到了应用的整体性能，有时候你代码写的再好也许就是因为这些服务导致应用性能无法提升上去。</p><h3 id="负载均衡器和Web-应用服务器"><a href="#负载均衡器和Web-应用服务器" class="headerlink" title="负载均衡器和Web/应用服务器"></a>负载均衡器和Web/应用服务器</h3><p>业务应用最终是需要运行在Web/应用服务器中才能对外提供服务的。Nginx、Apache Http Server、微软的IIS是常用的Web服务器Tomcat、Jetty是常用的Servlet容器；JBoss、Weblogic是常用的JavaEE应用服务器。互联网技术领域，常选择Nginx为Web服务器，Tomcat做Servlet容器。</p><p>进一步的，如果想要部署多了克隆的业务应用结点一起对外提供服务，那么则需要负责均衡器反向代理多个克隆服务节点共同对外提供服务。LVS做四层流量转发，Nginx做七层流量转发，HaProxy兼具七层、四层流量转发功能。此外DNS轮训也是一种负载均衡方案。当然，F5等硬件负载均衡器性能会更高。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>如缓存五分钟法则所讲：如果一个数据频繁被访问，那么就应该放内存中。这里的缓存就是一种读写效率都非常高的存储方案，能够应对高并发的访问请求，通常情况下也不需要持久化的保证。但相对其他存储来说，缓存一般是基于内存的，成本比较昂贵，因此不能滥用。</p><p>缓存可以分为：本地缓存和分布式缓存。</p><ul><li>本地缓存：主要指的是内存中的缓存机制。在Java中，Google Guava中就提供了本地缓存的实现机制。当然使用java的ConncurrentHashMap你也可以实现自己的本地缓存方案。</li><li>分布式缓存：指的单独的缓存服务。几年前比较流行的是memcached，但其只是一个KV的存储，支持的数据结构太少。现在最为流行的就是Redis，能够支持丰富的数据结构，基于事件驱动的单线程非阻塞IO也能够应对高并发的场景。集群方案除了官方的redis cluster, 目前比较流行的还有豌豆荚的<a href="https://github.com/wandoulabs/codis" target="_blank" rel="noopener">codis</a>、twitter的<a href="https://github.com/twitter/twemproxy" target="_blank" rel="noopener">twemproxy</a>。</li></ul><p>对于缓存的使用，需要注意以下几点：</p><ul><li><p>缓存的失效机制：当给某一个key设置了有效期，那么缓存何时对此key进行删除呢？一般来说会有以下几种方式：</p><ul><li>守护进程定时去扫描key，找到已经失效的key，然后删除</li><li>读取key的时候先去判断key是否失效，如果失效则删除并返回空。</li></ul></li><li><p>缓存的淘汰机制：是当缓存内存达到上限时如何删除缓存中的key。Redis提供了以下数据淘汰策略：</p><ul><li>volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰</li><li>volatile-random：从已设置过期时间的数据集中任意选择数据淘汰</li><li>allkeys-lru：从数据集中挑选最近最少使用的数据淘汰</li><li>allkeys-random：从数据集中任意选择数据淘汰</li><li>no-enviction（驱逐）：禁止驱逐数据</li></ul><p>对于其具体的实现机制，可以参考<a href="http://redisbook.com/" target="_blank" rel="noopener">《Redis设计与实现》</a>一书</p></li><li><p>缓存的更新机制: 通常来说有四种方式：Cache aside, Read through, Write through, Write behind caching，具体的可见陈皓大神的这篇总结：<a href="http://coolshell.cn/articles/17416.html" target="_blank" rel="noopener">缓存更新的套路</a>。</p></li><li><p>缓存的服务过载保护：缓存的服务过载指的是由于缓存失效，而引起后端服务的压力骤增，进一步产生雪崩效应。这个现象和缓存更新是相关的，采取何种策略在缓存失效的时候去更新缓存直接决定了服务过载的保护机制。通常的分为客户端和服务端的应对方案。前者的方案有：基于超时的简单模式、基于超时的常规模式、基于刷新的简单模式、基于刷新的常规模式、基于刷新的续费模式。后者的方案则是很常见的流量控制和服务降级。具体的可以看美团技术团队总结的这篇文章：<a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651745239&idx=1&sn=60490558770ade79fd9f1e88f9c7c0ac&scene=1&srcid=0617o5PapWXlKUP4OxSzA7KE#rd" target="_blank" rel="noopener">Cache应用中的服务过载案例研究</a>。</p></li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>数据库是后端开发中非常常见的一个服务组件。对于数据库的选型，要根据业务的特点和数据结构的特点来决定。</p><p>从存储介质上，数据库可以分为：</p><ul><li>内存数据库： 数据主要存储在内存中，同时也可以采取措施对数据进行持久化到硬盘中。如Redis、H2DB的内存模式。对于这种数据库，由于内存成本昂贵，因此一定要做好存储的量化分析、容量预估，防止内存不足造成服务不可用。</li><li>硬盘数据库：数据存储在硬盘上的这种数据库是最为常见的。MySQL、Oracle、Postgresql、HBASE、H2DB、SqlLite等等都是硬盘数据库。此外，<a href="https://github.com/ideawu/ssdb" target="_blank" rel="noopener">SSDB</a>是基于SSD硬盘的KV数据库，支持的数据接口很丰富，是Redis的另外一个选择。</li></ul><p>从存储数据类型、数据模式上，数据库可以分为：</p><ul><li>关系型数据库：MySQL、Oracle、Postgresql都是关系型数据库的，是采用关系模型(关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织)来组织数据的数据库。</li><li>非关系型数据库：非关系型数据库是相对关系型数据库来讲的。以键值对存储，且结构不固定，每一个元组可以有不一样的字段，每个元组可以根据需要增加一些自己的键值对，这样就不会局限于固定的结构，可以减少一些时间和空间的开销。但是，其没有关系型数据库那种严格的数据模式，并不适合复杂的查询以及需要强事务管理的业务。非关系型数据库又可以分为：<ul><li>KV数据库：主要以(key,value)键值对存储数据的数据库。以Redis、RocksDB(levelDB)、SSDB为代表。</li><li>文档数据库：总体形式上也是键值对的形式，但是值里面又可以有各种数据结构：数组、键值对、字符串等等。以mongodb、couchdb为代表。</li><li>列数据库：也叫作稀疏大数据库，一般是用来存储海量数据的。相对于行数据库，这种数据库是以列为单位存储数据在介质上的。以Hbase、Cassendra为代表。</li></ul></li></ul><p>和数据库相关的一个很重要的就是数据库的索引。有一种说法是：“掌握了索引就等于掌握了数据库”。暂且不去评判此说法是否真的准确，但索引的确关系着数据库的读写性能。需要对数据库的索引原理做到足够的了解才能更好的使用各种数据库。通常来说，Mysql、Oracle、Mongodb这些都是使用的B树作为索引，是考虑到传统硬盘的特点后兼顾了读写性能以及范围查找需求的选择，而Hbase用得LSM则是为了提高写性能对读性能做了牺牲。</p><h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><p>搜索引擎也是后端应用中一个很关键的组件，尤其是对内容类、电商类的应用，通过关键词、关键字搜索内容、商品是一个很常见的用户场景。比较成熟的开源搜索引擎有Solr和Elasticsearch，很多中小型互联网公司搜索引擎都是基于这两个开源系统搭建的。它们都是基于Lucence来实现的，不同之处主要在于termIndex的存储、分布式架构的支持等等。</p><p>对于搜索引擎的使用，从系统熟悉、服务搭建、功能定制，需要花费较长时间。在这个过程中，需要注意以下问题：</p><ul><li>搜索引擎与公司现有数据系统的集成。现有的持久化、供搜索的数据的载体是什么, 如何让搜索引擎在全量和增量建索引过程中无缝集成原来的数据载体，才能发挥搜索引擎自身的实时性, 水平扩展性(性能与容量和机器数量成正比)等优势。</li><li>和数据库一样，对搜索引擎的索引机制也需要做到深入的了解。</li></ul><p>更为详细的对于搜索引擎的工程化实践可以参考有赞工程师的这篇文章：<a href="http://www.cnblogs.com/hsydj/p/5303050.html" target="_blank" rel="noopener">有赞搜索引擎实践(工程篇)</a></p><p>另外，搜索引擎还可以用在数据的多维分析上，就是<a href="https://www.growingio.com/" target="_blank" rel="noopener">GrowingIO</a>、<a href="https://mixpanel.com/" target="_blank" rel="noopener">MixPanel</a>中的可以任意维度查询数据报表的功能。当然，<a href="http://druid.io/" target="_blank" rel="noopener">druid</a>也许是一个更好的实现多维分析的方案，官方也有其与es的比较：<a href="http://druid.io/docs/latest/comparisons/druid-vs-elasticsearch.html。" target="_blank" rel="noopener">http://druid.io/docs/latest/comparisons/druid-vs-elasticsearch.html。</a></p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>软件的组织结构，从开始的面向组件到SOA、SAAS是一个逐渐演变的过程。而到了今天微服务盛行的时代，你都不好意思说自己的系统只是单一的一个系统而没有解耦成一个个service。当然，小的系统的确没有拆分的必要性，但一个复杂的系统拆成一个个service做微服务架构确实是不得不做的事情。</p><p>那么问题就来了，service之间的通信如何来做呢？使用什么协议？通过什么方式调用？都是需要考虑的问题。</p><p>先抛开协议不谈，service之间的调用方式可以分为同步调用以及异步调用。同步调用的方式无需多说，那么异步调用是怎么进行的呢？一种很常见的方式就是使用消息队列，调用方把请求放到队列中即可返回，然后等待服务提供方去队列中去获取请求进行处理，然后把结果返回给调用方即可（可以通过回调）。</p><p>异步调用就是消息中间件一个非常常见的应用场景。此外，消息队列的应用场景还有以下：</p><ul><li>解耦：一个事务，只关心核心的流程，需要依赖其他系统但不那么重要的事情，有通知即可，无须等待结果。</li><li>最终一致性：指的是两个系统的状态保持一致，要么都成功，要么都失败，可以有一定的延迟，只要最终达到一致性即可。</li><li>广播：这是消息队列最基本的功能。生产者只需要发布消息，无须关心有哪些订阅者来消费消息。</li><li>错峰与流控：当上下游系统处理能力不同的时候就需要类似消息队列的方式做为缓冲区来隔开两个系统。</li></ul><p>目前主流的消息队列软件，主要有以下几种：</p><ul><li>ActiveMQ：Java中最为简单的消息队列，是对JMS的实现，没有规定消息的顺序、安全、重发等特性。</li><li>RabbitMQ：是对AMQP协议的实现，对于消息的顺序性、安全、重发等都做了很好的支持。比较适合不允许数据丢失、有事务需求的业务场景下的消息传输。</li><li>Kafka：是基于Log的消息队列，底层依赖于文件的顺序读取，是append-only的。适合对数据丢失不敏感、强调性能的一些海量日志传输场景中。是最近几年大数据领域很火的一个技术。</li><li>ZeroMQ：是一个网络编程的Pattern库，将常见的网络请求形式（分组管理，链接管理，发布订阅等）模式化、组件化，简而言之socket之上、MQ之下。对于MQ来说，网络传输只是它的一部分，更多需要处理的是消息存储、路由、Broker服务发现和查找、事务、消费模式（ack、重投等）、集群服务等。</li></ul><h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><p>不管是业务应用、依赖的后端服务还是其他的各种服务，最终还是要依赖于底层文件存储的。通常来说，文件存储需要满足的特性有：可靠性、容灾性、稳定性，即要保证存储的数据不会轻易丢失，即使发生故障也能够有回滚方案，也要保证高可用率。在底层可以采用传统的RAID作为解决方案，再上一层，目前hadoop的hdfs则是最为普遍的分布式文件存储方案，当然还有NFS、Samba这种共享文件系统也提供了简单的分布式存储的特性。</p><p>此外，如果文件存储确实成为了应用的瓶颈或者必须提高文件存储的性能从而提升整个系统的性能时，那么最为直接和简单的做法就是抛弃传统机械硬盘，用SSD硬盘替代。像现在很多公司在解决业务性能问题的时候，最终的关键点往往就是SSD。这也是用钱换取时间和人力成本最直接和最有效的方式。在数据库部分描述的SSDB就是对LevelDB封装之后，利用SSDB的特性的一种高性能KV数据库。</p><p>至于HDFS，如果要使用上面的数据，是需要通过hadoop的。类似xx on yarn的一些技术就是将非hadoop技术跑在hdfs上的解决方案(当然也是为了使用MR)。</p><h2 id="统一认证中心"><a href="#统一认证中心" class="headerlink" title="统一认证中心"></a>统一认证中心</h2><p>统一认证中心，主要是对app用户、内部用户、app等的认证服务，包括</p><ul><li>用户的注册、登录验证、token鉴权</li><li>内部信息系统用户的管理和登录鉴权</li><li>App的管理，包括app的secret生成，app信息的验证(如验证接口签名)等。</li></ul><p>之所以需要统一认证中心，就是为了能够集中对这些所有app都会用到的信息进行管理，也给所有应用提供统一的认证服务。尤其是在有很多业务需要共享用户数据的时候，构建一个统一认证中心是非常必要的。此外，通过统一认证中心构建移动app的单点登录也是水到渠成的事情(模仿web的机制，将认证后的信息加密存储到本地磁盘中供多个app使用)。</p><h2 id="单点登录系统"><a href="#单点登录系统" class="headerlink" title="单点登录系统"></a>单点登录系统</h2><p>目前很多大的在线web网站都是有单点登录系统的，通俗的来说就是只需要一次用户登录，就能够进入多个业务应用(权限可以不相同)，非常方便用户的操作。而在移动互联网公司中，内部的各种管理、信息系统同样也需要单点登录系统。目前，比较成熟的、用的最多的单点登录系统应该是耶鲁大学开源的<a href="https://github.com/Jasig/cas" target="_blank" rel="noopener">CAS</a>, 可以基于<a href="https://github.com/apereo/cas/tree/master/cas-server-webapp来定制开发的。此外，国人开源的[kisso](http://git.oschina.net/juapk/kisso)的这个也不错。基本上，单点登录的原理都类似下图所示：" target="_blank" rel="noopener">https://github.com/apereo/cas/tree/master/cas-server-webapp来定制开发的。此外，国人开源的[kisso](http://git.oschina.net/juapk/kisso)的这个也不错。基本上，单点登录的原理都类似下图所示：</a></p><p><img src="https://img-blog.csdnimg.cn/20190914170657429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70" alt="单点登录原理"></p><h2 id="统一配置中心"><a href="#统一配置中心" class="headerlink" title="统一配置中心"></a>统一配置中心</h2><p>在Java后端应用中，一种读写配置比较通用的方式就是将配置文件写在propeties、yaml、HCON文件中，修改的时候只需要更新文件重新部署即可，可以做到不牵扯代码层面改动的目的。统一配置中心，则是基于这种方式之上的统一对所有业务或者基础后端服务的相关配置文件进行管理的统一服务, 具有以下特性：</p><ul><li>能够在线动态修改配置文件并生效</li><li>配置文件可以区分环境(开发、测试、生产等)</li><li>使用方便: 在java中可以通过注解、xml配置的方式引入相关配置</li></ul><p><a href="https://github.com/knightliao/disconf" target="_blank" rel="noopener">disconf</a>是可以在生产环境使用的一个方案，也可能根据自己的需求开发自己的配置中心(可以选择zookeeper作为配置存储)。</p><h2 id="服务治理框架"><a href="#服务治理框架" class="headerlink" title="服务治理框架"></a>服务治理框架</h2><p>对于外部API调用或者客户端对后端api的访问，可以使用http协议或者说restful(当然也可以直接通过最原始的socket来调用)。但对于内部服务间的调用，一般都是通过RPC机制来调用的。目前主流的RPC协议有：</p><ul><li>RMI</li><li>Hessian</li><li>Thrift</li><li>Dubbo</li></ul><p>这些RPC协议各有优劣点，需要针对业务需求做出相应的最好的选择。</p><p>这样，当你的系统服务在逐渐增多，RPC调用链越来越复杂，很多情况下，需要不停的更新文档来维护这些调用关系。一个对这些服务进行管理的框架可以大大节省因此带来的繁琐的人力工作。</p><p>传统的ESB(企业服务总线)本质就是一个服务治理方案，但esb作为一种proxy的角色存在于client和server之间，所有请求都需要经过esb，使得esb很容易成为性能瓶颈。因此，基于传统的esb，更好的一种设计如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20190914170720616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70" alt="esb设计"></p><p>如图，以配置中心为枢纽，调用关系只存在于client和提供服务的server之间，就避免了传统esb的性能瓶颈问题。对于这种设计，esb应该支持的特性如下：</p><ul><li>服务提供方的注册、管理</li><li>服务消费者的注册、管理</li><li>服务的版本管理、负载均衡、流量控制、服务降级等</li><li>服务的容错、熔断等</li></ul><p>阿里开源的<a href="https://github.com/alibaba/dubbo" target="_blank" rel="noopener">dubbo</a>则对以上做了很好的实现，也是目前很多公司都在使用的方案。但由于某些原因，dubbo现已不再维护，推荐大家使用当当后来维护的<a href="https://github.com/dangdangdotcom/dubbox" target="_blank" rel="noopener">dubbox</a>。</p><h2 id="统一调度中心"><a href="#统一调度中心" class="headerlink" title="统一调度中心"></a>统一调度中心</h2><p>在很多业务中，定时调度是一个非常普遍的场景，比如定时去抓取数据、定时刷新订单的状态等。通常的做法就是针对各自的业务依赖Linux的cron机制或者java中的quartz。统一调度中心则是对所有的调度任务进行管理，这样能够统一对调度集群进行调优、扩展、任务管理等。<a href="https://github.com/azkaban/azkaban" target="_blank" rel="noopener">azkaban</a>和<a href="https://github.com/yahoo/oozie" target="_blank" rel="noopener">oozie</a>是hadoop的流式工作管理引擎，也可以作为统一调度中心来使用。当然，你也可以使用cron或者quartz来实现自己的统一调度中心。</p><ul><li>根据cron表达式调度任务</li><li>动态修改、停止、删除任务</li><li>支持任务工作流：比如一个任务完成之后再执行下一个任务</li><li>任务支持脚本、代码、url等多种形式</li><li>任务执行的日志记录、故障报警</li></ul><p>对于Java的quartz这里需要说明一下：这个quartz需要和spring quartz区分，后者是spring对quartz框架的简单实现也是目前使用的最多的一种调度方式。但其并没有做高可用集群的支持。而quartz虽然有集群的支持，但是配置起来非常复杂。现在很多方案都是使用zookeeper来实现spring quartz集群的。这里有一个国人开源的<a href="http://git.oschina.net/uncode/uncode-schedule" target="_blank" rel="noopener">uncode-shcedule</a>对此实现的还不错，可以根据自己的业务需求做二次开发。此外，当当开源的<a href="https://github.com/dangdangdotcom/elastic-job" target="_blank" rel="noopener">elastic-job</a>则在此之上又加入了弹性资源利用等更为强大的功能。</p><h2 id="统一日志服务"><a href="#统一日志服务" class="headerlink" title="统一日志服务"></a>统一日志服务</h2><p>日志是开发过程必不可少的东西。有时候，打印日志的时机、技巧是很能体现出工程师编码水平的。毕竟，日志是线上服务能够定位、排查异常最为直接的信息。</p><p>通常的，将日志分散在各个业务中非常不方便对问题的管理和排查。统一日志服务则使用单独的日志服务器记录日志，各个业务通过统一的日志框架将日志输出到日志服务器上。</p><p>可以通过实现log4j后者logback的appender来实现统一日志框架，然后通过RPC调用将日志打印到日志服务器上。</p><h2 id="数据基础设施"><a href="#数据基础设施" class="headerlink" title="数据基础设施"></a>数据基础设施</h2><p>数据是最近几年非常火的一个领域。从《精益数据分析》到《增长黑客》，都是在强调数据的非凡作用。很多公司也都在通过数据推动产品设计、市场运营、研发等。详细的可见之前的一篇<a href="http://www.rowkey.me/blog/2016/02/23/data-talk/" target="_blank" rel="noopener">《数据杂谈》</a>，对数据相关的东西做过一些总结。这里需要说明的一点是，只有当你的数据规模真的到了单机无法处理的规模才应该上大数据相关技术，千万不要为了大数据而大数据。很多情况下使用单机程序+mysql就能解决的问题非得上hadoop即浪费时间又浪费人力。</p><p>这里需要补充一点的是，对于很多公司，尤其是离线业务并没有那么密集的公司，在很多情况下大数据集群的资源是被浪费的。因此诞生了<strong>xx on yarn</strong>一系列技术让非hadoop系的技术可以利用大数据集群的资源，能够大大提高资源的利用率，如Docker on yarn(Hulu的VoidBox)。</p><h3 id="数据高速公路"><a href="#数据高速公路" class="headerlink" title="数据高速公路"></a>数据高速公路</h3><p>接着上面讲的统一日志服务，其输出的日志最终是变成数据到数据高速公路上供后续的数据处理程序消费的。这中间的过程包括日志的收集、传输。</p><ul><li><p>收集：统一日志服务将日志打印在日志服务上之后，需要日志收集机制将其集中起来。目前，常见的日志收集方案有：scribe、Chukwa、Kakfa和Flume。对比如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20190914170754214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70" alt="数据高速公路"></p></li><li><p>传输：通过消息队列将数据传输到数据处理服务中。对于日志来说，通常选择kafka这种消息队列即可。</p></li></ul><p>此外，这里还有一个关键的技术就是数据库和数据仓库间的数据同步问题，即将需要分析的数据从数据库中同步到诸如hive这种数据仓库时使用的方案。比较简单的、用的也比较多的可以使用<a href="http://hortonworks.com/apache/sqoop/" target="_blank" rel="noopener">sqoop</a>进行基于时间戳的数据同步，此外，阿里开源的<a href="https://github.com/alibaba/canal" target="_blank" rel="noopener">canal</a>实现了基于binlog增量同步，更加适合通用的同步场景，但是基于canal你还是需要做不少的业务开发工作的。推荐另一款国人开源的<a href="http://git.oschina.net/qiangzigege/MySQL-Binlog" target="_blank" rel="noopener">MySQL-Binlog</a>，原理和canal类似，默认提供了任务的后台管理功能，只需要实现接收到binlog后的处理逻辑即可。</p><h3 id="离线数据处理"><a href="#离线数据处理" class="headerlink" title="离线数据处理"></a>离线数据处理</h3><p>离线数据分析是可以有延迟的，一般针对是非实时需求的数据分析工作，产生的也是T-1的报表。目前最常用的离线数据分析技术除了hadoop还有spark。相比hadoop，spark性能上有很大优势，当然对硬件资源要求也高。</p><p>对于hadoop，传统的MR编写很复杂，也不利于维护，可以选择使用hive来用sql替代编写mr，但是前提务必要对hive的原理做到了解。可以参见美团的这篇博文来学习:<a href="http://tech.meituan.com/hive-sql-to-mapreduce.html" target="_blank" rel="noopener">Hive SQL的编译过程</a>。而对于spark，也有类似hive的spark sql。</p><p>此外，对于离线数据分析，还有一个很关键的就是数据倾斜问题。所谓数据倾斜指的是region数据分布不均，造成有的结点负载很低，而有些却负载很高，从而影响整体的性能。因此，处理好数据倾斜问题对于数据处理是很关键的。对于hive的数据倾斜，可见:<a href="http://www.cnblogs.com/ggjucheng/archive/2013/01/03/2842860.html" target="_blank" rel="noopener">hive大数据倾斜总结</a>。对于spark的倾斜问题，可见：<a href="http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651745207&idx=1&sn=3d70d59cede236eb1cb4f7374387a235&scene=0#rd" target="_blank" rel="noopener">Spark性能优化指南——高级篇</a>。</p><h3 id="实时数据处理"><a href="#实时数据处理" class="headerlink" title="实时数据处理"></a>实时数据处理</h3><p>相对于离线数据分析，实时数据分析也叫在线数据分析，针对的是对数据有实时要求的业务场景，如广告结算、订单结算等。目前，比较成熟的实时技术有storm和spark streaming。相比起storm，spark streaming其实本质上还是基于批量计算的。如果是对延迟很敏感的场景，还是应该使用storm。</p><p>对于实时数据分析，需要注意的就是实时数据处理结果写入存储的时候，要考虑并发的问题，虽然对于storm的bolt程序来说不会有并发的问题，但是写入的存储介质是会面临多任务同时读写的。通常采用的方案就是采用时间窗口的方式对数据做缓冲后批量写入。</p><p>此外，实时数据处理一般情况下都是基于增量处理的，相对于离线来说并非可靠的，一旦出现故障(如集群崩溃)或者数据处理失败，是很难对数据恢复或者修复异常数据的。因此结合离线+实时是目前最普遍采用的数据处理方案。<a href="http://www.csdn.net/article/2014-07-08/2820562-Lambda-Linkedln" target="_blank" rel="noopener">Lambda架构</a>就是一个结合离线和实时数据处理的架构方案。</p><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p>不论是源数据、离线处理得到的数据还是实时数据处理的数据最终都是要做持久化存储的。目前，大数据领域的常用存储方案有：</p><ul><li>HDFS: 直接存储在Hadoop的文件系统上，包括ORC、Parquet、Sequence的存储格式。此种存储是静态数据存储方式。适用于高吞吐量的离线大数据分析场景。这类存储的局限性是数据无法进行随机的读写。</li><li>HBase: 和Cassandra一样都属于动态数据存储。适用于大数据随机读写场景。这类存储的局限性是批量读取吞吐量远不如 HDFS，不适用于批量数据分析的场景。</li><li>Kudu: 在静态数据和动态数据的折中实现，平衡了随机读写和批量分析的性能，既支持随机读写，又支持OLAP分析。</li></ul><h3 id="多维数据分析"><a href="#多维数据分析" class="headerlink" title="多维数据分析"></a>多维数据分析</h3><p>数据的最终用途是用来分析的，即能够在多个维度以及其组合上输出统计报表数据。目前主要有两种解决此问题的方案：ROLAP和MOLAP。</p><ul><li>ROLAP：使用关系型数据库或者扩展的关系型数据库来管理数据仓库数据，以Hive、Spark SQL、Presto、Impala为代表，其中后两者是MPP架构，能够达到秒级的响应。</li><li>MOLAP：基于数据立方体的多位存储引擎，用空间换时间，把所有的分析情况都物化为物理表或者视图。以Druid、Pinot和Kylin为代表，不同于ROLAP, 其原生的支持多维的数据查询。</li></ul><p>其中，ROLAP能够组合任意维度进行数据展示和分析（Adhoc Query,数据即席查询），可以在离线和实时数据处理产生的定制报表无法满足数据需求方时，提供给一个可以根据自己的需求灵活的选择查询条件进行分析的工具，能够大大提高数据分析师、产品经理的工作效率。如果想进一步提供给需求方更加直观的UI操作界面，可以搭建内部的Hue。</p><p><img src="https://img-blog.csdnimg.cn/20190914170821204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70" alt="内部hive"></p><p>而MOLAP虽然不能满足任意维度查询，但是其空间换时间，性能是好于ROLAP的，也是多维数据实时分析的一种常用方案。对于其中常用的三个框架，对比如下：</p><table><thead><tr><th align="left">.</th><th align="left">使用场景</th><th align="left">语言</th><th align="left">协议</th><th align="left">特点</th></tr></thead><tbody><tr><td align="left">Druid</td><td align="left">实时处理分析</td><td align="left">Java</td><td align="left">JSON</td><td align="left">实时聚合</td></tr><tr><td align="left">Pinot</td><td align="left">实时处理分析</td><td align="left">Java</td><td align="left">JSON</td><td align="left">实时聚合</td></tr><tr><td align="left">Kylin</td><td align="left">OLAP分析引擎</td><td align="left">Java</td><td align="left">JDBC/OLAP</td><td align="left">预处理、cache</td></tr></tbody></table><p>其中，Druid相对比较轻量级，用的人较多，比较成熟。</p><h2 id="故障监控"><a href="#故障监控" class="headerlink" title="故障监控"></a>故障监控</h2><p>对于面向用户的线上服务，发生故障是一件很严重的事情。因此，做好线上服务的故障检测告警是一件非常重要的事情。可以将故障监控分为以下两个层面的监控：</p><ul><li>系统监控：主要指的对主机的带宽、cpu、内存、硬盘、io等硬件资源的监控。这可以使用开源的nagios、cacti等开源软件进行监控。目前，市面上也有很多第三方服务能够提供对于主机资源的监控，如监控宝等。对于分布式服务集群(如hadoop、storm、kafka、flume等集群)的监控则可以使用<a href="http://ganglia.github.io/" target="_blank" rel="noopener">ganglia</a>。此外，小米开源的<a href="https://github.com/open-falcon" target="_blank" rel="noopener">OpenFalcon</a>也很不错，涵盖了系统监控、JVM监控等，也支持自定义的监控机制。</li><li>业务监控：是在主机资源层面以上的监控，比如app的pv、uv数据异常、交易失败等。需要业务中加入相关的监控代码，比如在异常抛出的地方，加一段日志记录。</li></ul><p>监控还有一个关键的步骤就是告警。告警的方式有很多种：邮件、im、短信等。考虑到故障的重要性不同、告警的合理性、便于定位问题等因素，有以下建议：</p><ul><li>告警日志要记录发生故障的机器id，尤其是在集群服务中，如果没有记录机器id，那么对于后续的问题定位会很困难。</li><li>要对告警做聚合，不要每一个故障都单独进行告警，这样会对工程师造成极大的困扰。</li><li>要对告警做等级划分，不能对所有告警都做同样的优先级处理。</li><li>使用微信做为告警软件，能够在节省短信成本的情况下，保证告警的到达率。</li></ul><p>故障告警之后，那么最最关键的就是应对了。对于创业公司来说，24小时待命是必备的素质，当遇到告警的时候，需要尽快对故障做出反应，找到问题所在，并能在可控时间内解决问题。对于故障问题的排查，基本上都是依赖于日志的。只要日志打的合理，一般情况下是能够很快定位到问题所在的，但是如果是分布式服务，并且日志数据量特别大的情况下，如何定位日志就成为了难题。这里有几个方案：</p><ul><li>建立ELK(Elastic+Logstash+Kibana)日志集中分析平台，便于快速搜索、定位日志。对于ELK的介绍，可以见：<a href="https://xiequan.info/使用elasticsearch-logstash-kibana搭建日志集中分析平台实践/" target="_blank" rel="noopener">使用Elasticsearch + Logstash + Kibana搭建日志集中分析平台实践</a></li><li>建立分布式请求追踪系统(也可以叫全链路监测系统)，对于分布式系统尤其是<strong>微服务架构</strong>，能够极大的方便在海量调用中快速定位并收集单个异常请求信息，也能快速定位一条请求链路的性能瓶颈。唯品会的<a href="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&mid=2653547643&idx=1&sn=c06dc9b0f59e8ae3d2f9feb734da4459&scene=1&srcid=0808MaLgymxNlsh4Z31oWKUi#rd" target="_blank" rel="noopener">Mercury</a>、阿里的<a href="https://bigbully.github.io/Dapper-translation" target="_blank" rel="noopener">鹰眼</a>、新浪的<a href="http://ishare.iask.sina.com.cn/f/68869649.html" target="_blank" rel="noopener">WatchMan</a>、Twitter开源的<a href="https://github.com/openzipkin/zipkin" target="_blank" rel="noopener">Zipkin</a>基本都是基于Google的<a href="http://www.cnblogs.com/LBSer/p/3390852.html" target="_blank" rel="noopener">Dapper</a>论文而来。此外，<a href="https://www.zhihu.com/question/20292868" target="_blank" rel="noopener">腾讯的染色日志机制</a>本质上也是在链路追踪之上根据响应信息做了染色机制。Apache正在孵化中的<a href="http://htrace.incubator.apache.org/" target="_blank" rel="noopener">HTrace</a>则是针对大的分布式系统诸如hdfs文件系统、hbase存储引擎而设计的分布式追踪方案。这里需要提到的一点是，如果你的微服务实现使用了Spring cloud，那么<a href="http://cloud.spring.io/spring-cloud-sleuth/" target="_blank" rel="noopener">Spring Cloud Sleuth</a>则是最佳的分布式跟踪实现方案。</li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="一-NetFlix"><a href="#一-NetFlix" class="headerlink" title="一. NetFlix"></a>一. NetFlix</h3><p>近几年Netflix开源了其内部很多的服务：<a href="https://github.com/Netflix，包括大数据、构建交付工具、通用运行时服务类库、数据持久化、安全等。里面有一些对应了上面所说的基础设施：" target="_blank" rel="noopener">https://github.com/Netflix，包括大数据、构建交付工具、通用运行时服务类库、数据持久化、安全等。里面有一些对应了上面所说的基础设施：</a></p><ul><li><p><a href="https://github.com/Netflix/zuul/wiki" target="_blank" rel="noopener">zuul</a></p><p>这是Netflix所有后端服务最前端的一道门，也就是我们上面说的Api网关, 主要包含了以下功能：</p><ul><li>认证授权和安全：识别合法的外部请求，拒绝非法的。</li><li>监控：跟踪记录所有有意义的数据以便于给我们一个精确的产品视图。</li><li>动态路由：根据需要动态把请求路由到合适的后端服务上。</li><li>压力测试：渐进式的增加对集群的压力直到最大值。</li><li>限流：对每一种类型的请求都限定流量，拒绝超出的请求。</li><li>静态响应控制：对于某些请求直接在边缘返回而不转发到后端集群。</li><li>多区域弹性：在aws的多个region中进行请求路由。</li></ul></li><li><p><a href="https://github.com/Netflix/eureka" target="_blank" rel="noopener">Eureka</a></p><p>是Netflix的服务注册发现服务，类似于dubbo的功能。包括负载均衡和容错。</p></li><li><p><a href="https://github.com/Netflix/hystrix" target="_blank" rel="noopener">Hystrix</a></p><p>hystrix是一个类库。基于命令模式，实现依赖服务的容错、降级、隔离等。在依赖多个第三方服务的时候非常有用。此外，还可以通过自定义实现dubbo的filter来给dubbo添加hystrix的特性支持。</p></li></ul><p>此外，Netflix的这些开源组件统称做Netflix oss，提供了一整套分布式系统解决方案，涵盖了做分布式微服务需要的服务发现、服务容错、负载均衡、权限控制等。当然，如果你直接选用docker的话，那么K8s本身也提供了这些东西。</p><h3 id="二-Spring-Cloud"><a href="#二-Spring-Cloud" class="headerlink" title="二. Spring Cloud"></a>二. Spring Cloud</h3><h4 id="SpringCloud-Netflix系列"><a href="#SpringCloud-Netflix系列" class="headerlink" title="SpringCloud Netflix系列"></a>SpringCloud Netflix系列</h4><p><a href="http://projects.spring.io/spring-cloud/" target="_blank" rel="noopener">Spring cloud</a>给我们构建分布式系统提供了一整套开发工具和框架，基本上也涵盖了本文讲述的各个组件，其子项目<a href="http://cloud.spring.io/spring-cloud-netflix/" target="_blank" rel="noopener">Spring Cloud Netflix</a>则能够集成Netflix的各个组件。现在很多公司和团队都是基于Spring cloud这一套东西在做微服务实现的。不过，spring cloud包含很多子项目，想要吃透这些得花不小的成本。</p><ul><li><p>Spring Cloud Config</p><p>统一配置中心，类似于前文说过的disconf,不过其配置文件时存储在版本管理系统如git、svn上的。其配置的实时在线更新则需要依赖Spring Cloud Bus。</p></li><li><p>Spring Cloud Security</p><p>提供了oauth2客户端的负载均衡以及认证header等安全服务，可以做为Api网关的实现。</p></li><li><p>Spring Cloud Consul/Zookeepr</p><p>服务统一发现、注册、配置服务。类似于dubbo。</p></li><li><p>Spring Cloud Bus</p><p>提供了服务之间通信的分布式消息事件总线，主要用来在集群中传播状态改变（如配置改动）。</p></li><li><p>Spring Cloud Sleuth</p><p>分布式跟踪系统, 能够追踪单次请求的链路轨迹以及耗时等信息。</p></li></ul><h4 id="SpringCloud-Alibaba系列"><a href="#SpringCloud-Alibaba系列" class="headerlink" title="SpringCloud Alibaba系列"></a>SpringCloud Alibaba系列</h4><ul><li><p>Spring Cloud Alibaba Nacos</p><p>服务注册与发现组件</p></li><li><p>Spring Cloud Alibaba Nacos Config</p><p>统一配置中心组件</p></li><li><p>Spring Cloud Alibaba Sentinel</p><p>服务熔断组件，以流量为切入点</p></li><li><p>Spring Cloud Alibaba Dubbo</p><p>dubbo整合spring cloud</p></li><li><p>Spring Cloud Alibaba seata</p><p>分布式事务组件</p></li><li><p>Spring Cloud Alibaba RocketMQ</p><p>分布式消息组件</p></li><li><p>Spring Cloud Alibaba ScheduleX</p><p>分布式调度任务组件</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
            <tag> 后端基础设施 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot减少if-else</title>
      <link href="/2019/09/14/SpringBoot%E5%87%8F%E5%B0%91if-else/"/>
      <url>/2019/09/14/SpringBoot%E5%87%8F%E5%B0%91if-else/</url>
      
        <content type="html"><![CDATA[<h4 id="转载：在SpringBoot中，如何干掉太多if-else-。"><a href="#转载：在SpringBoot中，如何干掉太多if-else-。" class="headerlink" title="转载：在SpringBoot中，如何干掉太多if else !。"></a>转载：<a href="https://mp.weixin.qq.com/s/k2LKDor3b5hYWsYKB2Lntg" target="_blank" rel="noopener">在SpringBoot中，如何干掉太多if else !</a>。</h4><p>文章中实现换个方式，不算完全转载。</p><p><strong>项目代码github地址</strong>：<a href="https://github.com/crazyblitz/springboot-learn/tree/master/springboot-state-pattern" target="_blank" rel="noopener">策略设计模式解决代码过多的if else !</a></p><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>这里虚拟一个业务需求，让大家容易理解。假设有一个订单系统，里面的一个功能是根据订单的不同类型作出不同的处理逻辑。</p><p>订单实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Service层接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">handleOrder</span><span class="params">(Order order)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="传统实现"><a href="#传统实现" class="headerlink" title="传统实现"></a>传统实现</h4><p>根据订单类型写一堆的if else：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handleOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String type = order.getType();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"1"</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"处理普通订单"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"2"</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"处理团购订单"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"3"</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"处理促销订单"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="策略模式实现"><a href="#策略模式实现" class="headerlink" title="策略模式实现"></a>策略模式实现</h3><h4 id="利用策略模式，只需要两行即可实现业务逻辑："><a href="#利用策略模式，只需要两行即可实现业务逻辑：" class="headerlink" title="利用策略模式，只需要两行即可实现业务逻辑："></a>利用策略模式，只需要两行即可实现业务逻辑：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderHandlerContext orderHandlerContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handleOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderHandlerContext.getInstance(order.getType()).handle(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面的方法中注入了<code>OrderHandlerContext</code>，这是一个处理器上下文，用来保存不同的业务处理器，具体在下文会讲解。我们从中获取一个订单处理器<code>OrderHandler</code>，调用其方法实现业务逻辑。现在可以了解到，我们主要的业务逻辑是在处理器中实现的，因此有多少个订单类型，就对应有多少个处理器。以后需求变化，增加了订单类型，只需要添加相应的处理器就可以，上述<code>OrderServiceImpl</code>完全不需改动。</p><h4 id="我们先看看业务处理器的写法："><a href="#我们先看看业务处理器的写法：" class="headerlink" title="我们先看看业务处理器的写法："></a>我们先看看业务处理器的写法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderHandler</span> </span>&#123;</span><br><span class="line"> <span class="function">String <span class="title">handle</span><span class="params">(Order order)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@OrderHandlerType</span>(<span class="string">"2"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupOrderHandler</span> <span class="keyword">implements</span> <span class="title">OrderHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handle</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"处理团购订单"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@OrderHandlerType</span>(<span class="string">"1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalOrderHandler</span> <span class="keyword">implements</span> <span class="title">OrderHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handle</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"处理普通订单"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@OrderHandlerType</span>(<span class="string">"3"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PromotionHandler</span> <span class="keyword">implements</span> <span class="title">OrderHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handle</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"处理促销订单"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先每个处理器都必须添加到Spring容器中，因此需要加上@Component注解，其次需要加上一个自定义注解<code>@OrderHandlerType</code>，用于标识该处理器对应哪个订单类型，最后就是实现<code>OrderHandler</code>接口，实现自己的业务逻辑。</p><h4 id="自定义注解订单类型处理器-OrderHandlerType"><a href="#自定义注解订单类型处理器-OrderHandlerType" class="headerlink" title="自定义注解订单类型处理器@OrderHandlerType"></a>自定义注解订单类型处理器@OrderHandlerType</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> OrderHandlerType &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现OrderHandlerContext订单上下文逻辑"><a href="#实现OrderHandlerContext订单上下文逻辑" class="headerlink" title="实现OrderHandlerContext订单上下文逻辑"></a>实现OrderHandlerContext订单上下文逻辑</h4><p>逻辑中使用<code>SmartInitializingSingleton</code>获取Spring容器<code>OrderHandler接口实现类</code>。该接口在</p><p>所有单例实例化后调用。详细<code>ConfigurableListableBeanFactory#preInstantiateSingletons()</code>。</p><blockquote><p>在单例预实例化阶段结束时调用，保证已经创建了所有常规单例bean 。 <strong>此方法中的{@link ListableBeanFactory#getBeansOfType}调用不会在引导期间触发意外的副作用。</strong>  注意：<strong>对于单例bean <em>不会触发此回调</em>在{@link BeanFactory} bootstrap 之后根据需要懒洋洋地初始化，而不是任何其他bean范围</strong>。小心地将它用于具有预期引导语义的bean。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderHandlerContext</span> <span class="keyword">implements</span> <span class="title">SmartInitializingSingleton</span>, <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; orderHandlerMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterSingletonsInstantiated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, OrderHandler&gt; orderHandlers = applicationContext.getBeansOfType(OrderHandler.class);</span><br><span class="line">        <span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">            log.info(<span class="string">"orderHandlers: &#123;&#125;"</span>, orderHandlers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(orderHandlers)) &#123;</span><br><span class="line">            orderHandlers.forEach((key, value) -&gt; &#123;</span><br><span class="line">                OrderHandlerType orderHandlerType = AnnotationUtils.findAnnotation(value.getClass(), OrderHandlerType.class);</span><br><span class="line">                <span class="keyword">if</span> (orderHandlerType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!orderHandlerMap.containsKey(orderHandlerType.value())) &#123;</span><br><span class="line">                        orderHandlerMap.put(orderHandlerType.value(), value.getClass());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"OrderHandlerContext.orderHandlerMap already constains "</span> +</span><br><span class="line">                                <span class="string">"order type %s,please check your logic."</span>, orderHandlerType.value()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">                log.info(<span class="string">"orderHandlerMap: &#123;&#125;"</span>, JSONObject.toJSONString(orderHandlerMap));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.warn(<span class="string">"not found order handler bean in beanFactory"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(@NonNull ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderHandler <span class="title">getInstance</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Class orderHandlerClass = orderHandlerMap.get(type);</span><br><span class="line">        <span class="keyword">if</span> (orderHandlerClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"not found order handler for type: "</span> + type);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (OrderHandler) applicationContext.getBean(orderHandlerMap.get(type));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>利用策略模式可以简化繁杂的if else代码，方便维护，而利用自定义注解和自注册的方式，可以方便应对需求的变更。本文只是提供一个大致的思路，还有很多细节可以灵活变化，例如使用枚举类型、或者静态常量，作为订单的类型，相信你能想到更多更好的方法。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 策略设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shiro设计解析篇2</title>
      <link href="/2019/09/13/Shiro%E8%AE%BE%E8%AE%A1%E8%A7%A3%E6%9E%90%E7%AF%872/"/>
      <url>/2019/09/13/Shiro%E8%AE%BE%E8%AE%A1%E8%A7%A3%E6%9E%90%E7%AF%872/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合Shiro</title>
      <link href="/2019/09/13/SpringBoot%E6%95%B4%E5%90%88Shiro/"/>
      <url>/2019/09/13/SpringBoot%E6%95%B4%E5%90%88Shiro/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Shiro设计解析篇1</title>
      <link href="/2019/09/13/Shiro%E8%AE%BE%E8%AE%A1%E8%A7%A3%E6%9E%90%E7%AF%871/"/>
      <url>/2019/09/13/Shiro%E8%AE%BE%E8%AE%A1%E8%A7%A3%E6%9E%90%E7%AF%871/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java开发建议</title>
      <link href="/2019/09/13/Java%E5%BC%80%E5%8F%91%E5%BB%BA%E8%AE%AE/"/>
      <url>/2019/09/13/Java%E5%BC%80%E5%8F%91%E5%BB%BA%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java后端技术概念</title>
      <link href="/2019/09/13/Java%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A6%82%E5%BF%B5/"/>
      <url>/2019/09/13/Java%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何应对在线故障</title>
      <link href="/2019/09/13/%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E5%9C%A8%E7%BA%BF%E6%95%85%E9%9A%9C/"/>
      <url>/2019/09/13/%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E5%9C%A8%E7%BA%BF%E6%95%85%E9%9A%9C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>微服务杂谈</title>
      <link href="/2019/09/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9D%82%E8%B0%88/"/>
      <url>/2019/09/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9D%82%E8%B0%88/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合JWT</title>
      <link href="/2019/09/12/SpringBoot%E6%95%B4%E5%90%88JWT/"/>
      <url>/2019/09/12/SpringBoot%E6%95%B4%E5%90%88JWT/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>  SpringBoot整合JWT(JSON Web Token)，其中springboot版本2.0.1.RELEASE，jwt版本0.9.1，spring boot security版本为2.0.1.RELEASE。<strong>Jwt详细讲解见链接</strong>：<a href="[https://crazyblitz.github.io/2019/08/06/JWT%E8%AE%A4%E8%AF%81%E8%AF%A6%E8%A7%A3/](https://crazyblitz.github.io/2019/08/06/JWT认证详解/)">JWT(JSON Web Token)详细讲解</a>。</p><h3 id="关键POM-xml代码如下"><a href="#关键POM-xml代码如下" class="headerlink" title="关键POM.xml代码如下"></a>关键POM.xml代码如下</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--spring boot starter security--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--jwt--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="关键配置"><a href="#关键配置" class="headerlink" title="关键配置"></a>关键配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jwt:</span></span><br><span class="line"><span class="attr">  secret:</span> <span class="string">secret</span></span><br><span class="line">  <span class="comment">#默认是15秒</span></span><br><span class="line"><span class="attr">  expiration:</span> <span class="number">180</span></span><br><span class="line"><span class="attr">  token:</span> <span class="string">Authorization</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##配置不被spring security拦截的请求</span></span><br><span class="line"><span class="attr">security:</span></span><br><span class="line"><span class="attr">  postPath:</span> <span class="string">"/api/business/users/login"</span></span><br><span class="line"><span class="attr">  getPath:</span> <span class="string">"/api/business/users/index"</span></span><br></pre></td></tr></table></figure><h3 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h3><h4 id="JwtTokenUtils-Jwt-token生成工具类"><a href="#JwtTokenUtils-Jwt-token生成工具类" class="headerlink" title="JwtTokenUtils(Jwt token生成工具类)"></a>JwtTokenUtils(Jwt token生成工具类)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtTokenUtils</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLAIM_KEY_USERNAME = <span class="string">"sub"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLAIM_KEY_CREATED = <span class="string">"created"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5021913450632406869L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsernameFromToken</span><span class="params">(String token, String secret)</span> </span>&#123;</span><br><span class="line">        String username;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Claims claims = getClaimsFromToken(token, secret);</span><br><span class="line">            username = claims.getSubject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            username = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getCreatedDateFromToken</span><span class="params">(String token, String secret)</span> </span>&#123;</span><br><span class="line">        Date created;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Claims claims = getClaimsFromToken(token, secret);</span><br><span class="line">            created = <span class="keyword">new</span> Date((Long) claims.get(CLAIM_KEY_CREATED));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            created = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> created;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getExpirationDateFromToken</span><span class="params">(String token, String secret)</span> </span>&#123;</span><br><span class="line">        Date expiration;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Claims claims = getClaimsFromToken(token, secret);</span><br><span class="line">            expiration = claims.getExpiration();</span><br><span class="line">            log.info(<span class="string">"jwt解密:&#123;&#125;"</span>, claims);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            expiration = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> expiration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Claims <span class="title">getClaimsFromToken</span><span class="params">(String token, String secret)</span> </span>&#123;</span><br><span class="line">        SecretKey secretKey = generalKey(secret);</span><br><span class="line">        Claims claims;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            claims = Jwts.parser()</span><br><span class="line">                    .setSigningKey(secretKey)</span><br><span class="line">                    .parseClaimsJws(token)</span><br><span class="line">                    .getBody();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.debug(<span class="string">"validate is token error "</span>, e);</span><br><span class="line">            claims = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> claims;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Date <span class="title">generateExpirationDate</span><span class="params">(Long expiration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Date(System.currentTimeMillis() + expiration * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Boolean <span class="title">isTokenExpired</span><span class="params">(String token, String secret)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Date expiration = getExpirationDateFromToken(token, secret);</span><br><span class="line">        <span class="keyword">return</span> expiration.before(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Boolean <span class="title">isCreatedBeforeLastPasswordReset</span><span class="params">(Date created, Date lastPasswordReset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (lastPasswordReset != <span class="keyword">null</span> &amp;&amp; created.before(lastPasswordReset));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generateToken</span><span class="params">(String userName, String secret, Long expiration)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; claims = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        claims.put(CLAIM_KEY_USERNAME, userName);</span><br><span class="line">        claims.put(CLAIM_KEY_CREATED, <span class="keyword">new</span> Date(System.currentTimeMillis()));</span><br><span class="line">        <span class="keyword">return</span> generateToken(claims, secret, expiration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">generateToken</span><span class="params">(Map&lt;String, Object&gt; claims, String secret, Long expiration)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//生成签名的时候使用的秘钥secret</span></span><br><span class="line">        SecretKey secretKey = generalKey(secret);</span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .setHeaderParam(<span class="string">"typ"</span>, <span class="string">"JWT"</span>)</span><br><span class="line">                .setClaims(claims)</span><br><span class="line">                .setExpiration(generateExpirationDate(expiration))</span><br><span class="line">                .signWith(SignatureAlgorithm.HS512, secretKey)</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">canTokenBeRefreshed</span><span class="params">(String token, Date lastPasswordReset, String secret)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Date created = getCreatedDateFromToken(token, secret);</span><br><span class="line">        <span class="keyword">return</span> !isCreatedBeforeLastPasswordReset(created, lastPasswordReset)</span><br><span class="line">                &amp;&amp; !isTokenExpired(token, secret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">refreshToken</span><span class="params">(String token, String secret, Long expiration)</span> </span>&#123;</span><br><span class="line">        String refreshedToken;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Claims claims = getClaimsFromToken(token, secret);</span><br><span class="line">            claims.put(CLAIM_KEY_CREATED, <span class="keyword">new</span> Date());</span><br><span class="line">            refreshedToken = generateToken(claims, secret, expiration);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            refreshedToken = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> refreshedToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">validateToken</span><span class="params">(String token, String userName, String secret)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String username = getUsernameFromToken(token, secret);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">                username.equals(userName)</span><br><span class="line">                        &amp;&amp; !isTokenExpired(token, secret));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> SecretKey <span class="title">generalKey</span><span class="params">(String secret)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用base64解码</span></span><br><span class="line">        <span class="keyword">byte</span>[] encodedKey = Base64.decodeBase64(secret);</span><br><span class="line">        <span class="comment">// 根据给定的字节数组使用AES加密算法构造一个密钥</span></span><br><span class="line">        SecretKey secretKey = <span class="keyword">new</span> SecretKeySpec(encodedKey, <span class="number">0</span>, encodedKey.length, <span class="string">"AES"</span>);</span><br><span class="line">        <span class="keyword">return</span> secretKey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JwtUserFactory-Jwt-user工厂"><a href="#JwtUserFactory-Jwt-user工厂" class="headerlink" title="JwtUserFactory(Jwt user工厂)"></a>JwtUserFactory(Jwt user工厂)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtUserFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JwtUserFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JwtUser <span class="title">create</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JwtUser.builder().id(user.getUserId())</span><br><span class="line">                .password(user.getUserPassword())</span><br><span class="line">                .username(user.getUserName())</span><br><span class="line">                .authorities(mapToGrantedAuthorities()).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取权限</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;GrantedAuthority&gt; <span class="title">mapToGrantedAuthorities</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singletonList(<span class="keyword">new</span> SimpleGrantedAuthority(<span class="string">"ROLE_USER"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JwtUser-spring-security-UserDetails实现类"><a href="#JwtUser-spring-security-UserDetails实现类" class="headerlink" title="JwtUser(spring security UserDetails实现类)"></a>JwtUser(spring security UserDetails实现类)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtUser</span> <span class="keyword">implements</span> <span class="title">UserDetails</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Collection&lt;? extends GrantedAuthority&gt; authorities;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JwtUserDetailsServiceImpl-Spring-Security-UserDetailsService实现类"><a href="#JwtUserDetailsServiceImpl-Spring-Security-UserDetailsService实现类" class="headerlink" title="JwtUserDetailsServiceImpl(Spring Security UserDetailsService实现类)"></a>JwtUserDetailsServiceImpl(Spring Security UserDetailsService实现类)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtUserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现验证的userService</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> HttpServletRequest request;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String userName)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;User&gt;().lambda().eq(User::getUserName, userName);</span><br><span class="line">        User user = userService.getOne(wrapper);</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">            request.setAttribute(<span class="string">"userInfo"</span>, user);</span><br><span class="line">            <span class="keyword">return</span> JwtUserFactory.create(user);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JwtAuthenticationTokenFilter"><a href="#JwtAuthenticationTokenFilter" class="headerlink" title="JwtAuthenticationTokenFilter"></a>JwtAuthenticationTokenFilter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtAuthenticationTokenFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> JwtTokenUtils jwtTokenUtils;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FILTER_APPLIED = <span class="string">"__spring_security_JwtFilter_filterApplied"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * jwt token</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jwt.token&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String tokenHeader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jwt.secret&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String secret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过期时间</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jwt.expiration&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String expiration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOKEN_PREFIX = <span class="string">"00000000000"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"tokenHeader: &#123;&#125;,secret: &#123;&#125;,expiration: &#123;&#125;"</span>, tokenHeader, secret, expiration);</span><br><span class="line">        <span class="keyword">if</span> (request.getAttribute(FILTER_APPLIED) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String tokenHeader = request.getHeader(<span class="keyword">this</span>.tokenHeader);</span><br><span class="line">        <span class="keyword">if</span> (tokenHeader != <span class="keyword">null</span> &amp;&amp; tokenHeader.startsWith(TOKEN_PREFIX)) &#123;</span><br><span class="line">            String authToken = tokenHeader.substring(<span class="number">11</span>);</span><br><span class="line">            String username = jwtTokenUtils.getUsernameFromToken(authToken, secret);</span><br><span class="line">            <span class="keyword">if</span> (username != <span class="keyword">null</span> &amp;&amp; jwtTokenUtils.validateToken(authToken, username, secret)) &#123;</span><br><span class="line">                UserDetails userDetails = userDetailsService.loadUserByUsername(username);</span><br><span class="line">                <span class="keyword">if</span> (userDetails != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    UsernamePasswordAuthenticationToken authentication = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(</span><br><span class="line">                            userDetails, <span class="keyword">null</span>, userDetails.getAuthorities());</span><br><span class="line">                    authentication.setDetails(<span class="keyword">new</span> WebAuthenticationDetailsSource().buildDetails(request));</span><br><span class="line">                    SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">"username:&#123;&#125;, 数据库获取userName失败:&#123;&#125;"</span>, username, tokenHeader);</span><br><span class="line">                    SecurityContextHolder.getContext().setAuthentication(<span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (username != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    log.debug(<span class="string">"username:&#123;&#125;, token过期:&#123;&#125;"</span>, username, tokenHeader);</span><br><span class="line">                &#125;</span><br><span class="line">                SecurityContextHolder.getContext().setAuthentication(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            SecurityContextHolder.getContext().setAuthentication(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 防止filter在容器内多执行一遍</span></span><br><span class="line">        request.setAttribute(FILTER_APPLIED, <span class="keyword">true</span>);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JwtAuthenticationEntryPoint"><a href="#JwtAuthenticationEntryPoint" class="headerlink" title="JwtAuthenticationEntryPoint"></a>JwtAuthenticationEntryPoint</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截请求没有走凭证</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtAuthenticationEntryPoint</span> <span class="keyword">implements</span> <span class="title">AuthenticationEntryPoint</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commence</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse,</span></span></span><br><span class="line"><span class="function"><span class="params">                         AuthenticationException e)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">// 这个异常在未授权用户访问安全资源时会触发,我们会发出一个50未授权的response</span></span><br><span class="line">        ApiResult&lt;String&gt; result = <span class="keyword">new</span> ApiResult&lt;&gt;();</span><br><span class="line">        result.setCode(NetConstants.RTN_TOKEN_EXPIRE);</span><br><span class="line">        result.setMessage(<span class="string">"Unauthorized: "</span> + e.getMessage());</span><br><span class="line">        httpServletResponse.getWriter().print(JSONObject.toJSONString(result));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WebSecurityConfig-配置spring-security全局拦截"><a href="#WebSecurityConfig-配置spring-security全局拦截" class="headerlink" title="WebSecurityConfig(配置spring security全局拦截)"></a>WebSecurityConfig(配置spring security全局拦截)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;security.postPath&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String[] postPath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;security.getPath&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String[] getPath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> JwtAuthenticationEntryPoint unauthorizedHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置spring security验证管理器</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureAuthentication</span><span class="params">(AuthenticationManagerBuilder authenticationManagerBuilder)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        authenticationManagerBuilder</span><br><span class="line">                .userDetailsService(<span class="keyword">this</span>.userDetailsService)</span><br><span class="line">                .passwordEncoder(passwordEncoder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JwtAuthenticationTokenFilter <span class="title">authenticationTokenFilterBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JwtAuthenticationTokenFilter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationManager <span class="title">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity httpSecurity)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"postPath: &#123;&#125;,getPath: &#123;&#125;"</span>, postPath, getPath);</span><br><span class="line">        httpSecurity</span><br><span class="line">                <span class="comment">// 由于使用的是JWT，我们这里不需要csrf</span></span><br><span class="line">                .csrf().disable()</span><br><span class="line">                <span class="comment">//因为使用JWT,所以不需要HttpSession</span></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">                .and().exceptionHandling().authenticationEntryPoint(unauthorizedHandler)</span><br><span class="line">                <span class="comment">// 基于token，所以不需要session</span></span><br><span class="line">                .and().sessionManagement().sessionCreationPolicy(SessionCreationPolicy.ALWAYS)</span><br><span class="line">                .and().authorizeRequests()</span><br><span class="line">                .antMatchers(HttpMethod.OPTIONS, <span class="string">"/**"</span>).permitAll()</span><br><span class="line">                .requestMatchers(CorsUtils::isPreFlightRequest).permitAll()</span><br><span class="line">                <span class="comment">// 对于获取token的rest api要允许匿名访问</span></span><br><span class="line">                .antMatchers(HttpMethod.POST, postPath).permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.GET, getPath).permitAll()</span><br><span class="line">                <span class="comment">// 除上面外的所有请求全部需要鉴权认证</span></span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and().addFilterBefore(authenticationTokenFilterBean(), UsernamePasswordAuthenticationFilter.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁用缓存</span></span><br><span class="line">        httpSecurity.headers().cacheControl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="登录代码"><a href="#登录代码" class="headerlink" title="登录代码"></a>登录代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/api/business/users"</span>)</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> JwtTokenUtils jwtTokenUtils;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jwt.secret&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String secret;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jwt.expiration&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Long expiration;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录请求不做拦截</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApiResult&lt;String&gt; <span class="title">login</span><span class="params">(@RequestBody User user, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        ApiResult&lt;String&gt; apiResult = <span class="keyword">new</span> ApiResult&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Authentication authentication = authenticationManager.authenticate(<span class="keyword">new</span> UsernamePasswordAuthenticationToken(</span><br><span class="line">                    user.getUserName(), user.getUserPassword()));</span><br><span class="line">            SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">            <span class="comment">// Reload password post-security so we can generate token</span></span><br><span class="line">            String token = TOKEN_PREFIX + jwtTokenUtils.generateToken(user.getUserName(), secret, expiration);</span><br><span class="line">            response.addCookie(<span class="keyword">new</span> Cookie(<span class="string">"userToken"</span>, token));</span><br><span class="line">            apiResult.success(token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BadCredentialsException exception) &#123;</span><br><span class="line">            log.error(<span class="string">"验证出错: &#123;&#125;"</span>, exception.getMessage());</span><br><span class="line">            apiResult.fail(<span class="string">"密码不正确或者用户不存在."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> apiResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserDetails userDetails = (UserDetails) org.springframework.security.core.context.SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"欢迎光临: "</span> + userDetails.getUsername() + <span class="string">","</span> + userDetails.getPassword();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="详细项目地址：SpringBoot整合JWT"><a href="#详细项目地址：SpringBoot整合JWT" class="headerlink" title="详细项目地址：SpringBoot整合JWT"></a>详细项目地址：<a href="https://github.com/crazyblitz/springboot-learn/tree/master/springboot-jwt" target="_blank" rel="noopener">SpringBoot整合JWT</a></h4>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON Web Token认证 </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> Spring Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch安装部署(Windows)</title>
      <link href="/2019/09/08/ElasticSearch%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2-Windows/"/>
      <url>/2019/09/08/ElasticSearch%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2-Windows/</url>
      
        <content type="html"><![CDATA[<p>测试版本：elasticsearch-5.1.1</p><ol><li><p>解压elasticsearch-5.1.1.zip。</p></li><li><p>执行elasticsearch.bat启动服务，启动画面如下：</p><p><img src="https://img-blog.csdnimg.cn/20190908192158978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70" alt="elasticsearch-5.1.1启动画面"></p></li><li><p>访问elasticsearch,访问地址：<a href="http://127.0.0.1:9200/。" target="_blank" rel="noopener">http://127.0.0.1:9200/。</a></p><p><img src="https://img-blog.csdnimg.cn/20190908192256931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70" alt="elasticsearch访问地址"></p></li><li><p>安装elasticsearch head插件(不做说明)</p></li><li><p>配置JDK环境变量<code>JAVA_HOME,PATH,CLASS_PATH</code>。</p><p><strong>注意：环境变量必须配置在系统变量下，否则后面服务启动不了，会报Failed creating java %JAVA_HOME%\jre\bin\server\jvm.dll错误。</strong></p></li><li><p>安装elasticsearch成为win服务在cmd命令下执行：</p><p><code>elasticsearch-service.bat install</code></p><p><img src="https://img-blog.csdnimg.cn/20190908192607952.png" alt="win安装elasticsearch服务"></p></li><li><p>在服务里面可以查看到安装的elasticsearch服务。</p></li><li><p>elasticsearch-service.bat后面还可以执行以下命令</p><ul><li>install: 安装Elasticsearch服务</li><li>remove: 删除已安装的Elasticsearch服务（如果启动则停止服务）</li><li>start: 启动Elasticsearch服务（如果已安装）</li><li>stop: 停止服务（如果启动）</li><li>manager:启动GUI来管理已安装的服务</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7自定义服务</title>
      <link href="/2019/09/07/Centos7%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1/"/>
      <url>/2019/09/07/Centos7%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch查询种类</title>
      <link href="/2019/09/07/ElasticSearch%E6%9F%A5%E8%AF%A2%E7%A7%8D%E7%B1%BB/"/>
      <url>/2019/09/07/ElasticSearch%E6%9F%A5%E8%AF%A2%E7%A7%8D%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Data Commons抽象</title>
      <link href="/2019/09/07/Spring-Data-Commons%E6%8A%BD%E8%B1%A1/"/>
      <url>/2019/09/07/Spring-Data-Commons%E6%8A%BD%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JUC并发容器和框架</title>
      <link href="/2019/09/07/JUC%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%92%8C%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/09/07/JUC%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%92%8C%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程基础</title>
      <link href="/2019/09/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/09/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JUC中锁组件</title>
      <link href="/2019/09/07/JUC%E4%B8%AD%E9%94%81%E7%BB%84%E4%BB%B6/"/>
      <url>/2019/09/07/JUC%E4%B8%AD%E9%94%81%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JUC并发工具类总结</title>
      <link href="/2019/09/07/JUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%80%BB%E7%BB%93/"/>
      <url>/2019/09/07/JUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JUC原子操作类总结</title>
      <link href="/2019/09/07/JUC%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB%E6%80%BB%E7%BB%93/"/>
      <url>/2019/09/07/JUC%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  <code>当程序更新一个变量时，如果多线程同时更新这个变量，可能得到期望之外的值</code>，比如变量i=1,A线程更新i+1，</p><p>B线程也更新i+1，经过两个线程操作之后可能i不等于3，因为A和B线程在更新变量i的时候拿到的i都是1，这就是线程不安全的更新操作，<code>通常我们会使用synchronized来解决这个问题，synchronized会保证多线程不会同时更新变量i。</code></p><p>   而从JDK1.5开始提供了java.util.concurrent.atomic包（以下简称Atomic包），这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。 </p><p>   因为变量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是<code>原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。</code> <strong>Atomic包里的类基本都是使用Unsafe实现的包装类。</strong></p><h3 id="原子更新基本类型"><a href="#原子更新基本类型" class="headerlink" title="原子更新基本类型"></a>原子更新基本类型</h3><ol><li>:类介绍</li></ol><ul><li><p>AtomicBoolean：原子更新布尔类型。 </p></li><li><p>AtomicInteger：原子更新整型。 </p></li><li><p>AtomicLong：原子更新长整型。 </p></li></ul><ol start="2"><li>常用方法(AotmicInteger为例)</li></ol><ul><li>int addAndGet（int delta）：以原子方式将输入的数值与实例中的值（AtomicInteger里的 </li></ul><p>value）相加，并返回结果。 </p><ul><li>boolean compareAndSet（int expect，int update）：如果输入的数值等于预期值，则以原子方 </li></ul><p>式将该值设置为输入的值。 </p><ul><li><p>int getAndIncrement()：以原子方式将当前值加1，注意，这里返回的是自增前的值。 </p></li><li><p>int getAndSet（int newValue）：以原子方式设置为newValue的值，并返回旧值。</p></li></ul><ol start="3"><li><code>getAndIncrement</code>实现原子操作原理</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        <span class="comment">// 先取出旧值</span></span><br><span class="line">        <span class="keyword">int</span> current = get();</span><br><span class="line">        <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 原子更新操作</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next)) <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span> <span class="params">( <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 当前值,偏移量,内存预期值,更新值</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">如果当前数值是expected，则原子的将Java变量更新成x * <span class="doctag">@return</span> 如果更新成功则返回true</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> compareAndSwapObject</span><br><span class="line">(Object o, <span class="keyword">long</span> offset, Object expected, Object x);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> expected, <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> expected, <span class="keyword">long</span> x)</span></span>;</span><br></pre></td></tr></table></figure><ol start="4"><li>其他实现</li></ol><p>通过看AtomicBoolean源码，发现它是先把Boolean转换成整 型，再使用compareAndSwapInt进行CAS，所以原子更新char、float和double变量也可以用类似 的思路来实现。</p><ul><li>原子更新Boolean</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          valueOffset = unsafe.objectFieldOffset</span><br><span class="line">              (AtomicBoolean.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a new &#123;<span class="doctag">@code</span> AtomicBoolean&#125; with the given initial value.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> initialValue the initial value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AtomicBoolean</span><span class="params">(<span class="keyword">boolean</span> initialValue)</span> </span>&#123;</span><br><span class="line">      value = initialValue ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><p>原子更新Double</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLongFieldUpdater&lt;AtomicDouble&gt; updater =</span><br><span class="line">    AtomicLongFieldUpdater.newUpdater(AtomicDouble.class, <span class="string">"value"</span>);</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> AtomicDouble&#125; with the given initial value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialValue the initial value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicDouble</span><span class="params">(<span class="keyword">double</span> initialValue)</span> </span>&#123;</span><br><span class="line">  value = doubleToRawLongBits(initialValue);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically sets to the given value and returns the old value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">double</span> newValue)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> next = doubleToRawLongBits(newValue);</span><br><span class="line">  <span class="keyword">return</span> longBitsToDouble(updater.getAndSet(<span class="keyword">this</span>, next));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="原子更新数组"><a href="#原子更新数组" class="headerlink" title="原子更新数组"></a>原子更新数组</h3><p>通过原子的方式更新数组里某个元素。</p><ol><li>类介绍</li></ol><ul><li><p>AtomicIntegerArray：原子更新整型数组里的元素。 </p></li><li><p>AtomicLongArray：原子更新长整型数组里的元素。 </p></li><li><p>AtomicReferenceArray：原子更新引用类型数组里的元素。 </p></li></ul><ol start="2"><li>常用方法</li></ol><ul><li><p>int addAndGet（int i，int delta）：以原子方式将输入值与数组中索引i的元素相加。 </p></li><li><p>boolean compareAndSet（int i，int expect，int update）：如果当前值等于预期值，则以原子 </p><p>方式将数组位置i的元素设置成update值。 </p></li></ul><p><strong>注意：数组value通过构造方法传递进去，然后AtomicIntegerArray会将当前数组复制一份，所以当AtomicIntegerArray对内部的数组元素进行修改时，不会影响传入的数组。</strong></p><ol start="3"><li><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerArrayTest</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span>[] value = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">static</span> AtomicIntegerArray ai = <span class="keyword">new</span> AtomicIntegerArray(value);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          ai.getAndSet(<span class="number">0</span>， <span class="number">3</span>); System.out.println(ai.get(<span class="number">0</span>));</span><br><span class="line">          System.out.println(value[<span class="number">0</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="原子更新引用类型"><a href="#原子更新引用类型" class="headerlink" title="原子更新引用类型"></a>原子更新引用类型</h3><p>原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下3个类。 </p><ol><li>类介绍</li></ol><ul><li><p>AtomicReference：原子更新引用类型。 </p></li><li><p>AtomicReferenceFieldUpdater：原子更新引用类型里的字段。 </p></li><li><p>AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子更新一个布尔类 </p><p>型的标记位和引用类型。AtomicMarkableReference（V initialRef，boolean initialMark）。 </p></li></ul><ol start="2"><li><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicReference&lt;User&gt; atomicUserRef = <span class="keyword">new</span> AtomicReference&lt;user&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">"conan"</span>,<span class="number">15</span>); atomicUserRef.set(user);</span><br><span class="line">        User updateUser = <span class="keyword">new</span> User(<span class="string">"Shinichi"</span>,<span class="number">17</span>); atomicUserRef.compareAndSet(user,updateUser);</span><br><span class="line">        System.out.println(atomicUserRef.get().getName());</span><br><span class="line">        System.out.println(atomicUserRef.get().getOld());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> old;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name,<span class="keyword">int</span> old)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.old = old;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="原子更新字段"><a href="#原子更新字段" class="headerlink" title="原子更新字段"></a>原子更新字段</h3><p>如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供了以下3个类进行原子字段更新。</p><ol><li>类介绍</li></ol><ul><li><p>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。 </p></li><li><p>AtomicLongFieldUpdater：原子更新长整型字段的更新器。 </p></li><li><p>AtomicStampedReference：<strong>原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的 ABA问题。</strong></p></li></ul><ol start="2"><li>原子更新字段步骤</li></ol><ul><li><code>因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。</code></li><li><strong><code>更新类的字段（属性）必须使用public volatile修饰符。</code></strong></li></ul><ol start="3"><li><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建原子更新器，并设置需要更新的对象类和对象的属性 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.newUpdater(User.class, <span class="string">"old"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置柯南的年龄是10岁</span></span><br><span class="line">        User conan = <span class="keyword">new</span> User(<span class="string">"conan"</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 柯南长了一岁，但是仍然会输出旧的年龄 </span></span><br><span class="line">        System.out.println(a.getAndIncrement(conan));</span><br><span class="line">        <span class="comment">// 输出柯南现在的年龄</span></span><br><span class="line">        System.out.println(a.get(conan));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> old;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> old)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.old = old;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis分页插件PageHelper使用</title>
      <link href="/2019/09/07/Mybatis%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6PageHelper%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/09/07/Mybatis%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6PageHelper%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="分页插件参数"><a href="#分页插件参数" class="headerlink" title="分页插件参数"></a>分页插件参数</h3><ul><li><p><code>reasonable</code>：分页合理化参数，默认值为<code>false</code>。当该参数设置为 <code>true</code> 时，<code>pageNum&lt;=0</code> 时会查询第一页，<code>pageNum&gt;pages</code>（超过总数时），会查询最后一页。默认<code>false</code> 时，直接根据参数进行查询</p></li><li><p><code>params</code>：为了支持<code>startPage(Object params)</code>方法，增加了该参数来配置参数映射，用于从对象中根据属性名取值， 可以配置 <code>pageNum,pageSize,count,pageSizeZero,reasonable</code>，不配置映射的用默认值， 默认值为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pageNum=pageNum;</span><br><span class="line">pageSize=pageSize;</span><br><span class="line">count=countSql;</span><br><span class="line">reasonable=reasonable;</span><br><span class="line">pageSizeZero=pageSizeZero</span><br></pre></td></tr></table></figure></li><li><p><code>helperDialect</code>：分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。 你可以配置<code>helperDialect</code>属性来指定分页插件使用哪种方言。配置时，可以使用下面的缩写值：<br><code>oracle</code>,<code>mysql</code>,<code>mariadb</code>,<code>sqlite</code>,<code>hsqldb</code>,<code>postgresql</code>,<code>db2</code>,<code>sqlserver</code>,<code>informix</code>,<code>h2</code>,<code>sqlserver2012</code>,<code>derby</code><br><strong>特别注意：</strong>使用 SqlServer2012 数据库时，需要手动指定为 <code>sqlserver2012</code>，否则会使用 SqlServer2005 的方式进行分页。<br>你也可以实现 <code>AbstractHelperDialect</code>，然后配置该属性为实现类的全限定名称即可使用自定义的实现方法。</p></li></ul><h3 id="推荐使用"><a href="#推荐使用" class="headerlink" title="推荐使用"></a>推荐使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二种，Mapper接口方式的调用，推荐这种使用方式。</span></span><br><span class="line">PageHelper.startPage(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">List&lt;Country&gt; list = countryMapper.selectIf(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种，Mapper接口方式的调用，推荐这种使用方式。</span></span><br><span class="line">PageHelper.offsetPage(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">List&lt;Country&gt; list = countryMapper.selectIf(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第四种，参数方法调用</span></span><br><span class="line"><span class="comment">//存在以下 Mapper 接口方法，你不需要在 xml 处理后两个参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CountryMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;Country&gt; <span class="title">selectByPageNumSize</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @Param(<span class="string">"user"</span>)</span> User user,</span></span><br><span class="line"><span class="function">            @<span class="title">Param</span><span class="params">(<span class="string">"pageNum"</span>)</span> <span class="keyword">int</span> pageNum, </span></span><br><span class="line"><span class="function">            @<span class="title">Param</span><span class="params">(<span class="string">"pageSize"</span>)</span> <span class="keyword">int</span> pageSize)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h3><h5 id="1-：PageHelper-startPage-静态方法调用"><a href="#1-：PageHelper-startPage-静态方法调用" class="headerlink" title="(1)：PageHelper.startPage 静态方法调用"></a>(1)：<code>PageHelper.startPage</code> 静态方法调用</h5><p>在你需要进行分页的 MyBatis 查询方法前调用 <code>PageHelper.startPage</code> 静态方法即可，紧跟在这个方法后的第一个<strong>MyBatis 查询方法</strong>会被进行分页。</p><p>例如：</p><p>例一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取第1页，10条内容，默认查询总数count</span></span><br><span class="line">PageHelper.startPage(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//紧跟着的第一个select方法会被分页</span></span><br><span class="line">List&lt;Country&gt; list = countryMapper.selectIf(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>例二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PageHelper.startPage(request);</span><br><span class="line"><span class="comment">//紧跟着的第一个select方法会被分页</span></span><br><span class="line">List&lt;Country&gt; list = countryMapper.selectIf(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//后面的不会被分页，除非再次调用PageHelper.startPage</span></span><br><span class="line">List&lt;Country&gt; list2 = countryMapper.selectIf(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h5 id="2-：PageInfo的用法"><a href="#2-：PageInfo的用法" class="headerlink" title="(2)：PageInfo的用法"></a>(2)：<code>PageInfo</code>的用法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取第1页，10条内容，默认查询总数count</span></span><br><span class="line">PageHelper.startPage(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">List&lt;Country&gt; list = countryMapper.selectAll();</span><br><span class="line"><span class="comment">//用PageInfo对结果进行包装</span></span><br><span class="line">PageInfo page = <span class="keyword">new</span> PageInfo(list);</span><br><span class="line"><span class="comment">//测试PageInfo全部属性</span></span><br><span class="line"><span class="comment">//PageInfo包含了非常全面的分页属性</span></span><br><span class="line">assertEquals(<span class="number">1</span>, page.getPageNum());</span><br><span class="line">assertEquals(<span class="number">10</span>, page.getPageSize());</span><br><span class="line">assertEquals(<span class="number">1</span>, page.getStartRow());</span><br><span class="line">assertEquals(<span class="number">10</span>, page.getEndRow());</span><br><span class="line">assertEquals(<span class="number">183</span>, page.getTotal());</span><br><span class="line">assertEquals(<span class="number">19</span>, page.getPages());</span><br><span class="line">assertEquals(<span class="number">1</span>, page.getFirstPage());</span><br><span class="line">assertEquals(<span class="number">8</span>, page.getLastPage());</span><br><span class="line">assertEquals(<span class="keyword">true</span>, page.isFirstPage());</span><br><span class="line">assertEquals(<span class="keyword">false</span>, page.isLastPage());</span><br><span class="line">assertEquals(<span class="keyword">false</span>, page.isHasPreviousPage());</span><br><span class="line">assertEquals(<span class="keyword">true</span>, page.isHasNextPage());</span><br></pre></td></tr></table></figure><h5 id="3-：改变默认分页参数"><a href="#3-：改变默认分页参数" class="headerlink" title="(3)：改变默认分页参数"></a>(3)：改变<code>默认分页参数</code></h5><p>想要使用参数方式，需要配置 <code>supportMethodsArguments</code> 参数为 <code>true</code>，同时要配置 <code>params</code> 参数。 例如下面的配置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">    &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt;</span><br><span class="line">    &lt;plugin interceptor=<span class="string">"com.github.pagehelper.PageInterceptor"</span>&gt;</span><br><span class="line">        &lt;!-- 使用下面的方式配置参数，后面会有所有的参数介绍 --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"supportMethodsArguments"</span> value=<span class="string">"true"</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">"params"</span> value=<span class="string">"pageNum=pageNumKey;pageSize=pageSizeKey;"</span>/&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure><p>在Mybatis方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Country&gt; <span class="title">selectByPageNumSize</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @Param(<span class="string">"user"</span>)</span> User user,</span></span><br><span class="line"><span class="function">        @<span class="title">Param</span><span class="params">(<span class="string">"pageNumKey"</span>)</span> <span class="keyword">int</span> pageNum, </span></span><br><span class="line"><span class="function">        @<span class="title">Param</span><span class="params">(<span class="string">"pageSizeKey"</span>)</span> <span class="keyword">int</span> pageSize)</span>;</span><br></pre></td></tr></table></figure><p>当调用这个方法时，由于同时发现了 <code>pageNumKey</code> 和 <code>pageSizeKey</code> 参数，这个方法就会被分页。params 提供的几个参数都可以这样使用。</p><h5 id="4-：PageHelper安全调用"><a href="#4-：PageHelper安全调用" class="headerlink" title="(4)：PageHelper安全调用"></a>(4)：<code>PageHelper</code>安全调用</h5><p> <strong>什么时候会导致不安全的分页？</strong></p><p><code>PageHelper</code> 方法使用了静态的 <code>ThreadLocal</code> 参数，分页参数和线程是绑定的。</p><p>只要你可以保证在 <code>PageHelper</code> 方法调用后紧跟 MyBatis 查询方法，这就是安全的。因为 <code>PageHelper</code> 在 <code>finally</code> 代码段中自动清除了 <code>ThreadLocal</code> 存储的对象。</p><p>如果代码在进入 <code>Executor</code> 前发生异常，就会导致线程不可用，这属于人为的 Bug（例如接口方法和 XML 中的不匹配，导致找不到 <code>MappedStatement</code> 时）， 这种情况由于线程不可用，也不会导致 <code>ThreadLocal</code> 参数被错误的使用。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PageHelper.startPage(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">List&lt;Country&gt; list;</span><br><span class="line"><span class="keyword">if</span>(param1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">    list = countryMapper.selectIf(param1);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    list = <span class="keyword">new</span> ArrayList&lt;Country&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下由于 param1 存在 null 的情况，就会导致 PageHelper 生产了一个分页参数，但是没有被消费，这个参数就会一直保留在这个线程上。当这个线程再次被使用时，就可能导致不该分页的方法去消费这个分页参数，这就产生了莫名其妙的分页。</p><p><strong>正确如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Country&gt; list;</span><br><span class="line"><span class="keyword">if</span>(param1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">    PageHelper.startPage(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    list = countryMapper.selectIf(param1);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    list = <span class="keyword">new</span> ArrayList&lt;Country&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-：请不要配置多个分页插件"><a href="#5-：请不要配置多个分页插件" class="headerlink" title="(5)：请不要配置多个分页插件"></a>(5)：请不要配置多个分页插件</h5><p>请不要在系统中配置多个分页插件(使用Spring时,<code>mybatis-config.xml</code>和<code>Spring&lt;bean&gt;</code>配置方式，请选择其中一种，不要同时配置多个分页插件)！</p><h5 id="6-：分页插件不支持嵌套结果映射"><a href="#6-：分页插件不支持嵌套结果映射" class="headerlink" title="(6)：分页插件不支持嵌套结果映射"></a>(6)：分页插件不支持嵌套结果映射</h5><p>由于嵌套结果方式会导致结果集被折叠，因此分页查询的结果在折叠后总数会减少，所以无法保证分页结果数量正确。</p><h5 id="7-：分页插件不支持带有for-update语句的分页"><a href="#7-：分页插件不支持带有for-update语句的分页" class="headerlink" title="(7)：分页插件不支持带有for update语句的分页"></a>(7)：分页插件不支持带有<code>for update</code>语句的分页</h5><p>对于带有<code>for update</code>的sql，会抛出运行时异常，对于这样的sql建议手动分页，毕竟这样的sql需要重视。</p><h5 id="8-：SpringBoot使用Mybatis-分页插件PageHelper"><a href="#8-：SpringBoot使用Mybatis-分页插件PageHelper" class="headerlink" title="(8)：SpringBoot使用Mybatis,分页插件PageHelper"></a>(8)：SpringBoot使用Mybatis,分页插件PageHelper</h5><p><code>application.properties</code>配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pagehelper:</span></span><br><span class="line"><span class="attr">    helperDialect:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">    reasonable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    supportMethodsArguments:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    params:</span> <span class="string">count=countSql</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line"><span class="attr">    type-aliases-package:</span> <span class="string">tk.mybatis.springboot.model</span></span><br><span class="line"><span class="attr">    mapper-locations:</span> <span class="attr">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
            <tag> PageHelper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud Config 规范</title>
      <link href="/2019/09/04/Spring-Cloud-Config-%E8%A7%84%E8%8C%83/"/>
      <url>/2019/09/04/Spring-Cloud-Config-%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h3 id="Spring-Cloud-Config规范"><a href="#Spring-Cloud-Config规范" class="headerlink" title="Spring Cloud Config规范"></a>Spring Cloud Config规范</h3><p>转载 : <a href="https://yq.aliyun.com/articles/678958?spm=a2c4e.11163080.searchblog.9.3c3a2ec1j7S3rP" target="_blank" rel="noopener">Spring Cloud Config规范</a></p><p>首先Spring Cloud 是基于 Spring 来扩展的，Spring 本身就提供当<strong>创建一个Bean时可从Environment 中将一些属性值通过@Value的形式注入到业务代码中的能力</strong>。那Spring Cloud Config 要解决的问题就是：</p><ol><li><strong>如何将配置加载到 Environment 。</strong></li><li><strong>配置变更时，如何控制 Bean 是否需要 create,重新触发一次 Bean 的初始化，才能将 @Value 注解指定的字段从 Environment 中重新注入。</strong></li><li><strong>配置变更时，如何控制新的配置会更新到 Environment 中，才能保证配置变更时可注入最新的值。</strong></li></ol><p>要解决以上三个问题：Spring Cloud Config 规范中刚好定义了核心的三个接口：</p><ol><li><code>PropertySourceLocator</code>：抽象出这个接口，就是<strong>让用户可定制化的将一些配置加载到 Environment</strong>。这部分的配置获取遵循了 Spring Cloud Config 的理念，<code>即希望能从外部储存介质中来 loacte</code>。</li><li><code>RefreshScope</code>: Spring Cloud 定义这个注解，是扩展了 Spring 原有的 Scope 类型。用来标识当前这个 Bean 是一个refresh 类型的 Scope。<strong>其主要作用就是可以控制 Bean 的整个生命周期。</strong></li><li><code>ContextRefresher</code>：抽象出这个 Class，是让用户自己按需来刷新上下文(比如当有配置刷新时，希望可以刷新上下文，将最新的配置更新到 Environment，重新创建 Bean 时，就可以从 Environment 中注入最新的配置)。</li></ol><h3 id="Spring-Cloud-Config-原理"><a href="#Spring-Cloud-Config-原理" class="headerlink" title="Spring Cloud Config 原理"></a>Spring Cloud Config 原理</h3><h4 id="1、如何将配置加载到Environment：PropertySourceLocator"><a href="#1、如何将配置加载到Environment：PropertySourceLocator" class="headerlink" title="1、如何将配置加载到Environment：PropertySourceLocator"></a>1、如何将配置加载到Environment：PropertySourceLocator</h4><p>在整个 Spring Boot 启动的生命周期过程中，有一个阶段是 <code>prepare environment</code>。在这个阶段，会publish 一个 ApplicationEnvironmentPreparedEvent，通知所有对这个事件感兴趣的 Listener,提供对 Environment 做更多的定制化的操作。Spring Cloud 定义了一个BootstrapApplicationListener，在 BootstrapApplicationListener 的处理过程中有一步非常关键的操作如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ConfigurableApplicationContext <span class="title">bootstrapServiceContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ConfigurableEnvironment environment, <span class="keyword">final</span> SpringApplication application,</span></span></span><br><span class="line"><span class="function"><span class="params">            String configName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略</span></span><br><span class="line">        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        <span class="comment">// Use names and ensure unique to protect against duplicates</span></span><br><span class="line">        List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;(SpringFactoriesLoader</span><br><span class="line">                .loadFactoryNames(BootstrapConfiguration.class, classLoader));</span><br><span class="line">        <span class="comment">//省略</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这是 Spring 的工厂加载机制，可通过在 META-INF/spring.factories 文件中配置一些程序中预定义的一些扩展点。比如 Spring Cloud 这里的实现，可以看到 BootstrapConfiguration 不是一个具体的接口，而是一个注解。通过这种方式配置的扩展点好处是不局限于某一种接口的实现，而是同一类别的实现。可以查看 spring-cloud-context 包中的 spring.factories 文件关于BootstrapConfiguration的配置，有一个比较核心入口的配置就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.cloud.bootstrap.BootstrapConfiguration=\</span><br><span class="line">org.springframework.cloud.bootstrap.config.PropertySourceBootstrapConfiguration</span><br></pre></td></tr></table></figure><p>可以发现 PropertySourceBootstrapConfiguration <strong>实现了 ApplicationContextInitializer 接口，其目的就是在应用程序上下文初始化的时候做一些额外的操作</strong>。在 Bootstrap 阶段，会通过 Spring IOC 的整个生命周期来初始化所有通过key为<em>org.springframework.cloud.bootstrap.BootstrapConfiguration</em> 在 spring.factories 中配置的 Bean。Spring Cloud Alibaba Nacos Config 的实现就是通过该key来自定义一些在Bootstrap 阶段需要初始化的一些Bean。在该模块的 spring.factories 配置文件中可以看到如下配置：</p><p>在 Bootstrap 阶段初始化的过程中，会获取所有 ApplicationContextInitializer 类型的 Bean，并设置回SpringApplication主流程当中。如下 BootstrapApplicationListener 类中的部分代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(ConfigurableApplicationContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">        SpringApplication application, ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">    <span class="comment">//这里的 context 是一个 bootstrap 级别的 ApplicationContext，这里已经含有了在 bootstrap阶段所有需要初始化的 Bean。</span></span><br><span class="line">    <span class="comment">//因此可以获取 ApplicationContextInitializer.class 类型的所有实例</span></span><br><span class="line">    List&lt;ApplicationContextInitializer&gt; initializers = getOrderedBeansOfType(context,</span><br><span class="line">            ApplicationContextInitializer.class);</span><br><span class="line">    <span class="comment">//设置回 SpringApplication 主流程当中</span></span><br><span class="line">    application.addInitializers(initializers </span><br><span class="line">            .toArray(<span class="keyword">new</span> ApplicationContextInitializer[initializers.size()]));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，就可以通过在 SpringApplication 的主流程中来回调这些ApplicationContextInitializer 的实例，做一些初始化的操作。如下 SpringApplication 类中的部分代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(ConfigurableApplicationContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">        ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</span></span></span><br><span class="line"><span class="function"><span class="params">        ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class="line">    context.setEnvironment(environment);</span><br><span class="line">    postProcessApplicationContext(context);</span><br><span class="line">    <span class="comment">//回调在BootstrapApplicationListener中设置的ApplicationContextInitializer实例</span></span><br><span class="line">    applyInitializers(context);</span><br><span class="line">    listeners.contextPrepared(context);</span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyInitializers</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ApplicationContextInitializer initializer : getInitializers()) &#123;</span><br><span class="line">        Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(</span><br><span class="line">                initializer.getClass(), ApplicationContextInitializer.class);</span><br><span class="line">        Assert.isInstanceOf(requiredType, context, <span class="string">"Unable to call initializer."</span>);</span><br><span class="line">        initializer.initialize(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 applyInitializers 方法中，会触发 PropertySourceBootstrapConfiguration 中的 initialize 方法。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">    CompositePropertySource composite = <span class="keyword">new</span> CompositePropertySource(</span><br><span class="line">            BOOTSTRAP_PROPERTY_SOURCE_NAME);</span><br><span class="line">    AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.propertySourceLocators);</span><br><span class="line">    <span class="keyword">boolean</span> empty = <span class="keyword">true</span>;</span><br><span class="line">    ConfigurableEnvironment environment = applicationContext.getEnvironment();</span><br><span class="line">    <span class="keyword">for</span> (PropertySourceLocator locator : <span class="keyword">this</span>.propertySourceLocators) &#123;</span><br><span class="line">        PropertySource&lt;?&gt; source = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//回调所有实现PropertySourceLocator接口实例的locate方法，</span></span><br><span class="line">        source = locator.locate(environment);</span><br><span class="line">        <span class="keyword">if</span> (source == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        composite.addPropertySource(source);</span><br><span class="line">        empty = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!empty) &#123;</span><br><span class="line">    <span class="comment">//从当前Enviroment中获取 propertySources</span></span><br><span class="line">        MutablePropertySources propertySources = environment.getPropertySources();</span><br><span class="line">        <span class="comment">//省略...</span></span><br><span class="line">        <span class="comment">//将composite中的PropertySource添加到当前应用上下文的propertySources中</span></span><br><span class="line">        insertPropertySources(propertySources, composite);</span><br><span class="line">        <span class="comment">//省略...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中会回调所有实现 PropertySourceLocator 接口实例的locate方法，<br>locate 方法返回一个 PropertySource 的实例，统一add到CompositePropertySource实例中。如果 composite 中有新加的PropertySource,最后将composite中的PropertySource添加到当前应用上下文的propertySources中。<strong>Spring Cloud Alibaba Nacos Config 在 Bootstrap 阶段通过Java配置的方式初始化了一个 NacosPropertySourceLocator 类型的Bean。从而在 locate 方法中将存放在Nacos中的配置信息读取出来，将读取结果存放到 PropertySource 的实例中返回。具体如何从Nacos中读取配置信息可参考 NacosPropertySourceLocator 类的实现。</strong></p><p><strong>Spring Cloud Config 正是提供了PropertySourceLocator接口，来提供应用外部化配置可动态加载的能力。</strong>Spring Ioc 容器在初始化 Bean 的时候，如果发现 Bean 的字段上含有 @Value 的注解，就会从 Enviroment 中的PropertySources 来获取其值，完成属性的注入。</p><h4 id="Spring-Cloud-Config-外部化配置可动态刷新"><a href="#Spring-Cloud-Config-外部化配置可动态刷新" class="headerlink" title="Spring Cloud Config 外部化配置可动态刷新"></a>Spring Cloud Config 外部化配置可动态刷新</h4><p>感知到外部化配置的变更这部分代码的操作是需要用户来完成的。<strong>Spring Cloud Config 只提供了具备外部化配置可动态刷新的能力，并不具备自动感知外部化配置发生变更的能力。</strong>比如如果你的配置是基于Mysql来实现的，那么在代码里面肯定要有能力感知到配置发生变化了，然后再显示的调用 ContextRefresher 的 refresh方法，从而完成外部化配置的动态刷新(只会刷新使用RefreshScope注解的Bean)。</p><p><strong>例如在 Spring Cloud Alibaba Nacos Config 的实现过程中，Nacos 提供了对dataid 变更的Listener 回调。在对每个dataid 注册好了相应的Listener之后，如果Nacos内部通过长轮询的方式感知到数据的变更，就会回调相应的Listener,在 Listener 的实现过程中，就是通过调用 ContextRefresher 的 refresh方法完成配置的动态刷新。具体可参考 NacosContextRefresher 类的实现。</strong></p><p>Spring Cloud Config的动态配置刷新原理图如下所示：</p><p><img src="https://cdn.nlark.com/lark/0/2018/png/81998/1541064749541-30e4f8c5-8047-4a5c-9bc3-bd6ce3b6f8ae.png" alt="Spring Cloud Config配置刷新原理"></p><p><strong>ContextRefresher的refresh的方法主要做了两件事：</strong></p><ol><li>触发PropertySourceLocator的locator方法，需要加载最新的值，并替换 Environment 中旧值</li><li>Bean中的引用配置值需要重新注入一遍。重新注入的流程是在Bean初始化时做的操作，那也就是需要将refresh scope中的Bean 缓存失效，当再次从refresh scope中获取这个Bean时，发现取不到，就会重新触发一次Bean的初始化过程。</li></ol><p>这两个操作所对应的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Set <span class="title">refresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; before = extract(</span><br><span class="line">            <span class="keyword">this</span>.context.getEnvironment().getPropertySources());</span><br><span class="line">    <span class="comment">//1、加载最新的值，并替换Envrioment中旧值</span></span><br><span class="line">    addConfigFilesToEnvironment();</span><br><span class="line">    Set&lt;String&gt; keys = changes(before,</span><br><span class="line">            extract(<span class="keyword">this</span>.context.getEnvironment().getPropertySources())).keySet();</span><br><span class="line">    <span class="keyword">this</span>.context.publishEvent(<span class="keyword">new</span> EnvironmentChangeEvent(context, keys));</span><br><span class="line">    <span class="comment">//2、将refresh scope中的Bean 缓存失效: 清空</span></span><br><span class="line">    <span class="keyword">this</span>.scope.refreshAll();</span><br><span class="line">    <span class="keyword">return</span> keys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addConfigFilesToEnvironment 方法中发生替换的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ConfigurableApplicationContext <span class="title">addConfigFilesToEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConfigurableApplicationContext capture = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//省略...</span></span><br><span class="line">        <span class="comment">//1、这里会重新触发PropertySourceLoactor的locate的方法,获取最新的外部化配置</span></span><br><span class="line">        capture = (SpringApplicationBuilder)builder.run();</span><br><span class="line">        </span><br><span class="line">        MutablePropertySources target = <span class="keyword">this</span>.context.getEnvironment()</span><br><span class="line">                .getPropertySources();</span><br><span class="line">        String targetName = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (PropertySource&lt;?&gt; source : environment.getPropertySources()) &#123;</span><br><span class="line">            String name = source.getName();</span><br><span class="line">            <span class="comment">//省略..</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//只有不是标准的 Source 才可替换</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.standardSources.contains(name)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (target.contains(name)) &#123;</span><br><span class="line">                    <span class="comment">//开始用新的PropertySource替换旧值</span></span><br><span class="line">                    target.replace(name, source);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> capture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this.scope.refreshAll() 清空缓存的操作代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Throwable&gt; errors = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</span><br><span class="line">    <span class="comment">//清空Refresh Scope 中的缓存</span></span><br><span class="line">    Collection&lt;BeanLifecycleWrapper&gt; wrappers = <span class="keyword">this</span>.cache.clear();</span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了验证每次配置刷新时，Bean 是新创建的，特意写了一个Demo 验证了下，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Acm Properties: beijing-region</span><br><span class="line"><span class="comment">//刷新前Object </span></span><br><span class="line">Instance is :com.alibaba.demo.normal.ConfigProperties@<span class="number">1</span>be9634</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">01</span> <span class="number">19</span>:<span class="number">16</span>:<span class="number">32.535</span>  INFO <span class="number">27254</span> --- [gPullingdefault] startup date [Thu Nov <span class="number">01</span> <span class="number">19</span>:<span class="number">16</span>:<span class="number">32</span> CST <span class="number">2018</span>]; root of context hierarchyAcm Properties: qingdao-region</span><br><span class="line"><span class="comment">//刷新后Object </span></span><br><span class="line">Instance is :com.alibaba.demo.normal.ConfigProperties@<span class="number">2</span>c6965e0</span><br></pre></td></tr></table></figure><h4 id="Spring-Cloud-Config-扩展Scope的核心类-RefreshScope"><a href="#Spring-Cloud-Config-扩展Scope的核心类-RefreshScope" class="headerlink" title="Spring Cloud Config 扩展Scope的核心类:RefreshScope"></a>Spring Cloud Config 扩展Scope的核心类:RefreshScope</h4><p>可以看到上面的代码中有 this.scope.refreshAll()，其中的scope就是RefreshScope。是用来存放scope类型为refresh类型的Bean（即使用RefreshScope注解标识的Bean），也就是说当一个Bean既不是singleton也不是prototype时，就会从自定义的Scope中去获取(Spring 允许自定义Scope)，然后调用Scope的get方法来获取一个实例，Spring Cloud 正是扩展了Scope，从而控制了整个 Bean 的生命周期。当配置需要动态刷新的时候， 调用this.scope.refreshAll()这个方法，就会将整个RefreshScope的缓存清空，完成配置可动态刷新的可能。</p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>关于ContextRefresh 和 RefreshScope的初始化配置是在<code>RefreshAutoConfiguration</code>类中完成的。<strong>而RefreshAutoConfiguration类初始化的入口是在spring-cloud-context中的META-INF/spring.factories中配置的。从而完成整个和动态刷新相关的Bean的初始化操作。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
            <tag> Spring Cloud Config </tag>
            
            <tag> 外部化自动刷新配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 事件</title>
      <link href="/2019/09/03/SpringBoot-%E4%BA%8B%E4%BB%B6/"/>
      <url>/2019/09/03/SpringBoot-%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="SpringBoot事件"><a href="#SpringBoot事件" class="headerlink" title="SpringBoot事件"></a>SpringBoot事件</h3><p>尽管SpringApplicationRunListener和SpringBoot事件(SpringApplicationEvent)从SpringBoot 1.0开始引入，然而纵观SpringBoot 1.x~2.0的发展，<code>监听方法与SpringBoot事件的对应关系发生了变化</code>。事件如下表所示：</p><table><thead><tr><th align="center">监听方法</th><th align="center">SpringBoot事件</th><th align="center">SpringBoot起始版本</th></tr></thead><tbody><tr><td align="center">starting()</td><td align="center">ApplicationStartingEvent</td><td align="center">1.5</td></tr><tr><td align="center">environmentPrepared(ConfigurableEnvironment )</td><td align="center">ApplicationEnvironmentPreparedEvent</td><td align="center">1.0</td></tr><tr><td align="center">contextPrepared(ConfigurableApplicationContext );</td><td align="center"></td><td align="center">1.0</td></tr><tr><td align="center">contextLoaded(ConfigurableApplicationContext context);</td><td align="center">ApplicationPreparedEvent</td><td align="center">1.0</td></tr><tr><td align="center">started(ConfigurableApplicationContext )</td><td align="center">ApplicationStartedEvent</td><td align="center">1.0</td></tr><tr><td align="center">running(ConfigurableApplicationContext )</td><td align="center">ApplicationReadyEvent</td><td align="center">1.3</td></tr><tr><td align="center">failed(ConfigurableApplicationContext ,Throwable )</td><td align="center">ApplicationFailedEvent</td><td align="center">1.0</td></tr></tbody></table><p>值得注意的是，SpringApplicationRunListener是SpringBoot应用运行时监听器，并非SpringBoot事件监听器。不过SpringBoot官方文档对这部分只字未提，开发人员只要遵照SpringApplicationListener构造器参数约定，以及结合<code>SpringFactoriesLoader机制</code>,完全能够将该接口进行扩展。</p><p>换言之，以上SpringBoot事件所对应的ApplicationListener实现由SpringApplication构造器参数关联并添加属性SimpleApplicationEventMulticaster#initialMulticaster属性中。</p><p>官方进一步解释了这些事件的顺序和时机：</p><ol><li>ApplicationStartingEvent：<strong>在应用开始运行但还没有进行任何处理时(除了注册监听器[listeners ]和初始化器[initializers])。</strong></li><li>ApplicationEnvironmentPreparedEvent ：<strong>当<code>Environment</code>被上下文使用，但是在上下文创建之前。可以修改和检查<code>Environment</code>。</strong></li><li>ApplicationPreparedEvent：<strong>在开始刷新之前，bean的定义均被加载，<code>Environment</code>可以投入使用。</strong></li><li>ApplicationStartedEvent：<strong>上下文刷新之后，但是在所有应用和命令行运行期(command line runner)被调用之前。</strong></li><li>ApplicationReadyEvent：<strong>在应用程序和命令行运行器(command line runner)被调用之后，该事件用于通知应用已经准备处理请求。</strong></li><li>ApplicationFailedEvent：<strong>启动时发送异常将发送</strong></li></ol><h3 id="SpringApplicationRunListener"><a href="#SpringApplicationRunListener" class="headerlink" title="SpringApplicationRunListener"></a>SpringApplicationRunListener</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpringApplicationRunListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ApplicationStartingEvent</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ApplicationEnvironmentPreparedEvent </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ApplicationPreparedEvent</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ApplicationStartedEvent</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">started</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ApplicationReadyEvent</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">running</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ApplicationFailedEvent</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">failed</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringBoot1-4事件处理之后变动"><a href="#SpringBoot1-4事件处理之后变动" class="headerlink" title="SpringBoot1.4事件处理之后变动"></a>SpringBoot1.4事件处理之后变动</h3><p><code>SpringBoot 1.4开始</code>,框架层面采用的是<code>Spring Boot事件和Spring事件&quot;各自为政，互不干涉&quot;的设计原则</code>。在实现上，前后设计差异主要体现在EventPublishingRunListener关联的<code>SimpleApplicationEventMulticaster</code>注册为Spring Bean。</p><p> SpringBoot 1.4以前，由于SpringApplication和ApplicationContext共用SimpleApplicationEventMulticaster对象的原因，Spring应用上下文中ApplicationListener Bean和@EventListener方法均能监听Spring Boot ApplicationReadyEvent和ApplicationFailedEvent事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventPublishingRunListener</span> <span class="keyword">implements</span> <span class="title">SpringApplicationRunListener</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// SpringBoot 1.4 以后</span></span><br><span class="line">    ...</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// SpringBoot 1.4以前</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">registerApplicationEventMulticaster(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerApplicationEventMulticaster</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">context.getBeanFactory().registerSingleton(</span><br><span class="line">AbstractApplicationContext.APPLICATION_EVENT_MULTICASTER_BEAN_NAME,</span><br><span class="line"><span class="keyword">this</span>.multicaster);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.multicaster <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">((BeanFactoryAware) <span class="keyword">this</span>.multicaster)</span><br><span class="line">.setBeanFactory(context.getBeanFactory());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此实现就杜绝了Spring应用上下文所关联的ApplicationListener接受SpringBoot事件的广播，从而各自监听所在环境的事件。值得注意的事，EventPublishingRunListener仍在调用其contextLoaded()方法时，将SpringApplication所关联的ApplicationListener添加至ConfigurableApplicationContext中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : <span class="keyword">this</span>.application.getListeners()) &#123;</span><br><span class="line"><span class="keyword">if</span> (listener <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">((ApplicationContextAware) listener).setApplicationContext(context);</span><br><span class="line">&#125;</span><br><span class="line">context.addApplicationListener(listener);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.initialMulticaster.multicastEvent(</span><br><span class="line"><span class="keyword">new</span> ApplicationPreparedEvent(<span class="keyword">this</span>.application, <span class="keyword">this</span>.args, context));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据EventPublishingRunListener生命周期回调的特性，此时Spring应用上下文尚未初始化。因此，以上添加操作最终会追加到AbstractApplicationContext所关联的SimpleApplicationEventMulticaster属性中，当前Spring应用上下文发布完Spring事件后，这些被contextLoaded方法监听的ApplicationListener集合能够被它们监听。示例验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringEventListenerBootStrap</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">new</span> SpringApplicationBuidler(Object.class)</span><br><span class="line">listeners(event-&gt;System.out.println(<span class="string">"SpringApplication事件监听器: "</span>+</span><br><span class="line">event.getClass().getSimpleName()))</span><br><span class="line">.web(<span class="keyword">false</span>).run(args).close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  SpringBoot事件/监听机制继承与Spring事件/监听机制，同样涵盖SpringBoot事件，SpringBoot事件监听手段，SpringBoot事件广播器等。</p><h5 id="1-：总结SpringBoot事件"><a href="#1-：总结SpringBoot事件" class="headerlink" title="(1)：总结SpringBoot事件"></a>(1)：<code>总结SpringBoot事件</code></h5><p>​    SpringBoot事件类型继承Spring事件类型<code>ApplicationEvent</code>，并且也是<code>SpringApplicationEvent</code>子类。</p><p>大多数Spring内建事件为Spring应用上下文事件,即ApplicationContextEvent，其事件源为ApplicationContext。而SpringBoot事件源则是SpringApplication，其内建事件根据<code>EventPublishingRunListener</code>生命周期回调方法依次发布。其中,ApplicationReadyEvent和ApplicationFailedEvent在Spring应用上下文初始化发布，即在</p><p>ContextRefreshedEvent之后发布。</p><h5 id="2-：SpringBoot事件监听手段"><a href="#2-：SpringBoot事件监听手段" class="headerlink" title="(2)：SpringBoot事件监听手段"></a>(2)：<code>SpringBoot事件监听手段</code></h5><p>​    尽管SpringBoot事件监听器仍然继承于Spring，不过由于SpringBoot 1.4版本前后采取了不同的设计，因此其监听手段需要区别对待。</p><p>​    在早期SpringBoot事件监听机制(SpringBoot 1.0~1.3版本)中，由于SpringApplication与Spring应用上下文</p><p>ConfigurableApplicationContext采用相同的SimpleApplicationEventMulticaster实例，因此Spring关联的</p><p>ApplicationListener和@EventListener方法能够监听Spring Boot事件ApplicationReadyEvent和</p><p>ApplicationFailedEvent。随着SpringBoot 1.4开始采用SpringApplication与ConfigurableApplicationContext</p><p>隔离SimpleApplicationEventMulticaster实例的设计，这种监听手段不在奏效。换言之，从此时开始，SpringBoot事件监听手段仅为SpringApplication关联的ApplicationListener对象集合。其关联路径有二，一为SpringApplication构造阶段在Class Path下所在加载的<code>META-INF/spring.factories</code>资源中的ApplicationListener对象集合；二是通过方法SpringApplication#addListeners(ApplicationListener…)或者</p><p>SpringApplicationBuilder#listeners(ApplicationListener)显示地装配。</p><h5 id="3-：SpringBoot事件广播器"><a href="#3-：SpringBoot事件广播器" class="headerlink" title="(3)：SpringBoot事件广播器"></a>(3)：SpringBoot事件广播器</h5><p>​    SpringBoot事件广播器同样来源Spring的实现类SimpleApplicationEventMulticaster，其广播行为与Spring事件广播毫无差别，只不过SpringBoot发布事件类型是特定的。因此可以完整的做出以下结论，<strong>SpringBoot事件机制继承与Spring事件监听机制，其事件类型继承与Spring ApplicationEvent，事件监听器仍通过ApplicationListener实现，而广播器实现SimpleApplicationEventMulticaster将它们关联起来。</strong></p><p>​    <strong>EventPublishingRunListener</strong>作为SpringBoot事件发布的执行者，也是SpringBoot框架内部的唯一的</p><p><strong>SpringApplicationRunListener</strong>实现类。</p>]]></content>
      
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> Spring Boot事件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot ApplicationRunner接口</title>
      <link href="/2019/09/03/SpringBoot-ApplicationRunner%E6%8E%A5%E5%8F%A3/"/>
      <url>/2019/09/03/SpringBoot-ApplicationRunner%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> ApplicationRunnber </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Synchronized关键字的使用和原理解析</title>
      <link href="/2019/09/03/Synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/09/03/Synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Volatile关键字的使用和原理解析</title>
      <link href="/2019/09/03/Volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/09/03/Volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Netty编程三步走</title>
      <link href="/2019/09/03/Netty%E7%BC%96%E7%A8%8B%E4%B8%89%E6%AD%A5%E8%B5%B0/"/>
      <url>/2019/09/03/Netty%E7%BC%96%E7%A8%8B%E4%B8%89%E6%AD%A5%E8%B5%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合Netty</title>
      <link href="/2019/09/03/SpringBoot%E6%95%B4%E5%90%88Netty/"/>
      <url>/2019/09/03/SpringBoot%E6%95%B4%E5%90%88Netty/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring上下文多次刷新的问题</title>
      <link href="/2019/08/30/Spring%E4%B8%8A%E4%B8%8B%E6%96%87%E5%A4%9A%E6%AC%A1%E5%88%B7%E6%96%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2019/08/30/Spring%E4%B8%8A%E4%B8%8B%E6%96%87%E5%A4%9A%E6%AC%A1%E5%88%B7%E6%96%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-GenericApplicationContext上下文的实现类多次刷新"><a href="#1-GenericApplicationContext上下文的实现类多次刷新" class="headerlink" title="1: GenericApplicationContext上下文的实现类多次刷新"></a>1: GenericApplicationContext上下文的实现类多次刷新</h3><p>由于该类<code>refreshBeanFactory()</code>方法限制了上下文只能被刷新一次。例如实现类AnnotationConfigApplicatioContext注解上下文，上下文不能多次刷新。</p><ul><li><code>AnnotationConfigApplicatioContext</code></li><li><code>ReactiveWebServerApplicationContext</code></li><li><code>AnnotationConfigServletWebServerApplicationContext</code></li><li><code>ServletWebServerApplicationContext</code></li><li><code>XmlServletWebServerApplicationContext</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MultiApplicationContextRefresh &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    AnnotationConfigApplicationContext context=new AnnotationConfigApplicationContext(MultiApplicationContextRefresh.class);</span><br><span class="line">    context.refresh();</span><br><span class="line">    context.refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.IllegalStateException: GenericApplicationContext does not support multiple refresh attempts: just call <span class="string">'refresh'</span> once</span><br><span class="line">at org.springframework.context.support.GenericApplicationContext.refreshBeanFactory(GenericApplicationContext.java:<span class="number">264</span>)</span><br><span class="line">at org.springframework.context.support.AbstractApplicationContext.obtainFreshBeanFactory(AbstractApplicationContext.java:<span class="number">619</span>)</span><br><span class="line">at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:<span class="number">520</span>)</span><br><span class="line">at com.ley.spring.refresh.MultiApplicationContextRefresh.main(MultiApplicationContextRefresh.java:<span class="number">12</span>)</span><br></pre></td></tr></table></figure><h3 id="2-AbstractXmlApplicationContext实现类多次刷新"><a href="#2-AbstractXmlApplicationContext实现类多次刷新" class="headerlink" title="2: AbstractXmlApplicationContext实现类多次刷新"></a>2: AbstractXmlApplicationContext实现类多次刷新</h3><p>由于该类并没有对<code>refresh()</code>函数做限制，可以进行多次刷新。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiApplicationContextRefresh</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext context1=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:applicationContext.xml"</span>);</span><br><span class="line">    context1.refresh();</span><br><span class="line">    System.out.println(context1.getBean(<span class="string">"user"</span>));</span><br><span class="line">    context1.refresh();</span><br><span class="line">    System.out.println(context1.getBean(<span class="string">"user"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">default-lazy-init</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.ley.spring.refresh.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"20"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ApplicatioContext </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL5.7中JSON系列部分操作函数</title>
      <link href="/2019/08/30/MySQL5-7%E4%B8%ADJSON%E7%B3%BB%E5%88%97%E9%83%A8%E5%88%86%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0/"/>
      <url>/2019/08/30/MySQL5-7%E4%B8%ADJSON%E7%B3%BB%E5%88%97%E9%83%A8%E5%88%86%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="创建JSON值函数"><a href="#创建JSON值函数" class="headerlink" title="创建JSON值函数"></a>创建JSON值函数</h3><ul><li><p><code>JSON_ARRAY([*val*[, *val*\] ...])</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT JSON_ARRAY(1, "abc", NULL, TRUE, CURTIME());</span><br><span class="line">+<span class="comment">---------------------------------------------+</span></span><br><span class="line">| JSON_ARRAY(1, "abc", NULL, TRUE, CURTIME()) |</span><br><span class="line">+<span class="comment">---------------------------------------------+</span></span><br><span class="line">| [1, "abc", null, true, "11:30:24.000000"]   |</span><br><span class="line">+<span class="comment">---------------------------------------------+</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="查找JSON值函数"><a href="#查找JSON值函数" class="headerlink" title="查找JSON值函数"></a>查找JSON值函数</h3><ul><li><p><code>JSON_CONTAINS(target, candidate[, path])</code>：查看候选的JSON文档是否包含在目标JSON文档。<code>path</code>为目标JSON文档路径名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @j = <span class="string">'&#123;"a": 1, "b": 2, "c": &#123;"d": 4&#125;&#125;'</span>;</span><br><span class="line"><span class="keyword">SET</span> @j2 = <span class="string">'1'</span>;</span><br><span class="line"><span class="comment">-- $.a:代表意思是取目标JSON文档的路径下的值</span></span><br><span class="line"><span class="comment">-- true</span></span><br><span class="line"><span class="keyword">SELECT</span> JSON_CONTAINS(@j, @j2, <span class="string">'$.a'</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>JSON_CONTAINS_PATH(json_doc, one_or_all, path[, path] ...)</code>:查找候选的JSON文档是否包含在目标JSON文档。<strong><code>支持OGNL表达式</code></strong></p><ul><li>‘one’：至少一个JSON路径含有候选文档</li><li>‘all’：所有JSON路径含有候选文档。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @j = <span class="string">'&#123;"a": 1, "b": 2, "c": &#123;"d": 4&#125;&#125;'</span>;</span><br><span class="line"><span class="comment">-- true</span></span><br><span class="line"><span class="keyword">SELECT</span> JSON_CONTAINS_PATH(@j, <span class="string">'one'</span>, <span class="string">'$.a'</span>, <span class="string">'$.e'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- false</span></span><br><span class="line"><span class="keyword">SELECT</span> JSON_CONTAINS_PATH(@j, <span class="string">'all'</span>, <span class="string">'$.a'</span>, <span class="string">'$.e'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- true</span></span><br><span class="line"><span class="keyword">SELECT</span> JSON_CONTAINS_PATH(@j, <span class="string">'one'</span>, <span class="string">'$.c.d'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- false</span></span><br><span class="line"><span class="keyword">SELECT</span> JSON_CONTAINS_PATH(@j, <span class="string">'one'</span>, <span class="string">'$.a.d'</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>JSON_EXTRACT(json_doc, path[, path] ...)</code>：从JSON文档返回指定下path的JSON数据。<code>*代表所有</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- $[1]:代表取数组下标为1的数据</span></span><br><span class="line"><span class="comment">-- 20</span></span><br><span class="line"><span class="keyword">SELECT</span> JSON_EXTRACT(<span class="string">'[10, 20, [30, 40]]'</span>, <span class="string">'$[1]'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- [20,10]</span></span><br><span class="line"><span class="keyword">SELECT</span> JSON_EXTRACT(<span class="string">'[10, 20, [30, 40]]'</span>, <span class="string">'$[1]'</span>, <span class="string">'$[0]'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- [30,40]</span></span><br><span class="line"><span class="keyword">SELECT</span> JSON_EXTRACT(<span class="string">'[10, 20, [30, 40]]'</span>, <span class="string">'$[2][*]'</span>);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8 Stream之list转map问题及解决</title>
      <link href="/2019/08/28/Java8-Stream%E4%B9%8Blist%E8%BD%ACmap%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/"/>
      <url>/2019/08/28/Java8-Stream%E4%B9%8Blist%E8%BD%ACmap%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h3><p>List集合转Map,用到的是Stream中<code>Collectors.toMap</code>方法。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个List集合</span></span><br><span class="line">List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList();  </span><br><span class="line">list.add(<span class="keyword">new</span> Person(<span class="string">"1001"</span>, <span class="string">"小A"</span>));  </span><br><span class="line">list.add(<span class="keyword">new</span> Person(<span class="string">"1002"</span>, <span class="string">"小B"</span>));  </span><br><span class="line">list.add(<span class="keyword">new</span> Person(<span class="string">"1003"</span>, <span class="string">"小C"</span>));</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">//将list转换map</span></span><br><span class="line">Map&lt;String, String&gt; map = list.stream().collect(Collectors.toMap(Person::getId, Person::getName));</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure><p>输出结果为：</p><p><img src="https://img-blog.csdn.net/20181011144617192?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjI5Mjc3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="å¨è¿éæå¥å¾çæè¿°"></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="1-：Duplicate-key-xxx"><a href="#1-：Duplicate-key-xxx" class="headerlink" title="(1)：Duplicate key xxx"></a>(1)：Duplicate key xxx</h4><p><code>原因是声明的List集合时,有的值重复</code>。</p><ul><li><p>重复时用后面value覆盖前面的value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> Person(<span class="string">"1001"</span>, <span class="string">"小A"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Person(<span class="string">"1001"</span>, <span class="string">"小B"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Person(<span class="string">"1003"</span>, <span class="string">"小C"</span>));</span><br><span class="line">Map&lt;String, String&gt; map = list.stream()</span><br><span class="line">    .collect(Collectors.toMap(Person::getId, Person::getName, (key1, key2) -&gt; key2));</span><br><span class="line">System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重复时将前面的value和后面的value拼接起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> Person(<span class="string">"1001"</span>, <span class="string">"小A"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Person(<span class="string">"1001"</span>, <span class="string">"小B"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Person(<span class="string">"1003"</span>, <span class="string">"小C"</span>));</span><br><span class="line">Map&lt;String, String&gt; map = list.stream()</span><br><span class="line">.collect(Collectors.toMap(Person::getId, Person::getName, (key1, key2) -&gt; key1 + <span class="string">","</span> + key2));</span><br><span class="line">System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重复时将重复的key的数据组成集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> Person(<span class="string">"1001"</span>, <span class="string">"小A"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Person(<span class="string">"1001"</span>, <span class="string">"小B"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Person(<span class="string">"1003"</span>, <span class="string">"小C"</span>));</span><br><span class="line">Map&lt;String, List&lt;String&gt;&gt; map = list.stream().collect(Collectors.toMap(Person::getId, p -&gt; &#123;</span><br><span class="line">List&lt;String&gt; getNameList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">getNameList.add(p.getName());</span><br><span class="line"><span class="keyword">return</span> getNameList;</span><br><span class="line">&#125;, (List&lt;String&gt; value1, List&lt;String&gt; value2) -&gt; &#123;</span><br><span class="line">value1.addAll(value2);</span><br><span class="line"><span class="keyword">return</span> value1;</span><br><span class="line">&#125;));</span><br><span class="line">System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-：第二种问题报错误：NullPointerException"><a href="#2-：第二种问题报错误：NullPointerException" class="headerlink" title="(2)：第二种问题报错误：NullPointerException"></a>(2)：第二种问题报错误：NullPointerException</h4><p><code>原因：声明List集合时有的值为空，但是HashMap中k,v是可以存null值的</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2() &#123;</span><br><span class="line">// 声明一个List集合</span><br><span class="line">List&lt;Person&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(new Person(&quot;1001&quot;, &quot;小A&quot;));</span><br><span class="line">list.add(new Person(&quot;1002&quot;, &quot;小B&quot;));</span><br><span class="line">list.add(new Person(&quot;1003&quot;, null));</span><br><span class="line">Map&lt;String, List&lt;String&gt;&gt; map = list.stream().collect(Collectors.toMap(Person::getId, p -&gt; &#123;</span><br><span class="line">List&lt;String&gt; getNameList = new ArrayList&lt;&gt;();</span><br><span class="line">getNameList.add(p.getName());</span><br><span class="line">return getNameList;</span><br><span class="line">&#125;, (List&lt;String&gt; value1, List&lt;String&gt; value2) -&gt; &#123;</span><br><span class="line">value1.addAll(value2);</span><br><span class="line">return value1;</span><br><span class="line">&#125;));</span><br><span class="line">System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
            <tag> Stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决idea控制台输出中文乱码问题</title>
      <link href="/2019/08/27/%E8%A7%A3%E5%86%B3idea%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
      <url>/2019/08/27/%E8%A7%A3%E5%86%B3idea%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="问题情况"><a href="#问题情况" class="headerlink" title="问题情况"></a>问题情况</h3><p><code>Idea</code>控制台输出中文乱码部分如图所示：</p><p><img src="https://img-blog.csdn.net/2018071809560839?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdTg2NTAzMzUwMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>如果是tomcat启动显示中文乱码，打开tomcat配置页面，Edit Congiurations。</li></ol><p><img src="https://img-blog.csdn.net/20180718095922839?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdTg2NTAzMzUwMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><ol start="2"><li><p>选择项目部署的tomcat，在配置项<code>VM options</code>文本输入<code>-Dfile.encoding=UTF-8</code>，点击Apply或者OK即可。</p><p><img src="https://img-blog.csdn.net/20180718110038782?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdTg2NTAzMzUwMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p></li><li><p>重启tomcat，<code>tomcat</code>乱码问题解决。</p><p><img src="https://img-blog.csdn.net/20180718113027640?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdTg2NTAzMzUwMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p></li><li><p>若乱码问题依然存在，请尝试继续按以下步骤解决：</p><ul><li>File-&gt;Settings-&gt;Editor-&gt;File Encodings 设置文件编码为UTF-8，*.properties勾上<code>Transparent native-to-ascii conversion。</code></li></ul><p>​      <img src="https://img-blog.csdn.net/20180608220601158?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MTMyMzYx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><ul><li><p>File-&gt;Settings-&gt;Build,Execution,Deployment-&gt;Compiler-&gt;Java Complier</p><p>设置 <strong>Additional command line parameters</strong>选项为 <strong>-encoding utf-8</strong></p></li><li><p>打卡Idea本地安装目录的<code>bin</code>文件夹下<code>idea.exe.vmoptions</code>和<code>idea64.exe.vmoptions</code>这两个文件。在文件末尾追加<code>-Dfile.encoding=UTF-8</code>。</p><p><img src="https://img-blog.csdn.net/20180718133811347?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdTg2NTAzMzUwMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p><img src="https://img-blog.csdn.net/20180718133739611?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdTg2NTAzMzUwMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p></li><li><p>然后重启<code>Idea</code>即可解决乱码问题。</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Idea </tag>
            
            <tag> 中文乱码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 扩展接口(SPI)</title>
      <link href="/2019/08/27/Spring-%E6%89%A9%E5%B1%95%E6%8E%A5%E5%8F%A3-SPI/"/>
      <url>/2019/08/27/Spring-%E6%89%A9%E5%B1%95%E6%8E%A5%E5%8F%A3-SPI/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7 yum方式安装MySQL5.7</title>
      <link href="/2019/08/25/Centos7-yum%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85MySQL5-7/"/>
      <url>/2019/08/25/Centos7-yum%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85MySQL5-7/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud整合Nacos篇之服务提供者</title>
      <link href="/2019/08/25/SpringCloud%E6%95%B4%E5%90%88Nacos%E7%AF%87%E4%B9%8B%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85/"/>
      <url>/2019/08/25/SpringCloud%E6%95%B4%E5%90%88Nacos%E7%AF%87%E4%B9%8B%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库SQL性能分析</title>
      <link href="/2019/08/25/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
      <url>/2019/08/25/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="1-查询性能优化"><a href="#1-查询性能优化" class="headerlink" title="1:查询性能优化"></a>1:查询性能优化</h3><p>一般来说在编写SQL时，需要注意以下问题：</p><ul><li><strong>是否能使用到索引。</strong></li><li><strong>是否在大表中或者高频率查询中引起全表查询。</strong></li></ul><p>主要通过经验分析配合 <strong>explain</strong> 关键字来进行分析。</p><h3 id="2-查询基础"><a href="#2-查询基础" class="headerlink" title="2:查询基础"></a>2:查询基础</h3><p>了解查询过程，才能知道哪些步骤可能出现瓶颈，<strong>execution plain</strong> 结果也会有限体现：</p><ol><li>Client往服务器发送查询指令</li><li><strong>服务器查询缓存</strong>，如果存在则直接返回，否则下一步</li><li><strong>服务器解析，预处理，优化查询，生成执行计划</strong></li><li>执行引擎调用存储引擎API执行查询</li><li>服务器将结果返回给客户端</li></ol><h3 id="2-1-优化数据访问"><a href="#2-1-优化数据访问" class="headerlink" title="(2-1):优化数据访问"></a>(2-1):优化数据访问</h3><ol><li>应用程序是否获取超过需要的数据量？<strong>(多次遇到过查询表所有数据然后在程序中只读取10行之类的代码。)</strong></li><li>MySQL服务器是否分析了超过需要的行？</li><li>数据是否没有存储引擎层被过来掉？<strong>(Using index,Using where)</strong></li></ol><h4 id="2-2-访问类型"><a href="#2-2-访问类型" class="headerlink" title="(2-2):访问类型"></a>(2-2):访问类型</h4><p><strong>Full Table Scan &gt; Index Scan &gt; Range Scan &gt; Unique Index LookUp &gt; Constant</strong></p><p>访问速度依次递增。</p><p>对于使用where语句来过滤数据的话,最好到最坏的情况是：</p><ol><li>对索引查询用where来消除不匹配的数据行，在存储引擎层。</li><li>使用覆盖索引(Extra为Using Index)来避免访问行，取得索引数据后过滤行，发送在MySQL服务层。</li><li>从表中查询数据，然后过滤(Using Where)，发送在服务端并且要读取行数据。</li></ol><h3 id="2-3-关于执行计划"><a href="#2-3-关于执行计划" class="headerlink" title="(2-3):关于执行计划"></a>(2-3):关于执行计划</h3><p>执行计划结果样例如下图：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1564148501889-ce986183-0a8a-455f-9d10-16b885b9c27e.png" alt="image.png"></p><p><strong>id,type,key,rows,extra是衡量指标。</strong></p><p>(2-3-1): id: select查询序列号，表示查询中执行select子句或操作表顺序</p><ol><li>id相同，执行顺序由上至下</li><li>id不同，如果是子查询，id序号会递增，<strong>id值越大优先级越高，越先被执行</strong>。</li><li>id相同不同，id如果相同，可以被认为是一组，由上至下执行；在所有组中id值越大，优先级越高，越先被执行。</li></ol><p>(2-3-2)：select_type：查询类型，主要用于区别普通查询，联合查询，子查询等复杂查询</p><ol><li>simple：<strong>简单的select查询，查询不包含子查询。</strong></li><li>primary：查询中若包含任何复杂的子部分，最外层查询则被标记为primary。</li><li>subquery：在select或者where列表中包含了子查询</li><li>derived：在<strong>from列表中包含的子查询被标记为derived(衍生)</strong>，MySQL会递归执行这些子查询，把结果存到临时表中。</li><li>union：在第二个select出现在union之后，则被标记为union。</li><li>union result：从union表获取结果的select</li></ol><p>(2-3-3): table：显示这一行数据是关于哪张表</p><p>(2-3-4)：type：访问类型排列，显示了查询使用何种类型，结果值从最好到最坏。</p><p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><ol><li>system：表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计</li><li>const：表示通过索引一次就找到了,<strong>const**</strong>用于比较primary key或者unique索引。**</li><li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。<strong>常见于主键或唯一索引扫描</strong></li><li>ref：非唯一性索引扫描，返回匹配某个单独值的所有行。<strong>属于查找和扫描的混合体</strong></li><li>range：只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引一般就是在你的where。例如</li></ol><p>语句中出现了between，&lt;，&gt;，in等查询这种范围扫描索引比全表扫描要好。</p><ol><li>index：index和ALL区别为<strong>Index类型只遍历索引树</strong>。index从索引读，ALL从磁盘读。</li><li>all：全表扫描，将遍历全表找到匹配行。</li></ol><p><strong>一般来说，得保证查询至少达到range级别,最好能达到ref。</strong></p><p>举例：</p><ol><li>const：where id = 1 id是写死的常量id只有1条，性能好。</li><li>eq_ref：where t1.id = t2.id t2.id只有1条记录，t2表只有1条记录,t2是全表扫描。</li><li>ref: where col1 = ‘ac’ ac是常量,但是col1是非唯一性索引。</li><li>rang：where id between 30 and 60,。</li><li>index: select id from t1</li><li>all: where条件字段没建立索引,或者索引失效。</li></ol><p>(2-3-5)：possible_keys：显示可能应用在这张表的索引。</p><p>(2-3-6)：key：实际使用到的索引。如果为NULL，则没有使用索引。</p><p>​     <strong>查询中若使用了**</strong>覆盖索引<strong>**，则该索引仅出现在key列表中：select 查询的字段个数、顺序和复合索引的字段的个数、顺序一一符合。</strong></p><p>(2-3-7)：key_len：表示索引使用的字节数。在不损失性能的情况下，长度越短越好。</p><p>(2-3-8)：ref：显示索引的哪一列使用了。</p><p>(2-3-9)：rows：根据表统计信息及索引使用情况，大致估算出找到所需的几率需要读取的行数。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1564150150409-8d9f1010-ebf4-4327-917a-d183420a5086.png" alt="img"></p><p>(2-3-10)：extra：包含不合适在其他列中显示但十分重要的额外信息。</p><p>（前三个最重要：Using filesort、Using temporary表明语句烂需要优化，Using index表明语句还不错）</p><ol><li><strong>using where</strong>：表名使用了where过滤</li><li><strong>using index</strong>：select操作使用了覆盖索引(<strong>covering index</strong>)。表明效率不错</li><li><strong>using filesort</strong>：说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。</li><li><strong>using tempory</strong>：使用了临时表保存中间结果，MySQL对查询结果排序使用了临时表。常见的<strong>order by,group by</strong>。</li><li>using join buffer：使用了连接缓存</li><li>impossible where：where子句的值总是false</li><li><strong>distinct</strong>：优化distinct操作，在找到第一匹配的元组后即停止找同样值动作。</li></ol><h3 id="3：常见优化"><a href="#3：常见优化" class="headerlink" title="3：常见优化"></a>3：常见优化</h3><ol><li><strong>IN查询能避免则避免，如果避免不了，IN查询的数量不要超过1000。如果是连续的值，应该使用**</strong>between … and …** <strong>。或者使用连接进行替换。</strong></li><li><strong>SELECT语句务必指明字段名称。</strong></li><li><strong>当只需要1条数据时候，使用limit 1。</strong></li><li><strong>如果排序字段没有用到索引，就尽量少排序</strong>。</li><li><strong>如果限制条件其他字段没有索引，尽量少用or。</strong></li><li><strong>尽量使用union all代替union：union比后者再进行唯一性过滤操作。</strong></li><li><strong>不使用ORDER BY RAND()。</strong></li><li><strong>区分IN和EXISTS，not in和not exists**</strong>。**</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table1 <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> tableb) ==&gt;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tabla <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> tableb <span class="keyword">where</span> tableb.id = table1.id)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">col</span> <span class="keyword">from</span> table1 <span class="keyword">where</span> table1.id <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> table2.id <span class="keyword">from</span> table2) ==&gt;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">col</span> <span class="keyword">from</span> table1,table2 <span class="keyword">where</span> table1.id = table2.id <span class="keyword">and</span> table2.id <span class="keyword">is</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure><blockquote><p>   区分in和exists主要是造成了驱动顺序的改变（这是性能变化的关键），如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询。所以<strong>IN适合于外表大而内表小的情况。</strong></p><p>   <strong>EXISTS适合于外表小而内表大的情况</strong></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#in 子查询优化</span></span><br><span class="line"><span class="comment">#仍然in子查询,多查询一次</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table1 <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span>(<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> table2 <span class="keyword">where</span> 条件)</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table2 <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span>(<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> table2 <span class="keyword">where</span> 条件) <span class="keyword">as</span> tbt)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用left join</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> basic_zdjbxx <span class="keyword">WHERE</span> suiji <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> zdcode <span class="keyword">FROM</span> basic_h <span class="keyword">WHERE</span> zdcode != <span class="string">""</span> )</span><br><span class="line"><span class="keyword">SELECT</span> zd.* <span class="keyword">FROM</span> ( <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> zdcode <span class="keyword">FROM</span> basic_h <span class="keyword">WHERE</span> zdcode != <span class="string">""</span> ) <span class="keyword">AS</span> h </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> basic_zdjbxx zd <span class="keyword">ON</span> zd.suiji = h.zdcode</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用exists(适用于外表小而内表达的情况)</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> film <span class="keyword">where</span> film_id <span class="keyword">in</span> ( <span class="keyword">select</span> film_id <span class="keyword">from</span> film.actor <span class="keyword">where</span> actor_id = <span class="number">1</span>);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> film <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> * <span class="keyword">from</span> film_actor <span class="keyword">where</span> actor_id = <span class="number">1</span> <span class="keyword">and</span> film_actor.film_id = film.film_id);</span><br></pre></td></tr></table></figure><ol><li></li><li><p><strong>使用合理的分页方式以提高分页的效率。</strong></p></li><li><p>分段查询：<strong>如果选择时间的范围过大，造成查询缓慢。主要是扫描条数过多。可以通过程序，分段进行查询，循环遍历，将结果合并处理。</strong></p></li><li><p><strong>避免在where子句对字段进行null值判断</strong>。对于null的判断会导致引擎放弃使用索引而进行全表扫描。</p></li><li><p><strong>不建议使用%前缀模糊查询。建议走全文索引(solr,elasticsearch)。</strong></p></li></ol><p>​     <strong>在需要创建全文索引之前，请联系DBA确定能否创建。同时需要注意的是查询语句的写法与普通索引的区别</strong></p><ol><li><strong>避免在where子句中对字段进行表达式操作。</strong></li><li><strong>避免隐式转换。**</strong>建议先确定where中的参数类型**</li><li><strong>联合索引遵守最左前缀法则。例如索引含有字段id,name,school,不应该使用name;school无法使用这个索引。常用查询放前面。</strong></li><li><strong>必要时可以使用force index来强制查询走某个索引。</strong></li><li><strong>注意范围查询语句。**</strong>对于联合索引来说，如果存在范围查询，比如between,&gt;,&lt;等条件时，会造成后面的索引字段失效。**</li><li><strong>关于JOIN优化：尽量使用inner join,避免使用left join。inner join会自动找出数据表作用驱动表。利用小表驱动大表(**</strong>减少嵌套循环次数，以减少IO总量及CPU运算次数<strong><strong>)。</strong></strong>合理利用索引：被驱动表的索引字段作为on限制字段。**</li></ol><blockquote><p><strong>参与联合查询的表至少为2张表，一般都存在大小之分。如果连接方式是inner join，在没有其他过滤条件的情况下MySQL会自动选择小表作为驱动表，但是left join在驱动表的选择上遵循的是左边驱动右边的原则，即left join左边的表名为驱动表。</strong></p></blockquote><h3 id="4：一些SQL优化建议"><a href="#4：一些SQL优化建议" class="headerlink" title="4：一些SQL优化建议"></a>4：一些SQL优化建议</h3><ol><li><strong>SQL语句不要写太复杂：一个SQL语句要尽量简单，不要嵌套太多层。</strong></li><li><strong>使用临时表缓存中间结果。</strong></li><li><strong>使用LIKE要注意是否全表扫描。==&gt;在where子句使用!=,&lt;,&gt;,引擎会放弃使用索引,进行全表扫描。</strong></li><li><strong>尽量避免使用or来连接条件。</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num = 11 or num = 20 ==&gt;</span><br><span class="line">select id from t where num = 10 union all select id from t where num = 20</span><br><span class="line">select id from t where num in (10,20)</span><br></pre></td></tr></table></figure><p>​    <strong>union使用注意事项：**</strong>所有select语句中字段数目要相同。**</p><ol><li><strong>尽量避免使用in和not in：当字段是连续值且数字，可以使用between … and …</strong></li><li><strong>可以考虑强制查询使用索引</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#强制使用主键</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">force</span> <span class="keyword">index</span>(PRI) <span class="keyword">limit</span> <span class="number">2</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">#强制使用索引hollis_index</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">force</span> <span class="keyword">index</span>(hollis_index) <span class="keyword">limit</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">force</span> <span class="keyword">index</span>(PRI,hollis_index) <span class="keyword">limit</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><ol><li><strong>避免使用表达式，函数等操作作为查询条件。</strong></li><li><strong>尽量避免大事务操作，提高系统并发能力。</strong></li><li><strong>任何地方不要使用select * from t 代替具体字段。</strong></li><li><strong>尽可能使用varchar/nvarchar代替char/nchar</strong></li><li><strong>尽量使用数字型字段。</strong></li><li><strong>索引并不是越多越好。索引会降低insert和update效率</strong></li><li><strong>并不是索引对查询有效，SQL根据表中数据进行优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引。</strong></li></ol><h3 id="5-SQL执行顺序"><a href="#5-SQL执行顺序" class="headerlink" title="5: SQL执行顺序"></a>5: SQL执行顺序</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1564153060836-b48a4668-8171-4eea-a517-0536c2b86745.png" alt="img"></p><p><strong>写一条SQL查询应当遵循以下顺序。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT XXX FROM XXX WHERE XXX GROUP BY XXX HAVING XXX ORDER BY XXX LIMIT XXX;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BeanPostProcessor加载次序及其对Bean造成的影响</title>
      <link href="/2019/08/24/BeanPostProcessor%E5%8A%A0%E8%BD%BD%E6%AC%A1%E5%BA%8F%E5%8F%8A%E5%85%B6%E5%AF%B9Bean%E9%80%A0%E6%88%90%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
      <url>/2019/08/24/BeanPostProcessor%E5%8A%A0%E8%BD%BD%E6%AC%A1%E5%BA%8F%E5%8F%8A%E5%85%B6%E5%AF%B9Bean%E9%80%A0%E6%88%90%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="1：前言"><a href="#1：前言" class="headerlink" title="1：前言"></a>1：前言</h3><p><code>BeanPostProcessor</code>是一个工厂钩子，<code>允许Spring框架在新创建Bean实例时对其进行定制化修改</code>。例如：通过检查其标注的接口或者使用代理对其进行包裹。应用上下文会从Bean定义中自动检测出BeanPostProcessor并将它们应用到随后创建的任何Bean上。</p><p>普通Bean对象的工厂允许在程序中注册post-processors，应用到随后在本工厂中创建的所有Bean上。典型的场景如：</p><ul><li>通过<code>标记接口等填充bean</code>后置处理器通常会实现postProcessBeforeInitialization</li><li>而<code>使用代理包装bean</code>的后置处理器通常会实现则一般使用postProcessAfterInitialization</li></ul><p>BeanPostProcessor本身也是一个Bean，一般而言其实例化时机要早过普通的Bean，但是BeanPostProcessor也会依赖一些Bean，这就导致了一些Bean的实例化早于BeanPostProcessor，由此会导致一些问题。最近在处理shiro和spring cache整合时就碰到了，导致的结果就是spring cache不起作用。现将问题场景、查找历程及解决方法展现一下。</p><h3 id="2：问题场景"><a href="#2：问题场景" class="headerlink" title="2：问题场景"></a>2：问题场景</h3><p>打算在项目中将shiro与spring cache整合，使用spring cache统一管理缓存，也包括shiro认证时的用户信息查询。<code>项目中将service分层，outter层负责权限和session，inner层主打事务和缓存并与DAO交互，两层之间也可以较容易的扩展为RPC或微服务模式</code>。因此在shiro的authRealm中依赖了innerUserService，并在innerUserService中配置了spring cache的标注，使用cache进行缓存。配置如下（摘录重要部分）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置shiro secuirty manager</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"securityManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SecurityManager <span class="title">securityManager</span><span class="params">(@Qualifier(<span class="string">"authRealm"</span>)</span> TourismAuthorizingRealm authRealm, @<span class="title">Qualifier</span><span class="params">(<span class="string">"cookieRememberMeManager"</span>)</span> CookieRememberMeManager cookieRememberMeManager) </span>&#123;</span><br><span class="line">        log.info(<span class="string">"securityManager()"</span>);</span><br><span class="line">        DefaultWebSecurityManager securityManager = <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置rememberMe管理器</span></span><br><span class="line">        securityManager.setRememberMeManager(cookieRememberMeManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置realm,解决doGetAuthorizationInfo方法没有调用问题</span></span><br><span class="line">        securityManager.setRealm(authRealm);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置自定义权限登录器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"authRealm"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TourismAuthorizingRealm <span class="title">tourismAuthorizingRealm</span><span class="params">(@Qualifier(<span class="string">"hashedCredentialsMatcher"</span>)</span> HashedCredentialsMatcher matcher) </span>&#123;</span><br><span class="line">        log.info(<span class="string">"tourismAuthorizingRealm bean"</span>);</span><br><span class="line">        TourismAuthorizingRealm myAuthorizingRealm = <span class="keyword">new</span> TourismAuthorizingRealm();</span><br><span class="line">        <span class="comment">// 设置密码凭证匹配器</span></span><br><span class="line">        myAuthorizingRealm.setCredentialsMatcher(matcher);</span><br><span class="line">        <span class="keyword">return</span> myAuthorizingRealm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开启shiro aop注解支持.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 使用代理方式;所以需要开启代码支持;</span></span><br><span class="line"><span class="comment">     * Controller才能使用<span class="doctag">@RequiresPermissions</span></span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> securityManager</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthorizationAttributeSourceAdvisor <span class="title">authorizationAttributeSourceAdvisor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @Qualifier(<span class="string">"securityManager"</span>)</span> SecurityManager securityManager) </span>&#123;</span><br><span class="line">        AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = <span class="keyword">new</span> AuthorizationAttributeSourceAdvisor();</span><br><span class="line">        authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);</span><br><span class="line">        <span class="keyword">return</span> authorizationAttributeSourceAdvisor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置 shiro filter factory</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">shiroFilter</span><span class="params">(@Qualifier(<span class="string">"securityManager"</span>)</span> SecurityManager securityManager) </span>&#123;</span><br><span class="line">        ShiroFilterFactoryBean shiroFilterFactoryBean = <span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">        <span class="comment">// 必须设置 SecurityManager</span></span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line">        <span class="keyword">return</span> shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 配置shiro生命周期</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"lifecycleBeanPostProcessor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> LifecycleBeanPostProcessor <span class="title">lifecycleBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"lifecycleBeanPostProcessor bean"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LifecycleBeanPostProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中TourismAuthorizingRealm是自定义的shiro authorizingRealm，<code>用于执行认证和授权</code>。其实现依赖userService从库中查找用户信息，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TourismAuthorizingRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"userService"</span>)</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * shiro的权限配置方法</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"权限配置--&gt;doGetAuthorizationInfo"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        SimpleAuthorizationInfo authorizationInfo = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line">        logger.info(<span class="string">"-----------------------------&gt;"</span> + principals.getPrimaryPrincipal());</span><br><span class="line"></span><br><span class="line">        User user = (User) principals.getPrimaryPrincipal();</span><br><span class="line">        logger.info(<span class="string">"doGetAuthorizationInfo() user: &#123;&#125;"</span>, user);</span><br><span class="line">        List&lt;Role&gt; roles = userService.getRoles(user.getUserId());</span><br><span class="line">        <span class="keyword">for</span> (Role role : roles) &#123;</span><br><span class="line"></span><br><span class="line">            authorizationInfo.addRole(role.getRoleName());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果有权限，应该增加所有角色对应的权限</span></span><br><span class="line">            <span class="comment">// authorizationInfo.addStringPermission()</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"用户: &#123;&#125;,具有的角色: &#123;&#125;"</span>, user.getUserName(), authorizationInfo.getRoles());</span><br><span class="line">        logger.info(<span class="string">"用户: &#123;&#125;,具有的权限: &#123;&#125;"</span>, user.getUserName(), authorizationInfo.getStringPermissions());</span><br><span class="line">        <span class="keyword">return</span> authorizationInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * shiro的身份验证方法</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"正在验证身份..."</span>);</span><br><span class="line">        SimpleAuthenticationInfo info;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将token转换成UsernamePasswordToken</span></span><br><span class="line">        UsernamePasswordToken upToken = (UsernamePasswordToken) token;</span><br><span class="line">        <span class="comment">//从转换后的token中获取用户名</span></span><br><span class="line">        String username = upToken.getUsername();</span><br><span class="line">        <span class="comment">//查询数据库，得到用户</span></span><br><span class="line">        User user = userService.getOne(<span class="keyword">new</span> QueryWrapper&lt;User&gt;().lambda().eq(User::getUserName, username));</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.info(<span class="string">"没有用户: &#123;&#125;"</span>, username);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到加密密码的盐值</span></span><br><span class="line">        ByteSource salt = ByteSource.Util.bytes(user.getUserSalt());</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"加密密码的盐: &#123;&#125;"</span>, salt);</span><br><span class="line">        <span class="comment">//得到盐值加密后的密码: 只用于方便数据库测试,后期不会用到。</span></span><br><span class="line">        Object md = <span class="keyword">new</span> SimpleHash(PasswordUtils.ALGORITHM_NAME, upToken.getPassword(), salt, PasswordUtils.HASH_ITERATIONS);</span><br><span class="line">        logger.info(<span class="string">"盐值加密后的密码: &#123;&#125;"</span>, md);</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> 用户名;用户密码;加密盐;realm name</span></span><br><span class="line">        info = <span class="keyword">new</span> SimpleAuthenticationInfo(user, user.getUserPassword(), salt, getName());</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在UserService中配置了spring cache标注,代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Cacheable</span>(value = <span class="string">"user-cache"</span>, key = <span class="string">"#username"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findByUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">User user = userMapper.findByUsername(username);</span><br><span class="line">logger.info(<span class="string">"Real execute find from database, username:&#123;&#125;"</span>, username);</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并在配置文件上标注了<code>@EnableCaching(mode=AdviceMode.PROXY)以启动spring cache</code>。这里不过多解释具体shiro和spring cache的使用，有兴趣的同学请自行搜索相关资料。</p><p>按道理这样的配置在认证的时候可以直接使用userService中配置的spring cache缓存。但是，在具体的场景时，当authRealm依赖了userService以后,spring cache失效了。。而authRealm不依赖userService的时候，cache却正常运行。</p><h3 id="3：问题查找"><a href="#3：问题查找" class="headerlink" title="3：问题查找"></a>3：问题查找</h3><h4 id="3-1：Spring-cache失效的表象原因"><a href="#3-1：Spring-cache失效的表象原因" class="headerlink" title="3-1：Spring cache失效的表象原因"></a>3-1：Spring cache失效的表象原因</h4><p>首先,<code>spring cache的实现是基于Spring AOP和拦截器的方式拦截定义的特定缓存注解</code>，然后执行特定逻辑。因此其实现依赖于动态代理机制auto-proxy，而经过初步调试发现，当被authRealm依赖以后，userService就不会被代理了，因此无从进入AOP的pointcut，也就是说AOP切面失效了！</p><h4 id="3-2：Spring-cache集成机制分析深层次原因"><a href="#3-2：Spring-cache集成机制分析深层次原因" class="headerlink" title="3-2：Spring cache集成机制分析深层次原因"></a>3-2：Spring cache集成机制分析深层次原因</h4><p> 为何没有被代理呢，我们先来确认一下正常情况下什么时候进行代理封装，这时关于BeanPostProcessor的定义浮现脑海，据文档记载BeanPostProcessor允许在Bean实例化的前后对其做一些猥琐的事情，比如代理。我们在BeanPostProcessor的实现类有<code>AbstractAutoProxyCreator,InfrastructureAdvisorAutoProxyCreator</code></p><p> 这一脉。而反观@EnableCaching标注在启动的时候会导入 CachingConfigurationSelector，其selectImports方法会返回AutoProxyRegistrar和ProxyCachingConfiguration的全类名（我们定义了mode=AdviceMode.PROXY），也就是加载这两个类。第一个的作用就是注册InfrastructureAdvisorAutoProxyCreator到BeanDefinitionRegistry中。第二个的作用就是注册了BeanFactoryCacheOperationSourceAdvisor和CacheInterceptor。</p><p> 因此，当正常情况下，一个添加了spring cache相关标注的bean会在创建后被<code>InfrastructureAdvisorAutoProxyCreator</code>基于advisor进行代理增强，代理后便可在拦截器<code>CacheInterceptor</code>中对其方法进行拦截，然后执行cache相关逻辑。</p><p>所以通过以上的分析，<code>userSerivcce并没有经过Spring AOP代理增强。</code>经测试发现，当被authRealm依赖的情况下在userSevice的Bean实例化时，用于处理该Bean的PostBeanProcessor明显比没被authRealm依赖时少，并且不含有InfrastructureAdvisorAutoProxyCreator。而且控制台会多打印出来一行信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...................</span><br><span class="line">Bean <span class="string">'UserServiceImpl'</span> of type [shiro.web.inner.service.impl.UserServiceImpl] <span class="function">is not eligible <span class="keyword">for</span> getting processed by all <span class="title">BeanPostProcessors</span> <span class="params">(<span class="keyword">for</span> example: not eligible <span class="keyword">for</span> auto-proxying)</span></span></span><br><span class="line"><span class="function">...................</span></span><br></pre></td></tr></table></figure><p>据此可以推断，可能由于UserService实例化时机过早，导致后面那些BeanPostProcessor还未来得及实例化和注册。</p><h3 id="4：BeanPostProcessor启动阶段对其依赖Bean造成影响"><a href="#4：BeanPostProcessor启动阶段对其依赖Bean造成影响" class="headerlink" title="4：BeanPostProcessor启动阶段对其依赖Bean造成影响"></a>4：BeanPostProcessor启动阶段对其依赖Bean造成影响</h3><p>首先确认了authRealm也是受害者，因为shiroFilter-&gt;SecurityManager-&gt;authRealm的依赖关系导致其不得不提前实例化。表面上的罪魁祸首是shiroFilter，但是到底是谁导致的shiroFilter预料之外的提前启动呢。shiroFilter与InfrastructureAdvisorAutoProxyCreator的具体启动时机到底是什么时候呢。经过调试后发现，了解到BeanPostProcessor的启动时机。在AbstractBeanFactory中维护了BeanPostProcessor的列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;BeanPostProcessor&gt; beanPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanPostProcessor&gt;();</span><br></pre></td></tr></table></figure><p>并实现了ConfigurableBeanFactory定义的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addBeanPostProcessor</span><span class="params">(BeanPostProcessor beanPostProcessor)</span></span>;</span><br></pre></td></tr></table></figure><p>因此首先监控<code>AbstractBeanFactory.addBeanPostProcessor()</code>，看看启动过程中谁调用了该方法来注册BeanPostProcessor。发现实例化及注册PostBeanFactory的阶段分为四个：</p><ul><li><p>第一个阶段是在启动时由<code>AbstractApplicationContext.refresh()</code>，其中的prepareBeanFactory方法中注册了ApplicationContextAwareProcessor、ApplicationListenerDetector：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后是<code>ServletWebServerApplicationContext</code>中<code>postProcessBeanFactory</code>注册<code>WebApplicationContextServletContextAwareProcessor</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register ServletContextAwareProcessor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ServletContextAwareProcessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">beanFactory.addBeanPostProcessor(</span><br><span class="line"><span class="keyword">new</span> WebApplicationContextServletContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">beanFactory.ignoreDependencyInterface(ServletContextAware.class);</span><br><span class="line">registerWebApplicationScopes();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后在<code>AbstractApplicationContext#refresh#invokeBeanFactoryPostProcessors</code>方法调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate and invoke all registered BeanFactoryPostProcessor beans,</span></span><br><span class="line"><span class="comment"> * respecting explicit order if given.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Must be called before singleton instantiation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 其中PostProcessorRegistrationDelegate是处理BeanPostProcessor的代理类</span></span><br><span class="line">PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后是处理@Configuration注解的<code>ConfigurationClassPostProcessor</code>,实现BeanFactoryPostProcessorr</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ImportAwareBeanPostProcessor(beanFactory));</span><br></pre></td></tr></table></figure></li><li><p>最后在<code>AbstractApplicationContext#refresh#registerBeanPostProcessors</code>方法调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate and register all BeanPostProcessor beans,</span></span><br><span class="line"><span class="comment"> * respecting explicit order if given.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Must be called before any instantiation of application beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>PostProcessorRegistrationDelegate.registerBeanPostProcessors</code>，首选注册了BeanPostProcessorChecker：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br></pre></td></tr></table></figure></li></ul><p>其中BeanPostProcessorChecker类在Bean创建完，它会在Bean创建完后检查可在当前Bean上起作用的BeanPostProcessor个数与总的BeanPostProcessor个数，如果起作用的个数少于总数，则报出上面那句info信息。</p><p>在<code>PostProcessorRegistrationDelegate.registerBeanPostProcessors</code>分为四个阶段依次实例化并注册实现了PriorityOrdered的BeanPostProcessor、实现了Ordered的BeanPostProcessor、没实现Ordered的BeanPostProcessor，内部的BeanPostProcessors，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 从bean工厂获取postProcessorNames</span></span><br><span class="line">String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register BeanPostProcessorChecker that logs an info message when</span></span><br><span class="line"><span class="comment">// a bean is created during BeanPostProcessor instantiation, i.e. when</span></span><br><span class="line"><span class="comment">// a bean is not eligible for getting processed by all BeanPostProcessors.</span></span><br><span class="line">       ...</span><br><span class="line">       beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></span><br><span class="line">List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">           <span class="comment">// BeanPostProcessor早于一般bean实例化</span></span><br><span class="line">BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">orderedPostProcessors.add(pp);</span><br><span class="line"><span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">internalPostProcessors.add(pp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now, register all regular BeanPostProcessors.</span></span><br><span class="line">List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">nonOrderedPostProcessors.add(pp);</span><br><span class="line"><span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">internalPostProcessors.add(pp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></span><br><span class="line">sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span></span><br><span class="line"><span class="comment">// moving it to the end of the processor chain (for picking up proxies etc).</span></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>需要注意的是，除了第一个阶段，其他阶段同一个阶段的BeanPostProcessor是在全部实例化完成以后才会统一注册到beanFactory的</code>，因此，<code>同一个阶段的BeanPostProcessor及其依赖的Bean在实例化的时候是无法享受到相同阶段先实例化的BeanPostProcessor的“服务”的，因为它们还没有注册</code>。</p><p>从上面调试与源代码分析，BeanPostProcessor的实例化与注册分为四个阶段，第一阶段applicationContext内置阶段、第二阶段priorityOrdered阶段、第三阶段Ordered阶段、第四阶段nonOrdered阶段。而BeanPostProcessor同时也是Bean，其注册之前一定先实例化。而且是分批实例化和注册，也就是属于同一批的BeanPostProcesser全部实例化完成后，再全部注册，不存在先实例化先注册的问题。而在实例化的时候其依赖的Bean同样要先实例化。<br><strong>因此导致一个结果就是，被PriorityOrdered BeanPostProcessor所依赖的Bean其初始化时无法享受到PriorityOrdered、Ordered、和nonOrdered BeanPostProcessor的服务。而被Ordered BeanPostProcessor所依赖的Bean无法享受Ordered、和nonOrdered的BeanPostProcessor的服务。最后被nonOrdered BeanPostProcessor所依赖的Bean无法享受到nonOrdered BeanPostProcessor的服务。</strong></p><p>由于InfrastructureAdvisorAutoProxyCreator的启动阶段是Ordered，因此我们需要确保没有任何priorityOrdered和Ordered的BeanPostProcessor直接或间接的依赖到shiroFilter，也就是依赖到我们的userService。</p><p>同时在PriorityOrdered接口的注解中也提到了该情况：</p><blockquote><p>注意：{@code PriorityOrdered}后处理器bean在<em>特殊阶段初始化，优于其他后处理器bean。这种巧妙的*会影响它们的自动装配行为：它们只会针对</em> bean自动装配，这些bean不需要急切初始化类型匹配。</p></blockquote><h4 id="4-1：-BeanPostProcessor在进行依赖的Bean注入时，根据Bean名称进行类型检查时导致的“误伤”"><a href="#4-1：-BeanPostProcessor在进行依赖的Bean注入时，根据Bean名称进行类型检查时导致的“误伤”" class="headerlink" title="4-1： BeanPostProcessor在进行依赖的Bean注入时，根据Bean名称进行类型检查时导致的“误伤”"></a>4-1： BeanPostProcessor在进行依赖的Bean注入时，根据Bean名称进行类型检查时导致的“误伤”</h4><p>问题貌似已查明，修改Configuration中所有PriorityOrdered和Ordered类型的PostBeanProcessor的Bean配置，使其不再依赖shiroFilter。再次启动，却发现仍然提前启动了shiroFilter-&gt;SecurityManager-&gt;authRealm-&gt;userService。</p><p>继续进行调试，查找shiroFilter具体的启动时机。发现在一个叫做dataSourceInitializerPostProcessor的BeanPostProcessor实例化的时候，在根据类型获得其依赖的参数时，对shiroFilter执行了初始化。导致后续SecurityManager-&gt;authRealm-&gt;userService统统提前初始化。但是在dataSourceInitializerPostProcessor之前的BeanPostProcessor却没有。经调试它们是否会导致shiroFilter初始化的区别在调用AbstractBeanFactory.isTypeMatch方法时出现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>&#123;</span><br><span class="line">.....................</span><br><span class="line"><span class="comment">// Check bean class whether we're dealing with a FactoryBean.</span></span><br><span class="line"><span class="keyword">if</span> (FactoryBean.class.isAssignableFrom(beanType)) &#123;<span class="comment">//判断名称对应的Bean是否是一个FactoryBean,若是FactoryBean才执行本句</span></span><br><span class="line"><span class="keyword">if</span> (!BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line"><span class="comment">// If it's a FactoryBean, we want to look at what it creates, not the factory class.</span></span><br><span class="line">beanType = getTypeForFactoryBean(beanName, mbd);</span><br><span class="line"><span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br><span class="line">.....................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进入AbstractAutowireCapableBeanFactory.getTypeForFactoryBean方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getTypeForFactoryBean(String beanName, RootBeanDefinition mbd) &#123;</span><br><span class="line">  ...</span><br><span class="line"><span class="comment">// If not resolvable above and the referenced factory bean doesn't exist yet,</span></span><br><span class="line"><span class="comment">// exit here - we don't want to force the creation of another bean just to</span></span><br><span class="line"><span class="comment">// obtain a FactoryBean's object type...</span></span><br><span class="line"><span class="keyword">if</span> (!isBeanEligibleForMetadataCaching(factoryBeanName)) &#123;<span class="comment">//判断该bean对应的factoryBeanName是否已经初始化了,如果没有,就返回.如果有,则继续</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解说的很明确，如果名字对应的factoryBean所在的factoryBean工厂尚未解析并实例化，那就直接退出，不会强制创建该facotryBean工厂，也就是Configuration对应的Bean。再次调试，果然发现，在先前的<strong>BeanPostProcessor和DataSourceInitializerPostProcessor之间，存在一个lifecycleBeanPostProcessor，而LifecycleBeanPostProcessor是在我们的Configuration中显示定义的，因此，当lifecycleBeanPostProcessor启动时会导致Configuration实例化。</strong></p><p><strong>最终隐藏大BOSS查明，解决方案就简单了，将lifecycleBeanPostProcessor移出到一个单独的Configuration就好了。</strong></p><h3 id="5：总结"><a href="#5：总结" class="headerlink" title="5：总结"></a>5：总结</h3><h4 id="5-1：BeanPostProcessor启动顺序，以及其对于依赖的Bean的影响"><a href="#5-1：BeanPostProcessor启动顺序，以及其对于依赖的Bean的影响" class="headerlink" title="5-1：BeanPostProcessor启动顺序，以及其对于依赖的Bean的影响"></a>5-1：BeanPostProcessor启动顺序，以及其对于依赖的Bean的影响</h4><p><em>BeanPostProcessor的启动时机。分为四个阶段，第一阶段ApplicationContext内置阶段、第二阶段priorityOrdered阶段、第三阶段Ordered阶段、第四阶段nonOrdered阶段。</em></p><p><em>而BeanPostProcessor同时也是Bean，其注册之前一定先实例化。而且是分批实例化和注册，也就是属于同一批的BeanPostProcesser全部实例化完成后，再全部注册，不存在先实例化先注册的问题。而在实例化的时候其依赖的Bean同样要先实例化。</em></p><p><em>因此导致一个结果就是，被PriorityOrderedBeanPostProcessor所依赖的Bean其初始化以后无法享受到PriorityOrdered、Ordered、和nonOrdered的BeanPostProcessor的服务。而被OrderedBeanPostProcessor所依赖的Bean无法享受Ordered、和nonOrdered的BeanPostProcessor的服务。最后被nonOrderedBeanPostProcessor所依赖的Bean无法享受到nonOrderedBeanPostProcessor的服务。</em></p><h4 id="5-2：注意避免BeanPostProcessor启动时的“误伤”陷阱"><a href="#5-2：注意避免BeanPostProcessor启动时的“误伤”陷阱" class="headerlink" title="5-2：注意避免BeanPostProcessor启动时的“误伤”陷阱"></a>5-2：注意避免BeanPostProcessor启动时的“误伤”陷阱</h4><p><strong><code>BeanPostProcessor实例化时，自动依赖注入根据类型获得需要注入的Bean时，会将某些符合条件的Bean（FactoryBean并且其FactoryBeanFactory已经实例化的）先实例化，如果此FacotryBean又依赖其他普通Bean，会导致该Bean提前启动，造成误伤（无法享受部分BeanPostProcessor的后处理，例如典型的auto-proxy）。</code></strong></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> BeanPostProcessor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jackson常用注解学习</title>
      <link href="/2019/08/22/Jackson%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/08/22/Jackson%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="Jackson常用注解学习"><a href="#Jackson常用注解学习" class="headerlink" title="Jackson常用注解学习"></a>Jackson常用注解学习</h2><h3 id="1-返回json去掉空值-JsonSerialize"><a href="#1-返回json去掉空值-JsonSerialize" class="headerlink" title="1:返回json去掉空值()(@JsonSerialize)"></a>1:返回json去掉空值()(@JsonSerialize)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonSerialize</span>(include = Inclusion.NON_NULL)</span><br></pre></td></tr></table></figure><h3 id="2-去掉指定属性-JsonIgnore"><a href="#2-去掉指定属性-JsonIgnore" class="headerlink" title="2:去掉指定属性(@JsonIgnore  )"></a>2:去掉指定属性(@JsonIgnore  )</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonIgnore</span></span><br></pre></td></tr></table></figure><h3 id="3-格式化-JsonFormat"><a href="#3-格式化-JsonFormat" class="headerlink" title="3:格式化(@JsonFormat)"></a>3:格式化(@JsonFormat)</h3><ul><li>时间格式化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonFormat</span>(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br></pre></td></tr></table></figure><p>注意时间地域差异，根据地区差异进行调整，<strong><code>timezone</code></strong>参数调整。默认中国时间使用东8区，即配置<strong><code>timezone=&quot;GMT+8&quot;</code></strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonFormat</span>(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>,timezone=<span class="string">"GMT+8"</span>)</span><br></pre></td></tr></table></figure><h3 id="4-初级"><a href="#4-初级" class="headerlink" title="4:初级"></a>4:初级</h3><h4 id="1-：属性重命名-JsonProperty"><a href="#1-：属性重命名-JsonProperty" class="headerlink" title="(1)：属性重命名(@JsonProperty)"></a>(1)：属性重命名(@JsonProperty)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonProperty</span>(<span class="string">"userName"</span>) </span><br><span class="line"><span class="keyword">public</span> String name;</span><br></pre></td></tr></table></figure><p>返回如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    <span class="attr">"userName"</span> : <span class="string">"Bob"</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不加注解返回如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"Bob"</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-：忽略属性"><a href="#2-：忽略属性" class="headerlink" title="(2)：忽略属性"></a>(2)：忽略属性</h4><h5 id="JsonIgnore：POJO忽略指定属性"><a href="#JsonIgnore：POJO忽略指定属性" class="headerlink" title="@JsonIgnore：POJO忽略指定属性"></a>@JsonIgnore：POJO忽略指定属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> value; </span><br><span class="line">  <span class="meta">@JsonIgnore</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> internalValue; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    <span class="attr">"value"</span> : <span class="number">42</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="JsonIgnoreProperties："><a href="#JsonIgnoreProperties：" class="headerlink" title="@JsonIgnoreProperties："></a>@JsonIgnoreProperties：</h5><p>实体类使用注解，用来序列化时候忽略指定的一系列属性，或者反序列化时候忽略未知属性(没有getter/setter属性)。</p><ul><li>序列化的时候，<code>@JsonIgnoreProperties({&quot;prop1&quot;, &quot;prop2&quot;})</code>，忽略列表中的属性。</li><li>反序列化的时候，<code>@JsonIgnoreProperties(ignoreUnknown=true)</code>，忽略没有get/set的属性。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonIgnoreProperties</span>(&#123; <span class="string">"extra"</span>, <span class="string">"uselessValue"</span> &#125;) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Value</span> </span>&#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> value; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    <span class="attr">"value"</span> : <span class="number">42</span>, </span><br><span class="line">    <span class="attr">"extra"</span> : <span class="string">"fluffy"</span>, </span><br><span class="line">    <span class="attr">"uselessValue"</span> : <span class="number">-13</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>忽略掉从JSON(由于在应用中没有完全匹配的POJO)中获取的所有<strong>“多余”</strong>属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonIgnoreProperties</span>(ignoreUnknown=<span class="keyword">true</span>) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PojoWithAny</span> </span>&#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> value; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-：序列化-输出-JsonSerialize"><a href="#3-：序列化-输出-JsonSerialize" class="headerlink" title="(3)：序列化(输出)(@JsonSerialize)"></a>(3)：序列化(输出)(@JsonSerialize)</h4><p>虽然运行时的类型（type）可能是’AdvancedType’（高级类型）, 但是我们确实想序列化<br> 成为’BasicType’（基础类型）; 有两种处理方式: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@JsonSerialize</span>(as=BasicType.class) </span><br><span class="line">  <span class="comment">//@JsonSerialize(typing=Typing.STATIC) </span></span><br><span class="line">  <span class="keyword">public</span> BasicType another; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-：反序列化-输入-JsonDeserialize"><a href="#4-：反序列化-输入-JsonDeserialize" class="headerlink" title="(4)：反序列化(输入)(@JsonDeserialize)"></a>(4)：反序列化(输入)(@JsonDeserialize)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueContainer</span> </span>&#123; </span><br><span class="line">  <span class="comment">// 虽然代码中使用的类型（type）是'Value', 但我们希望读取到的JSON之后得到的对象      的类型是'ValueImpl' </span></span><br><span class="line">  <span class="meta">@JsonDeserialize</span>(as=ValueImpl.class) </span><br><span class="line">  <span class="keyword">public</span> Value value;</span><br></pre></td></tr></table></figure><h4 id="5-：原始值输出-JsonRawValue"><a href="#5-：原始值输出-JsonRawValue" class="headerlink" title="(5)：原始值输出(@JsonRawValue)"></a>(5)：原始值输出(@JsonRawValue)</h4><p>作用在方法或者字段上，声明按<code>原始值</code>输出，Jackson不做任何处理。</p><p>使用场景：<code>用在String类型字段</code>，比如前端用的是JSON，数据库存储的是String类型。</p><h4 id="6-：只序列化字段的值或者方法返回值-JsonValue"><a href="#6-：只序列化字段的值或者方法返回值-JsonValue" class="headerlink" title="(6)：只序列化字段的值或者方法返回值(@JsonValue)"></a>(6)：只序列化字段的值或者方法返回值(@JsonValue)</h4><p>一个类最多使用一个@JsonValue注解。</p><h4 id="7-：-JsonInclude"><a href="#7-：-JsonInclude" class="headerlink" title="(7)：@JsonInclude"></a>(7)：@JsonInclude</h4><p>实体类/属性使用注解，用来忽略NULL属性，空的属性或者NULL的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//场景2：(有些值为NULL不想传过去，往往还得在SQL或者代码做循环判断，损耗性能)，</span></span><br><span class="line"><span class="comment">//为null的字段将不显示。</span></span><br><span class="line"><span class="meta">@JsonInclude</span>(Include.NON_NULL)</span><br><span class="line"><span class="comment">//场景1：(实体类中某些属性只在代码中有用，序列化不想带出来，浪费流量)，这里是不让person属性序列化</span></span><br><span class="line"><span class="meta">@JsonIgnoreProperties</span>(value=&#123;<span class="string">"person"</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="5：中级"><a href="#5：中级" class="headerlink" title="5：中级"></a>5：中级</h3><h4 id="1-：处理多态类型序列化和反序列化-JsonTypeInfo"><a href="#1-：处理多态类型序列化和反序列化-JsonTypeInfo" class="headerlink" title="(1)：处理多态类型序列化和反序列化(JsonTypeInfo)"></a>(1)：处理多态类型序列化和反序列化(JsonTypeInfo)</h4><p><strong><code>JsonTypeInfo</code></strong>注解使用，详细查考官方文档。</p><p>简单使用示例：按照类示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将Java类的名称（“com.myempl.ImplClass”）存储到JSON的一个名称为“class”的属性中 </span></span><br><span class="line"><span class="meta">@JsonTypeInfo</span>(use=Id.CLASS, include=As.PROPERTY,property=”<span class="class"><span class="keyword">class</span>”) </span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">abstract</span> <span class="title">class</span> <span class="title">BaseClass</span> </span>&#123; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Impl1</span> <span class="keyword">extends</span> <span class="title">BaseClass</span> </span>&#123; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> x; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Impl2</span> <span class="keyword">extends</span> <span class="title">BaseClass</span> </span>&#123; </span><br><span class="line"><span class="keyword">public</span> String name; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PojoWithTypedObjects</span> </span>&#123; </span><br><span class="line"><span class="keyword">public</span> List&lt;BaseClass&gt; items; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>json如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    “items” : </span><br><span class="line">    [ </span><br><span class="line">        &#123;“class”:”Impl2”,  “name”: “Bob”&#125;, </span><br><span class="line">        &#123;“class”:”Impl1”, :”x” : 13&#125; </span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照类型示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zoo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Animal animal;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@JsonTypeInfo</span>(</span><br><span class="line">      use = JsonTypeInfo.Id.NAME, </span><br><span class="line">      include = As.PROPERTY, </span><br><span class="line">      property = <span class="string">"type"</span>)</span><br><span class="line">    <span class="meta">@JsonSubTypes</span>(&#123;</span><br><span class="line">        <span class="meta">@JsonSubTypes</span>.Type(value = Dog.class, name = <span class="string">"dog"</span>),</span><br><span class="line">        <span class="meta">@JsonSubTypes</span>.Type(value = Cat.class, name = <span class="string">"cat"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@JsonTypeName</span>(<span class="string">"dog"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">double</span> barkVolume;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@JsonTypeName</span>(<span class="string">"cat"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> likesCream;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> lives;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenSerializingPolymorphic_thenCorrect</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    Zoo.Dog dog = <span class="keyword">new</span> Zoo.Dog(<span class="string">"lacy"</span>);</span><br><span class="line">    Zoo zoo = <span class="keyword">new</span> Zoo(dog);</span><br><span class="line"> </span><br><span class="line">    String result = <span class="keyword">new</span> ObjectMapper()</span><br><span class="line">      .writeValueAsString(zoo);</span><br><span class="line"> </span><br><span class="line">    assertThat(result, containsString(<span class="string">"type"</span>));</span><br><span class="line">    assertThat(result, containsString(<span class="string">"dog"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"animal"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"dog"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"lacy"</span>,</span><br><span class="line">        <span class="attr">"barkVolume"</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-：重新设置属性自动发现-JsonAutoDetect"><a href="#2-：重新设置属性自动发现-JsonAutoDetect" class="headerlink" title="(2)：重新设置属性自动发现(JsonAutoDetect)"></a>(2)：重新设置属性自动发现(JsonAutoDetect)</h4><p><strong>属性/实体能否被序列化/反序列化</strong></p><p>Jackson默认属性发现规则：</p><ul><li>所有被public修饰的字段（成员变量）</li><li>所有被public修饰的getter（即形如“getXxx()”的方法）</li><li>所有被public修饰的setter（即形如“setXxx(value)”的方法），不管可见或不可见</li></ul><p>发现机制属性</p><ul><li><code>fieldVisibility=JsonAutoDetect.Visibility.ANY</code>: 指自动发现所有修饰符的属性</li><li><code>fieldVisibility=JsonAutoDetect.Visibility.NONE</code>：禁止发现所有属性，但是getter/setter方法无效</li><li><code>fieldVisibility=JsonAutoDetect.Visibility.NON_PRIVATE</code>: 指自动发现除被private修饰以外的属性</li></ul><p>如果你想自动发现所有字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonAutoDetect</span>(fieldVisibility=JsonAutoDetect.Visibility.ANY) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">POJOWithFields</span> </span>&#123; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> value; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>禁用对所有字段的自动发现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonAutoDetect</span>(fieldVisibility=JsonAutoDetect.Visibility.NONE) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">POJOWithNoFields</span> </span>&#123; </span><br><span class="line"><span class="comment">//不会被序列化，除非再有一个可以访问的“getValue”方法 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> value; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON </tag>
            
            <tag> Jackson </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring AopContext 在多线程运用</title>
      <link href="/2019/08/19/Spring-AopContext-%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%90%E7%94%A8/"/>
      <url>/2019/08/19/Spring-AopContext-%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%90%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-AopContext-在多线程运用"><a href="#Spring-AopContext-在多线程运用" class="headerlink" title="Spring AopContext 在多线程运用"></a>Spring AopContext 在多线程运用</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>众所周知,<code>Spring AOP无法对同一个类中自身方法相互调用进行拦截</code>。<strong><code>由于Spring AOP是针对方法级别的和属性级别(引介增强)。所以，无法对方法的嵌套调用实现AOP的增强。</code></strong>你可以通过调用AopContext.currentProxy()来获取当前AOP增强的对象，然后进行强转成功目标对象类型，内部通过ThreadLocal静态final对象来维护当前线程的代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nestAop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        hello2();</span><br><span class="line">        System.out.println(<span class="string">"nestAop"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hello2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.ley.spring.learn.nest.aop.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">poincut</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"poincut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"enter method: &#123;&#125;"</span>, joinPoint.getSignature().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用<strong><code>AopContext.currentProxy())</code></strong>来操作。详细实现代码可以查看源码<code>CglibAopProxy</code>和<code>JdkDynamicAopProxy</code>。Spring AOP原理两个重要实现类。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nestAopHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PersonService personService = (PersonService) AopContext.currentProxy();</span><br><span class="line">    personService.hello2();</span><br><span class="line">    System.out.println(<span class="string">"nest aop handle"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>AopContext</code>实现是使用<strong><code>ThreadLocal</code></strong>来保存代理对象，那么如果想在<strong>多线程</strong>中使用该怎么办呢？Spring AOP中的<strong>AopContext类又是包级私有的静态方法,而且还是抽象类，你无法通过反射来进行操作</strong>。那么转换一种思想，通过继承的方式，先继承<code>AopContext</code>类，提供默认构造函数。那么此时，你可以通过反射来进行操作了。实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAopContext</span> <span class="keyword">extends</span> <span class="title">AopContext</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nestAop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        hello2();</span><br><span class="line">        System.out.println(<span class="string">"nestAop"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aopInThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PersonService personService = (PersonService) AopContext.currentProxy();</span><br><span class="line">        Object currentProxy = AopContext.currentProxy();</span><br><span class="line">        threadPool.submit(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 反射调用方法</span></span><br><span class="line">            Method method = ReflectionUtils.findMethod(MyAopContext.class, <span class="string">"setCurrentProxy"</span>, Object.class);</span><br><span class="line">            ReflectionUtils.makeAccessible(method);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 注意: 这儿你需要捕获异常,JUC多线程中执行失败不显示异常信息</span></span><br><span class="line">                <span class="comment">// 需要手动捕获</span></span><br><span class="line">                ReflectionUtils.invokeMethod(method, BeanUtils.instantiateClass(MyAopContext.class), currentProxy);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            personService.hello3();</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"nest in multi thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该方法是在多线程环境,需要手动捕获异常</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hello3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PersonService personService = (PersonService) AopContext.currentProxy();</span><br><span class="line">            personService.hello4();</span><br><span class="line">            System.out.println(<span class="string">"hello3"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想要捕获多线程的异常，可以使用<code>带有监听的Future-&gt;ListenableFuture</code>。其中Guava和Spring都提供了带有监听机制的Future，可以方便用来捕获多线程中的异常，方便排除。如下代码是使用Guava提供的ListenableFuture进行实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aopInThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PersonService personService = (PersonService) AopContext.currentProxy();</span><br><span class="line">    Object currentProxy = AopContext.currentProxy();</span><br><span class="line">    <span class="comment">// 使用Guava提供ListenableFuture</span></span><br><span class="line">    ListeningExecutorService service = MoreExecutors.listeningDecorator(threadPool);</span><br><span class="line">    ListenableFuture&lt;?&gt; listenableFuture = service.submit(() -&gt; &#123;</span><br><span class="line">        Method method = ReflectionUtils.findMethod(MyAopContext.class, <span class="string">"setCurrentProxy"</span>, Object.class);</span><br><span class="line">        ReflectionUtils.makeAccessible(method);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ReflectionUtils.invokeMethod(method, BeanUtils.instantiateClass(MyAopContext.class), currentProxy);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        personService.hello3();</span><br><span class="line">    &#125;);</span><br><span class="line">    Futures.addCallback(listenableFuture, <span class="keyword">new</span> FutureCallback&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(@Nullable Object o)</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">"执行成功"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">            log.error(throwable.getMessage(), throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, threadPool);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"nest in multi thread"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>详细代码请看Github：</code></strong><a href="https://github.com/crazyblitz/springboot-learn/tree/master/spring-learn/src/main/java/com/ley/spring/learn/nest/aop" target="_blank" rel="noopener">嵌套方法AOP解决以及嵌套方法AOP在多线程运用</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> AOP </tag>
            
            <tag> Spring </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Stream收集数据</title>
      <link href="/2019/08/16/%E4%BD%BF%E7%94%A8Stream%E6%94%B6%E9%9B%86%E6%95%B0%E6%8D%AE/"/>
      <url>/2019/08/16/%E4%BD%BF%E7%94%A8Stream%E6%94%B6%E9%9B%86%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="使用流收集数据"><a href="#使用流收集数据" class="headerlink" title="使用流收集数据"></a>使用流收集数据</h2><p>  终端操作<code>collect</code>方法用于收集流中的元素，并放到不同类型的结果中，比如<code>List</code>、<code>Set</code>或者<code>Map</code>。其实<code>collect</code>方法可以接受各种Collectors接口的静态方法作为参数来实现更为强大的规约操作，比如查找最大值最小值，汇总，分区和分组等等。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>为了演示Collectors接口中的静态方法使用，这里创建一个Dish类（菜谱类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dish</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Type &#123;MEAT, FISH, OTHER&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 食物名称 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="comment">/** 是否是素食 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> vegetarian;</span><br><span class="line">    <span class="comment">/** 卡路里 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories;</span><br><span class="line">    <span class="comment">/** 类型：肉，海鲜，其他 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Type type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dish</span><span class="params">(String name, <span class="keyword">boolean</span> vegetarian, <span class="keyword">int</span> calories, Type type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.vegetarian = vegetarian;</span><br><span class="line">        <span class="keyword">this</span>.calories = calories;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get,set略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建一个List，包含各种食材：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Dish&gt; list = Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> Dish(<span class="string">"pork"</span>, <span class="keyword">false</span>, <span class="number">800</span>, Dish.Type.MEAT),</span><br><span class="line">        <span class="keyword">new</span> Dish(<span class="string">"beef"</span>, <span class="keyword">false</span>, <span class="number">700</span>, Dish.Type.MEAT),</span><br><span class="line">        <span class="keyword">new</span> Dish(<span class="string">"chicken"</span>, <span class="keyword">false</span>, <span class="number">400</span>, Dish.Type.MEAT),</span><br><span class="line">        <span class="keyword">new</span> Dish(<span class="string">"french fries"</span>, <span class="keyword">true</span>, <span class="number">530</span>, Dish.Type.OTHER),</span><br><span class="line">        <span class="keyword">new</span> Dish(<span class="string">"rice"</span>, <span class="keyword">true</span>, <span class="number">350</span>, Dish.Type.OTHER),</span><br><span class="line">        <span class="keyword">new</span> Dish(<span class="string">"season fruit"</span>, <span class="keyword">true</span>, <span class="number">120</span>, Dish.Type.OTHER),</span><br><span class="line">        <span class="keyword">new</span> Dish(<span class="string">"pizza"</span>, <span class="keyword">true</span>, <span class="number">550</span>, Dish.Type.OTHER),</span><br><span class="line">        <span class="keyword">new</span> Dish(<span class="string">"prawns"</span>, <span class="keyword">false</span>, <span class="number">300</span>, Dish.Type.FISH),</span><br><span class="line">        <span class="keyword">new</span> Dish(<span class="string">"salmon"</span>, <span class="keyword">false</span>, <span class="number">450</span>, Dish.Type.FISH) );</span><br></pre></td></tr></table></figure><p>在测试类中导入所有Collectors接口的静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.*;</span><br></pre></td></tr></table></figure><h3 id="规约与汇总"><a href="#规约与汇总" class="headerlink" title="规约与汇总"></a>规约与汇总</h3><h4 id="最大最小值"><a href="#最大最小值" class="headerlink" title="最大最小值"></a>最大最小值</h4><p><code>Collectors.maxBy</code>和<code>Collectors.minBy</code>用来计算流中的最大或最小值，比如按卡路里的大小来筛选出卡路里最高的食材：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().collect(maxBy(Comparator.comparingInt(Dish::getCalories)))    .ifPresent(System.out::println);</span><br></pre></td></tr></table></figure><p>输出<code>pork</code>。</p><h4 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h4><p><code>Collectors.summingInt</code>可以用于求和，参数类型为int类型。相应的基本类型对应的方法还有<code>Collectors.summingLong</code>和<code>Collectors.summingDouble</code>。比如求所有食材的卡路里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda表达式篇二</title>
      <link href="/2019/08/16/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AF%87%E4%BA%8C/"/>
      <url>/2019/08/16/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AF%87%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="Lambda表达式篇二"><a href="#Lambda表达式篇二" class="headerlink" title="Lambda表达式篇二"></a>Lambda表达式篇二</h2><p>   Java 8已经给我们提供了一套能够描述常见函数描述符的函数式接口。比如<code>Predicate&lt;T&gt;</code>、<code>Consumer&lt;T&gt;</code>、<code>Function&lt;T,R&gt;</code>、<code>Supplier&lt;T&gt;</code>等，这些函数式接口位于<code>java.util.function</code>包。这一节主要记录这些函数式接口的应用。</p><h3 id="Java8中的函数式接口"><a href="#Java8中的函数式接口" class="headerlink" title="Java8中的函数式接口"></a>Java8中的函数式接口</h3><p>下表列出了Java8中常见的函数式接口：</p><table><thead><tr><th align="left">函数式接口</th><th align="left">函数描述符</th><th align="left">原始类型特化</th></tr></thead><tbody><tr><td align="left">Predicate(过滤)</td><td align="left">T-&gt;boolean</td><td align="left">IntPredicate,LongPredicate, DoublePredicate</td></tr><tr><td align="left">Consumer(消费者)</td><td align="left">T-&gt;void</td><td align="left">IntConsumer,LongConsumer, DoubleConsumer</td></tr><tr><td align="left">Function&lt;T,R&gt;</td><td align="left">T-&gt;R</td><td align="left">IntFunction, IntToDoubleFunction, IntToLongFunction, LongFunction, LongToDoubleFunction, LongToIntFunction, DoubleFunction, ToIntFunction, ToDoubleFunction, ToLongFunction</td></tr><tr><td align="left">Supplier(生产者)</td><td align="left">()-&gt;T</td><td align="left">BooleanSupplier,IntSupplier, LongSupplier, DoubleSupplier</td></tr><tr><td align="left">UnaryOperator</td><td align="left">T-&gt;T</td><td align="left">IntUnaryOperator, LongUnaryOperator, DoubleUnaryOperator</td></tr><tr><td align="left">BinaryOperator</td><td align="left">(T,T)-&gt;T</td><td align="left">IntBinaryOperator, LongBinaryOperator, DoubleBinaryOperator</td></tr><tr><td align="left">BiPredicate&lt;L,R&gt;</td><td align="left">(L,R)-&gt;boolean</td><td align="left"></td></tr><tr><td align="left">BiConsumer&lt;T,U&gt;</td><td align="left">(T,U)-&gt;void</td><td align="left">ObjIntConsumer, ObjLongConsumer, ObjDoubleConsumer</td></tr><tr><td align="left">BiFunction&lt;T,U,R&gt;</td><td align="left">(T,U)-&gt;R</td><td align="left">ToIntBiFunction&lt;T,U&gt;, ToLongBiFunction&lt;T,U&gt;, ToDoubleBiFunction&lt;T,U&gt;</td></tr></tbody></table><h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><p>predicate:断言。从接口的名称就可以推断出这个函数式接口的主要作用就是用于判断作用，Predicate源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">negate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">or</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">isEqual</span><span class="params">(Object targetRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">null</span> == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可看到<code>java.util.function.Predicate&lt;T&gt;</code>接口定义了一个名叫<code>test</code>的抽象方法，它接受泛型<code>T</code>对象，并返回一个<code>boolean</code>，函数描述符为<code>(T) -&gt; boolean</code>举几个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 偶数判断</span></span><br><span class="line">Predicate&lt;Integer&gt; isEven = (in) -&gt; in % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">isEven.test(<span class="number">17</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字符串的长度是否为0</span></span><br><span class="line">Predicate&lt;String&gt; isEmptyString = String::isEmpty;</span><br><span class="line">isEmptyString.test(<span class="string">""</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>除了抽象方法外，<code>java.util.function.Predicate&lt;T&gt;</code>接口还定义了三个默认方法：<code>and</code>，<code>negate</code>和<code>or</code>，对应“与”，“非”和“或”操作，这样我们便可以复合Lambda表达式了，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是偶数，并且大于30</span></span><br><span class="line">Predicate&lt;Integer&gt; isEven = (in) -&gt; in % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">isEven.and((in) -&gt; in &gt; <span class="number">30</span>).test(<span class="number">40</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 奇数判断</span></span><br><span class="line">Predicate&lt;Integer&gt; isEven = (in) -&gt; in % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">Predicate&lt;Integer&gt; isOdd = isEven.negate();</span><br><span class="line">isOdd.test(<span class="number">17</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>消费者。该函数式接口用于消费一个对象，即接收一个对象，对其执行某些操作，然后没有返回值。Consumer源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可看到<code>java.util.function.Consumer&lt;T&gt;</code>定义了一个名叫<code>accept</code>的抽象方法，它接受泛型<code>T</code>的对象，没有返回(<code>void</code>)，函数描述符为<code>(T) -&gt; void</code>。其还提供了一个默认方法<code>andThen</code>。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;Apple&gt; printAppleColor = (a)-&gt; System.out.println(a.getColor());</span><br><span class="line">printAppleColor.accept(<span class="keyword">new</span> Apple(<span class="string">"red"</span>,<span class="number">17</span>)); <span class="comment">// red</span></span><br><span class="line"></span><br><span class="line">printAppleColor.andThen((a) -&gt; System.out.println(a.getWeight())).accept(<span class="keyword">new</span> Apple(<span class="string">"red"</span>, <span class="number">17</span>)); <span class="comment">// red 17.0</span></span><br></pre></td></tr></table></figure><h3 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h3><p>供应商;供应者;供给者。其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可看到<code>java.util.function.Supplier&lt;T&gt;</code>定义了一个名叫<code>get</code>的抽象方法，它不接收参数，返回泛型<code>T</code>的对象，函数描述符为<code>() -&gt; T</code>。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Person&gt; personSupplier = Person::<span class="keyword">new</span>;</span><br><span class="line">personSupplier.get();   <span class="comment">// new Person</span></span><br></pre></td></tr></table></figure><h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><p>Functions源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;V, R&gt; <span class="title">compose</span><span class="params">(Function&lt;? <span class="keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Function&lt;T, T&gt; <span class="title">identity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>java.util.function.Function&lt;T, R&gt;</code>接口定义了一个叫作<code>apply</code>的方法，它接受一个泛型<code>T</code>的对象，并返回一个泛型<code>R</code>的对象，函数描述符为<code>(T) -&gt; R</code>。举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Apple, Double&gt; getAppleWeight = (a) -&gt; &#123;    return a.getWeight();&#125;;getAppleWeight.apply(new Apple(17)); // 17.0</span><br></pre></td></tr></table></figure><p>Functions接口还提供了两个抽象方法<code>compose</code>和<code>andThen</code>，从源码可以看出两者的根本区别。举个<code>compose</code>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Apple, Double&gt; getAppleWeight = (a) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> a.getWeight();</span><br><span class="line">&#125;;</span><br><span class="line">getAppleWeight.apply(<span class="keyword">new</span> Apple(<span class="number">17</span>)); <span class="comment">// 17.0</span></span><br></pre></td></tr></table></figure><p>过程为：<code>f(g(2))</code>，也就是<code>1+(2*2)</code>。</p><p>举个andThen的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; f = (x) -&gt; x + <span class="number">1</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; g = (x) -&gt; x * <span class="number">2</span>;</span><br><span class="line">f.compose(g).apply(<span class="number">2</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>过程为：<code>g(f(2))</code>，也就是<code>(2+1)*2</code>。</p><h3 id="原始类型特化"><a href="#原始类型特化" class="headerlink" title="原始类型特化"></a>原始类型特化</h3><p>在学习Function接口的时候，我们定义了<code>f</code>函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; f = (x) -&gt; x + 1;</span><br></pre></td></tr></table></figure><p>x的类型为Integer类型，1为int类型，返回值为Integer类型，整个过程实际上为<code>Integer.valueOf(x.intValue() + 1)</code>。虽然编译器可以自动帮我们完成拆装箱，但这会造成不必要的性能消耗。考虑到了这一点，Java8为我们提供了int类型的Function接口：IntFunction:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntFunction</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以<code>f</code>最好重构为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntFunction&lt;Integer&gt; f = (x) -&gt; x + 1;</span><br></pre></td></tr></table></figure><p>剩余的原始类型特化函数式接口可参考上面的表格。</p><h3 id="Java8中增强的Comparator"><a href="#Java8中增强的Comparator" class="headerlink" title="Java8中增强的Comparator"></a>Java8中增强的Comparator</h3><p>在Java8之前，Comparator接口用于实现简单的比较排序算法。比如有如下List：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Double&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">12.3</span>);</span><br><span class="line">list.add(<span class="number">100.2</span>);</span><br><span class="line">list.add(<span class="number">3.14</span>);</span><br><span class="line">list.add(<span class="number">27.7</span>);</span><br><span class="line">list.add(-<span class="number">9.8</span>);</span><br></pre></td></tr></table></figure><p>使用Comparator接口对其从小到大排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Double&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Double o1, Double o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Comparator接口也是一个函数式接口，函数描述符为<code>(T,T) -&gt; int</code>，Java8中可以使用Lambda改造上面的排序方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, (o1, o2) -&gt; o1.compareTo(o2));</span><br></pre></td></tr></table></figure><p>Java8对List提供了<code>sort</code>方法，可以替代<code>Collections.sort</code>，所以上面的代码可以简化为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.sort((o1, o2) -&gt; o1.compareTo(o2));</span><br></pre></td></tr></table></figure><p>使用方法的引用来进一步简化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.sort(Double::compareTo);</span><br></pre></td></tr></table></figure><p>Java8对Comparator进行了增强，加入了一些实用的默认方法，比如对排序结果反转：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Double&gt; comparator = Double::compareTo;</span><br><span class="line">list.sort(comparator.reversed());</span><br></pre></td></tr></table></figure><p>更多方法可以参考Comparator接口的JavaDoc。</p><blockquote><p>查看Comparator的时候发现其虽然是函数式接口，但是却包含了<code>compare</code>和<code>equals</code>这两个抽象方法，顿时有点懵逼，函数式接口不是只能有一个抽象方法么？查找资料后发现：函数式接口中可以额外定义多个抽象方法，但这些抽象方法签名必须和Object的public方法一样，接口最终有确定的类实现，而类的最终父类是Object。因此函数式接口可以定义Object的public方法。</p></blockquote><h3 id="转载-https-mrbird-cc-java8lambda2-html"><a href="#转载-https-mrbird-cc-java8lambda2-html" class="headerlink" title="转载:https://mrbird.cc/java8lambda2.html"></a>转载:<a href="https://mrbird.cc/java8lambda2.html" target="_blank" rel="noopener">https://mrbird.cc/java8lambda2.html</a></h3>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sql Or NoSql 选型方案及比较</title>
      <link href="/2019/08/16/Sql-Or-NoSql-%E9%80%89%E5%9E%8B%E6%96%B9%E6%A1%88%E5%8F%8A%E6%AF%94%E8%BE%83/"/>
      <url>/2019/08/16/Sql-Or-NoSql-%E9%80%89%E5%9E%8B%E6%96%B9%E6%A1%88%E5%8F%8A%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<h2 id="Sql-Or-NoSql"><a href="#Sql-Or-NoSql" class="headerlink" title="Sql Or NoSql"></a>Sql Or NoSql</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>你是否在为系统的数据库来一波大流量就几乎打满CPU，日常CPU居高不下烦恼？你是否在各种NoSql间纠结不定，到底该选用那种最好？今天的你就是昨天的我，这也是写这篇文章的初衷。</p><p>这篇文章是我好几个月来一直想写的一篇文章，也是一直想学习的一个内容，作为互联网从业人员，我们要知道关系型数据库（MySql、Oracle）无法满足我们对存储的所有要求，因此对底层存储的选型，对每种存储引擎的理解非常重要。同时也由于过去一段时间的工作经历，对这块有了一些更多的思考，想通过自己的总结把这块写出来分享给大家。</p><h3 id="结构化数据、非结构化数据与半结构化数据"><a href="#结构化数据、非结构化数据与半结构化数据" class="headerlink" title="结构化数据、非结构化数据与半结构化数据"></a>结构化数据、非结构化数据与半结构化数据</h3><p>   文章的开始，聊一下结构化数据、非结构化数据与半结构化数据，因为数据特点的不同，将在技术上直接影响存储引擎的选型。</p><p>   首先是结构化数据，根据定义<strong><code>结构化数据指的是由二维表结构来逻辑表达和实现的数据，严格遵循数据格式与长度规范，也称作为行数据</code></strong>，特点为：数据以行为单位，一行数据表示一个实体的信息，每一行数据的属性是相同的。例如：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1565679679544-1c94c526-bc37-4779-a6d6-4c37c664f275.png" alt="结构化数据.PNG"></p><p>   因此关系型数据库完美契合结构化数据的特点，关系型数据库也是关系型数据最主要的存储与管理引擎。</p><p>   非结构化数据，指的是<strong><code>数据结构不规则或不完整，没有任何预定义的数据模型，不方便用二维逻辑表来表现的数据</code></strong>，例如办公文档（Word）、文本、图片、HTML、各类报表、视频音频等。</p><p>   介于结构化与非结构化数据之间的数据就是半结构化数据了，它是结构化数据的一种形式，虽然<strong><code>不符合二维逻辑这种数据模型结构，但是包含相关标记，用来分割语义元素以及对记录和字段进行分层</code></strong>。常见的半结构化数据有<code>XML和JSON</code>，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">phone</span>&gt;</span>12345<span class="tag">&lt;/<span class="name">phone</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br></pre></td></tr></table></figure><p>   这种结构也被成为自描述的结构。</p><h2 id="以关系型数据库的方式做存储的架构演进"><a href="#以关系型数据库的方式做存储的架构演进" class="headerlink" title="以关系型数据库的方式做存储的架构演进"></a>以关系型数据库的方式做存储的架构演进</h2><p>   首先，我们看一下使用关系型数据库的方式，企业一个系统发展的几个阶段的架构演进（由于本文写的是Sql与NoSql，因此只以<strong>存储方式作为切入点</strong>，不会涉及类似MQ、ZK这些中间件内容）：</p><p>   <img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1565679960823-53ce36f9-79a9-4db3-b0ba-2d4ecba6a26a.png" alt="关系型数据库演进.PNG"></p><p>  阶段一：企业刚发展的阶段，最简单，<code>一个应用服务器配一个关系型数据库，每次读写数据库</code>。</p><p>  阶段二：无论是使用MySQL还是Oracle还是别的关系型数据库，数据库通常不会先成为性能瓶颈，通常随着企业规模的扩大，一台应用服务器扛不住上游过来的流量且一台应用服务器会产生单点故障的问题，因此<strong><code>加应用服务器并且在流量入口使用Nginx做一层负载均衡</code></strong>，保证把流量均匀打到应用服务器上。</p><p>  阶段三：随着企业规模的继续扩大，此时由于读写都在同一个数据库上，数据库性能出现一定的瓶颈，此时简单地做一层<strong><code>读写分离</code></strong>，每次写主库，读备库，主备库之间通过<code>binlog</code>同步数据，就能很大程度上解决这个阶段的数据库性能问题</p><p>  阶段四：企业发展越来越好了，业务越来越大了，做了读写分离数据库压力还是越来越大，这时候怎么办呢，一台数据库扛不住，那我们就分几台吧，做<strong><code>分库分表</code></strong>，<code>对表做垂直拆分，对库做水平拆分</code>。以扩数据库为例，扩出两台数据库，以一定的单号（例如交易单号），以一定的规则（例如取模），交易单号对2取模为0的丢到数据库1去，交易单号对2取模为1的丢到数据库2去，通过这样的方式将写数据库的流量均分到两台数据库上。一般分库分表会使用<strong>Shard</strong>的方式，通过一个中间件，便于连接管理、数据监控且客户端无需感知数据库ip。</p><h3 id="关系型数据库的优点"><a href="#关系型数据库的优点" class="headerlink" title="关系型数据库的优点"></a>关系型数据库的优点</h3><p>  上面的方式，看似可以解决问题（实际上确实也能解决很多问题），<strong><code>正常对关系型数据库做一下读写分离 + 分库分表，支撑个1W+的读写QPS还是问题不大的</code></strong>。但是受限于关系型数据库本身，这套架构方案依然有着明显的不足，下面对利用关系型数据库方式做存储的方案的优点先进行一下分析，后一部分再分析一下缺点，对某个技术的优缺点的充分理解是技术选型的前提。</p><ul><li><p><strong>易理解</strong></p><p>因为行 + 列的二维表逻辑是非常贴近逻辑世界的一个概念，关系模型相对网状、层次等其他模型更加容易被理解　</p></li><li><p><strong>操作方便</strong></p></li></ul><p>　　通用的SQL语言使得操作关系型数据库非常方便，支持join等复杂查询</p><ul><li><strong>数据一致性</strong></li></ul><p>　　支持ACID特性，可以维护数据之间的一致性，这是使用数据库非常重要的一个理由之一，例如同银行转账，张三转给李四100元钱，张三扣100元，李四加100元，而且必须同时成功或者同时失败，否则就会造成用户的资损</p><ul><li><strong>数据稳定</strong></li></ul><p>　　数据持久化到磁盘，没有丢失数据风险，支持海量数据存储</p><ul><li><strong>服务稳定</strong></li></ul><p>　　最常用的关系型数据库产品MySql、Oracle服务器性能卓越，服务稳定，通常很少出现宕机异常</p><h3 id="关系型数据库的缺点"><a href="#关系型数据库的缺点" class="headerlink" title="关系型数据库的缺点"></a>关系型数据库的缺点</h3><p>紧接着的，我们看一下关系型数据库的缺点，也是比较明显的。</p><ul><li><strong>高并发下IO压力大</strong></li></ul><p>　　数据按行存储，即使只针对其中某一列进行运算，也会将整行数据从存储设备中读入内存，导致IO较高</p><ul><li><strong>为维护索引付出的代价大</strong></li></ul><p>　　为了提供丰富的查询能力，通常热点表都会有多个二级索引，一旦有了二级索引，数据的新增必然伴随着所有二级索引的新增，数据的更新也必然伴随着所有二级索引的更新，这不可避免地降低了关系型数据库的读写能力，且索引越多读写能力越差。有机会的话可以看一下自己公司的数据库，除了数据文件不可避免地占空间外，索引占的空间其实也并不少</p><ul><li><strong>为维护数据一致性付出的代价大</strong></li></ul><p>　　数据一致性是关系型数据库的核心，但是同样为了维护数据一致性的代价也是非常大的。我们都知道SQL标准为事务定义了不同的隔离级别，<code>从低到高依次是读未提交、读已提交、可重复度、串行化，事务隔离级别越低，可能出现的并发异常越多，但是通常而言能提供的并发能力越强</code>。那么为了保证事务一致性，数据库就需要<code>提供并发控制与故障恢复</code>两种技术，前者用于减少并发异常，后者可以在系统异常的时候保证事务与数据库状态不会被破坏。对于并发控制，其核心思想就是加锁，无论是乐观锁还是悲观锁，只要提供的隔离级别越高，那么读写性能必然越差</p><ul><li><strong>水平扩展后带来的种种问题难处理</strong></li></ul><p>​    前文提过，随着企业规模扩大，一种方式是对数据库做分库，做了分库之后，数据迁移（1个库的数据按照一定规则打到2个库中）、跨库join（订单数据里有用户数据，两条数据不在同一个库中）、分布式事务处理都是需要考虑的问题，尤其是分布式事务处理，业界当前都没有特别好的解决方案</p><ul><li><strong>表结构扩展不方便</strong></li></ul><p>　　由于数据库存储的是结构化数据，因此表结构schema是固定的，扩展不方便，如果需要修改表结构，需要执行DDL（data definition language）语句修改，修改期间会导致锁表，部分服务不可用</p><ul><li><strong>全文搜索功能弱</strong></li></ul><p>　　例如like “%中国真伟大%”，只能搜索到”2019年中国真伟大，爱祖国”，无法搜索到”中国真是太伟大了”这样的文本，即不具备分词能力，且like查询在”%中国真伟大”这样的搜索条件下，无法命中索引，将会导致查询效率大大降低。</p><p>   写了这么多，我的理解核心还是前三点，它反映出的一个问题是<strong>关系型数据库在高并发下的能力是有瓶颈的</strong>，尤其是写入/更新频繁的情况下，出现瓶颈的结果就是<code>数据库CPU高、Sql执行慢、客户端报数据库连接池不够等错误</code>，因此例如万人秒杀这种场景，我们绝对不可能通过数据库直接去扣减库存。</p><p>  可能有朋友说，数据库在高并发下的能力有瓶颈，我公司有钱，加CPU、换固态硬盘、继续买服务器加数据库做分库不就好了，问题是这是一种性价比非常低的方式，花1000万达到的效果，换其他方式可能100万就达到了，<strong>不考虑人员、服务器投入产出比的Leader就是个不合格的Leader，且关系型数据库的方式，受限于它本身的特点，可能花了钱都未必能达到想要的效果</strong>。至于什么是花100万就能达到花1000万效果的方式呢？可以继续往下看，这就是我们要说的NoSql。</p><h3 id="结合NoSql的方式做存储的架构演进"><a href="#结合NoSql的方式做存储的架构演进" class="headerlink" title="结合NoSql的方式做存储的架构演进"></a>结合NoSql的方式做存储的架构演进</h3><p>   像上文分析的，数据库作为一种关系型数据的存储引擎，存储的是关系型数据，它有优点，同时也有明显的缺点，因此通常在企业规模不断扩大的情况下，不会一味指望通过增强数据库的能力来解决数据存储问题，而是会引入其他存储，也就是我们说的NoSql。</p><p>   NoSql的全称为Not Only SQL，泛指非关系型数据库，是对关系型数据库的一种<strong>补充</strong>，特别注意补充这两个字，<strong>这意味着NoSql与关系型数据库并不是对立关系，二者各有优劣，取长补短，在合适的场景下选择合适的存储引擎才是正确的做法。</strong></p><p>   比较简单的NoSql就是缓存：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1565681417354-91a60881-f34e-44cc-8136-f47735a3458c.png" alt="NoSQL缓存.PNG"></p><p>   针对那些读远多于写的数据，引入一层缓存，每次读从缓存中读取，缓存中读取不到，再去数据库中取，取完之后再写入到缓存，对数据做好失效机制通常就没有大问题了。<strong><code>通常来说，缓存是性能优化的第一选择也是见效最明显的方案。</code></strong></p><p>   但是，<strong><code>缓存通常都是KV型存储且容量有限（基于内存）</code></strong>，无法解决所有问题，于是再进一步的优化，我们继续引入其他NoSql：</p><p>  <img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1565681610068-07501fe4-00a4-4aac-8a38-5fc0136b24a9.png" alt="其他NoSQL.PNG"></p><p>   数据库、缓存与其他NoSql并行工作，充分发挥每种NoSql的特点。当然NoSql在性能方面大大优于关系挺数据库的同时，往往也伴随着一些特性的缺失，比较常见的就是事务功能的缺失。 </p><p>   下面看一下常用的NoSql及他们的代表产品，并对每种NoSql的优缺点和适用场景做一下分析，便于熟悉每种NoSql的特点，方便技术选型。</p><h3 id="KV型NoSql（代表—-Redis）"><a href="#KV型NoSql（代表—-Redis）" class="headerlink" title="KV型NoSql（代表—-Redis）"></a>KV型NoSql（代表—-Redis）</h3><p>   KV型NoSql顾名思义就是以键值对形式存储的非关系型数据库，是最简单、最容易理解也是大家最熟悉的一种NoSql，因此比较快地带过。Redis、MemCache是其中的代表，Redis又是KV型NoSql中应用最广泛的NoSql，KV型数据库以Redis为例，<strong><code>最大的优点我总结下来就两点：</code></strong></p><ul><li><p>数据基于内存，读写效率高</p></li><li><p>K/V型数据，时间复杂度为O(1)，查询速度快</p><p>因此，KV型NoSql最大的优点就是<strong><code>高性能</code></strong>，利用Redis自带的BenchMark做基准测试，TPS可达到10万的级别，性能非常强劲。同样的Redis也有所有KV型NoSql都有的比较明显的缺点：</p></li><li><p>只能根据K查V，无法根据V查K</p></li><li><p>查询方式单一，只有KV的方式，不支持条件查询，多条件查询唯一的做法就是数据冗余，但这会极大的浪费存储空间。</p></li><li><p>内存是有限的，无法支持海量数据存储</p></li><li><p>同样的，由于KV型NoSql的存储是基于内存的，会有丢失数据的风险</p></li></ul><p>综上所述，KV型NoSql最合适的场景就是<strong>缓存</strong>的场景：</p><ul><li><p>读远多于写</p></li><li><p>读取能力强</p></li><li><p>没有持久化的需求，可以容忍数据丢失，反正丢了再查询一把写入就是了</p><p>例如根据用户id查询用户信息，每次根据用户id去缓存中查询一把，查到数据直接返回，查不到去关系型数据库里面根据id查询一把数据写到缓存中去。</p></li></ul><h3 id="搜索型NoSql（代表—-ElasticSearch）"><a href="#搜索型NoSql（代表—-ElasticSearch）" class="headerlink" title="搜索型NoSql（代表—-ElasticSearch）"></a>搜索型NoSql（代表—-ElasticSearch）</h3><p>  传统关系型数据库主要通过索引来达到快速查询的目的，但是在全文搜索的场景下，索引是无能为力的，like查询一来无法满足所有模糊匹配需求，二来使用限制太大且使用不当容易造成慢查询，<strong><code>搜索型NoSql的诞生正是为了解决关系型数据库全文搜索能力较弱的问题</code></strong>，ElasticSearch是搜索型NoSql的代表产品。</p><p>  全文搜索的原理是<strong><code>倒排索引</code></strong>，我们看一下什么是倒排索引。要说倒排索引我们先看下什么是正排索引，传统的正排索引是<strong>文档–&gt;关键字</strong>的映射，例如”Tom is my friend”这句话，会将其切分为”Tom”、”is”、”my”、”friend”四个单词，在搜索的时候对文档进行扫描，符合条件的查出来。这种方式原理非常简单，但是由于其检索效率太低，基本没什么实用价值。</p><p>倒排索引则完全相反，它是<strong>关键字–&gt;文档</strong>的映射，我用张表格展示一下就比较清楚了：</p><p>  <img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1565682157714-30a0d3db-0636-4e19-9f2d-8dc0f12c5fa8.png" alt="倒排索引.PNG"></p><p>  意思是我现在这里有”Tom is Tom”、”Tom is my friend”、”Thank you, Betty”、”Tom is Betty’s husband”四句话，搜索引擎会根据一定的切分规则将这句话切成N个关键字，并以关键字的维度维护关键字在每个文本中的出现次数。这样下次搜索”Tom”的时候，由于Tom这个词语在”Tom is Tom”、”Tom is my friend”、”Tom is Betty’s husband”三句话中都有出现，因此这三条记录都会被检索出来，且由于”Tom is Tom”这句话中”Tom”出现了2次，因此这条记录对”Tom”这个单词的匹配度最高，最先展示。这就是搜索引擎倒排索引的基本原理，假设某个关键字在某个文档中出现，那么倒排索引中有两部分内容：</p><ul><li><p>文档ID</p></li><li><p>在该文档中出现的位置情况</p><p> 可以举一反三，我们搜索”Betty Tom”这两个词语也是一样，搜索引擎将”Betty Tom”切分为”Tom”、”Betty”两个单词，根据开发者指定的满足率，比如满足率=50%，那么只要记录中出现了两个单词之一的记录都会被检索出来，再按照匹配度进行展示。</p><p> <strong>搜索型NoSql以ElasticSearch为例，它的优点为：</strong></p></li><li><p>支持分词场景、全文搜索，这是区别于关系型数据库最大特点</p></li><li><p>支持条件查询，支持聚合操作，类似关系型数据库的Group By，但是功能更加强大，适合做数据分析</p></li><li><p>数据写文件无丢失风险，在集群环境下可以方便横向扩展，可承载PB级别的数据</p></li><li><p>高可用，自动发现新的或者失败的节点，重组和重新平衡数据，确保数据是安全和可访问的。</p></li></ul><p>同样，ElasticSearch也有比较明显的缺点：</p><ul><li><p>性能全靠内存来顶，也是使用的时候最需要注意的点，非常吃硬件资源、吃内存，大数据量下64G + SSD基本是标配，算得上是数据库中的爱马仕了。为什么要专门提一下内存呢，因为内存这个东西是很值钱的，相同的配置多一倍内存，一个月差不多就要多花几百块钱，至于ElasticSearch内存用在什么地方，大概有如下这些：</p></li><li><ul><li>Indexing Buffer—-ElasticSearch基于Luence，Lucene的倒排索引是先在内存里生成，然后定期以Segment File的方式刷磁盘的，每个Segment File实际就是一个完整的倒排索引</li><li>Segment Memory—-倒排索引前面说过是基于关键字的，Lucene在4.0后会将所有关键字以FST这种数据结构的方式将所有关键字在启动的时候全量加载到内存，加快查询速度，官方建议至少留系统一半内存给Lucene</li><li>各类缓存—-Filter Cache、Field Cache、Indexing Cache等，用于提升查询分析性能，例如Filter Cache用于缓存使用过的Filter的结果集</li><li>Cluter State Buffer—-ElasticSearch被设计为每个Node都可以响应用户请求，因此每个Node的内存中都包含有一份集群状态的拷贝，一个规模很大的集群这个状态信息可能会非常大</li></ul></li><li><p>读写之间有延迟，写入的数据差不多1s样子会被读取到，这也正常，写入的时候自动加入这么多索引肯定影响性能</p></li><li><p>数据结构灵活性不高，ElasticSearch这个东西，字段一旦建立就没法修改类型了，假如建立的数据表某个字段没有加全文索引，想加上，那么只能把整个表删了再重建</p><p>因此，搜索型NoSql最适用的场景就是<strong>有条件搜索尤其是全文搜索的场景</strong>，作为关系型数据库的一种替代方案。</p></li></ul><p>另外，搜索型数据库还有一种特别重要的应用场景。我们可以想，一旦对数据库做了分库分表后，原来可以在单表中做的聚合操作、统计操作是否通通失效？例如我把订单表分16个库，1024张表，那么订单数据就散落在1024张表中，我想要统计昨天浙江省单笔成交金额最高的订单是哪笔如何做？我想要把昨天的所有订单按照时间排序分页展示如何做？<strong>这就是文档型NoSql的另一大作用了，我们可以把分表之后的数据统一打在文档型NoSql中，利用文档型NoSql的搜索与聚合能力完成对全量数据的查询</strong>。</p><p>至于为什么把它放在KV型NoSql后面作为第二个写呢，因为通常搜索型NoSql也会作为一层前置缓存，来对关系型数据库进行保护。</p><h3 id="列式NoSql（代表—-HBase）"><a href="#列式NoSql（代表—-HBase）" class="headerlink" title="列式NoSql（代表—-HBase）"></a>列式NoSql（代表—-HBase）</h3><p>  列式NoSql，大数据时代最具代表性的技术之一了，以HBase为代表。</p><p>  列式NoSql是基于列式存储的，那么什么是列式存储呢，列式Sql和关系型数据库一样都有主键的概念，区别在于关系型数据库是按照行组织的数据：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1565685245588-c1b4c438-9c3a-4bf4-9268-1526ccb51408.png" alt="关系型数据库样例.PNG"></p><p>  看到每行有name、phone、address三个字段，这是行式存储的方式，且可以观察id = 2的这条数据，<strong>即使phone字段没有，它也是占空间的。数据库会根据创建表的字段类型预分配空间。</strong></p><p>  列式存储完全是另一种方式，它是按每一列进行组织的数据：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1565690989795-ef912061-e290-4c31-8ca1-ed6608a8ee6a.png" alt="列式存储.PNG"></p><p>这么做有什么好处呢？大致有以下几点：</p><ul><li>查询时只有指定的列会被读取，不会读取所有列</li><li>存储上节约空间，Null值不会被存储，一列中有时候会有很多重复数据（尤其是枚举数据，性别、状态等），这类数据可压缩，<strong>行式数据库压缩率通常在3:1<del>5:1之间，列式数据库的压缩率一般在8:1</del>30:1左右。</strong></li><li>列数据被组织到一起，一次磁盘IO可以将一列数据一次性读取到内存中</li></ul><p>第二点说到了数据压缩，什么意思呢，以比较常见的字典表压缩方式举例：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1565691934205-a4c06727-f06b-4e58-a23c-08210386b554.png" alt="字典表压缩方式.PNG"></p><p>  接着继续讲讲优缺点，列式NoSql，以HBase为代表的，优点为：</p><ul><li>海量数据无限存储，PB级别数据随便存，底层基于HDFS（Hadoop文件系统），数据持久化</li><li>读写性能好，只要没有滥用造成数据热点，读写基本随便玩</li><li>横向扩展在关系型数据库及非关系型数据库中都是最方便的之一，只需要添加新机器就可以实现数据容量的线性增长，且可用在廉价服务器上，节省成本</li><li>本身没有单点故障，可用性高</li><li>可存储结构化或者半结构化的数据</li><li>列数理论上无限，HBase本身只对列族数量有要求，建议1~3个</li></ul><p>说了这么多HBase的优点，又到了说HBase缺点的时候了：</p><ul><li>HBase是Hadoop生态的一部分，因此它本身是一款比较重的产品，依赖很多Hadoop组件，数据规模不大没必要用，运维还是有点复杂的</li><li>KV式，不支持条件查询，或者说条件查询非常非常弱吧，HBase在Scan扫描一批数据的情况下还是提供了前缀匹配这种API的，条件查询除非定义多个RowKey做数据冗余</li><li>不支持分页查询，因为统计不了数据总数</li></ul><p>因此<strong>HBase比较适用于那种KV型的且未来无法预估数据增长量的场景</strong>，另外HBase使用还是需要一定的经验，主要体现在RowKey的设计上。</p><h3 id="文档型NoSql（代表—-MongoDB）"><a href="#文档型NoSql（代表—-MongoDB）" class="headerlink" title="文档型NoSql（代表—-MongoDB）"></a>文档型NoSql（代表—-MongoDB）</h3><p>坦白讲，根据我的工作经历，文档型NoSql我只有比较浅的使用经验，因此这部分只能结合之前的使用与网上的文章大致给大家介绍一下。</p><p>什么是文档型NoSql呢，文档型NoSql指的是将半结构化数据存储为文档的一种NoSql，文档型NoSql通常以JSON或者XML格式存储数据，因此文档型NoSql是没有Schema的，由于没有Schema的特性，我们可以随意地存储与读取数据，因此文档型NoSql的出现是<strong>解决关系型数据库表结构扩展不方便的问题的</strong>。</p><p>MongoDB是文档型NoSql的代表产品，同时也是所有NoSql产品中的明星产品之一，因此这里以MongoDB为例。按我的理解，作为文档型NoSql，MongoDB是一款完全和关系型数据库对标的产品，就我们从存储上来看：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1565752949259-06d9bce3-b485-46a8-b85f-2a276f3675b3.png" alt="文档型数据库.PNG"></p><p>看到，关系型数据库是按部就班地每个字段一列存，在MongDB里面就是一个JSON字符串存储。关系型数据可以为name、phone建立索引，MongoDB使用createIndex命令一样可以为列建立索引，建立索引之后可以大大提升查询效率。其他方面而言，就大的基本概念，二者之间基本也是类似的：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1565753085583-0b65879b-936c-44e3-bf51-9a67f95b135e.png" alt="关系型数据库和文档数据库对比.PNG"></p><p>因此，对于MongDB，我们只要理解成一个Free-Schema的关系型数据库就完事了，它的优缺点比较一目了然，优点：</p><ul><li>没有预定义的字段，扩展字段容易</li><li>相较于关系型数据库，读写性能优越，命中二级索引的查询不会比关系型数据库慢，对于非索引字段的查询则是全面胜出</li></ul><p>缺点在于：</p><ul><li>不支持事务操作，虽然Mongodb4.0之后宣称支持事务，但是效果待观测</li><li>多表之间的关联查询不支持（虽然有嵌入文档的方式），join查询还是需要多次操作</li><li>空间占用较大，这个是MongDB的设计问题，空间预分配机制 + 删除数据后空间不释放，只有用db.repairDatabase()去修复才能释放</li><li>目前没发现MongoDB有关系型数据库例如MySql的Navicat这种成熟的运维工具</li></ul><p><strong>总而言之，MongDB的使用场景很大程度上可以对标关系型数据库，但是**</strong>比较适合处理那些没有join、没有强一致性要求且表Schema会常变化的数据<strong>**。</strong></p><h3 id="总结：数据库与NoSql及各种NoSql间的对比"><a href="#总结：数据库与NoSql及各种NoSql间的对比" class="headerlink" title="总结：数据库与NoSql及各种NoSql间的对比"></a>总结：数据库与NoSql及各种NoSql间的对比</h3><p>最后一部分，做一个总结，本文归根到底是两个话题：</p><ul><li>何时选用关系型数据库，何时选用非关系型数据库</li><li>选用非关系型数据库，使用哪种非关系型数据库</li></ul><p>首先是第一个话题，关系型数据库与非关系型数据库的选择，在我理解里面无非就是两点考虑：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1565753171973-b1365f3c-8479-4c88-a36e-4313fb73c5ce.png" alt="Sql和各种NoSql比较.PNG"></p><p>第一点，不多解释应该都理解，<strong>非关系型数据库都是通过牺牲了ACID特性来获取更高的性能的</strong>，假设两张表之间有比较强的一致性需求，那么这类数据是不适合放在非关系型数据库中的。</p><p>第二点，<strong>核心数据不走非关系型数据库</strong>，例如用户表、订单表，但是这有一个前提，就是这一类核心数据会有多种查询模式，例如用户表有ABCD四个字段，可能根据AB查，可能根据AC查，可能根据D查，假设核心数据，但是就是个KV形式，比如用户的聊天记录，那么HBase一存就完事了。</p><p><strong>这几年的工作经验来看，非核心数据尤其是日志、流水一类中间数据千万不要写在关系型数据库中，这一类数据通常有两个特点：</strong></p><ul><li><strong>写远高于读</strong></li><li><strong>写入量巨大</strong></li></ul><p>一旦使用关系型数据库作为存储引擎，将大大降低关系型数据库的能力，<strong>正常读写QPS(**</strong>每秒查询率<strong>**)</strong>不高的核心服务会受这一类数据读写的拖累。</p><p>接着是第二个问题，如果我们使用非关系型数据库作为存储引擎，那么如何选型？其实上面的文章基本都写了，这里只是做一个总结（所有的缺点都不会体现事务这个点，因为这是所有NoSql相比关系型数据库共有的一个问题）</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1565753499953-18dbfd9d-ac04-45d9-9b84-bfa5a9072c12.png" alt="Sql和NoSql选型对比总结.PNG"></p><p>但是这里特别说明，<strong>选型一定要结合实际情况而不是照本宣科</strong>，比如：</p><ul><li>企业发展之初，明明一个关系型数据库就能搞定且支撑一年的架构，搞一套大而全的技术方案出来</li><li>有一些数据条件查询多，更适合使用ElasticSearch做存储降低关系型数据库压力，但是公司成本有限，这种情况下这类数据可以尝试继续使用关系型数据库做存储</li><li>有一类数据格式简单，就是个KV类型且增长量大，但是公司没有HBase这方面的人才，运维上可能会有一定难度，出于实际情况考虑，可先用关系型数据库顶一阵子</li></ul><p>所以，如果不考虑实际情况，虽然合适有些存储引擎更加合适，但是强行使用反而适得其反，总而言之，适合自己的才是最好的。</p><h3 id="转载-五月的仓颉-Sql-Or-NoSql"><a href="#转载-五月的仓颉-Sql-Or-NoSql" class="headerlink" title="转载: 五月的仓颉:Sql Or NoSql"></a>转载:<a href="https://mp.weixin.qq.com/s/pjQeyb7dHm0YC2hQVffvFw" target="_blank" rel="noopener"> 五月的仓颉:Sql Or NoSql</a></h3>]]></content>
      
      
      <categories>
          
          <category> 架构方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sql </tag>
            
            <tag> NoSql </tag>
            
            <tag> 架构方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis使用接口访问数据库原理</title>
      <link href="/2019/08/16/Mybatis%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/"/>
      <url>/2019/08/16/Mybatis%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Mybatis使用接口访问数据库原理"><a href="#Mybatis使用接口访问数据库原理" class="headerlink" title="Mybatis使用接口访问数据库原理"></a>Mybatis使用接口访问数据库原理</h2><h3 id="相关类"><a href="#相关类" class="headerlink" title="相关类:"></a>相关类:</h3><ul><li><p><code>MapperProxyFactory</code></p></li><li><p><code>MapperProxy</code></p></li><li><p><code>MapperMethod</code></p><p>最终委托给了SqlSession,通过sqlStatement进行匹配方法,这里的<code>statement等于接口的全类限定名+方法名</code>,也就<code>意味着Mybatis的dao接口</code>,不要出现相同的方法签名。而Mybatis存储访问数据库的一个<strong>MappedStatement(很重要,存储SQL,输入参数,输出参数等等)</strong>是使用<code>StrictMap</code>结构存储,该类继承了HashMap,在内部重写了put()方法,限定了dao接口不能出现相同的方法签名,该类是org.apache.ibatis.session.Configuration的静态内部类。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// MapperMethod的执行查询的主要方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperMethod</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlCommand command;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MethodSignature method;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperMethod</span><span class="params">(Class&lt;?&gt; mapperInterface, Method method, Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.command = <span class="keyword">new</span> SqlCommand(config, mapperInterface, method);</span><br><span class="line">    <span class="keyword">this</span>.method = <span class="keyword">new</span> MethodSignature(config, mapperInterface, method);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">switch</span> (command.getType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> INSERT: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        <span class="comment">// 取出MappedStatement的id,即dao的接口全限定名+方法名</span></span><br><span class="line">        result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> UPDATE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> DELETE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> SELECT:</span><br><span class="line">        <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">          executeWithResultHandler(sqlSession, args);</span><br><span class="line">          result = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">          result = executeForMany(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">          result = executeForMap(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</span><br><span class="line">          result = executeForCursor(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">          result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">          <span class="keyword">if</span> (method.returnsOptional()</span><br><span class="line">              &amp;&amp; (result == <span class="keyword">null</span> || !method.getReturnType().equals(result.getClass()))) &#123;</span><br><span class="line">            result = Optional.ofNullable(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FLUSH:</span><br><span class="line">        result = sqlSession.flushStatements();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Unknown execution method for: "</span> + command.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Mapper method '"</span> + command.getName()</span><br><span class="line">          + <span class="string">" attempted to return null from a method with a primitive return type ("</span> + method.getReturnType() + <span class="string">")."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// MapperProxy,生成Mapper类的代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6424540398559729838L</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSession;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperProxy</span><span class="params">(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sqlSession = sqlSession;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">    <span class="keyword">this</span>.methodCache = methodCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> MapperMethod <span class="title">cachedMapperMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> methodCache.computeIfAbsent(method, k -&gt; <span class="keyword">new</span> MapperMethod(mapperInterface, method, sqlSession.getConfiguration()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MapperProxyFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxyFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperProxyFactory</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getMapperInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;Method, MapperMethod&gt; <span class="title">getMethodCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> methodCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关流程"><a href="#相关流程" class="headerlink" title="相关流程:"></a>相关流程:</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1565684597952-b2fda8f4-1651-438b-b8db-5db8374e7281.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1565684748523-e96b9043-ff1c-4190-b236-1251320462ce.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1565684753852-e49e88bb-5d1d-4833-a26d-83ff51709f34.png" alt="img"></p><h3 id="设计模式使用"><a href="#设计模式使用" class="headerlink" title="设计模式使用"></a>设计模式使用</h3><ul><li><code>代理模式(Jdk代理)</code></li><li><code>命令模式</code></li><li><code>委托模式</code></li></ul><h3 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h3><ul><li><code>你无法通过反射的方式来调用接口的方法。</code></li><li>你需要使用SqlSession来进行一次数据库查询或者更新。利用<strong>MappedStatement的id属性,即接口的全类限定名+方法名。这样可以写出通用的Mybatis程序。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
            <tag> 代理模式 </tag>
            
            <tag> 命令模式 </tag>
            
            <tag> Jdk代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8 Stream学习</title>
      <link href="/2019/08/15/Java8-Stream%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/08/15/Java8-Stream%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="Java8-Stream学习"><a href="#Java8-Stream学习" class="headerlink" title="Java8 Stream学习"></a>Java8 Stream学习</h2><p>   Java 8 中的 Stream 俗称为流，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。Stream 用于<code>对集合对象进行各种非常便利、高效的聚合操作，或者大批量数据操作</code>。Stream API 借助于Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势。通过下面的例子我们可以初步体会到使用 Stream 处理集合的便利性。</p><h3 id="初探Stream"><a href="#初探Stream" class="headerlink" title="初探Stream"></a>初探Stream</h3><p>有如下一个List，现要从中筛选出以<code>J</code>开头的元素，然后转换为大写，最后输出结果。Java 8之前我们是这样做的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"Java"</span>, <span class="string">"JavaScript"</span>, <span class="string">"python"</span>, <span class="string">"PHP"</span>, <span class="string">"C#"</span>, <span class="string">"Golang"</span>, <span class="string">"Swift"</span>);</span><br><span class="line">List&lt;String&gt; filterList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str.startsWith(<span class="string">"J"</span>)) &#123;</span><br><span class="line">        filterList.add(str.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String str : filterList) &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了筛选集合我们进行了两次外部迭代，并且还创建了一个用来临时存放筛选元素的集合对象。借助Java 8中的Stream我们可以极大的简化这个处理过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"Java"</span>, <span class="string">"JavaScript"</span>, <span class="string">"python"</span>, <span class="string">"PHP"</span>, <span class="string">"C#"</span>, <span class="string">"Golang"</span>, <span class="string">"Swift"</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .filter(s -&gt; s.startsWith(<span class="string">"J"</span>))</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p> 上面的例子中，集合使用<code>stream</code>方法创建了一个流，然后使用<code>filter</code>和<code>map</code>方法来处理这个集合，它们统称为<strong>中间操作</strong>。中间操作都会返回另一个流，以便于将各种对集合的操作连接起来形成一条流水线。最后我们使用了<code>forEach</code>方法迭代筛选结果，这种位于流的末端，对流进行处理并且生成结果的方法称为<strong>终端操作</strong>。</p><p>总而言之，流的使用一般包括三件事情：</p><ol><li>一个<strong>数据源</strong>（如集合）来执行一个查询；</li><li>一个<strong>中间操作</strong>链，形成一条流的流水线；</li><li>一个<strong>终端操作</strong>，执行流水线，并能生成结果。</li></ol><p>下表列出了流中常见的中间操作和终端操作：</p><table><thead><tr><th align="left"></th><th align="left"></th><th align="left"></th><th align="left"></th><th align="left"></th></tr></thead><tbody><tr><td align="left">操作</td><td align="left">类型</td><td align="left">返回类型</td><td align="left">使用的类型/函数式接口</td><td align="left">函数描述符</td></tr><tr><td align="left">filter</td><td align="left">中间</td><td align="left"><code>Stream&lt;T&gt;</code></td><td align="left"><code>Predicate&lt;T&gt;</code></td><td align="left"><code>T -&gt; boolean</code></td></tr><tr><td align="left">distinct</td><td align="left">中间</td><td align="left"><code>Stream&lt;T&gt;</code></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">skip</td><td align="left">中间</td><td align="left"><code>Stream&lt;T&gt;</code></td><td align="left"><code>long</code></td><td align="left"></td></tr><tr><td align="left">limit</td><td align="left">中间</td><td align="left"><code>Stream&lt;T&gt;</code></td><td align="left"><code>long</code></td><td align="left"></td></tr><tr><td align="left">map</td><td align="left">中间</td><td align="left"><code>Stream&lt;R&gt;</code></td><td align="left"><code>Function&lt;T, R&gt;</code></td><td align="left"><code>T -&gt; R</code></td></tr><tr><td align="left">flatMap</td><td align="left">中间</td><td align="left"><code>Stream&lt;R&gt;</code></td><td align="left"><code>Function&lt;T, Stream&lt;R&gt;&gt;</code></td><td align="left"><code>T -&gt; Stream&lt;R&gt;</code></td></tr><tr><td align="left">sorted</td><td align="left">中间</td><td align="left"><code>Stream&lt;T&gt;</code></td><td align="left"><code>Comparator&lt;T&gt;</code></td><td align="left"><code>(T, T) -&gt; int</code></td></tr><tr><td align="left">anyMatch</td><td align="left">终端</td><td align="left"><code>boolean</code></td><td align="left"><code>Predicate&lt;T&gt;</code></td><td align="left"><code>T -&gt; boolean</code></td></tr><tr><td align="left">noneMatch</td><td align="left">终端</td><td align="left"><code>boolean</code></td><td align="left"><code>Predicate&lt;T&gt;</code></td><td align="left"><code>T -&gt; boolean</code></td></tr><tr><td align="left">allMatch</td><td align="left">终端</td><td align="left"><code>boolean</code></td><td align="left"><code>Predicate&lt;T&gt;</code></td><td align="left"><code>T -&gt; boolean</code></td></tr><tr><td align="left">findAny</td><td align="left">终端</td><td align="left"><code>Optional&lt;T&gt;</code></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">findFirst</td><td align="left">终端</td><td align="left"><code>Optional&lt;T&gt;</code></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">forEach</td><td align="left">终端</td><td align="left"><code>void</code></td><td align="left"><code>Consumer&lt;T&gt;</code></td><td align="left"><code>T -&gt; void</code></td></tr><tr><td align="left">collect</td><td align="left">终端</td><td align="left"><code>R</code></td><td align="left"><code>Collector&lt;T, A, R&gt;</code></td><td align="left"></td></tr><tr><td align="left">reduce</td><td align="left">终端</td><td align="left"><code>Optional&lt;T&gt;</code></td><td align="left"><code>BinaryOperator&lt;T&gt;</code></td><td align="left"><code>(T, T) -&gt; T</code></td></tr><tr><td align="left">count</td><td align="left">终端</td><td align="left"><code>long</code></td><td align="left"></td><td align="left"></td></tr></tbody></table><p>下面详细介绍这些操作的使用。除了特殊说明，默认使用下面这个集合作为演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"Java"</span>, <span class="string">"JavaScript"</span>, <span class="string">"python"</span>, <span class="string">"PHP"</span>, <span class="string">"C#"</span>, <span class="string">"Golang"</span>, <span class="string">"Swift"</span>, <span class="string">"C++"</span>, <span class="string">"Ruby"</span>);</span><br></pre></td></tr></table></figure><h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>Streams接口支持·<code>filter</code>方法，该方法接收一个<code>Predicate&lt;T&gt;</code>，函数描述符为<code>T -&gt; boolean</code>，用于对集合进行筛选，返回所有满足的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().filter(s -&gt; s.contains(<span class="string">"#"</span>))    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>结果输出<code>C#</code>。</p><h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h4><p><code>distinct</code>方法用于<code>排除流中重复的元素</code>，类似于SQL中的distinct操作。比如筛选中集合中所有的偶数，并排除重复的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">numbers.stream()</span><br><span class="line">       .filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">       .distinct()</span><br><span class="line">       .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>结果输出<code>2 4</code>。</p><h4 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h4><p><code>skip(n)</code>方法用于跳过流中的前n个元素，如果集合元素小于n，则返回空流。比如筛选出以<code>J</code>开头的元素，并排除第一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .filter(s -&gt; s.startsWith(<span class="string">"J"</span>))</span><br><span class="line">    .skip(<span class="number">1</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>结果输出<code>JavaScript</code>。</p><h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p><code>limit(n)</code>方法返回一个长度不超过n的流，比如下面的例子将输出<code>Java JavaScript python</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .limit(<span class="number">3</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p><code>map</code>方法接收一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .map(String::length)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>结果输出<code>4 10 6 3 2 6 5 3 4</code>。</p><p><code>map</code>还支持将流特化为指定原始类型的流，如通过<code>mapToInt</code>，<code>mapToDouble</code>和<code>mapToLong</code>方法，可以将流转换为<code>IntStream</code>，<code>DoubleStream</code>和<code>LongStream</code>。特化后的流支持<code>sum</code>，<code>min</code>和<code>max</code>方法来对流中的元素进行计算。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">IntStream intStream = numbers.stream().mapToInt(a -&gt; a);</span><br><span class="line">System.out.println(intStream.sum()); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure><p>也可以通过下面的方法，将<code>IntStream</code>转换为<code>Stream</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; s = intStream.boxed();</span><br></pre></td></tr></table></figure><h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h4><p><code>flatMap</code>用于将多个流合并成一个流，俗称流的扁平化。这么说有点抽象，举个例子，比如现在需要将list中的各个元素拆分为一个个字母，并过滤掉重复的结果，你可能会这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">   .map(s -&gt; s.split(<span class="string">""</span>))</span><br><span class="line">   .distinct()</span><br><span class="line">   .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Ljava.lang.String;<span class="meta">@e</span>9e54c2</span><br><span class="line">[Ljava.lang.String;@<span class="number">65</span>ab7765</span><br><span class="line">[Ljava.lang.String;@<span class="number">1</span>b28cdfa</span><br><span class="line">[Ljava.lang.String;<span class="meta">@eed</span>1f14</span><br><span class="line">[Ljava.lang.String;@<span class="number">7229724f</span></span><br><span class="line">[Ljava.lang.String;@<span class="number">4</span>c873330</span><br><span class="line">[Ljava.lang.String;@<span class="number">119</span>d7047</span><br><span class="line">[Ljava.lang.String;@<span class="number">776</span>ec8df</span><br><span class="line">[Ljava.lang.String;@<span class="number">4</span>eec7777</span><br></pre></td></tr></table></figure><p>这明显不符合我们的预期。实际上在<code>map(s -&gt; s.split(&quot;&quot;))</code>操作后，返回了一个<code>Stream&lt;String[]&gt;</code>类型的流，所以输出结果为每个数组对象的句柄，而我们真正想要的结果是<code>Stream&lt;String&gt;</code>。在Stream中，可以使用<code>Arrays.stream()</code>方法来将数组转换为流，改造上面的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .map(s -&gt; s.split(<span class="string">""</span>))</span><br><span class="line">    .map(Arrays::stream)</span><br><span class="line">    .distinct()</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.util.stream.ReferencePipeline$Head<span class="meta">@eed</span>1f14</span><br><span class="line">java.util.stream.ReferencePipeline$Head@<span class="number">7229724f</span></span><br><span class="line">java.util.stream.ReferencePipeline$Head@<span class="number">4</span>c873330</span><br><span class="line">java.util.stream.ReferencePipeline$Head@<span class="number">119</span>d7047</span><br><span class="line">java.util.stream.ReferencePipeline$Head@<span class="number">776</span>ec8df</span><br><span class="line">java.util.stream.ReferencePipeline$Head@<span class="number">4</span>eec7777</span><br><span class="line">java.util.stream.ReferencePipeline$Head@<span class="number">3</span>b07d329</span><br><span class="line">java.util.stream.ReferencePipeline$Head@<span class="number">41629346</span></span><br><span class="line">java.util.stream.ReferencePipeline$Head@<span class="number">404</span>b9385</span><br></pre></td></tr></table></figure><p>因为上面的流经过<code>map(Arrays::stream)</code>处理后，将每个数组变成了一个新的流，返回结果为流的数组<code>Stream&lt;String&gt;[]</code>，所以输出是各个流的句柄。我们还需将这些新的流连接成一个流，使用<code>flatMap</code>来改写上面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .map(s -&gt; s.split(<span class="string">""</span>))</span><br><span class="line">    .flatMap(Arrays::stream)</span><br><span class="line">    .distinct()</span><br><span class="line">    .forEach(s -&gt; System.out.print(s + <span class="string">" "</span>));</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">J a v S c r i p t y h o n P H C # G l g w f + R u b</span><br></pre></td></tr></table></figure><p>和<code>map</code>类似，<code>flatMap</code>方法也有相应的原始类型特化方法，如<code>flatMapToInt</code>等。</p><h3 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h3><h4 id="anyMatch"><a href="#anyMatch" class="headerlink" title="anyMatch"></a>anyMatch</h4><p><code>anyMatch</code>方法用于判断流中是否有符合判断条件的元素，返回值为boolean类型。比如判断list中是否含有<code>SQL</code>元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .anyMatch(s -&gt; <span class="string">"SQL"</span>.equals(s)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="allMatch"><a href="#allMatch" class="headerlink" title="allMatch"></a>allMatch</h3><p><code>allMatch</code>方法用于判断流中是否所有元素都满足给定的判断条件，返回值为boolean类型。比如判断list中是否所有元素长度都不大于10：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .allMatch(s -&gt; s.length() &lt;= <span class="number">10</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="noneMatch"><a href="#noneMatch" class="headerlink" title="noneMatch"></a>noneMatch</h4><p><code>noneMatch</code>方法用于判断流中是否所有元素都不满足给定的判断条件，返回值为boolean类型。比如判断list中不存在长度大于10的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .noneMatch(s -&gt; s.length() &gt; <span class="number">10</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="findAny"><a href="#findAny" class="headerlink" title="findAny"></a>findAny</h3><p><code>findAny</code>方法用于返回流中的任意元素的Optional类型，例如筛选出list中任意一个以<code>J</code>开头的元素，如果存在，则输出它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().filter(s -&gt; s.startsWith(<span class="string">"J"</span>)).findAny().ifPresent(System.out::println); <span class="comment">// Java</span></span><br></pre></td></tr></table></figure><h3 id="findFirst"><a href="#findFirst" class="headerlink" title="findFirst"></a>findFirst</h3><p><code>findFirst</code>方法用于返回流中的第一个元素的Optional类型，例如筛选出list中长度大于5的元素，如果存在，则输出第一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .filter(s -&gt; s.length() &gt; 5)</span><br><span class="line">    .findFirst()</span><br><span class="line">    .ifPresent(System.out::println); // JavaScript</span><br></pre></td></tr></table></figure><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p><code>reduce</code>函数从字面上来看就是压缩，缩减的意思，它可以用于数字类型的流的求和，求最大值和最小值。如对numbers中的元素求和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">numbers.stream()</span><br><span class="line">       .reduce(<span class="number">0</span>, Integer::sum); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure><p><code>reduce</code>函数也可以不指定初始值，但这时候将返回一个Optional对象，比如求最大值和最小值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numbers.stream().reduce(Integer::max.ifPresent(System.out::println); <span class="comment">// 4</span></span><br><span class="line">numbers.stream().reduce(Integer::min).ifPresent(System.out::println); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p><code>forEach</code>用于迭代流中的每个元素，最为常见的就是迭代输出，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p><code>count</code>方法用于统计流中元素的个数，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().count(); // 9</span><br></pre></td></tr></table></figure><h3 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h3><p><code>collect</code>方法用于收集流中的元素，并放到不同类型的结果中，比如<code>List</code>、<code>Set</code>或者<code>Map</code>。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; filterList = list.stream().filter(s -&gt; s.startsWith(<span class="string">"J"</span>)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>如果需要以<code>Set</code>来替代<code>List</code>，只需要使用<code>Collectors.toSet()</code>就好了。</p><h3 id="流的构建"><a href="#流的构建" class="headerlink" title="流的构建"></a>流的构建</h3><p>除了使用集合对象的<code>stream</code>方法构建流之外，我们可以手动构建一些流。</p><h4 id="数值范围构建"><a href="#数值范围构建" class="headerlink" title="数值范围构建"></a>数值范围构建</h4><p><code>IntStream</code>和<code>LongStream</code>对象支持<code>range</code>和<code>rangeClosed</code>方法来构建数值流。这两个方法都是第一个参数接受起始值，第二个参数接受结束值。但range是不包含结束值的，而rangeClosed则包含结束值。比如对1到100的整数求和：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream.rangeClosed(1, 100).sum(); // 5050</span><br></pre></td></tr></table></figure><h4 id="由值构建"><a href="#由值构建" class="headerlink" title="由值构建"></a>由值构建</h4><p>静态方法<code>Stream.of</code>可以显式值创建一个流。它可以接受任意数量的参数。例如，以下代码直接使用<code>Stream.of</code>创建了一个字符串流:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; s = Stream.of(<span class="string">"Java"</span>, <span class="string">"JavaScript"</span>, <span class="string">"C++"</span>, <span class="string">"Ruby"</span>);</span><br></pre></td></tr></table></figure><p>也可以使用<code>Stream.empty()</code>构建一个空流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Object&gt; emptyStream = Stream.empty();</span><br></pre></td></tr></table></figure><h4 id="由数组构建"><a href="#由数组构建" class="headerlink" title="由数组构建"></a>由数组构建</h4><p>静态方法<code>Arrays.stream</code>可以通过数组创建一个流。它接受一个数组作为参数。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">IntStream intStream = Arrays.stream(arr);</span><br></pre></td></tr></table></figure><h4 id="由文件生成流"><a href="#由文件生成流" class="headerlink" title="由文件生成流"></a>由文件生成流</h4><p><code>java.nio.file.Files</code>中的很多静态方法都会返回一个流。例如<code>Files.lines</code>方法会返回一个由指定文件中的各行构成的字符串流。比如统计一个文件中共有多少个字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> wordCout = <span class="number">0L</span>;</span><br><span class="line"><span class="keyword">try</span> (Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="string">"file.txt"</span>), Charset.defaultCharset())) &#123;</span><br><span class="line">    wordCout = lines.map(l -&gt; l.split(<span class="string">""</span>))</span><br><span class="line">                    .flatMap(Arrays::stream)</span><br><span class="line">                    .count();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ignore) &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="由函数构造"><a href="#由函数构造" class="headerlink" title="由函数构造"></a>由函数构造</h4><p>Stream API提供了两个静态方法来从函数生成流：<code>Stream.iterate</code>和<code>Stream.generate</code>。这两个操作可以创建所谓的无限流。比如下面的例子构建了10个偶数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p><code>iterate</code>方法接受一个初始值（在这里是0），还有一个依次应用在每个产生的新值上的Lambda（UnaryOperator类型）。这里，我们使用Lambda <code>n -&gt; n + 2</code>，返回的是前一个元 素加上2。因此，<code>iterate</code>方法生成了一个所有正偶数的流：流的第一个元素是初始值0。然后加上2来生成新的值2，再加上2来得到新的值4，以此类推。</p><p>与<code>iterate</code>方法类似，<code>generate</code>方法也可让你按需生成一个无限流。但<code>generate</code>不是依次对每个新生成的值应用函数，比如下面的例子生成了5个0到1之间的随机双精度数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.generate(Math::random).limit(<span class="number">5</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.6334646850587863</span></span><br><span class="line"><span class="number">0.4190147641834009</span></span><br><span class="line"><span class="number">0.4361968394515475</span></span><br><span class="line"><span class="number">0.6911796456838655</span></span><br><span class="line"><span class="number">0.08156838267267075</span></span><br></pre></td></tr></table></figure><h3 id="转载-https-mrbird-cc-java8stream1-html"><a href="#转载-https-mrbird-cc-java8stream1-html" class="headerlink" title="转载:https://mrbird.cc/java8stream1.html"></a>转载:<a href="https://mrbird.cc/java8stream1.html" target="_blank" rel="noopener">https://mrbird.cc/java8stream1.html</a></h3>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lamdba </tag>
            
            <tag> Java8 Stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet状态管理</title>
      <link href="/2019/08/11/Servlet%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
      <url>/2019/08/11/Servlet%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用Jsoup防御XSS攻击</title>
      <link href="/2019/08/11/%E4%BD%BF%E7%94%A8Jsoup%E9%98%B2%E5%BE%A1XSS%E6%94%BB%E5%87%BB/"/>
      <url>/2019/08/11/%E4%BD%BF%E7%94%A8Jsoup%E9%98%B2%E5%BE%A1XSS%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot异常处理</title>
      <link href="/2019/08/11/Spring-Boot%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2019/08/11/Spring-Boot%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot开启Spring Security</title>
      <link href="/2019/08/11/Spring-Boot%E5%BC%80%E5%90%AFSpring-Security/"/>
      <url>/2019/08/11/Spring-Boot%E5%BC%80%E5%90%AFSpring-Security/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security自定义用户登录</title>
      <link href="/2019/08/11/Spring-Security%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95/"/>
      <url>/2019/08/11/Spring-Security%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security添加图像验证码</title>
      <link href="/2019/08/11/Spring-Security%E6%B7%BB%E5%8A%A0%E5%9B%BE%E5%83%8F%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
      <url>/2019/08/11/Spring-Security%E6%B7%BB%E5%8A%A0%E5%9B%BE%E5%83%8F%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security添加记住我功能</title>
      <link href="/2019/08/11/Spring-Security%E6%B7%BB%E5%8A%A0%E8%AE%B0%E4%BD%8F%E6%88%91%E5%8A%9F%E8%83%BD/"/>
      <url>/2019/08/11/Spring-Security%E6%B7%BB%E5%8A%A0%E8%AE%B0%E4%BD%8F%E6%88%91%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security短信验证码登录</title>
      <link href="/2019/08/11/Spring-Security%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E7%99%BB%E5%BD%95/"/>
      <url>/2019/08/11/Spring-Security%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security退出登录</title>
      <link href="/2019/08/11/Spring-Security%E9%80%80%E5%87%BA%E7%99%BB%E5%BD%95/"/>
      <url>/2019/08/11/Spring-Security%E9%80%80%E5%87%BA%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security Session管理</title>
      <link href="/2019/08/11/Spring-Security-Session%E7%AE%A1%E7%90%86/"/>
      <url>/2019/08/11/Spring-Security-Session%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security权限控制</title>
      <link href="/2019/08/11/Spring-Security%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/08/11/Spring-Security%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security Oauth2入门</title>
      <link href="/2019/08/11/Spring-Security-Oauth2%E5%85%A5%E9%97%A8/"/>
      <url>/2019/08/11/Spring-Security-Oauth2%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security Oauth2自定义Token获取方式</title>
      <link href="/2019/08/11/Spring-Security-Oauth2%E8%87%AA%E5%AE%9A%E4%B9%89Token%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F/"/>
      <url>/2019/08/11/Spring-Security-Oauth2%E8%87%AA%E5%AE%9A%E4%B9%89Token%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security OAuth2自定义令牌控制</title>
      <link href="/2019/08/11/Spring-Security-OAuth2%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BB%A4%E7%89%8C%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/08/11/Spring-Security-OAuth2%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BB%A4%E7%89%8C%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security OAuth2 SSO</title>
      <link href="/2019/08/11/Spring-Security-OAuth2-SSO/"/>
      <url>/2019/08/11/Spring-Security-OAuth2-SSO/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot配合Hibernate Validator参数校验</title>
      <link href="/2019/08/11/SpringBoot%E9%85%8D%E5%90%88Hibernate-Validator%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"/>
      <url>/2019/08/11/SpringBoot%E9%85%8D%E5%90%88Hibernate-Validator%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型</title>
      <link href="/2019/08/11/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/08/11/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>深入理解volatile关键字</title>
      <link href="/2019/08/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2019/08/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Fork/Join学习</title>
      <link href="/2019/08/11/Fork-Join%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/08/11/Fork-Join%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal学习</title>
      <link href="/2019/08/11/ThreadLocal%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/08/11/ThreadLocal%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>深入学习Java线程池</title>
      <link href="/2019/08/11/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2019/08/11/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  在前面的例子中，我们都是通过<code>new Thread</code>来创建一个线程，由于线程的创建和销毁都需要消耗一定的CPU资源，所以在高并发下这种创建线程的方式将严重影响代码执行效率。而线程池的作用就是让一个线程执行结束后不马上销毁，继续执行新的任务，这样就节省了不断创建线程和销毁线程的开销。</p><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>创建Java线程池最为核心的类为<code>ThreadPoolExecutor</code>：</p><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190630215357.png" alt="QQ截图20190630215357.png"></p><p>它提供了四种构造函数来创建线程池，其中最为核心的构造函数如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><p>这7个参数的含义如下：</p><ol><li><strong>corePoolSize</strong> 线程池核心线程数。即线程池中保留的线程个数，即使这些线程是空闲的，也不会被销毁，除非通过ThreadPoolExecutor的<code>allowCoreThreadTimeOut(true)</code>方法开启了核心线程的超时策略；</li><li><strong>maximumPoolSize</strong> 线程池中允许的最大线程个数；</li><li><strong>keepAliveTime</strong> 用于设置那些超出核心线程数量的线程的最大等待时间，超过这个时间还没有新任务的话，超出的线程将被销毁；</li><li><strong>unit</strong> 超时时间单位；</li><li><strong>workQueue</strong> 线程队列。用于保存通过execute方法提交的，等待被执行的任务；</li><li><strong>threadFactory</strong> 线程创建工程，即指定怎样创建线程；</li><li><strong>handler</strong> 拒绝策略。<code>当ThreadPoolExecutor已经关闭或者ThreadPoolExecutor已经饱和时(达到了最大线程池大小且工作对了已满),execute()方法将要调用Handler。</code></li></ol><p>在通过这个构造方法创建线程池的时候，这几个参数必须满足以下条件，否则将抛出<code>IllegalArgumentException</code>异常：</p><ol><li>corePoolSize不能小于0；</li><li>keepAliveTime不能小于0；</li><li>maximumPoolSize 不能小于等于0；</li><li>maximumPoolSize不能小于corePoolSize；</li></ol><p>此外，workQueue、threadFactory和handler不能为null，否则将抛出空指针异常。</p><p>下面举些例子来深入理解这几个参数的含义。</p><p>使用上面的构造方法创建一个线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">    System.out.println(<span class="string">"线程池创建完毕"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> activeCount = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> queueSize = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (activeCount != threadPoolExecutor.getActiveCount()</span><br><span class="line">                || queueSize != threadPoolExecutor.getQueue().size()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"活跃线程个数 "</span> + threadPoolExecutor.getActiveCount());</span><br><span class="line">            System.out.println(<span class="string">"核心线程个数 "</span> + threadPoolExecutor.getCorePoolSize());</span><br><span class="line">            System.out.println(<span class="string">"队列线程个数 "</span> + threadPoolExecutor.getQueue().size());</span><br><span class="line">            System.out.println(<span class="string">"最大线程数 "</span> + threadPoolExecutor.getMaximumPoolSize());</span><br><span class="line">            System.out.println(<span class="string">"------------------------------------"</span>);</span><br><span class="line">            activeCount = threadPoolExecutor.getActiveCount();</span><br><span class="line">            queueSize = threadPoolExecutor.getQueue().size();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码创建了一个核心线程数量为1，允许最大线程数量为2，最大活跃时间为10秒，线程队列长度为1的线程池。</p><p>假如我们通过execute方法向线程池提交1个任务，看看结果如何：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">System.out.println(<span class="string">"线程池创建完毕"</span>);</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> activeCount = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> queueSize = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (activeCount != threadPoolExecutor.getActiveCount()</span><br><span class="line">                || queueSize != threadPoolExecutor.getQueue().size()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"活跃线程个数 "</span> + threadPoolExecutor.getActiveCount());</span><br><span class="line">            System.out.println(<span class="string">"核心线程个数 "</span> + threadPoolExecutor.getCorePoolSize());</span><br><span class="line">            System.out.println(<span class="string">"队列线程个数 "</span> + threadPoolExecutor.getQueue().size());</span><br><span class="line">            System.out.println(<span class="string">"最大线程数 "</span> + threadPoolExecutor.getMaximumPoolSize());</span><br><span class="line">            System.out.println(<span class="string">"------------------------------------"</span>);</span><br><span class="line">            activeCount = threadPoolExecutor.getActiveCount();</span><br><span class="line">            queueSize = threadPoolExecutor.getQueue().size();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadPoolExecutor的execute和submit方法都可以向线程池提交任务，区别是，submit方法能够返回执行结果，返回值类型为Future</p><p>sleep方法代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="keyword">try</span> &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">"线程执行sleep方法"</span>);        TimeUnit.SECONDS.sleep(value);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;&#125;</span><br></pre></td></tr></table></figure><p>启动程序，控制台输出如下：<img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190630222238.png" alt="QQ截图20190630222238.png"></p><p>线程池核心线程数量为1，通过execute提交了一个任务后，由于核心线程是空闲的，所以任务被执行了。由于这个任务的逻辑是休眠100秒，所以在这100秒内，线程池的活跃线程数量为1。此外，因为提交的任务被核心线程执行了，所以并没有线程需要被放到线程队列里等待，线程队列长度为0。</p><p>假如我们通过execute方法向线程池提交2个任务，看看结果如何：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br></pre></td></tr></table></figure><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190701183457.png" alt="QQ截图20190701183457.png"></p><p>线程池核心线程数量为1，通过execute提交了2个任务后，一开始核心线程是空闲的，Thread-0被执行。由于这个任务的逻辑是休眠100秒，所以在这100秒内，线程池的活跃线程数量为1。因为核心线程数量为1，所以另外一个任务在这100秒内不能被执行，于是被放到线程队列里等待，线程队列长度为1。</p><p>假如我们通过execute方法向线程池提交3个任务，看看结果如何：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br></pre></td></tr></table></figure><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190701184303.png" alt="QQ截图20190701184303.png"></p><p>这三个任务都是休眠100秒，所以核心线程池中第一个任务正在被执行，第二个任务被放入到了线程队列。而当第三个任务被提交进来时，线程队列满了（我们定义的长度为1），由于该线程池允许的最大线程数量为2，所以线程池还可以再创建一个线程来执行另外一个任务，于是乎之前在线程队列里的线程被取出执行（FIFO），第三个任务被放入到了线程队列。</p><p>改变第二个和第三个任务的睡眠时间，观察输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));threadPoolExecutor.execute(() -&gt; sleep(<span class="number">5</span>));</span><br><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190701185215.png" alt="QQ截图20190701185215.png"></p><p>第二个任务提交5秒后，任务执行完毕，所以线程队列里的任务被执行，于是队列线程个数为0，活跃线程数量为2（第一个和第三个任务）。再过5秒后，第三个任务执行完毕，于是活跃线程数量为1（第一个100秒还没执行完毕）。</p><p>在第三个任务结束的瞬间，我们观察线程快照:</p><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190701185617.png" alt="QQ截图20190701185617.png"></p><p>可以看到，线程池中有两个线程，Thread-0在执行第一个任务（休眠100秒，还没结束），Thread-1执行完第三个任务后并没有马上被销毁。过段时间后（10秒钟后）再观察线程快照:</p><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190701190444.png" alt="QQ截图20190701190444.png"></p><p>可以看到，Thread-1这个线程被销毁了，因为我们在创建线程池的时候，指定keepAliveTime 为10秒，10秒后，超出核心线程池线程外的那些线程将被销毁。</p><p>假如一次性提交4个任务，看看会怎样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br></pre></td></tr></table></figure><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190701190808.png" alt="QQ截图20190701190808.png"></p><p>因为我们设置的拒绝策略为AbortPolicy，所以最后提交的那个任务直接被拒绝了。更多拒绝策略下面会介绍到。</p><h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>线程池包含以下几个状态：</p><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190702100110.png" alt="QQ截图20190702100110.png"></p><p>当线程池中所有任务都处理完毕后，线程并不会自己关闭。我们可以通过调用<code>shutdown</code>和<code>shutdownNow</code>方法来关闭线程池。两者的区别在于：</p><ol><li><code>shutdown</code>方法将线程池置为shutdown状态，<code>拒绝新的任务提交，但线程池并不会马上关闭，而是等待所有正在执行的和线程队列里的任务都执行完毕后，线程池才会被关闭</code>。所以这个方法是平滑的关闭线程池。</li><li><code>shutdownNow</code>方法将线程池置为stop状态，拒绝新的任务提交，中断正在执行的那些任务，并且清除线程队列里的任务并返回。所以这个方法是比较“暴力”的。</li></ol><p>举两个例子观察下两者的区别：</p><p><code>shutdown</code>例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">2</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">    System.out.println(<span class="string">"已经执行了线程池shutdown方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行shortTask完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"shortTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">longTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行longTask完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"longTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动程序，控制台输出如下：</p><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190702101041.png" alt="QQ截图20190702101041.png"></p><p>可以看到，虽然在任务都被提交后马上执行了<code>shutdown</code>方法，但是并不会马上关闭线程池，而是等待所有被提交的任务都执行完了才关闭。</p><p><code>shutdownNow</code>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">2</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask());</span><br><span class="line"></span><br><span class="line">    List&lt;Runnable&gt; runnables = threadPoolExecutor.shutdownNow(); <span class="comment">// 马上关闭，并返回还未被执行的任务</span></span><br><span class="line">    System.out.println(runnables);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"已经执行了线程池shutdownNow方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行shortTask完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"shortTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">longTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行longTask完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"longTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动程序，控制台输出如下：<img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190702101355.png" alt="QQ截图20190702101355.png"></p><p>可以看到，在执行<code>shutdownNow</code>方法后，线程池马上就被关闭了，正在执行中的两个任务被打断，并且返回了线程队列中等待被执行的两个任务。</p><p>通过上面两个例子我们还可以看到<code>shutdown</code>和<code>shutdownNow</code>方法都不是阻塞的。常与<code>shutdown</code>搭配的方法有<code>awaitTermination</code>。</p><p><code>awaitTermination</code>方法接收timeout和TimeUnit两个参数，用于设定超时时间及单位。当等待超过设定时间时，会监测ExecutorService是否已经关闭，若关闭则返回true，否则返回false。该方法是阻塞的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">2</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">    <span class="keyword">boolean</span> isShutdown = threadPoolExecutor.awaitTermination(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span> (isShutdown) &#123;</span><br><span class="line">        System.out.println(<span class="string">"线程池在3秒内成功关闭"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"等了3秒还没关闭，不等了╰（‵□′）╯"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行shortTask完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"shortTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">longTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行longTask完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"longTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动程序输出如下：</p><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190702102156.png" alt="QQ截图20190702102156.png"></p><h3 id="4大拒绝策略"><a href="#4大拒绝策略" class="headerlink" title="4大拒绝策略"></a>4大拒绝策略</h3><p>当线程池无法再接收新的任务的时候，可采取如下四种策略：<img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190302111014.png" alt="QQ截图20190302111014.png"></p><h4 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h4><p><code>CallerRunsPolicy</code>策略：由调用线程处理该任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">"任务1"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask(<span class="string">"任务2"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask(<span class="string">"任务3"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">"任务4"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">"任务5"</span>));</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">shortTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行shortTask-name-"</span> + name + <span class="string">"完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"shortTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">longTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">longTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行longTask-name-"</span> + name + <span class="string">"完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"longTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的线程池最多只能一次性提交4个任务，第5个任务提交后会被拒绝策略处理。启动程序输出如下：</p><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190702103818.png" alt="QQ截图20190702103818.png"></p><p>可以看到，第5个提交的任务由调用线程（即main线程）处理该任务。</p><h4 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h4><p><code>AbortPolicy</code>策略：丢弃任务，并抛出<code>RejectedExecutionException</code>异常。前面的例子就是使用该策略，所以不再演示。</p><h4 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h4><p><code>DiscardOldestPolicy</code>策略：丢弃最早被放入到线程队列的任务，将新提交的任务放入到线程队列末端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">"任务1"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask(<span class="string">"任务2"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask(<span class="string">"任务3"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">"任务4"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">"任务5"</span>));</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">shortTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行shortTask-name-"</span> + name + <span class="string">"完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"shortTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">longTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">longTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行longTask-name-"</span> + name + <span class="string">"完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"longTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动程序输出如下：</p><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190702105646.png" alt="QQ截图20190702105646.png"></p><p>可以看到最后提交的任务被执行了，而第3个任务是第一个被放到线程队列的任务，被丢弃了。</p><h4 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h4><p><code>DiscardPolicy</code>策略：直接丢弃新的任务，不抛异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">"任务1"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask(<span class="string">"任务2"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask(<span class="string">"任务3"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">"任务4"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">"任务5"</span>));</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">shortTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行shortTask-name-"</span> + name + <span class="string">"完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"shortTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">longTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">longTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行longTask-name-"</span> + name + <span class="string">"完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"longTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动程序，输出如下：<img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190702110022.png" alt="QQ截图20190702110022.png"></p><p>第5个任务直接被拒绝丢弃了，而没有抛出任何异常</p><h4 id="线程池工厂方法"><a href="#线程池工厂方法" class="headerlink" title="线程池工厂方法"></a>线程池工厂方法</h4><p>除了使用ThreadPoolExecutor的构造方法创建线程池外，我们也可以使用<code>Executors</code>提供的工厂方法来创建不同类型的线程池：</p><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190702110350.png" alt="QQ截图20190702110350.png"></p><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><p><strong><code>适用于为了满足资源管理的请求,而需要限制当前线程数量的应用场景,它适用于负载比较重的服务器。</code></strong></p><p>查看<code>newFixedThreadPool</code>方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，通过<code>newFixedThreadPool</code>创建的是一个固定大小的线程池，大小由<code>nThreads</code>参数指定，它具有如下几个特点:</p><ol><li>当线程池中的线程数达到corePoolSize后，新任务将在无界队列中等待，因此线程池中<br>的线程数不会超过corePoolSize。</li><li>由于1,使用无界队列时,使用无界队列时maximumPoolSize将是一个无效参数。</li><li>由于1和2，使用无界队列时keepAliveTime将是一个无效参数</li><li>由于使用无界队列，运行中的FixedThreadPool（未执行方法shutdown()或shutdownNow()）不会拒绝任务（不会调用RejectedExecutionHandler.rejectedExecution方法）。</li></ol><h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><p><strong><code>适用于执行很多的短期异步任务的小程序,或者负载较轻的服务器。</code></strong></p><p>查看<code>newCachedThreadPool</code>方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个理论上无限大小的线程池：</p><ol><li>核心线程数为0，SynchronousQueue队列是没有长度的队列，所以当有新的任务提交，如果有空闲的还未超时的（最大空闲时间60秒）线程则执行该任务，否则新增一个线程来处理该任务。</li><li>因为线程数量没有限制，理论上可以接收无限个新任务，所以这里也没有指定拒绝策略。</li><li>CachedThreadPool的maximumPool是无界的。这意味着，如果主线程提交任务的速度高于maximumPool中线程处理任务的速度时，CachedThreadPool会不断创建新线程。极端情况下，CachedThreadPool会因为创建过多线程而耗尽CPU和内存资源。</li></ol><h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><p><strong><code>适用于需要保证顺序的执行各个任务;并且在任意时间点,不会有多个线程活动的场景。</code></strong></p><p>查看<code>newSingleThreadExecutor</code>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>核心线程数和最大线程数都为1，每次只能有一个线程处理任务。</li><li>LinkedBlockingQueue队列可以接收无限个新任务。</li></ol><h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h4><ul><li>ScheduledThreadPoolExecutor：<strong><code>适用于多个后台线程执行周期任务,同时为了满足资源管理需求而需要限制后台线程的数量的应用场景。</code></strong></li><li>SingleThreadScheduledExecutor：<strong><code>适用于需要单个后台线程执行周期任务，同时需要保证顺序地执行各个任务的应用场景。</code></strong></li></ul><p>查看<code>newScheduledThreadPool</code>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以<code>newScheduledThreadPool</code>理论是也是可以接收无限个任务，DelayedWorkQueue也是一个无界队列。</p><p>使用newScheduledThreadPool创建的线程池除了可以处理普通的Runnable任务外，它还具有调度的功能：</p><p>1.延迟指定时间后执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 延迟5秒执行</span></span><br><span class="line">executorService.schedule(() -&gt; System.out.println(<span class="string">"hello"</span>), <span class="number">5</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>2.按指定的速率执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 延迟1秒执行，然后每5秒执行一次</span></span><br><span class="line">executorService.scheduleAtFixedRate(</span><br><span class="line">        () -&gt; System.out.println(LocalTime.now()), <span class="number">1</span>, <span class="number">5</span>, TimeUnit.SECONDS</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190702152117.png" alt="QQ截图20190702152117.png"></p><p>3.按指定的时延执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">1</span>);executorService.scheduleWithFixedDelay(() -&gt; System.out.println(LocalTime.now()), <span class="number">1</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190702152440.png" alt="QQ截图20190702152440.png"></p><p>乍一看，scheduleAtFixedRate和scheduleWithFixedDelay没啥区别，实际它们还是有区别的：</p><ul><li>scheduleAtFixedRate按照固定速率执行任务，比如每5秒执行一个任务，即使上一个任务没有结束，5秒后也会开始处理新的任务；</li><li>scheduleWithFixedDelay按照固定的时延处理任务，比如每延迟5秒执行一个任务，无论上一个任务处理了1秒，1分钟还是1小时，下一个任务总是在上一个任务执行完毕后5秒钟后开始执行。</li></ul><p>对于这些线程池工厂方法的使用，阿里巴巴编程规程指出：</p><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190702153306.png" alt="QQ截图20190702153306.png"></p><p>因为这几个线程池理论是都可以接收无限个任务，所以这就有内存溢出的风险。实际上只要我们掌握了ThreadPoolExecutor构造函数7个参数的含义，我们就可以根据不同的业务来创建出符合需求的线程池。一般线程池的创建可以参考如下规则：</p><ul><li>IO密集型任务，线程池线程数量可以设置为2 X CPU核心数；</li><li>计算密集型任务，线程池线程数量可以设置为CPU核心数 + 1。</li><li>混合型: 可以拆分成IO密集型任务和计算密集型任务。</li></ul><h3 id="一些API的用法"><a href="#一些API的用法" class="headerlink" title="一些API的用法"></a>一些API的用法</h3><p>ThreadPoolExecutor提供了几个判断线程池状态的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">    System.out.println(<span class="string">"线程池为shutdown状态："</span> + threadPoolExecutor.isShutdown());</span><br><span class="line">    System.out.println(<span class="string">"线程池正在关闭："</span> + threadPoolExecutor.isTerminating());</span><br><span class="line">    System.out.println(<span class="string">"线程池已经关闭："</span> + threadPoolExecutor.isTerminated());</span><br><span class="line">    threadPoolExecutor.awaitTermination(<span class="number">6</span>, TimeUnit.SECONDS);</span><br><span class="line">    System.out.println(<span class="string">"线程池已经关闭"</span> + threadPoolExecutor.isTerminated());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出如下：</p><p><img src="https://mrbird.cc/img/20190703205843.png" alt="20190703205843.png"></p><p>前面我们提到，线程池核心线程即使是空闲状态也不会被销毁，除非使用<code>allowCoreThreadTimeOut</code>设置了允许核心线程超时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">               <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">               <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">               <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">       );</span><br><span class="line">       threadPoolExecutor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</span><br><span class="line">       threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">               System.out.println(<span class="string">"任务执行完毕"</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>程序输出如下所示：</p><p><img src="https://mrbird.cc/img/asdfasdfaaaaa.gif" alt="asdfasdfaaaaa.gif"></p><p>5秒后任务执行完毕，核心线程处于空闲的状态。因为通过<code>allowCoreThreadTimeOut</code>方法设置了允许核心线程超时，所以3秒后（keepAliveTime设置为3秒），核心线程被销毁。核心线程被销毁后，线程池也就没有作用了，于是就自动关闭了。</p><p><strong>值得注意的是，如果一个线程池调用了<code>allowCoreThreadTimeOut(true)</code>方法，那么它的<code>keepAliveTime</code>不能为0。</strong></p><p>ThreadPoolExecutor提供了一<code>remove</code>方法，查看其源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = workQueue.remove(task);</span><br><span class="line">    tryTerminate(); <span class="comment">// In case SHUTDOWN and now empty</span></span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可看到，它删除的是线程队列中的任务，而非正在被执行的任务。举个例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">    );</span><br><span class="line">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(<span class="string">"任务执行完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Runnable r = () -&gt; System.out.println(<span class="string">"看看我是否会被删除"</span>);</span><br><span class="line">    threadPoolExecutor.execute(r);</span><br><span class="line">    threadPoolExecutor.remove(r);</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行程序，输出如下：</p><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190703211746.png" alt="QQ截图20190703211746.png"></p><p>可看到任务并没有被执行，已经被删除，因为唯一一个核心线程已经在执行任务了，所以后提交的这个任务被放到了线程队列里，然后通过remove方法删除。</p><p>默认情况下，只有当往线程池里提交了任务后，线程池才会启动核心线程处理任务。我们可以通过调用<code>preStartCoreThread</code>方法，<code>让核心线程即使没有任务提交，也处于等待执行任务的活跃状态：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">    );</span><br><span class="line">    System.out.println(<span class="string">"活跃线程数: "</span> + threadPoolExecutor.getActiveCount());</span><br><span class="line">    threadPoolExecutor.prestartCoreThread();</span><br><span class="line">    System.out.println(<span class="string">"活跃线程数: "</span> + threadPoolExecutor.getActiveCount());</span><br><span class="line">    threadPoolExecutor.prestartCoreThread();</span><br><span class="line">    System.out.println(<span class="string">"活跃线程数: "</span> + threadPoolExecutor.getActiveCount());</span><br><span class="line">    threadPoolExecutor.prestartCoreThread();</span><br><span class="line">    System.out.println(<span class="string">"活跃线程数: "</span> + threadPoolExecutor.getActiveCount());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出如下所示：</p><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190703213145.png" alt="QQ截图20190703213145.png"></p><p>该方法返回boolean类型值，如果所以核心线程都启动了，返回false，反之返回true。</p><p>还有一个和它类似的<code>preStartAllCoreThreads</code>方法，它的作用是一次性启动所有核心线程，让其处于活跃地等待执行任务的状态。</p><p><strong>ThreadPoolExecutor的invokeAny方法用于随机执行任务集合中的某个任务，并返回执行结果，该方法是同步方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务集合</span></span><br><span class="line">    List&lt;Callable&lt;Integer&gt;&gt; tasks = IntStream.range(<span class="number">0</span>, <span class="number">4</span>).boxed().map(i -&gt; (Callable&lt;Integer&gt;) () -&gt; &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(<span class="number">5</span>));</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">// 随机执行结果</span></span><br><span class="line">    Integer result = threadPoolExecutor.invokeAny(tasks);</span><br><span class="line">    System.out.println(<span class="string">"-------------------"</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    threadPoolExecutor.shutdownNow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动程序，输出如下：</p><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190704091530.png" alt="QQ截图20190704091530.png"></p><p><strong>ThreadPoolExecutor的invokeAll则是执行任务集合中的所有任务，返回Future集合：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    List&lt;Callable&lt;Integer&gt;&gt; tasks = IntStream.range(<span class="number">0</span>, <span class="number">4</span>).boxed().map(i -&gt; (Callable&lt;Integer&gt;) () -&gt; &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(<span class="number">5</span>));</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    List&lt;Future&lt;Integer&gt;&gt; futureList = threadPoolExecutor.invokeAll(tasks);</span><br><span class="line">    futureList.stream().map(f-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> f.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdownNow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：<img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190704091836.png" alt="QQ截图20190704091836.png"></p><p>总结下这些方法：</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">allowCoreThreadTimeOut(boolean value)</td><td align="left">是否允许核心线程空闲后超时，是的话超时后核心线程将销毁，线程池自动关闭</td></tr><tr><td align="left">awaitTermination(long timeout, TimeUnit unit)</td><td align="left">阻塞当前线程，等待线程池关闭，timeout用于指定等待时间。</td></tr><tr><td align="left">execute(Runnable command)</td><td align="left">向线程池提交任务，没有返回值</td></tr><tr><td align="left">submit(Runnable task)</td><td align="left">向线程池提交任务，返回Future</td></tr><tr><td align="left">isShutdown()</td><td align="left">判断线程池是否为shutdown状态</td></tr><tr><td align="left">isTerminating()</td><td align="left">判断线程池是否正在关闭</td></tr><tr><td align="left">isTerminated()</td><td align="left">判断线程池是否已经关闭</td></tr><tr><td align="left">remove(Runnable task)</td><td align="left">移除线程队列中的指定任务</td></tr><tr><td align="left">prestartCoreThread()</td><td align="left">提前让一个核心线程处于活跃状态，等待执行任务</td></tr><tr><td align="left">prestartAllCoreThreads()</td><td align="left">提前让所有核心线程处于活跃状态，等待执行任务</td></tr><tr><td align="left">getActiveCount()</td><td align="left">获取线程池活跃线程数</td></tr><tr><td align="left">getCorePoolSize()</td><td align="left">获取线程池核心线程数</td></tr><tr><td align="left">threadPoolExecutor.getQueue()</td><td align="left">获取线程池线程队列</td></tr><tr><td align="left">getMaximumPoolSize()</td><td align="left">获取线程池最大线程数</td></tr><tr><td align="left">shutdown()</td><td align="left">让线程池处于shutdown状态，不再接收任务，等待所有正在运行中的任务结束后，关闭线程池。</td></tr><tr><td align="left">shutdownNow()</td><td align="left">让线程池处于stop状态，不再接受任务，尝试打断正在运行中的任务，并关闭线程池，返回线程队列中的任务。</td></tr></tbody></table><h4 id="转载-https-mrbird-cc-Java-Thread-Pool-html"><a href="#转载-https-mrbird-cc-Java-Thread-Pool-html" class="headerlink" title="转载:https://mrbird.cc/Java-Thread-Pool.html"></a>转载:<a href="https://mrbird.cc/Java-Thread-Pool.html" target="_blank" rel="noopener">https://mrbird.cc/Java-Thread-Pool.html</a></h4>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git标签管理</title>
      <link href="/2019/08/11/Git%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86/"/>
      <url>/2019/08/11/Git%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="创建标签-tag"><a href="#创建标签-tag" class="headerlink" title="创建标签(tag)"></a>创建标签(tag)</h2><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br></pre></td></tr></table></figure><p>然后，敲命令<code>git tag &lt;name&gt;</code>就可以打一个新标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.0</span><br></pre></td></tr></table></figure><p>可以用命令<code>git tag</code>查看所有标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p><p>方法是找到历史提交的commit id，然后打上就可以了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline --abbrev-commit</span><br><span class="line">12a631b (HEAD -&gt; master, tag: v1.0, origin/master) merged bug fix 101</span><br><span class="line">4c805e2 fix bug 101</span><br><span class="line">e1e9c68 merge with no-ff</span><br><span class="line">f52c633 add merge</span><br><span class="line">cf810e4 conflict fixed</span><br><span class="line">5dc6824 &amp; simple</span><br><span class="line">14096d0 AND simple</span><br><span class="line">b17d20e branch <span class="built_in">test</span></span><br><span class="line">d46f35e remove test.txt</span><br><span class="line">b84166e add test.txt</span><br><span class="line">519219b git tracks changes</span><br><span class="line">e43a48b understand how stage works</span><br><span class="line">1094adb append GPL</span><br><span class="line">e475afc add distributed</span><br><span class="line">eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure><p>比方说要对<code>add merge</code>这次提交打标签，它对应的commit id是<code>f52c633</code>，敲入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v0.9 f52c633</span><br></pre></td></tr></table></figure><p>再用命令<code>git tag</code>查看标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v0.9</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><p><strong>注意，标签不是按时间顺序列出，而是按字母排序的</strong>。可以用<code>git show &lt;tagname&gt;</code>查看标签信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.9</span><br><span class="line">commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:56:54 2018 +0800</span><br><span class="line"></span><br><span class="line">    add merge</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到，<code>v0.9</code>确实打在<code>add merge</code>这次提交上。</p><p>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v0.1 -m <span class="string">"version 0.1 released"</span> 1094adb</span><br></pre></td></tr></table></figure><p>用命令<code>git show &lt;tagname&gt;</code>可以看到说明文字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.1</span><br><span class="line">tag v0.1</span><br><span class="line">Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 22:48:43 2018 +0800</span><br><span class="line"></span><br><span class="line">version 0.1 released</span><br><span class="line"></span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签</strong></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</li><li>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</li><li>命令<code>git tag</code>可以查看所有标签。</li></ul><hr><hr><hr><h2 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h2><p>如果标签打错了，也可以删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.1</span><br><span class="line">Deleted tag <span class="string">'v0.1'</span> (was f15b0dd)</span><br></pre></td></tr></table></figure><p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p><p>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v1.0</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v1.0 -&gt; v1.0</span><br></pre></td></tr></table></figure><p>或者，一次性推送全部尚未推送到远程的本地标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v0.9 -&gt; v0.9</span><br></pre></td></tr></table></figure><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.9</span><br><span class="line">Deleted tag <span class="string">'v0.9'</span> (was f52c633)</span><br></pre></td></tr></table></figure><p>然后，从远程删除。删除命令也是push，但是格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :refs/tags/v0.9</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> - [deleted]         v0.9</span><br></pre></td></tr></table></figure><p>要看看是否真的从远程库删除了标签，可以登陆GitHub查看。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li><li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li><li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li><li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git多人协作</title>
      <link href="/2019/08/11/Git%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C/"/>
      <url>/2019/08/11/Git%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>当你从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。</p><p>要查看远程库的信息，用<code>git remote</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><p>或者，用<code>git remote -v</code>显示更详细的信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure><p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p><h3 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h3><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>如果要推送其他分支，比如<code>dev</code>，就改成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p><ul><li><strong><code>master</code>分支是主分支，因此要时刻与远程同步；</strong></li><li><strong><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</strong></li><li><strong>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</strong></li><li><strong>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</strong></li></ul><p>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p><h3 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h3><p>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。</p><p>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:michaelliao/learngit.git</span><br><span class="line">Cloning into &apos;learngit&apos;...</span><br><span class="line">remote: Counting objects: 40, done.</span><br><span class="line">remote: Compressing objects: 100% (21/21), done.</span><br><span class="line">remote: Total 40 (delta 14), reused 40 (delta 14), pack-reused 0</span><br><span class="line">Receiving objects: 100% (40/40), done.</span><br><span class="line">Resolving deltas: 100% (14/14), done.</span><br></pre></td></tr></table></figure><p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的<code>master</code>分支。不信可以用<code>git branch</code>命令看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>现在，你的小伙伴要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支：</p><p>在，你的小伙伴要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><p>现在，他就可以在<code>dev</code>上继续修改，然后，时不时地把<code>dev</code>分支<code>push</code>到远程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git add env.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">"add env"</span></span><br><span class="line">[dev 7a5e5dd] add env</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 env.txt</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (3/3), 308 bytes | 308.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   f52c633..7a5e5dd  dev -&gt; dev</span><br></pre></td></tr></table></figure><p>你的小伙伴已经向<code>origin/dev</code>分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cat env.txt</span><br><span class="line">env</span><br><span class="line"></span><br><span class="line">$ git add env.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">"add new env"</span></span><br><span class="line">[dev 7bd91f1] add new env</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 env.txt</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> ! [rejected]        dev -&gt; dev (non-fast-forward)</span><br><span class="line">error: failed to push some refs to <span class="string">'git@github.com:michaelliao/learngit.git'</span></span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: <span class="string">'git pull ...'</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">'Note about fast-forwards'</span> <span class="keyword">in</span> <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p>推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，<strong>先用<code>git pull</code></strong>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">There is no tracking information <span class="keyword">for</span> the current branch.</span><br><span class="line">Please specify <span class="built_in">which</span> branch you want to merge with.</span><br><span class="line">See git-pull(1) <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to <span class="built_in">set</span> tracking information <span class="keyword">for</span> this branch you can <span class="keyword">do</span> so with:</span><br><span class="line"></span><br><span class="line">    git branch --<span class="built_in">set</span>-upstream-to=origin/&lt;branch&gt; dev</span><br></pre></td></tr></table></figure><p><code>git pull</code>也失败了，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --<span class="built_in">set</span>-upstream-to=origin/dev dev</span><br><span class="line">Branch <span class="string">'dev'</span> <span class="built_in">set</span> up to track remote branch <span class="string">'dev'</span> from <span class="string">'origin'</span>.</span><br></pre></td></tr></table></figure><p>再pull：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">Auto-merging env.txt</span><br><span class="line">CONFLICT (add/add): Merge conflict <span class="keyword">in</span> env.txt</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure><p>这回<code>git pull</code>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的<a href="http://www.liaoxuefeng.com/wiki/896043488029600/900004111093344" target="_blank" rel="noopener">解决冲突</a>完全一样。解决后，提交，再push：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"fix env conflict"</span></span><br><span class="line">[dev 57c53ab] fix env conflict</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: 6, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (4/4), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 6 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   7a5e5dd..57c53ab  dev -&gt; dev</span><br></pre></td></tr></table></figure><p>因此，多人协作的工作模式通常是这样：</p><ol><li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li></ol><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>查看远程库信息，使用<code>git remote -v</code>；</li><li><strong>本地新建的分支如果不推送到远程，对其他人就是不可见的；</strong></li><li><strong>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</strong></li><li>在<strong>本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</strong></li><li><strong>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</strong></li><li><strong>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git中Feature分支</title>
      <link href="/2019/08/11/Git%E4%B8%ADFeature%E5%88%86%E6%94%AF/"/>
      <url>/2019/08/11/Git%E4%B8%ADFeature%E5%88%86%E6%94%AF/</url>
      
        <content type="html"><![CDATA[<p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p><p><strong>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</strong></p><p>现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。</p><p>于是准备开发：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b feature-vulcan</span><br><span class="line">Switched to a new branch <span class="string">'feature-vulcan'</span></span><br></pre></td></tr></table></figure><p>5分钟后，开发完毕：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git add vulcan.py</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch feature-vulcan</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   vulcan.py</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add feature vulcan&quot;</span><br><span class="line">[feature-vulcan 287773e] add feature vulcan</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 vulcan.py</span><br></pre></td></tr></table></figure><p>切回<code>dev</code>，准备合并：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br></pre></td></tr></table></figure><p>一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。</p><p>但是！就在此时，接到上级命令，因经费不足，新功能必须取消！虽然白干了，但是这个包含机密资料的分支还是必须就地销毁：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d feature-vulcan</span><br><span class="line">error: The branch <span class="string">'feature-vulcan'</span> is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run <span class="string">'git branch -D feature-vulcan'</span>.</span><br></pre></td></tr></table></figure><p>销毁失败。Git友情提醒，<code>feature-vulcan</code>分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的<code>-D</code>参数。。</p><p>现在我们强行删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -D feature-vulcan</span><br><span class="line">Deleted branch feature-vulcan (was 287773e).</span><br></pre></td></tr></table></figure><p>终于删除成功！</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>开发一个新feature，最好新建一个分支；</p><p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git中bug分支</title>
      <link href="/2019/08/11/Git%E4%B8%ADbug%E5%88%86%E6%94%AF/"/>
      <url>/2019/08/11/Git%E4%B8%ADbug%E5%88%86%E6%94%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h2><p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p><p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支<code>issue-101</code>来修复它，但是，等等，当前正在<code>dev</code>上进行的工作还没有提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   hello.py</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br></pre></td></tr></table></figure><p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p><p>幸好，<strong>Git还提供了一个<code>stash</code>功能(该命令需要文件被加入缓存区，即add过后)</strong>，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 先add文件</span></span><br><span class="line">$ git add filename</span><br><span class="line">$ git stash</span><br><span class="line"><span class="comment">## 记录工作目录和索引的当前状态,但是想要返回到干净目录,保存了本地修改,并恢复工作目录</span></span><br><span class="line"><span class="comment">## 以匹配HEAD提交</span></span><br><span class="line">Saved working directory and index state WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure><p>命令介绍</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 查看储藏修改</span></span><br><span class="line">git stash list [&lt;options&gt;]</span><br><span class="line"><span class="comment">### 储藏的列表进行检查</span></span><br><span class="line">git stash show [&lt;stash&gt;]</span><br><span class="line"><span class="comment">### 重新应用储藏</span></span><br><span class="line">git stash ( pop | apply ) [--index] [-q|--quiet] [&lt;stash&gt;]</span><br><span class="line">git stash branch &lt;branchname&gt; [&lt;stash&gt;]</span><br><span class="line"><span class="comment">### git stash相当于git stash save,默认情况下,储藏列表为"分支名称的WIP"</span></span><br><span class="line"><span class="comment">### stash@&#123;0&#125;是最近创建的垃圾邮件,stash@&#123;1&#125;依次内推</span></span><br><span class="line">git stash save [-p|--patch] [-k|--[no-]keep-index] [-q|--quiet]</span><br><span class="line">         [-u|--include-untracked] [-a|--all] [&lt;message&gt;]</span><br><span class="line">git stash [push [-p|--patch] [-k|--[no-]keep-index] [-q|--quiet]</span><br><span class="line">         [-u|--include-untracked] [-a|--all] [-m|--message &lt;message&gt;]]</span><br><span class="line">         [--] [&lt;pathspec&gt;…​]]</span><br></pre></td></tr></table></figure><p>现在，用<code>git status</code>查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p><p><strong>首先确定要在哪个分支上修复bug</strong>，假定需要在<code>master</code>分支上修复，就从<code>master</code>创建临时分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 6 commits.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">$ git checkout -b issue-101</span><br><span class="line">Switched to a new branch <span class="string">'issue-101'</span></span><br></pre></td></tr></table></figure><p>现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"fix bug 101"</span></span><br><span class="line">[issue-101 4c805e2] fix bug 101</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>修复完成后，切换到<code>master</code>分支，并完成合并，最后删除<code>issue-101</code>分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 6 commits.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">$ git merge --no-ff -m <span class="string">"merged bug fix 101"</span> issue-101</span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> readme.txt | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到<code>dev</code>分支干活了！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>工作区是干净的，刚才的工作现场存到哪去了？用<code>git stash list</code>命令看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p><p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p><p><strong>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git stash pop</span><br><span class="line">On branch dev</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   hello.py</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Dropped refs/stash@&#123;0&#125; (5d677e2ee266f39ea296182fb2354265b91b3b2a)</span><br></pre></td></tr></table></figure><p>再用<code>git stash list</code>查看，就看不到任何stash内容了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br></pre></td></tr></table></figure><p>你可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p><p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git rebase命令实战</title>
      <link href="/2019/08/10/Git-rebase%E5%91%BD%E4%BB%A4%E5%AE%9E%E6%88%98/"/>
      <url>/2019/08/10/Git-rebase%E5%91%BD%E4%BB%A4%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p>多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。</p><p>每次合并再push后，分支变成了这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* d1be385 (HEAD -&gt; master, origin/master) init hello</span><br><span class="line">*   e5e69f1 Merge branch <span class="string">'dev'</span></span><br><span class="line">|\  </span><br><span class="line">| *   57c53ab (origin/dev, dev) fix env conflict</span><br><span class="line">| |\  </span><br><span class="line">| | * 7a5e5dd add env</span><br><span class="line">| * | 7bd91f1 add new env</span><br><span class="line">| |/  </span><br><span class="line">* |   12a631b merged bug fix 101</span><br><span class="line">|\ \  </span><br><span class="line">| * | 4c805e2 fix bug 101</span><br><span class="line">|/ /  </span><br><span class="line">* |   e1e9c68 merge with no-ff</span><br><span class="line">|\ \  </span><br><span class="line">| |/  </span><br><span class="line">| * f52c633 add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br></pre></td></tr></table></figure><p>总之看上去很乱，有强迫症的童鞋会问：为什么Git的提交历史不能是一条干净的直线？</p><p>其实是可以做到的！</p><p>Git有一种称为rebase的操作，有人把它翻译成“变基”。</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1216294032394112/l" alt="rebase"></p><p>先不要随意展开想象。我们还是从实际问题出发，看看怎么把分叉的提交变成直线。</p><p>在和远程分支同步后，我们对<code>hello.py</code>这个文件做了两次提交。用<code>git log</code>命令看看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 582d922 (HEAD -&gt; master) add author</span><br><span class="line">* 8875536 add comment</span><br><span class="line">* d1be385 (origin/master) init hello</span><br><span class="line">*   e5e69f1 Merge branch <span class="string">'dev'</span></span><br><span class="line">|\  </span><br><span class="line">| *   57c53ab (origin/dev, dev) fix env conflict</span><br><span class="line">| |\  </span><br><span class="line">| | * 7a5e5dd add env</span><br><span class="line">| * | 7bd91f1 add new env</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注意到Git用<code>(HEAD -&gt; master)</code>和<code>(origin/master)</code>标识出当前分支的HEAD和远程origin的位置分别是<code>582d922 add author</code>和<code>d1be385 init hello</code>，本地分支比远程分支快两个提交。</p><p>现在我们尝试推送本地分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> ! [rejected]        master -&gt; master (fetch first)</span><br><span class="line">error: failed to push some refs to <span class="string">'git@github.com:michaelliao/learngit.git'</span></span><br><span class="line">hint: Updates were rejected because the remote contains work that you <span class="keyword">do</span></span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., <span class="string">'git pull ...'</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">'Note about fast-forwards'</span> <span class="keyword">in</span> <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p>很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (1/1), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">From github.com:michaelliao/learngit</span><br><span class="line">   d1be385..f005ed4  master     -&gt; origin/master</span><br><span class="line"> * [new tag]         v1.0       -&gt; v1.0</span><br><span class="line">Auto-merging hello.py</span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> hello.py | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>再用<code>git status</code>看看状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 3 commits.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。</p><p>用<code>git log</code>看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   e0ea545 (HEAD -&gt; master) Merge branch &apos;master&apos; of github.com:michaelliao/learngit</span><br><span class="line">|\  </span><br><span class="line">| * f005ed4 (origin/master) set exit=1</span><br><span class="line">* | 582d922 add author</span><br><span class="line">* | 8875536 add comment</span><br><span class="line">|/  </span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>对强迫症童鞋来说，现在事情有点不对头，提交历史分叉了。如果现在把本地分支push到远程，有没有问题？不好看。</p><p>这个时候，rebase就派上了用场。我们输入命令<code>git rebase</code>试试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: add comment</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">Mhello.py</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging hello.py</span><br><span class="line">Applying: add author</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">Mhello.py</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging hello.py</span><br></pre></td></tr></table></figure><p>输出了一大堆操作，到底是啥效果？再用<code>git log</code>看看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 7e61ed4 (HEAD -&gt; master) add author</span><br><span class="line">* 3611cfe add comment</span><br><span class="line">* f005ed4 (origin/master) <span class="built_in">set</span> <span class="built_in">exit</span>=1</span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了<code>f005ed4 (origin/master) set exit=1</code>之后，这样，整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的，但是，我们本地的commit修改内容已经变化了，它们的修改不再基于<code>d1be385 init hello</code>，而是基于<code>f005ed4 (origin/master) set exit=1</code>，但最后的提交<code>7e61ed4</code>内容是一致的。</p><p>这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。</p><p>最后，通过push操作把本地分支推送到远程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Mac:~/learngit michael$ git push origin master</span><br><span class="line">Counting objects: 6, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (5/5), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (6/6), 576 bytes | 576.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 6 (delta 2), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (2/2), completed with 1 <span class="built_in">local</span> object.</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   f005ed4..7e61ed4  master -&gt; master</span><br></pre></td></tr></table></figure><p>再用<code>git log</code>看看效果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 7e61ed4 (HEAD -&gt; master, origin/master) add author</span><br><span class="line">* 3611cfe add comment</span><br><span class="line">* f005ed4 <span class="built_in">set</span> <span class="built_in">exit</span>=1</span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>远程分支的提交历史也是一条直线。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><strong>rebase操作可以把本地未push的分叉提交历史整理成直线；</strong></li><li><strong>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git命令总结</title>
      <link href="/2019/08/10/Git%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2019/08/10/Git%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Git命令文档"><a href="#Git命令文档" class="headerlink" title="Git命令文档"></a>Git命令文档</h2><p><img src="https://img-blog.csdnimg.cn/20190811223221553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70" alt="git常用命令"></p><p><img src="https://img-blog.csdnimg.cn/20190811223320138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70" alt="git命令1"></p><p><img src="https://img-blog.csdnimg.cn/20190811223352123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70" alt="git命令2"></p><p><img src="https://img-blog.csdnimg.cn/20190811223417984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70" alt="git命令4"></p><p><img src="https://img-blog.csdnimg.cn/20190811164604560.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20190811223601734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70" alt="git图片3"></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git差异和冲突解决</title>
      <link href="/2019/08/10/Git%E5%B7%AE%E5%BC%82%E5%92%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3/"/>
      <url>/2019/08/10/Git%E5%B7%AE%E5%BC%82%E5%92%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="Git差异和冲突解决"><a href="#Git差异和冲突解决" class="headerlink" title="Git差异和冲突解决"></a>Git差异和冲突解决</h2><h3 id="Git冲突解决"><a href="#Git冲突解决" class="headerlink" title="Git冲突解决"></a>Git冲突解决</h3><p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p><p>准备新的<code>feature1</code>分支，继续我们的新分支开发：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b feature1</span><br><span class="line">Switched to a new branch <span class="string">'feature1'</span></span><br></pre></td></tr></table></figure><p>修改<code>readme.txt</code>最后一行，改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick AND simple.</span><br></pre></td></tr></table></figure><p>在<code>feature1</code>分支上提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">"AND simple"</span></span><br><span class="line">[feature1 14096d0] AND simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>切换到<code>master</code>分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 1 commit.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br></pre></td></tr></table></figure><p>Git还会自动提示我们当前<code>master</code>分支比远程的<code>master</code>分支要超前1个提交。</p><p>在<code>master</code>分支上把<code>readme.txt</code>文件的最后一行改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick &amp; simple.</span><br></pre></td></tr></table></figure><p>提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"&amp; simple"</span></span><br><span class="line">[master 5dc6824] &amp; simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>现在，<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了这样：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919023000423040/0" alt="git-br-feature1"></p><p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge feature1</span><br><span class="line">Auto-merging readme.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> readme.txt</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure><p>果然冲突了！Git告诉我们，<code>readme.txt</code>文件存在冲突，必须手动解决冲突后再提交。<code>git status</code>也可以告诉我们冲突的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 2 commits.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">"git commit"</span>)</span><br><span class="line">  (use <span class="string">"git merge --abort"</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to mark resolution)</span><br><span class="line"></span><br><span class="line">both modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><p>我们可以直接查看readme.txt的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick and simple.</span><br></pre></td></tr></table></figure><p>再提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"conflict fixed"</span></span><br><span class="line">[master cf810e4] conflict fixed</span><br></pre></td></tr></table></figure><p>现在，<code>master</code>分支和<code>feature1</code>分支变成了下图所示：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919023031831104/0" alt="git-br-conflict-merged"></p><p>用带参数的<code>git log</code>也可以看到分支的合并情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   cf810e4 (HEAD -&gt; master) conflict fixed</span><br><span class="line">|\  </span><br><span class="line">| * 14096d0 (feature1) AND simple</span><br><span class="line">* | 5dc6824 &amp; simple</span><br><span class="line">|/  </span><br><span class="line">* b17d20e branch <span class="built_in">test</span></span><br><span class="line">* d46f35e (origin/master) remove test.txt</span><br><span class="line">* b84166e add test.txt</span><br><span class="line">* 519219b git tracks changes</span><br><span class="line">* e43a48b understand how stage works</span><br><span class="line">* 1094adb append GPL</span><br><span class="line">* e475afc add distributed</span><br><span class="line">* eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure><p>最后，删除<code>feature1</code>分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d feature1</span><br><span class="line">Deleted branch feature1 (was 14096d0)</span><br></pre></td></tr></table></figure><h3 id="Git差异比较"><a href="#Git差异比较" class="headerlink" title="Git差异比较"></a>Git差异比较</h3><h4 id="工作目录-vs-暂存区"><a href="#工作目录-vs-暂存区" class="headerlink" title="工作目录 vs 暂存区"></a>工作目录 vs 暂存区</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>意义：查看文件在工作目录与暂存区的差别。如果还没 add 进暂存区，则查看文件自身修改前后的差别。也可查看和另一分支的区别。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff &lt;branch&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure><h4 id="暂存区-vs-Git仓库-–cached-代表进暂存区-即add过后"><a href="#暂存区-vs-Git仓库-–cached-代表进暂存区-即add过后" class="headerlink" title="暂存区 vs Git仓库(–cached :代表进暂存区,即add过后)"></a>暂存区 vs Git仓库(–cached :代表进暂存区,即add过后)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>意义：表示查看已经 add 进暂存区但是尚未 commit 的内容同最新一次 commit 时的内容的差异。 也可以指定仓库版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached &lt;commit&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure><h4 id="工作目录-vs-Git仓库"><a href="#工作目录-vs-Git仓库" class="headerlink" title="工作目录 vs Git仓库"></a>工作目录 vs Git仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;commit&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>意义：查看工作目录同Git仓库指定 commit 的内容的差异。 <code>&lt;commit&gt;</code>=<code>HEAD</code> 时：查看工作目录同最近一次 commit 的内容的差异。</p><h4 id="Git仓库-vs-Git仓库"><a href="#Git仓库-vs-Git仓库" class="headerlink" title="Git仓库 vs Git仓库"></a>Git仓库 vs Git仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;commit&gt; &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>意义：Git仓库任意两次 commit 之间的差别。</p><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>以上命令可以不指定 <code>&lt;filename&gt;</code>，则对全部文件操作。 以上命令涉及和 Git仓库 对比的，均可指定 commit 的版本。</p><ul><li><code>HEAD</code> 最近一次 commit</li><li><code>HEAD^</code>  上次提交</li><li><code>HEAD~100</code> 上100次提交</li><li>每次提交产生的哈希值</li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis Dynamic SQL</title>
      <link href="/2019/08/07/Mybatis-Dynamic-SQL/"/>
      <url>/2019/08/07/Mybatis-Dynamic-SQL/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>钉钉消息推送开发总结</title>
      <link href="/2019/08/07/%E9%92%89%E9%92%89%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
      <url>/2019/08/07/%E9%92%89%E9%92%89%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot中的JSON技术</title>
      <link href="/2019/08/07/Spring-Boot%E4%B8%AD%E7%9A%84JSON%E6%8A%80%E6%9C%AF/"/>
      <url>/2019/08/07/Spring-Boot%E4%B8%AD%E7%9A%84JSON%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>平日里在项目中处理<strong>JSON</strong>一般用的都是阿里巴巴的<strong>Fastjson</strong>，后来发现使用Spring Boot内置的<strong>Jackson</strong>来完成JSON的序列化和反序列化操作也挺方便。Jackson不但可以完成简单的序列化和反序列化操作，也能实现复杂的个性化的序列化和反序列化操作。</p><h3 id="自定义ObjectMapper"><a href="#自定义ObjectMapper" class="headerlink" title="自定义ObjectMapper"></a>自定义ObjectMapper</h3><p>我们都知道，在Spring中使用<code>@ResponseBody</code>注解可以将方法返回的对象序列化成JSON，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"getuser"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setUserName(<span class="string">"mrbird"</span>);</span><br><span class="line">    user.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>User类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6222176558369919436L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问<code>getuser</code>页面输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"userName"</span>:<span class="string">"mrbird"</span>,<span class="attr">"age"</span>:<span class="number">0</span>,<span class="attr">"password"</span>:<span class="literal">null</span>,<span class="attr">"birthday"</span>:<span class="number">1522634892365</span>&#125;</span><br></pre></td></tr></table></figure><p>可看到时间默认以时间戳的形式输出，如果想要改变这个默认行为，我们可以自定义一个<strong>ObjectMapper</strong>来替代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JacksonConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectMapper <span class="title">getObjectMapper</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.setDateFormat(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</span><br><span class="line">        <span class="keyword">return</span> mapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面配置获取了ObjectMapper对象，并且设置了时间格式。再次访问<code>getuser</code>，页面输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;userName&quot;:&quot;mrbird&quot;,&quot;age&quot;:0,&quot;password&quot;:null,&quot;birthday&quot;:&quot;2018-04-02 10:14:24&quot;&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>Jackson通过使用mapper的<code>writeValueAsString</code>方法将Java对象序列化为JSON格式字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ObjectMapper mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"serialization"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUserName(<span class="string">"mrbird"</span>);</span><br><span class="line">        user.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">        String str = mapper.writeValueAsString(user);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>使用<code>@ResponseBody</code>注解可以使对象序列化为JSON格式字符串，除此之外，Jackson也提供了反序列化方法。</p><h4 id="树遍历"><a href="#树遍历" class="headerlink" title="树遍历"></a>树遍历</h4><p>当采用树遍历的方式时，JSON被读入到JsonNode对象中，可以像操作XML DOM那样读取JSON。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ObjectMapper mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"readjsonstring"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">readJsonString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String json = <span class="string">"&#123;\"name\":\"mrbird\",\"age\":26&#125;"</span>;</span><br><span class="line">        JsonNode node = <span class="keyword">this</span>.mapper.readTree(json);</span><br><span class="line">        String name = node.get(<span class="string">"name"</span>).asText();</span><br><span class="line">        <span class="keyword">int</span> age = node.get(<span class="string">"age"</span>).asInt();</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">" "</span> + age;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>readTree</code>方法可以接受一个字符串或者字节数组、文件、InputStream等， 返回<strong>JsonNode</strong>作为根节点，你可以像操作<strong>XML DOM</strong>那样操作遍历<strong>JsonNode</strong>以获取数据。</p><p>解析多级JSON例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String json = <span class="string">"&#123;\"name\":\"mrbird\",\"hobby\":&#123;\"first\":\"sleep\",\"second\":\"eat\"&#125;&#125;"</span>;;</span><br><span class="line">JsonNode node = <span class="keyword">this</span>.mapper.readTree(json);</span><br><span class="line">JsonNode hobby = node.get(<span class="string">"hobby"</span>);</span><br><span class="line">String first = hobby.get(<span class="string">"first"</span>).asText();</span><br></pre></td></tr></table></figure><h4 id="绑定对象"><a href="#绑定对象" class="headerlink" title="绑定对象"></a>绑定对象</h4><p>我们也可以将Java对象和JSON数据进行绑定，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ObjectMapper mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"readjsonasobject"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">readJsonAsObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String json = <span class="string">"&#123;\"name\":\"mrbird\",\"age\":26&#125;"</span>;</span><br><span class="line">        User user = mapper.readValue(json, User.class);</span><br><span class="line">        String name = user.getUserName();</span><br><span class="line">        <span class="keyword">int</span> age = user.getAge();</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">" "</span> + age;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Jackson注解"><a href="#Jackson注解" class="headerlink" title="Jackson注解"></a>Jackson注解</h3><p>Jackson包含了一些实用的注解：</p><h4 id="JsonProperty"><a href="#JsonProperty" class="headerlink" title="@JsonProperty"></a>@JsonProperty</h4><p><code>@JsonProperty</code>，作用在属性上，用来为JSON Key指定一个别名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonProperty</span>(<span class="string">"bth"</span>)<span class="keyword">private</span> Date birthday;</span><br></pre></td></tr></table></figure><p>再次访问<code>getuser</code>页面输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"userName"</span>:<span class="string">"mrbird"</span>,<span class="string">"age"</span>:<span class="number">0</span>,<span class="string">"password"</span>:<span class="keyword">null</span>,<span class="string">"bth"</span>:<span class="string">"2018-04-02 10:38:37"</span>&#125;</span><br></pre></td></tr></table></figure><p>key birthday已经被替换为了bth。</p><h4 id="Jsonlgnore"><a href="#Jsonlgnore" class="headerlink" title="@Jsonlgnore"></a>@Jsonlgnore</h4><p><code>@Jsonlgnore</code>，作用在属性上，用来忽略此属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonIgnoreprivate</span> String password;</span><br></pre></td></tr></table></figure><p>再次访问<code>getuser</code>页面输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"userName"</span>:<span class="string">"mrbird"</span>,<span class="string">"age"</span>:<span class="number">0</span>,<span class="string">"bth"</span>:<span class="string">"2018-04-02 10:40:45"</span>&#125;</span><br></pre></td></tr></table></figure><p>password属性已被忽略。</p><h4 id="JsonIgnoreProperties"><a href="#JsonIgnoreProperties" class="headerlink" title="@JsonIgnoreProperties"></a>@JsonIgnoreProperties</h4><p><code>@JsonIgnoreProperties</code>，忽略一组属性，作用于类上，比如<code>JsonIgnoreProperties({ &quot;password&quot;, &quot;age&quot; })</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonIgnoreProperties</span>(&#123; <span class="string">"password"</span>, <span class="string">"age"</span> &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次访问<code>getuser</code>页面输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"userName"</span>:<span class="string">"mrbird"</span>,<span class="attr">"bth"</span>:<span class="string">"2018-04-02 10:45:34"</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="JsonFormat"><a href="#JsonFormat" class="headerlink" title="@JsonFormat"></a>@JsonFormat</h4><p><code>@JsonFormat</code>，用于日期格式化，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonFormat</span>(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line"><span class="keyword">private</span> Date birthday;</span><br></pre></td></tr></table></figure><h4 id="JsonNaming"><a href="#JsonNaming" class="headerlink" title="@JsonNaming"></a>@JsonNaming</h4><p><code>@JsonNaming</code>，用于指定一个命名策略，作用于类或者属性上。Jackson自带了多种命名策略，你可以实现自己的命名策略，比如输出的key 由Java命名方式转为下面线命名方法 —— userName转化为user-name。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonNaming</span>(PropertyNamingStrategy.LowerCaseWithUnderscoresStrategy.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次访问<code>getuser</code>页面输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"user_name"</span>:<span class="string">"mrbird"</span>,<span class="attr">"bth"</span>:<span class="string">"2018-04-02 10:52:12"</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="JsonSerialize"><a href="#JsonSerialize" class="headerlink" title="@JsonSerialize"></a>@JsonSerialize</h4><p><code>@JsonSerialize</code>，指定一个实现类来自定义序列化。类必须实现<code>JsonSerializer</code>接口，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonGenerator;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JsonSerializer;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.SerializerProvider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserSerializer</span> <span class="keyword">extends</span> <span class="title">JsonSerializer</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(User user, JsonGenerator generator, SerializerProvider provider)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, JsonProcessingException </span>&#123;</span><br><span class="line">        generator.writeStartObject();</span><br><span class="line">        generator.writeStringField(<span class="string">"user-name"</span>, user.getUserName());</span><br><span class="line">        generator.writeEndObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中我们仅仅序列化userName属性，且输出的key是<code>user-name</code>。 使用注解<code>@JsonSerialize</code>来指定User对象的序列化方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonSerialize</span>(using = UserSerializer.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次访问<code>getuser</code>页面输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"user-name"</span>:<span class="string">"mrbird"</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="JsonDeserialize"><a href="#JsonDeserialize" class="headerlink" title="@JsonDeserialize"></a>@JsonDeserialize</h4><p><code>@JsonDeserialize</code>，用户自定义反序列化，同<code>@JsonSerialize</code> ，类需要实现<code>JsonDeserializer</code>接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonParser;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.DeserializationContext;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JsonDeserializer;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JsonNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDeserializer</span> <span class="keyword">extends</span> <span class="title">JsonDeserializer</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">deserialize</span><span class="params">(JsonParser parser, DeserializationContext context)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, JsonProcessingException </span>&#123;</span><br><span class="line">        JsonNode node = parser.getCodec().readTree(parser);</span><br><span class="line">        String userName = node.get(<span class="string">"user-name"</span>).asText();</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUserName(userName);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用注解<code>@JsonDeserialize</code>来指定User对象的序列化方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonDeserialize</span> (using = UserDeserializer.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ObjectMapper mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"readjsonasobject"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">readJsonAsObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String json = <span class="string">"&#123;\"user-name\":\"mrbird\"&#125;"</span>;</span><br><span class="line">        User user = mapper.readValue(json, User.class);</span><br><span class="line">        String name = user.getUserName();</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问<code>readjsonasobject</code>，页面输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mrbird</span><br></pre></td></tr></table></figure><h4 id="JsonView"><a href="#JsonView" class="headerlink" title="@JsonView"></a>@JsonView</h4><p><code>@JsonView</code>，作用在类或者属性上，用来定义一个序列化组。 比如对于User对象，某些情况下只返回userName属性就行，而某些情况下需要返回全部属性。 因此User对象可以定义成如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6222176558369919436L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserNameView</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AllUserFieldView</span> <span class="keyword">extends</span> <span class="title">UserNameView</span> </span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@JsonView</span>(UserNameView.class)</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@JsonView</span>(AllUserFieldView.class)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@JsonView</span>(AllUserFieldView.class)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@JsonView</span>(AllUserFieldView.class)</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>User定义了两个接口类，一个为<code>userNameView</code>，另外一个为<code>AllUserFieldView</code>继承了<code>userNameView</code>接口。这两个接口代表了两个序列化组的名称。属性userName使用了<code>@JsonView(UserNameView.class)</code>，而剩下属性使用了<code>@JsonView(AllUserFieldView.class)</code>。</p><p>Spring中Controller方法允许使用<code>@JsonView</code>指定一个组名，被序列化的对象只有在这个组的属性才会被序列化，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonView</span>(User.UserNameView.class)</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"getuser"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setUserName(<span class="string">"mrbird"</span>);</span><br><span class="line">    user.setAge(<span class="number">26</span>);</span><br><span class="line">    user.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">    user.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问<code>getuser</code>页面输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"userName"</span>:<span class="string">"mrbird"</span>&#125;</span><br></pre></td></tr></table></figure><p>如果将<code>@JsonView(User.UserNameView.class)</code>替换为<code>@JsonView(User.AllUserFieldView.class)</code>，输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"userName"</span>:<span class="string">"mrbird"</span>,<span class="attr">"age"</span>:<span class="number">26</span>,<span class="attr">"password"</span>:<span class="string">"123456"</span>,<span class="attr">"birthday"</span>:<span class="string">"2018-04-02 11:24:00"</span>&#125;</span><br></pre></td></tr></table></figure><p>因为接口<code>AllUserFieldView</code>继承了接口<code>UserNameView</code>所以userName也会被输出。</p><h3 id="集合的反序列化"><a href="#集合的反序列化" class="headerlink" title="集合的反序列化"></a>集合的反序列化</h3><p>在Controller方法中，可以使用<code>＠RequestBody</code>将提交的JSON自动映射到方法参数上，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"updateuser"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(@RequestBody List&lt;User&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面方法可以接受如下一个JSON请求，并自动映射到User对象上：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;<span class="attr">"userName"</span>:<span class="string">"mrbird"</span>,<span class="attr">"age"</span>:<span class="number">26</span>&#125;,&#123;<span class="attr">"userName"</span>:<span class="string">"scott"</span>,<span class="attr">"age"</span>:<span class="number">27</span>&#125;]</span><br></pre></td></tr></table></figure><p><strong>Spring Boot</strong> 能自动识别出<strong>List</strong>对象包含的是<strong>User</strong>类<strong>，因为在方法中定义的泛型的类型会被保留在字节码中，所以Spring Boot能识别List包含的泛型类型从而能正确反序列化。</strong></p><p><strong>有些情况下，集合对象并没有包含泛型定义，如下代码所示，反序列化并不能得到期望的结果。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ObjectMapper mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"customize"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">customize</span><span class="params">()</span> <span class="keyword">throws</span> JsonParseException, JsonMappingException, IOException </span>&#123;</span><br><span class="line">    String jsonStr = <span class="string">"[&#123;\"userName\":\"mrbird\",\"age\":26&#125;,&#123;\"userName\":\"scott\",\"age\":27&#125;]"</span>;</span><br><span class="line">    List&lt;User&gt; list = mapper.readValue(jsonStr, List.class);</span><br><span class="line">    String msg = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">        msg += user.getUserName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问<code>customize</code>，控制台抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassCastException: java.util.LinkedHashMap cannot be cast to com.example.pojo.User</span><br></pre></td></tr></table></figure><p>这是因为在运行时刻，泛型己经被擦除了（不同于方法参数定义的泛型，不会被擦除）。为了提供泛型信息，Jackson提供了JavaType ，用来指明集合类型，将上述方法改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ObjectMapper mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"customize"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">customize</span><span class="params">()</span> <span class="keyword">throws</span> JsonParseException, JsonMappingException, IOException </span>&#123;</span><br><span class="line">    String jsonStr = <span class="string">"[&#123;\"userName\":\"mrbird\",\"age\":26&#125;,&#123;\"userName\":\"scott\",\"age\":27&#125;]"</span>;</span><br><span class="line">    JavaType type = mapper.getTypeFactory().constructParametricType(List.class, User.class);</span><br><span class="line">    List&lt;User&gt; list = mapper.readValue(jsonStr, type);</span><br><span class="line">    String msg = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">        msg += user.getUserName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON </tag>
            
            <tag> Jackson </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git分支管理</title>
      <link href="/2019/08/07/Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"/>
      <url>/2019/08/07/Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Git分支管理"><a href="#Git分支管理" class="headerlink" title="Git分支管理"></a>Git分支管理</h2><p><strong>git branch</strong> 命令不仅仅能创建和删除分支，如果不加任何参数，它会给出当前所有的分支清单。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">  develop</span><br><span class="line">* master</span><br><span class="line">   <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>带 * 表示当前所在分支。使用命令 <strong><em>git branch -v</em></strong> 可以查看各个分支最后一个提交对象的信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -v</span><br><span class="line">  develop ef993bc update About.html</span><br><span class="line">* master  0986092 [ahead 26] update index.html</span><br><span class="line">  <span class="built_in">test</span>    19fffc0 add <span class="built_in">test</span> file</span><br></pre></td></tr></table></figure><p>使用命令 <strong>git branch –merged</strong> 可以查看哪些分支与当前分支进行了合并操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --merged</span><br><span class="line">  develop</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>与之相反的命令为 <strong><em>git branch –no-merged</em></strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --no-merged</span><br><span class="line">  <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>test分支中还包含着尚未合并进来的工作成果，所以简单地用<strong><em>git branch -d</em></strong>删除该分支会提示错误，因为那样做会丢失数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d <span class="built_in">test</span></span><br><span class="line">error: The branch <span class="string">'test'</span> is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run <span class="string">'git branch -D test'</span>.</span><br></pre></td></tr></table></figure><p>Git提示可以用大写的删除选项 -D 强制执行。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git版本回退</title>
      <link href="/2019/08/07/Git%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/"/>
      <url>/2019/08/07/Git%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Git版本回退"><a href="#Git版本回退" class="headerlink" title="Git版本回退"></a>Git版本回退</h2><p>Git中，每次commit提交都会生成一个历史纪录。使用 <strong><em>git log</em></strong> 查看commit历史：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline </span><br><span class="line">ec88247 modifyed bar.html,foo.txt add new.txt</span><br><span class="line">47384c8 modify bar.html <span class="keyword">in</span> <span class="built_in">clone</span> again</span><br><span class="line">31e1f6f modify foo.txt <span class="keyword">in</span> original again</span><br><span class="line">8747b24 Merge branch <span class="string">'master'</span> of /home/mrbird/projects/first-project</span><br><span class="line">27b76ec modify foo.txt <span class="keyword">in</span> original</span><br><span class="line">796e40d modify bar.html <span class="keyword">in</span> <span class="built_in">clone</span></span><br><span class="line">8e1b132 modify foo.txt,add <span class="string">'hello msg'</span></span><br><span class="line">94418b1 add bar.html,modify foo.txt,delete bar.txt</span><br><span class="line">c2e4810 add foo.txt bar.txt</span><br></pre></td></tr></table></figure><p>每个记录都有一个与之对应的<strong>commit id</strong>，所以可以使用命令 <strong><em>git reset –hard commit-id</em></strong>  来回退到相应的版本。除此之卡，在Git中，使用<strong>HEAD</strong>来代表当前版本，如需回退到前一个版本，可以使用命令<code>git reset --hard HEAD^</code>，前两个版本则用<code>HEAD~2</code>表示，以此类推。</p><p>当前版本id为ec88247…比如，现要回退到commit_id为47384c8…的版本，可以使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 47384c8</span><br><span class="line">HEAD is now at 47384c8again modify bar.html <span class="keyword">in</span> <span class="built_in">clone</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD~1</span><br><span class="line">HEAD is now at 47384c8 modify bar.html <span class="keyword">in</span> <span class="built_in">clone</span> again</span><br></pre></td></tr></table></figure><p>再次查看commit历史</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline </span><br><span class="line">47384c8 modify bar.html <span class="keyword">in</span> <span class="built_in">clone</span> again</span><br><span class="line">31e1f6f modify foo.txt <span class="keyword">in</span> original again</span><br><span class="line">8747b24 Merge branch <span class="string">'master'</span> of /home/mrbird/projects/first-project</span><br><span class="line">27b76ec modify foo.txt <span class="keyword">in</span> original</span><br><span class="line">796e40d modify bar.html <span class="keyword">in</span> <span class="built_in">clone</span></span><br><span class="line">8e1b132 modify foo.txt,add <span class="string">'hello msg'</span></span><br><span class="line">94418b1 add bar.html,modify foo.txt,delete bar.txt</span><br><span class="line">c2e4810 add foo.txt bar.txt</span><br></pre></td></tr></table></figure><p>可发现，commit_id为ec88247…的记录已经不见了，如果要回退到这个版本，又忘记了与之对应的commit_id该怎么办呢。这时候可以使用 <strong><em>git reflog</em></strong> 命令来查看操作历史：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">47384c8 HEAD@&#123;0&#125;: reset: moving to 47384c8</span><br><span class="line">ec88247 HEAD@&#123;1&#125;: reset: moving to ec88247</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可看到，回退到commit_id为47384c8…的上一个版本的commit_id为ec88247…，所以，使用如下命令即可回到一开始回退前的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard ec88247</span><br><span class="line">HEAD is now at ec88247 modifyed bar.html,foo.txt add new.txt</span><br></pre></td></tr></table></figure><p>Git回退的三种类型: <code>git reset</code></p><ul><li>git reset –mixed HEAD~1:<strong><code>回退一个版本,且会将暂存区的内容和本地已提交的内容全部恢复到未暂存的状态,不影响原来本地文件(未提交的也不受影响)</code>。</strong></li><li>git reset –soft HEAD~1：<strong><code>回退一个版本,不清空暂存区,将已提交的内容恢复到暂存区,不影响原来本地的文件(未提交的也不受影响)</code></strong></li><li>git reset –hard HEAD~1：<strong><code>回退一个版本,清空暂存区,将已提交的内容的版本恢复到本地,本地的文件也将被恢复的版本替换</code></strong>。<strong>注意,这种方式是改变本地代码仓库源码</strong>。</li></ul><h3 id="Git版本回退：reset和revert的区别和使用场景"><a href="#Git版本回退：reset和revert的区别和使用场景" class="headerlink" title="Git版本回退：reset和revert的区别和使用场景"></a>Git版本回退：reset和revert的区别和使用场景</h3><h4 id="1-未使用git-add缓存代码"><a href="#1-未使用git-add缓存代码" class="headerlink" title="(1):未使用git add缓存代码"></a>(1):未使用git add缓存代码</h4><p>git checkout – filepathname 进行放弃文件修改。</p><p>git checkout . 放弃所有的文件修改。</p><p><code>该命令不会删除掉刚新建的文件。</code></p><h4 id="2-没有push-本地分支版本回退"><a href="#2-没有push-本地分支版本回退" class="headerlink" title="(2):没有push(本地分支版本回退)"></a>(2):没有push(本地分支版本回退)</h4><p><code>这种情况发生在你的本地代码仓库,可能你add ,commit 以后发现代码有点问题,准备取消提交,用到下面命令</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//找到需要回退的版本commit id</span><br><span class="line">git reflog</span><br><span class="line">// 回退版本</span><br><span class="line">git reset [--soft | --mixed | --hard</span><br><span class="line">git reset HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure><h4 id="3-已经push-公共远程分支版本"><a href="#3-已经push-公共远程分支版本" class="headerlink" title="(3):已经push(公共远程分支版本)"></a>(3):已经push(公共远程分支版本)</h4><p>对于已经把代码push到线上仓库,<strong>你回退本地代码其实也想同时回退线上代码,回滚到某个指定的版本,线上,线下代码保持一致</strong>。你要用到下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD //撤销最近一次提交</span><br><span class="line">git revert HEAD~1 //撤销上上次的提交,注意: 数字从0开始。</span><br><span class="line">git revert commit_id //撤销commit_id这次提交</span><br></pre></td></tr></table></figure><p>git revert用于反转提交,执行evert命令时要求<code>工作树必须是干净</code>的.</p><p><code>git revert用一个新提交来消除一个历史提交所做的任何修改.</code></p><p><strong><code>revert 之后你的本地代码会回滚到指定的历史版本</code></strong>,这时你再 git push 既可以把线上的代码更新.(这里不会像reset造成冲突的问题)。</p><p><code>revert 使用,需要先找到你想回滚版本唯一的commit标识代码</code>,可以用 git log 或者在adgit搭建的web环境历史提交记录里查看。通常是前几位即可。</p><p><strong>特别注意</strong>:不要使用下面方式来回滚公共远程分支版本(使用reset+push -f命令)。因为同事的本地分支并没有主动回退。(如果是一个人开发的，可以这样做)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//找到回退的版本</span><br><span class="line">git reflog</span><br><span class="line">git reset --hard HEAD~1(commit_id)</span><br><span class="line">git push -f</span><br></pre></td></tr></table></figure><blockquote><ol><li>revert是撤销一次提交,所以后面的commit id是你需要回滚到的版本的前一次提交。</li><li>使用revert HEAD是撤销最近的一次提交，如果你最近一次提交是用revert命令产生的，那么你再执行一次，就相当于撤销了上次的撤销操作，换句话说，你连续执行两次revert HEAD命令，就跟没执行是一样的。</li><li>使用revert HEAD~1 表示撤销最近2次提交，这个数字是从0开始的，如果你之前撤销过产生了commi id，那么也会计算在内的。</li><li>如果使用 revert 撤销的不是最近一次提交，那么一定会有代码冲突，需要你合并代码，合并代码只需要把当前的代码全部去掉，保留之前版本的代码就可以了。</li></ol></blockquote><h4 id="4-区别"><a href="#4-区别" class="headerlink" title="(4):区别"></a>(4):区别</h4><p><code>git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit</code></p><ul><li><p><code>git reset只是在本地仓库中回退版本，而远程仓库版本不会变化</code>。这样，即使本地reset,但是如果在git pull，</p><p>那么远程仓库内容又会和本地之前版本内容进行merge。</p></li><li><p>上面我们说的如果<code>你已经push到线上代码库, reset 删除指定commit以后,你git push可能导致一大堆冲突</code>。但是revert 并不会。</p></li><li><p>如果在日后现有分支和历史分支需要合并的时候,<code>reset 恢复部分的代码依然会出现在历史分支里</code>。但是revert 方向提交的commit 并不会出现在历史分支里。</p></li><li><p><code>reset 是在正常的commit历史中,删除了指定的commit,这时 HEAD 是向后移动了</code>,而 revert 是在正常的commit历史中再commit一次,只不过是反向提交,他的 HEAD 是一直向前的。</p></li></ul><h4 id="4-实例"><a href="#4-实例" class="headerlink" title="(4):实例"></a>(4):实例</h4><p>下面来看一个revert的使用例子</p><p>创建A.txt 内容为AAAA。然后添加到git</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"A.txt"</span></span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>修改A.txt 添加内容”BBBB”。然后添加到git</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"A.txt add BBBB"</span></span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>此时A.txt文件内容如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AAAA</span><br><span class="line">BBBB</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>此时的提交记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> </span><br><span class="line">---</span><br><span class="line">commit 329515ee5d367bda3effa3e8f0c958e98e93ce31</span><br><span class="line">Author: *****</span><br><span class="line">Date:   Tue Mar 6 19:25:39 2018 +0800</span><br><span class="line"></span><br><span class="line">    A.txt add BBBB</span><br><span class="line"></span><br><span class="line">commit fe0d9b1d7ed0176f542a52835b1923584a4ba060</span><br><span class="line">Author: *****</span><br><span class="line">Date:   Tue Mar 6 19:24:34 2018 +0800</span><br><span class="line"></span><br><span class="line">    A.txt</span><br><span class="line">12345678910111213</span><br></pre></td></tr></table></figure><p>现在我要撤回内容BBBB，如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git revert 329515</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>现在A.txt里的文件内容变为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AAAA</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>再次查看提交记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br><span class="line">---</span><br><span class="line">commit 23880e1f7649b7dca14cfda7553b2ff2e6088d6e</span><br><span class="line">Author: *****</span><br><span class="line">Date:   Tue Mar 6 19:29:35 2018 +0800</span><br><span class="line"></span><br><span class="line">    Revert <span class="string">"A.txt add BBBB"</span></span><br><span class="line"></span><br><span class="line">    This reverts commit 329515ee5d367bda3effa3e8f0c958e98e93ce31.</span><br><span class="line"></span><br><span class="line">commit 329515ee5d367bda3effa3e8f0c958e98e93ce31</span><br><span class="line">Author: *****</span><br><span class="line">Date:   Tue Mar 6 19:25:39 2018 +0800</span><br><span class="line"></span><br><span class="line">    A.txt add BBBB</span><br><span class="line"></span><br><span class="line">commit fe0d9b1d7ed0176f542a52835b1923584a4ba060</span><br><span class="line">Author: *****</span><br><span class="line">Date:   Tue Mar 6 19:24:34 2018 +0800</span><br><span class="line"></span><br><span class="line">    A.txt</span><br><span class="line">123456789101112131415161718192021</span><br></pre></td></tr></table></figure><p>可以看到我们撤回了提交的内容同时增加了一条commit记录。</p><p>如果<code>撤回到之前版本出现冲突</code>怎么办？我们先回到329515版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 329515</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>恢复后在往里面添加内容“CCCC”并提交。<br>此时A.txt文件内容为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AAAA</span><br><span class="line">BBBB</span><br><span class="line">CCCC</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>此时的提交记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> </span><br><span class="line">---</span><br><span class="line">commit f1258438d3b63e78bb747c510f9af3e56be5b3b0</span><br><span class="line">Author: *****</span><br><span class="line">Date:   Tue Mar 6 19:39:20 2018 +0800</span><br><span class="line"></span><br><span class="line">    A.txt add CCCC</span><br><span class="line"></span><br><span class="line">commit 329515ee5d367bda3effa3e8f0c958e98e93ce31</span><br><span class="line">Author: *****</span><br><span class="line">Date:   Tue Mar 6 19:25:39 2018 +0800</span><br><span class="line"></span><br><span class="line">    A.txt add BBBB</span><br><span class="line"></span><br><span class="line">commit fe0d9b1d7ed0176f542a52835b1923584a4ba060</span><br><span class="line">Author: *****</span><br><span class="line">Date:   Tue Mar 6 19:24:34 2018 +0800</span><br><span class="line"></span><br><span class="line">    A.txt</span><br><span class="line">12345678910111213141516171819</span><br></pre></td></tr></table></figure><p>然后我们撤回329515的修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git revert 329515</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>这个时候git提示你有冲突要解决。我们打开A.txt保留parent … 329515这个版本的内容(git add A.txt)，即”AAAA”。并执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git revert --<span class="built_in">continue</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>这个时候git会继续撤回，如果发现冲突会继续提示。此时的提交日志为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">commit 78979e45add34a0f009263e49cc1c6c48a0f93d4</span><br><span class="line">Author: *****</span><br><span class="line">Date:   Tue Mar 6 19:46:40 2018 +0800</span><br><span class="line"></span><br><span class="line">    Revert <span class="string">"A.txt add BBBB"</span></span><br><span class="line"></span><br><span class="line">    This reverts commit 329515ee5d367bda3effa3e8f0c958e98e93ce31.</span><br><span class="line"></span><br><span class="line">commit f1258438d3b63e78bb747c510f9af3e56be5b3b0</span><br><span class="line">Author: *****</span><br><span class="line">Date:   Tue Mar 6 19:39:20 2018 +0800</span><br><span class="line"></span><br><span class="line">    A.txt add CCCC</span><br><span class="line"></span><br><span class="line">commit 329515ee5d367bda3effa3e8f0c958e98e93ce31</span><br><span class="line">Author: *****</span><br><span class="line">Date:   Tue Mar 6 19:25:39 2018 +0800</span><br><span class="line"></span><br><span class="line">    A.txt add BBBB</span><br><span class="line"></span><br><span class="line">commit fe0d9b1d7ed0176f542a52835b1923584a4ba060</span><br><span class="line">Author: *****</span><br><span class="line">Date:   Tue Mar 6 19:24:34 2018 +0800</span><br><span class="line"></span><br><span class="line">    A.txt</span><br><span class="line">12345678910111213141516171819202122232425</span><br></pre></td></tr></table></figure><p>如果不想解决冲突的话可以取消撤回：<code>git revert --abort</code>。</p><h4 id="5-revert合并代码-解决冲突"><a href="#5-revert合并代码-解决冲突" class="headerlink" title="(5):revert合并代码,解决冲突"></a>(5):revert合并代码,解决冲突</h4><p>使用revert命令，如果不是撤销的最近一次提交，那么一定会有冲突，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">全部清空</span><br><span class="line">第一次提交</span><br><span class="line">=======</span><br><span class="line">全部清空</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; parent of c24cde7... 全部清空</span><br></pre></td></tr></table></figure><p>解决冲突很简单，因为我们只想回到某次提交，因此需要把当前最新的代码去掉即可，也就是HEAD标记的代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; </span><br><span class="line">HEAD全部清空</span><br><span class="line">第一次提交</span><br><span class="line">=======</span><br></pre></td></tr></table></figure><p>把上面部分代码去掉就可以了，然后再提交一次代码就可以解决冲突了。</p><h4 id="6-继续扩展-简单扩展的回滚方法"><a href="#6-继续扩展-简单扩展的回滚方法" class="headerlink" title="(6):继续扩展,简单扩展的回滚方法"></a>(6):继续扩展,简单扩展的回滚方法</h4><p>看到这里也许你已经觉得学会了远程仓库版本回滚方法了，但是实践中总是会遇到很多不按套路来的问题，考虑下面一种情况：</p><blockquote><p>如果你们开发中，忽然发现前面很远的地方有一次错误的合并代码，把本来下一次才能发的功能的代码合并到了这一次来了，这个时候全体成员都觉得直接回滚比较快，因为他们都有备份，覆盖了无所谓，这个时候用reset的话对队友的要求比较高，用revert的话呢要大面积的解决冲突，也很麻烦呀，怎么办呢？</p></blockquote><p>这个时候，可以使用简单粗暴的办法，直接从那个错误的提交的前一次拉取一份代码放到其他目录，然后将master代码全部删除，把那份新代码方进去，然后提交，果然简单粗暴啊，虽然这种方法不入流，但是，实践中发现很好使啊，所以，实践是检验真理的唯一标准。遇到问题还是要灵活应对。</p><h4 id="7-撤销文件三种情况"><a href="#7-撤销文件三种情况" class="headerlink" title="(7): 撤销文件三种情况"></a>(7): 撤销文件三种情况</h4><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192" target="_blank" rel="noopener">版本回退</a>一节，不过前提是没有推送到远程库。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git状态跟踪</title>
      <link href="/2019/08/07/Git%E7%8A%B6%E6%80%81%E8%B7%9F%E8%B8%AA/"/>
      <url>/2019/08/07/Git%E7%8A%B6%E6%80%81%E8%B7%9F%E8%B8%AA/</url>
      
        <content type="html"><![CDATA[<h2 id="Git状态跟踪"><a href="#Git状态跟踪" class="headerlink" title="Git状态跟踪"></a>Git状态跟踪</h2><p><strong>对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。</strong></p><p>1.已提交：表示该文件已经被安全地保存在版本库中了。</p><p>2.已修改：表示修改了某个文件，但还没有提交到暂存区。</p><p>3.已暂存：表示把已修改的文件已经放到暂存区了，下次提交时一并被保存到版本库中。</p><h3 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h3><p>要确定哪些文件当前处于什么状态，可以用   <strong>git status</strong> 命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>说明现在的工作目录相当干净，并且当前所在分支为master。</p><p>在当前目录下创建一个<strong>README</strong>文件，然后运行 <strong><em>git status</em></strong> 会看到该文件出现在未跟踪文件列表中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        README</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure><p>未跟踪的文件意味着Git在之前的快照（提交）中没有这些文件。</p><h3 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h3><p>使用命令 <strong><em>git add</em></strong> 开始跟踪文件README：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add README</span><br></pre></td></tr></table></figure><p>再运行 <strong><em>git status</em></strong> 命令，会看到 README 文件已被跟踪，并处于暂存状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   README</span><br></pre></td></tr></table></figure><p>只要在 “Changes to be committed” 这行下面的，就说明是已暂存状态。<code>git add</code> 后面可以指明要跟踪的文件或目录路径。如果是目录的话，就说明要递归跟踪该目录下的所有文件。</p><h3 id="暂存已修改的文件"><a href="#暂存已修改的文件" class="headerlink" title="暂存已修改的文件"></a>暂存已修改的文件</h3><p>修改已跟踪过的文件 README，然后再次运行 <strong><em>git status</em></strong> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   README</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   README</span><br></pre></td></tr></table></figure><p>README文件出现了两次，一次是未暂存，一次是一暂存。如果现在提交的话，那么提交的将是已暂存的README，对README的修改并不会被提交。</p><p>重新运行 <strong>git add</strong> 把最新版本README重新暂存起来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git add README</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   README</span><br></pre></td></tr></table></figure><h4 id="忽略某些文件"><a href="#忽略某些文件" class="headerlink" title="忽略某些文件"></a>忽略某些文件</h4><p><strong>如日志文件，编译缓存文件等没必要纳入Git管理的文件</strong>，我们可以创建一个<strong>.gitignore</strong>文件来将这些文件排除在外。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitignore</span><br><span class="line">*.[oa]</span><br><span class="line">*~</span><br></pre></td></tr></table></figure><p>第一行告诉 Git 忽略所有以 <code>.o</code> 或 <code>.a</code> 结尾的文件。</p><p>第二行告诉 Git 忽略所有以波浪符（~）结尾的文件。</p><p><strong>文件 .gitignore 的格式规范如下：</strong></p><ul><li>所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配（glob指shell简化后的正则表达式）。</li><li>匹配模式最后跟反斜杠（/）说明要忽略的是目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li><li>例子如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 此为注释 – 将被 Git 忽略</span><br><span class="line"># 忽略所有 .a 结尾的文件</span><br><span class="line">*.a</span><br><span class="line"># 但 lib.a 除外</span><br><span class="line">!lib.a</span><br><span class="line"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">/TODO</span><br><span class="line"># 忽略 build/ 目录下的所有文件</span><br><span class="line">build/</span><br><span class="line"># 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br><span class="line"># ignore all .txt files in the doc/ directory</span><br><span class="line">doc/**/*.txt</span><br></pre></td></tr></table></figure><h3 id="查看已暂存和未暂存的更新"><a href="#查看已暂存和未暂存的更新" class="headerlink" title="查看已暂存和未暂存的更新"></a>查看已暂存和未暂存的更新</h3><p>再次修改README文件，但不添加到暂存区。现在README已经修改了两次，第一次添加内容“hello git”并且使用 git add 添加到了暂存区。第二次添加内容“hello world”，但并未添加到暂存区。</p><p>若要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用 <strong><em>git diff –staged</em></strong> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --staged</span><br><span class="line">diff --git a/README b/README</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..8d0e412</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/README</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+hello git</span><br></pre></td></tr></table></figure><p>直接使用 <strong><em>git diff</em></strong> 命令查看已暂存和未暂存文件之间的差异：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/README b/README</span><br><span class="line">index 8d0e412..05fe86c 100644</span><br><span class="line">--- a/README</span><br><span class="line">+++ b/README</span><br><span class="line">@@ -1 +1,2 @@</span><br><span class="line"> hello git</span><br><span class="line">+hello world</span><br></pre></td></tr></table></figure><p>可看到，对于README文件来说，未暂存和已暂存文件相比，添加了一行“hello world”。</p><h3 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h3><p>使用 <strong><em>git commit -m</em></strong> 命令来提交更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &apos;创建README文件，内容为hello git&apos;</span><br><span class="line">[master 1f9882d] 创建README文件，内容为hello git</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 README</span><br></pre></td></tr></table></figure><h3 id="跳过暂存区"><a href="#跳过暂存区" class="headerlink" title="跳过暂存区"></a>跳过暂存区</h3><p>假如你觉得 <strong><em>git add</em></strong> 过程繁琐，可以使用 <strong><em>git commit -a</em></strong> 命令来跳过添加文件到暂存区的步骤，直接提交。</p><p>比如，对于README的第二次修改，我们还未将其添加到暂存区，所以第一次使用 <strong><em>git commit</em></strong> 命令只是提交了对README文件的第一次修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of &apos;origin/master&apos; by 1 commit.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   README</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>使用 <strong><em>git commit -a</em></strong> 命令直接将README文件的第二次修改提交到版本库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -a -m &quot;添加hello world&quot;</span><br><span class="line">[master db06721] 添加hello world</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>移除文件分为两种情况：从版本库和本地工作目录中移除；仅从版本库移除。</p><p>1.从版本库和本地工作目录中移除。使用 <strong><em>git rm</em></strong> 命令来移除README:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git rm README</span><br><span class="line">rm &apos;README&apos;</span><br><span class="line">$ git commit -m &apos;删除README&apos;</span><br><span class="line">[master 99a0462] 删除README</span><br><span class="line"> 1 file changed, 3 deletions(-)</span><br><span class="line"> delete mode 100644 README</span><br></pre></td></tr></table></figure><p>到本地工作目录下查看，会发现README文件已经不存在了。</p><p>这里有种情况，假如README文件还在暂存区并未提交，使用 git rm 命令将会出错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git rm README</span><br><span class="line">error: the following file has changes staged in the index:</span><br><span class="line">    README</span><br><span class="line">(use --cached to keep the file, or -f to force removal)</span><br></pre></td></tr></table></figure><p>Git提示我们使用 <strong><em>git rm -f</em></strong> 命令来删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git rm -f temp.log</span><br><span class="line">rm &apos;temp.log&apos;</span><br></pre></td></tr></table></figure><p>2.仅从版本库移除。</p><p>比如现在不小心将temp.log文件添加并提交到版本库中了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git add temp.log</span><br><span class="line">$ git commit -m &quot;add temp.log&quot;</span><br><span class="line">[master fa31ea5] add temp.log</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 temp.log</span><br></pre></td></tr></table></figure><p>现在想将其从版本库中删除，但并不删除本地文件，而是随后将其添加到.gitignore文件中，可以使用命令 <strong><em>git rm –cached</em></strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git rm --cached  temp.log</span><br><span class="line">rm &apos;temp.log&apos;</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;delete temp.log&quot;</span><br><span class="line">[master e512a82] delete temp.log</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> delete mode 100644 temp.log</span><br></pre></td></tr></table></figure><h3 id="移动文件（重命名）"><a href="#移动文件（重命名）" class="headerlink" title="移动文件（重命名）"></a>移动文件（重命名）</h3><p>git mv 命令用来重命名文件，比如将REAME文件重命名为README.config：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git mv README README.config</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 7 commits.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">        renamed:    README -&gt; README.config</span><br></pre></td></tr></table></figure><p>其过程类似于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv README README.config</span><br><span class="line">$ git rm README</span><br><span class="line">$ git add README.config</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git撤销操作</title>
      <link href="/2019/08/07/Git%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/08/07/Git%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="Git撤销操作"><a href="#Git撤销操作" class="headerlink" title="Git撤销操作"></a>Git撤销操作</h2><h3 id="修改最后一次提交"><a href="#修改最后一次提交" class="headerlink" title="修改最后一次提交"></a>修改最后一次提交</h3><p>如果提交后发现想要修改提交信息，可以直接使用  <strong><em>git commit –amend，</em></strong>使用该命令后，Git会启动文本编辑器，然后可看到上次提交时的说明，编辑它确认没问题后保存退出，就会使用新的提交说明覆盖刚才的提交信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><p>如果刚才提交时忘了暂存某些修改，可以先补上暂存操作，然后再运行 <code>--amend</code> 提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add forgotten_file</span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><h3 id="取消已经暂存的文件"><a href="#取消已经暂存的文件" class="headerlink" title="取消已经暂存的文件"></a>取消已经暂存的文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 8 commits.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   README.config</span><br><span class="line">        modified:   README.md</span><br></pre></td></tr></table></figure><p>使用命令 <strong><em>git reset HEAD README.config</em></strong>  将<strong>README.config</strong>移出暂存区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD README.config</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       README.config</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 8 commits.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">        modified:   README.config</span><br></pre></td></tr></table></figure><p>可看到，README.config已经为Changes not staged for commit状态。</p><h3 id="取消对文件的修改"><a href="#取消对文件的修改" class="headerlink" title="取消对文件的修改"></a>取消对文件的修改</h3><p>将README.config移出暂存区后，可以进一步使用命令，<strong><em>git checkout – README.config</em></strong> 取消对README.config的修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cat README.config</span><br><span class="line">hello</span><br><span class="line"></span><br><span class="line">$ git checkout -- README.config</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 8 commits.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">$ cat README.config</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ListenableFuture的使用心得</title>
      <link href="/2019/08/06/ListenableFuture%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
      <url>/2019/08/06/ListenableFuture%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<h3 id="1-由来"><a href="#1-由来" class="headerlink" title="1.由来"></a>1.由来</h3><p>​    <strong>ListenableFuture是可以监听的Future任务执行情况，是执行成功还是执行失败，并提供响应接口用于对不同结果进行处理。如果异步任务完成自动调用回调函数，减少并发程序复杂度。</strong></p><p>​     <strong>Future以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。</strong>阻塞的方式显然和我们的异步编程的初衷相违背，轮询的方式又会耗费无谓的CPU资源，而且也不能及时地得到计算结果，为什么不能用观察者设计模式当计算结果完成及时通知监听者呢？</p><h3 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2.适用场景"></a>2.适用场景</h3><ul><li>如果一个主任务开始执行，然后需要执行各个小任务，并且需要等待返回结果，统一返回给前端，此时Future和ListenableFuture作用几乎差不多，都是通过get()方法阻塞等待每个任务执行完毕返回。</li><li>如果一个主任务开始执行，然后执行各个小任务，主任务不需要等待每个小任务执行完，不需要每个小任务的结果，此时用ListenableFuture非常合适，它提供的FutureCallBack接口可以对每个任务的成功或失败单独做出响应。</li></ul><h3 id="3-使用示例"><a href="#3-使用示例" class="headerlink" title="3.使用示例"></a>3.使用示例</h3><p>(1):<strong>使用Future示例: 需要阻塞轮训，查看异步任务是否完成。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> denny.zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: FutureDemo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: Future多线程并发任务结果归集</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016年11月4日 下午1:50:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Long start = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//开启多线程</span></span><br><span class="line">        ExecutorService exs = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//结果集</span></span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            List&lt;Future&lt;Integer&gt;&gt; futureList = <span class="keyword">new</span> ArrayList&lt;Future&lt;Integer&gt;&gt;();</span><br><span class="line"><span class="comment">//1.高速提交10个任务，每个任务返回一个Future入list</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                futureList.add(exs.submit(<span class="keyword">new</span> CallableTask(i + <span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            Long getResultStart = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">"结果归集开始时间="</span> + <span class="keyword">new</span> Date());</span><br><span class="line"><span class="comment">//2.结果归集，遍历futureList,高速轮询（模拟实现了并发）获取future状态成功完成后获取结果，退出当前循环</span></span><br><span class="line">            <span class="keyword">for</span> (Future&lt;Integer&gt; future : futureList) &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">//CPU高速轮询：每个future都并发轮循，判断完成状态然后获取结果，这一行，是本实现方案的精髓所在。即有10个future在高速轮询，完成一个future的获取结果，就关闭一个轮询</span></span><br><span class="line">                    <span class="keyword">if</span> (future.isDone() &amp;&amp; !future.isCancelled()) &#123;<span class="comment">//获取future成功完成状态，如果想要限制每个任务的超时时间，取消本行的状态判断+future.get(1000*1, TimeUnit.MILLISECONDS)+catch超时异常使用即可。</span></span><br><span class="line">                        Integer i = future.get();<span class="comment">//获取结果</span></span><br><span class="line">                        System.out.println(<span class="string">"任务i="</span> + i + <span class="string">"获取完成!"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">                        list.add(i);</span><br><span class="line">                        <span class="keyword">break</span>;<span class="comment">//当前future获取结果完毕，跳出while</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1</span>);<span class="comment">//每次轮询休息1毫秒（CPU纳秒级），避免CPU高速轮循耗空CPU---》新手别忘记这个</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"list="</span> + list);</span><br><span class="line">            System.out.println(<span class="string">"总耗时="</span> + (System.currentTimeMillis() - start) + <span class="string">",取结果归集耗时="</span> + (System.currentTimeMillis() - getResultStart));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            exs.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">        Integer i;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CallableTask</span><span class="params">(Integer i)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.i = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);<span class="comment">//任务1耗时3秒</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);<span class="comment">//任务5耗时5秒</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);<span class="comment">//其它任务耗时1秒</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"task线程："</span> + Thread.currentThread().getName() + <span class="string">"任务i="</span> + i + <span class="string">",完成！"</span>);</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2):<strong>使用**</strong>CompletionService，<strong>**任务先完成优先获取到，结果按照任务的完成先后顺序排序。内部通过阻塞队列+FutureTask。</strong></p><p>(3):<strong>使用ListenableFuture，异步任务完成之后进行回调，不用在主线程进行等待</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Guava 和 spring4.0</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestListenableFuture</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> ListeningExecutorService service = MoreExecutors.listeningDecorator(Executors.newCachedThreadPool());</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 任务1</span></span><br><span class="line">        ListenableFuture&lt;Boolean&gt; booleanTask = service.submit(<span class="keyword">new</span> Callable&lt;Boolean&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 增加回调函数</span></span><br><span class="line">        Futures.addCallback(booleanTask, <span class="keyword">new</span> FutureCallback&lt;Boolean&gt;() &#123;</span><br><span class="line">            <span class="comment">// 成功处理</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Boolean result)</span> </span>&#123;</span><br><span class="line">                System.err.println(<span class="string">"BooleanTask: "</span> + result);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 失败处理</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 任务2</span></span><br><span class="line">        ListenableFuture&lt;String&gt; stringTask = service.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-原理分析"><a href="#4-原理分析" class="headerlink" title="4.原理分析"></a>4.原理分析</h3><h5 id="1-Future增加监听机制相关类"><a href="#1-Future增加监听机制相关类" class="headerlink" title="(1):Future增加监听机制相关类"></a>(1):Future增加监听机制相关类</h5><ol><li><strong>ListenableFuture</strong>：增加扩展功能使用，addCallback()方法为了支持增加回调函数</li><li><strong>ListenableFutureCallback：</strong>Future回调函数接口</li><li><strong>ListenableFutureTask</strong>：<strong>FutureTask子类，主要是为了增加回调函数注册和回调函数调用功能。该类重写了done()方法，执行对回调函数队列的调用。</strong></li><li><strong>ListenableFutureCallbackRegistry</strong>：回调函数注册类，调用addCallback()注册ListenableFutureTask<t>。</t></li></ol><h5 id="2-ListenableFutureTask"><a href="#2-ListenableFutureTask" class="headerlink" title="(2):ListenableFutureTask"></a>(2):<strong>ListenableFutureTask</strong></h5><p><strong>该类继承了FutureTask，重写了done()方法。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Extension of &#123;<span class="doctag">@link</span> FutureTask&#125; that implements &#123;<span class="doctag">@link</span> ListenableFuture&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Arjen Poutsma</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenableFutureTask</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">ListenableFuture</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并发编程,尽量使用final关键字,让变量不可变.</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ListenableFutureCallbackRegistry&lt;T&gt; callbacks = <span class="keyword">new</span> ListenableFutureCallbackRegistry&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Create a new &#123;<span class="doctag">@code</span> ListenableFutureTask&#125; that will, upon running,</span></span><br><span class="line"><span class="comment">   * execute the given &#123;<span class="doctag">@link</span> Callable&#125;.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> callable the callable task</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ListenableFutureTask</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(callable);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Create a &#123;<span class="doctag">@code</span> ListenableFutureTask&#125; that will, upon running,</span></span><br><span class="line"><span class="comment">   * execute the given &#123;<span class="doctag">@link</span> Runnable&#125;, and arrange that &#123;<span class="doctag">@link</span> #get()&#125;</span></span><br><span class="line"><span class="comment">   * will return the given result on successful completion.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> runnable the runnable task</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> result the result to return on successful completion</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ListenableFutureTask</span><span class="params">(Runnable runnable, @Nullable T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(runnable, result);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Throwable cause;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 成功</span></span><br><span class="line">      T result = get();</span><br><span class="line">      <span class="keyword">this</span>.callbacks.success(result);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 第一处捕获异常</span></span><br><span class="line">    <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            <span class="comment">// 异常,则中断线程</span></span><br><span class="line">      Thread.currentThread().interrupt();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 第二处捕获异常</span></span><br><span class="line">    <span class="keyword">catch</span> (ExecutionException ex) &#123;</span><br><span class="line">            <span class="comment">// JUC并发异常,需要捕获ExecutionException异常</span></span><br><span class="line">      cause = ex.getCause();</span><br><span class="line">      <span class="keyword">if</span> (cause == <span class="keyword">null</span>) &#123;</span><br><span class="line">        cause = ex;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 第三处捕获异常</span></span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      cause = ex;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 失败添加</span></span><br><span class="line">    <span class="keyword">this</span>.callbacks.failure(cause);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-ListenableFutureCallbackRegistry：回调函数注册类"><a href="#3-ListenableFutureCallbackRegistry：回调函数注册类" class="headerlink" title="(3):ListenableFutureCallbackRegistry：回调函数注册类"></a>(3):ListenableFutureCallbackRegistry：回调函数注册类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenableFutureCallbackRegistry</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;SuccessCallback&lt;? <span class="keyword">super</span> T&gt;&gt; successCallbacks = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;FailureCallback&gt; failureCallbacks = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> State state = State.NEW;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">private</span> Object result;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      互斥锁,控制并发变量,这里需要控制线程执行状态。NEW,SUCCESS,FAILURE</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object mutex = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCallback</span><span class="params">(ListenableFutureCallback&lt;? <span class="keyword">super</span> T&gt; callback)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(callback, <span class="string">"'callback' must not be null"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.mutex) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">this</span>.state) &#123;</span><br><span class="line">        <span class="keyword">case</span> NEW:</span><br><span class="line">          <span class="keyword">this</span>.successCallbacks.add(callback);</span><br><span class="line">          <span class="keyword">this</span>.failureCallbacks.add(callback);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SUCCESS:</span><br><span class="line">          notifySuccess(callback);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FAILURE:</span><br><span class="line">          notifyFailure(callback);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifySuccess</span><span class="params">(SuccessCallback&lt;? <span class="keyword">super</span> T&gt; callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      callback.onSuccess((T) <span class="keyword">this</span>.result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="comment">// Ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyFailure</span><span class="params">(FailureCallback callback)</span> </span>&#123;</span><br><span class="line">    Assert.state(<span class="keyword">this</span>.result <span class="keyword">instanceof</span> Throwable, <span class="string">"No Throwable result for failure state"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      callback.onFailure((Throwable) <span class="keyword">this</span>.result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="comment">// Ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSuccessCallback</span><span class="params">(SuccessCallback&lt;? <span class="keyword">super</span> T&gt; callback)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(callback, <span class="string">"'callback' must not be null"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.mutex) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">this</span>.state) &#123;</span><br><span class="line">        <span class="keyword">case</span> NEW:</span><br><span class="line">          <span class="keyword">this</span>.successCallbacks.add(callback);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SUCCESS:</span><br><span class="line">          notifySuccess(callback);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFailureCallback</span><span class="params">(FailureCallback callback)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(callback, <span class="string">"'callback' must not be null"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.mutex) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">this</span>.state) &#123;</span><br><span class="line">        <span class="keyword">case</span> NEW:</span><br><span class="line">          <span class="keyword">this</span>.failureCallbacks.add(callback);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FAILURE:</span><br><span class="line">          notifyFailure(callback);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">success</span><span class="params">(@Nullable T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.mutex) &#123;</span><br><span class="line">      <span class="keyword">this</span>.state = State.SUCCESS;</span><br><span class="line">      <span class="keyword">this</span>.result = result;</span><br><span class="line">      SuccessCallback&lt;? <span class="keyword">super</span> T&gt; callback;</span><br><span class="line">      <span class="keyword">while</span> ((callback = <span class="keyword">this</span>.successCallbacks.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        notifySuccess(callback);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failure</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.mutex) &#123;</span><br><span class="line">      <span class="keyword">this</span>.state = State.FAILURE;</span><br><span class="line">      <span class="keyword">this</span>.result = ex;</span><br><span class="line">      FailureCallback callback;</span><br><span class="line">      <span class="keyword">while</span> ((callback = <span class="keyword">this</span>.failureCallbacks.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        notifyFailure(callback);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">enum</span> State &#123;NEW, SUCCESS, FAILURE&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5：设计模式运用"><a href="#5：设计模式运用" class="headerlink" title="5：设计模式运用"></a>5：设计模式运用</h2><h4 id="1-适配器模式：FutureAdapter-对象适配器-使用聚合的方式-，ListenableFutureAdapter-类适配器-使用继承的方式-。"><a href="#1-适配器模式：FutureAdapter-对象适配器-使用聚合的方式-，ListenableFutureAdapter-类适配器-使用继承的方式-。" class="headerlink" title="(1):适配器模式：FutureAdapter(对象适配器,使用聚合的方式)，ListenableFutureAdapter(类适配器,使用继承的方式)。"></a>(1):适配器模式：FutureAdapter(对象适配器,使用聚合的方式)，ListenableFutureAdapter(类适配器,使用继承的方式)。</h4><p><strong>对象适配器：**</strong>FutureAdapter**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureAdapter</span>&lt;<span class="title">T</span>, <span class="title">S</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Future&lt;S&gt; adaptee;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">private</span> Object result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> State state = State.NEW;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object mutex = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructs a new &#123;<span class="doctag">@code</span> FutureAdapter&#125; with the given adaptee.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> adaptee the future to delegate to</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">FutureAdapter</span><span class="params">(Future&lt;S&gt; adaptee)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(adaptee, <span class="string">"Delegate must not be null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the adaptee.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Future&lt;S&gt; <span class="title">getAdaptee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.adaptee;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> T <span class="title">adaptInternal</span><span class="params">(S adapteeResult)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.mutex) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">this</span>.state) &#123;</span><br><span class="line">        ...</span><br><span class="line">                ...</span><br><span class="line">                ...</span><br><span class="line">        <span class="keyword">case</span> NEW:</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            T adapted = adapt(adapteeResult);</span><br><span class="line">            <span class="keyword">this</span>.result = adapted;</span><br><span class="line">            <span class="keyword">this</span>.state = State.SUCCESS;</span><br><span class="line">            <span class="keyword">return</span> adapted;</span><br><span class="line">          &#125;</span><br><span class="line">          ...</span><br><span class="line">                    ...</span><br><span class="line">                    ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Adapts the given adaptee's result into T.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the adapted result</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title">adapt</span><span class="params">(S adapteeResult)</span> <span class="keyword">throws</span> ExecutionException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类适配器：**</strong>ListenableFutureAdapter**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenableFutureAdapter</span>&lt;<span class="title">T</span>, <span class="title">S</span>&gt; <span class="keyword">extends</span> <span class="title">FutureAdapter</span>&lt;<span class="title">T</span>, <span class="title">S</span>&gt; <span class="keyword">implements</span> <span class="title">ListenableFuture</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Construct a new &#123;<span class="doctag">@code</span> ListenableFutureAdapter&#125; with the given adaptee.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> adaptee the future to adapt to</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">ListenableFutureAdapter</span><span class="params">(ListenableFuture&lt;S&gt; adaptee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(adaptee);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCallback</span><span class="params">(<span class="keyword">final</span> SuccessCallback&lt;? <span class="keyword">super</span> T&gt; successCallback, <span class="keyword">final</span> FailureCallback failureCallback)</span> </span>&#123;</span><br><span class="line">    ListenableFuture&lt;S&gt; listenableAdaptee = (ListenableFuture&lt;S&gt;) getAdaptee();</span><br><span class="line">    listenableAdaptee.addCallback(<span class="keyword">new</span> ListenableFutureCallback&lt;S&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(@Nullable S result)</span> </span>&#123;</span><br><span class="line">        T adapted = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            adapted = adaptInternal(result);</span><br><span class="line">          &#125;</span><br><span class="line">          ...</span><br><span class="line">                    ...</span><br><span class="line">                    ...</span><br><span class="line">        &#125;</span><br><span class="line">        successCallback.onSuccess(adapted);</span><br><span class="line">      &#125;</span><br><span class="line">            </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">        failureCallback.onFailure(ex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Guava </tag>
            
            <tag> Spring </tag>
            
            <tag> 并发 </tag>
            
            <tag> ListenableFuture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lamdba表达式学习(Java8)</title>
      <link href="/2019/08/06/Lamdba%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0-Java8/"/>
      <url>/2019/08/06/Lamdba%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0-Java8/</url>
      
        <content type="html"><![CDATA[<h2 id="1：lamdba语法"><a href="#1：lamdba语法" class="headerlink" title="1：lamdba语法"></a>1：lamdba语法</h2><p>java8新增了一个操作符-&gt;，称为lambda操作符或箭头操作符，它将lambda表达式分为两部分，箭头之前的是参数，箭头之后的是动作。例如：</p><blockquote><p>(Integer n1,Integer n2) -&gt; n1 + n2</p></blockquote><p>这个就相当于</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function">Integer <span class="title">method</span><span class="params">(Integer n1, Integer n2)</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">return</span> n1 + n2;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>参数类型可以忽略，可以推断出来。</p><blockquote><p>(n1,n2) -&gt; n1 + n2</p></blockquote><p>如果只有一个参数的话，圆括号也可以省略，像这样</p><blockquote><p>n1 -&gt; n1 * n1</p></blockquote><p>如果没有参数，如下所示：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; () -&gt; <span class="number">5</span>; <span class="comment">//固定返回5</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>箭头符号右侧是动作，除了我们看到的这种单行的形式之外，还可以声明一个代码段作为动作，像下面这样</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; n -&gt; &#123;</span><br><span class="line">&gt;     <span class="keyword">return</span> n * n;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>这个代码段可以写的很长很长。如果有返回值的话，需要使用return语句返回。</p><h2 id="2-函数接口-FunctionInterface"><a href="#2-函数接口-FunctionInterface" class="headerlink" title="2:函数接口: FunctionInterface"></a>2:函数接口: FunctionInterface</h2><p>在java中，lambda表达式一定要结合functional interface来使用，functional interface是指一个只包含一个抽象方法的接口，可以包含默认实现<strong>default</strong>。下面来看一个例子。这是一个functional interface：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs this operation on the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the input argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed &#123;<span class="doctag">@code</span> Consumer&#125; that performs, in sequence, this</span></span><br><span class="line"><span class="comment">     * operation followed by the &#123;<span class="doctag">@code</span> after&#125; operation. If performing either</span></span><br><span class="line"><span class="comment">     * operation throws an exception, it is relayed to the caller of the</span></span><br><span class="line"><span class="comment">     * composed operation.  If performing this operation throws an exception,</span></span><br><span class="line"><span class="comment">     * the &#123;<span class="doctag">@code</span> after&#125; operation will not be performed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> after the operation to perform after this operation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed &#123;<span class="doctag">@code</span> Consumer&#125; that performs in sequence this</span></span><br><span class="line"><span class="comment">     * operation followed by the &#123;<span class="doctag">@code</span> after&#125; operation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> after&#125; is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-变量捕获"><a href="#3-变量捕获" class="headerlink" title="3:变量捕获"></a>3:变量捕获</h3><p>说到lambda表达式，有一个话题是绕不开的，就是<strong>闭包</strong>。但这个问题在java中被简化了好多。这个问题可以分为两种情况来讨论：</p><ol><li>lambda表达式可以访问到所在的类中定义的字段(filed)，也可以修改这个字段。</li><li>lambda表达式可以访问到外层代码块(enclosing scope)中定义的局部变量(local varable)，但不能修改他们，并且，<strong>如果一个局部变量在lambda表达式中被读取的话，这个变量必须是final或事实上final</strong>（变量赋值以后就不能再任何地方再修改了）。<strong>如果在匿名类或 Lambda 表达式中访问的局部变量，如果不是 final 类型的话，编译器自动加上 final 修饰符。</strong></li><li><strong>为什么 Lambda 表达式(匿名类) 不能访问非 final 的局部变量呢？</strong></li></ol><blockquote><p><strong>因为实例变量存在堆中，而局部变量是在栈上分配，Lambda 表达(匿名类) 会在另一个线程中执行。如果在线程中要直接访问一个局部变量，可能线程执行时该局部变量已经被销毁了，而 final 类型的局部变量在 Lambda 表达式(匿名类) 中其实是局部变量的一个拷贝。</strong> </p></blockquote><p>  4.局部变量类型</p><p>   <strong>(1):对象类型，则对象的引用地址不可改变。</strong></p><p>  <strong>(2):基本类型,，则对象的值不能改变。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> filed1 = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> varable1 = <span class="number">10</span>;</span><br><span class="line">        MyInterface myInterface = n -&gt; &#123;</span><br><span class="line">            filed1 += <span class="number">2</span>;  <span class="comment">//可读取，可修改</span></span><br><span class="line">            <span class="keyword">int</span> m = varable1;  <span class="comment">//可读取</span></span><br><span class="line">            <span class="comment">//varable1 += 2;  //不可修改</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//varable1 += 2;    //已经在lambda表达式中被读取了，就是final了，不能被修改。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-方法引用"><a href="#4-方法引用" class="headerlink" title="4:方法引用"></a>4:方法引用</h3><p><strong>lambda表达式的本质是一个匿名方法</strong>，但如果有一个方法的签名（参数列表和返回值）和functional interface的签名一样并且逻辑正好是你需要的，那么你可以使用方法引用的方式来将它赋值给你的functional interface，而无需再编写lambda表达式。</p><p><strong>方法引用类型：</strong></p><ul><li>静态方法: 语法: <strong>ClassName::methodName</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myInterface = MyClass::staticMethod;</span><br><span class="line">myInterface.doSomething(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><ul><li>实例方法: 语法:  <strong>instance::methodName</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">myInterface = myClass::instanceMethod;</span><br><span class="line">myInterface.doSomething(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><ul><li>泛型方法: 语法：<strong>instace::<t>methodNam</t></strong>e</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">myInterface = myClass::&lt;integer&gt;genericMethod;</span><br><span class="line">myInterface.doSomething(5);&lt;/integer&gt;</span><br></pre></td></tr></table></figure><ul><li></li><li><p>构造方法: 语法: <strong>ClassName::new</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    String msg1, msg2;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">(String msg1, String msg2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg1 = msg1;</span><br><span class="line">        <span class="keyword">this</span>.msg2 = msg2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FooInterface</span> </span>&#123;</span><br><span class="line">    <span class="function">Foo <span class="title">fooMethod</span><span class="params">(String m1, String m2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FooInterface fooInterface = Foo::<span class="keyword">new</span>;</span><br><span class="line">Foo fooObj = fooInterface.fooMethod(<span class="string">"hello"</span>, <span class="string">"world"</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> lamdba </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot配置篇</title>
      <link href="/2019/08/06/Spring-Boot%E9%85%8D%E7%BD%AE%E7%AF%87/"/>
      <url>/2019/08/06/Spring-Boot%E9%85%8D%E7%BD%AE%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1:概述"></a>1:概述</h3><p>SpringBoot支持外部化配置,配置文件格式如下所示:</p><ul><li>properties files</li><li>yaml files</li><li>environment variables</li><li>command-line arguments</li></ul><p>使用外部化配置方式:</p><ul><li>@Value注解</li><li>Environment抽象(Spring环境接口抽象)</li><li>@ConfigurationProperties</li><li>PropertySource(文件属性抽象)</li></ul><p>2:自定义属性</p><p>POM内容如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--生成spring-configuration-metadata.json文件,提示属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当使用Spring Boot开发项目时,Spring Boot会默认读取classpath下application.properties</p><p>application.yml文件,详情请查看源码ConfigFileApplicationListener。这种自定义少量</p><p>属性常常通过@Value注解进行加载,但是@Value所在类必须在Spring IOC容器中。</p><p>application.yml自定义属性</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hello:</span></span><br><span class="line"><span class="attr">  user:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">"刘恩源"</span></span><br></pre></td></tr></table></figure><p>读取该属性常常通过@Value注解进行读取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloUser</span> </span>&#123;</span><br><span class="line"><span class="comment">//hello.user.name:default==&gt;&gt;表示当时该属性在</span></span><br><span class="line">    <span class="comment">//spring Environment没有找到取默认值default</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;hello.user.name:default&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类描述: spring boot config</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/6/16 11:36</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.annotation.Value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.annotation.PropertySource</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.boot.context.properties.ConfigurationProperties</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.boot.context.properties.EnableConfigurationProperties</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.core.env.Environment</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.annotation.Profile</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.support.PropertySourcesPlaceholderConfigurer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(ConfigApplication.class, args);</span><br><span class="line">        HelloUser helloUser = context.getBean(HelloUser.class);</span><br><span class="line">        System.out.println(String.format(<span class="string">"通过@Value注解读取自定义的少量属性: %s"</span>, helloUser.getUserName()));</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Value注解注入使用情况</p><p>转载自:<a href="https://www.cnblogs.com/wangbin2188/p/9014837.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangbin2188/p/9014837.html</a> </p><ul><li><p>注入普通字符串</p></li><li><p>注入操作系统属性</p></li><li><p>注入表达式结果</p></li><li><p>注入其他Bean属性</p></li><li><p>注入文件资源</p></li><li><p>注入URL资源</p></li><li><p>注入${…}来处理placeholder。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"normal"</span>)</span><br><span class="line"><span class="keyword">private</span> String normal; <span class="comment">// 注入普通字符串</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"#&#123;systemProperties['os.name']&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String systemPropertiesName; <span class="comment">// 注入操作系统属性</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"#&#123; T(java.lang.Math).random() * 100.0 &#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> randomNumber; <span class="comment">//注入表达式结果</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"#&#123;beanInject.another&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String fromAnotherBean; <span class="comment">// 注入其他Bean属性：注入beanInject对象的属性another，类具体定义见下面</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"classpath:com/hry/spring/configinject/config.txt"</span>)</span><br><span class="line"><span class="keyword">private</span> Resource resourceFile; <span class="comment">// 注入文件资源</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line"><span class="keyword">private</span> Resource testUrl; <span class="comment">// 注入URL资源</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-将配置文件属性赋给实体类"><a href="#3-将配置文件属性赋给实体类" class="headerlink" title="3:将配置文件属性赋给实体类"></a>3:将配置文件属性赋给实体类</h3><p>当有许多配置属性(建议超过5这样),可以将这些属性作为字段来创建一个JavaBean,并将属性赋给他们。例如</p><p>在application.yml配置属性如下:</p><pre><code>person:  name: &quot;刘恩源&quot;  age: 21  school: &quot;天津师范大学&quot;</code></pre><p>配置属性类PersonProperties</p><p>@ConfigurationProperties注解是将properties配置文件转换为bean使用,默认是将application.yml</p><p>或者application.properties属性转换成bean使用。@PropertySource只支持properties结尾的文件。</p><p>@EnableConfigurationProperties注解的作用是@ConfigurationProperties注解生效,并将属性</p><p>配置类注册到Spring IOC容器中。 如果需要加载指定配置文件,可以使用@PropertySource注解。    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String school;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;PersonProperties.class&#125;)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PersonProperties personProperties;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonConfiguration</span><span class="params">(PersonProperties personProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.personProperties = personProperties;</span><br><span class="line">        System.out.println(String.format(<span class="string">"PersonProperties: %s"</span>, <span class="keyword">this</span>.personProperties));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PersonProperties <span class="title">getPersonProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> personProperties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-自定义配置文件"><a href="#4-自定义配置文件" class="headerlink" title="4:自定义配置文件"></a>4:自定义配置文件</h3><p>上面介绍了读取默认配置文件application.yml|application.properties中的配置属性。当然,我们也可以读取</p><p>自定义的配置文件中属性。目前官方使用@PropertySource注解导入自定义的配置文件属性。</p><p>建立hello.properties</p><pre><code>#load config propertiesperson.name=刘恩源person.age=20person.school=天津师范大学</code></pre><p>建立PersonProperties.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立声明加载properties配置文件的encoding和name</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@PropertySource</span>(value = &#123;<span class="string">"classpath:/hello.properties"</span>&#125;, encoding = <span class="string">"UTF-8"</span>, name = <span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String school;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立PersonConfiguration,使用@EnableConfigurationProperties激活@ConfigurationProperties</p><p>注解,将其标注的JavaBean注入到Spring IOC容器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;PersonProperties.class&#125;)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PersonProperties personProperties    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonConfiguration</span><span class="params">(PersonProperties personProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.personProperties = personProperties;</span><br><span class="line">        System.out.println(String.format(<span class="string">"PersonProperties: %s"</span>, <span class="keyword">this</span>.personProperties));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PersonProperties <span class="title">getPersonProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> personProperties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载指定yml|yaml文件</p><p>配置如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YamlPropertiesConfiguration</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PropertySourcesPlaceholderConfigurer <span class="title">properties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PropertySourcesPlaceholderConfigurer configurer = <span class="keyword">new</span> PropertySourcesPlaceholderConfigurer();</span><br><span class="line">        YamlPropertiesFactoryBean yml = <span class="keyword">new</span> YamlPropertiesFactoryBean();</span><br><span class="line">        yml.setResources(<span class="keyword">new</span> ClassPathResource(<span class="string">"/hello.yml"</span>));</span><br><span class="line">        configurer.setProperties(yml.getObject());</span><br><span class="line">        <span class="keyword">return</span> configurer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以参照我实现的自定义注解@YmlPropertySource,加载yml|yaml文件,可以大致实现和@PropertySource</p><p>注解同样的功能。</p><p>@YmlPropertySource实现加载yml|yaml文件</p><h3 id="5-多环境配置"><a href="#5-多环境配置" class="headerlink" title="5:多环境配置"></a>5:多环境配置</h3><p>在企业开发环境中,需要不同的配置环境.SpringBoot使用spring.profiles.active属性加载不同环境的配置文件,配置文件格式为application-{profile}.properties|yml|yaml。{profile}对应环境标识。</p><ul><li>application-test.yml:测试环境</li><li>application-dev.yml:开发环境</li><li>application.prod:生产环境</li></ul><p>可以在springboot默认配置文件application.yml通过配置spring.profiles.active激活环境。也可以在</p><p>特定的类使用@Profile注解激活环境。该注解可以使用逻辑运算符。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Spring </tag>
            
            <tag> 外部化配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强大JSON解析工具gson</title>
      <link href="/2019/08/06/%E5%BC%BA%E5%A4%A7JSON%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7gson/"/>
      <url>/2019/08/06/%E5%BC%BA%E5%A4%A7JSON%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7gson/</url>
      
        <content type="html"><![CDATA[<h2 id="1-GsonUtils工具类"><a href="#1-GsonUtils工具类" class="headerlink" title="1:GsonUtils工具类"></a>1:GsonUtils工具类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * google json utils</span></span><br><span class="line"><span class="comment"> * **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GsonUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATE_FORMAT=<span class="string">"yyyy-MM-dd HH:mm:ss"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get google json</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Gson</span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Gson <span class="title">getGson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> GsonBuilder()).serializeNulls().setDateFormat(GsonUtils.DATE_FORMAT).create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * object to json</span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toJson</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getGson().toJson(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * json to type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Gson#toJson(Object, Type)</span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toJson</span><span class="params">(Object obj, Type type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getGson().toJson(obj, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * generic t to json</span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">String <span class="title">t2Json</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getGson().toJson(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * json to generic t</span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">json2T</span><span class="params">(String jsonString, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getGson().fromJson(jsonString, clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * json to collection</span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">json2Collection</span><span class="params">(String jsonStr, Type type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (List&lt;T&gt;) getGson().fromJson(jsonStr, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * json to type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Gson#fromJson(String, Type)</span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">fromJson</span><span class="params">(String jsonStr, Type type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getGson().fromJson(jsonStr, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * json to class type</span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">fromJson</span><span class="params">(String jsonStr, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getGson().fromJson(jsonStr, clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="1-java-bean对象转换成json"><a href="#1-java-bean对象转换成json" class="headerlink" title="1:java bean对象转换成json"></a>1:java bean对象转换成json</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实体类</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBean2Json</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(GsonUtils.toJson(<span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"王旭"</span>, <span class="number">22</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-List对象转换成json"><a href="#2-List对象转换成json" class="headerlink" title="2:List对象转换成json"></a>2:List对象转换成json</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//方法1</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBeanList2Json</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(GsonUtils.toJson(Arrays.asList(</span><br><span class="line">               <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"王旭"</span>, <span class="number">22</span>),</span><br><span class="line">               <span class="keyword">new</span> User(<span class="number">2</span>, <span class="string">"王旭1"</span>, <span class="number">23</span>),</span><br><span class="line">               <span class="keyword">new</span> User(<span class="number">3</span>, <span class="string">"王旭2"</span>, <span class="number">24</span>)</span><br><span class="line">               )</span><br><span class="line">       ));</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//方法2,指定具体的泛型</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBeanList2Json2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(GsonUtils.toJson(Arrays.asList(</span><br><span class="line">               <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"王旭"</span>, <span class="number">22</span>),</span><br><span class="line">               <span class="keyword">new</span> User(<span class="number">2</span>, <span class="string">"王旭1"</span>, <span class="number">23</span>),</span><br><span class="line">               <span class="keyword">new</span> User(<span class="number">3</span>, <span class="string">"王旭2"</span>, <span class="number">24</span>)</span><br><span class="line">       ), <span class="keyword">new</span> TypeToken&lt;List&lt;User&gt;&gt;() &#123;</span><br><span class="line">       &#125;.getType()));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="3-Map对象转换成json"><a href="#3-Map对象转换成json" class="headerlink" title="3:Map对象转换成json"></a>3:Map对象转换成json</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, User&gt; userMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    userMap.put(<span class="string">"1"</span>, <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"王旭"</span>, <span class="number">22</span>));</span><br><span class="line">    userMap.put(<span class="string">"2"</span>, <span class="keyword">new</span> User(<span class="number">2</span>, <span class="string">"王旭"</span>, <span class="number">23</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMap2Json</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(GsonUtils.toJson(userMap));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Json转成java-bean对象"><a href="#4-Json转成java-bean对象" class="headerlink" title="4:Json转成java bean对象"></a>4:Json转成java bean对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJson2Bean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = GsonUtils.fromJson(<span class="string">"&#123;\"id\":1,\"name\":\"王旭\",\"age\":22&#125;"</span>, User.class);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Json转成List对象"><a href="#5-Json转成List对象" class="headerlink" title="5:Json转成List对象"></a>5:Json转成List对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TypeToken用来获取转换出来的泛型类型,如果转换成泛型请使用该类</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJson2List</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       String jsonList = <span class="string">"[&#123;\"id\":1,\"name\":\"王旭\",\"age\":22&#125;,&#123;\"id\":2,\"name\":\"王旭1\",\"age\":23&#125;,&#123;\"id\":3,\"name\":\"王旭2\",\"age\":24&#125;]"</span>;</span><br><span class="line">       List&lt;User&gt; userList = GsonUtils.fromJson(jsonList, <span class="keyword">new</span> TypeToken&lt;List&lt;User&gt;&gt;() &#123;</span><br><span class="line">       &#125;.getType());</span><br><span class="line">       System.out.println(userList);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="6-Json转成map对象"><a href="#6-Json转成map对象" class="headerlink" title="6:Json转成map对象"></a>6:Json转成map对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其中,使用TypeToken可以将json转换成对应的Java类型</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJson2Map</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       TypeToken&lt;Map&lt;String, User&gt;&gt; typeToken = <span class="keyword">new</span> TypeToken&lt;Map&lt;String, User&gt;&gt;() &#123;</span><br><span class="line">       &#125;;</span><br><span class="line">       Map&lt;String, User&gt; map = GsonUtils.fromJson(<span class="string">"&#123;\"1\":&#123;\"id\":1,\"name\":\"王旭\",\"age\":22&#125;,\"2\":&#123;\"id\":2,\"name\":\"王旭\",\"age\":23&#125;&#125;"</span>,</span><br><span class="line">               typeToken.getType());</span><br><span class="line">       System.out.println(map);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在转换json的时候</span></span><br><span class="line"><span class="comment">//第一步:知道json是什么构造的</span></span><br><span class="line"><span class="comment">//第二步:转换出相应的Java类型</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJson2Map</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       TypeToken&lt;TreeMap&lt;String, User&gt;&gt; typeToken = <span class="keyword">new</span> TypeToken&lt;TreeMap&lt;String, User&gt;&gt;() &#123;</span><br><span class="line">       &#125;;</span><br><span class="line">       TreeMap&lt;String, User&gt; map = GsonUtils.fromJson(<span class="string">"&#123;\"1\":&#123;\"id\":1,\"name\":\"王旭\",\"age\":22&#125;,\"2\":&#123;\"id\":2,\"name\":\"王旭\",\"age\":23&#125;&#125;"</span>,</span><br><span class="line">               typeToken.getType());</span><br><span class="line">       <span class="keyword">for</span> (Map.Entry&lt;String, User&gt; entry : map.entrySet()) &#123;</span><br><span class="line">           System.out.println(entry.getKey()+<span class="string">":"</span>+entry.getValue());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> json </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gson </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Request header is too large 的问题解决</title>
      <link href="/2019/08/06/Request-header-is-too-large-%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/2019/08/06/Request-header-is-too-large-%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="1-问题原因"><a href="#1-问题原因" class="headerlink" title="1:问题原因:"></a>1:问题原因:</h2><blockquote><p>后台接受前台传入的内容字符串,由于内容字符串太大,导致打印台报错.</p></blockquote><p><strong>1-1:错误描述:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: Request header is too large</span><br><span class="line">    at org.apache.coyote.http11.Http11InputBuffer.fill(Http11InputBuffer.java:<span class="number">701</span>)</span><br><span class="line">    at org.apache.coyote.http11.Http11InputBuffer.parseRequestLine(Http11InputBuffer.java:<span class="number">455</span>)</span><br><span class="line">    at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:<span class="number">667</span>)</span><br><span class="line">    at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:<span class="number">66</span>)</span><br><span class="line">    at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:<span class="number">798</span>)</span><br><span class="line">    at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:<span class="number">1434</span>)</span><br><span class="line">    at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:<span class="number">49</span>)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1142</span>)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">617</span>)</span><br><span class="line">    at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:<span class="number">61</span>)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></figure><p><strong>1-2:解决方案(服务器容器:tomcat):</strong></p><blockquote><p>1:请求头超过了tomcat的限值。本来post请求是没有参数大小限制，但是服务器有自己的默认大小。<br>2:配置 tomcat的server.xml文件,增加请求字段长度</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</span><br><span class="line">               connectionTimeout=&quot;20000&quot;</span><br><span class="line">               redirectPort=&quot;8443&quot; maxHttpHeaderSize=&quot;102400&quot; maxPostSize=&quot;0&quot;  </span><br><span class="line">               URIEncoding=&quot;UTF-8&quot;/&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>增加maxHttpHeaderSize参数配置,当maxPostSize=0时,表示不限制.</strong></p></blockquote><p><strong>1-3:SpringBoot项目:</strong></p><blockquote><p>在application.yml文件中,配置<strong>server.max-http-header-size=102400</strong>参数,即可改变内嵌tomcat容器的最大头大小.</p></blockquote><p><strong>1-4:详细错误原因:</strong></p><blockquote><p>在tomcat的org.apache.coyote.http11.AbstractHttp11Protocol类中定义了其默认值: </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Maximum size of the HTTP message header.</span><br><span class="line"> */</span><br><span class="line">private int maxHttpHeaderSize = 8 * 1024;</span><br><span class="line">//所以当请求头大于8*1024时,就会报错.增对大数据量的请求,需要单独配置maxHttpHeaderSize参数属性.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomcat </tag>
            
            <tag> maxHttpHeaderSize </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot中RedisTemplate注意问题</title>
      <link href="/2019/08/06/SpringBoot%E4%B8%ADRedisTemplate%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2019/08/06/SpringBoot%E4%B8%ADRedisTemplate%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="1-ERR-value-is-not-an-integer-or-out-of-range"><a href="#1-ERR-value-is-not-an-integer-or-out-of-range" class="headerlink" title="1:ERR value is not an integer or out of range"></a>1:ERR value is not an integer or out of range</h2><p>1-1:背景:使用redisTemplate.opsForValue().increment(key, delat)方法。</p><p>1-2:分析:redis对任何不合法的值,都称为ERR。只有使用StringRedisSerializer序列化器才能使用incrment或者decrement方法。</p><p>1-3:问题解决:</p><blockquote><ul><li><strong>GenericJackson2JsonRedisSerializer、Jackson2JsonRedisSerializer是先将对象转为json，然后再保存到redis，所以，1在redis中是字符串1，所以无法进行加1</strong></li><li><strong>JdkSerializationRedisSerializer使用的jdk对象序列化，序列化后的值有类信息、版本号等，所以是一个包含很多字母的字符串，所以根本无法加1,这个序列化器跟memcache的序列化规则很像memcache怎样存储的对象</strong></li><li><strong>GenericToStringSerializer、StringRedisSerializer将字符串的值直接转为字节数组，所以保存到redis中是数字，所以可以进行加1</strong></li></ul></blockquote><p>1-4:总结:</p><blockquote><p><strong>使用GenericToStringSerializer、StringRedisSerializer序列化器，都可以使用increment方法.</strong></p></blockquote><p>1-5:建议redis key序列化使用StringRedisSerializer,redis value序列化使用Jackson2JsonRedisSerializer。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * key redis serializer: &#123;@link StringRedisSerializer&#125; and</span><br><span class="line"> * key redis serializer: &#123;@link Jackson2JsonRedisSerializer&#125;</span><br><span class="line"> **/</span><br><span class="line">@Bean(name = &quot;genericRedisTemplate&quot;)</span><br><span class="line">public RedisTemplate&lt;String, String&gt; redisTemplate3(RedisConnectionFactory factory) &#123;</span><br><span class="line">    RedisTemplate&lt;String, String&gt; template = new RedisTemplate&lt;&gt;();</span><br><span class="line">    RedisSerializer valueRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">    RedisSerializer keyRedisSerializer = new StringRedisSerializer();</span><br><span class="line">    template.setKeySerializer(keyRedisSerializer);</span><br><span class="line">    template.setValueSerializer(valueRedisSerializer);</span><br><span class="line">    template.setHashKeySerializer(keyRedisSerializer);</span><br><span class="line">    template.setHashValueSerializer(valueRedisSerializer);</span><br><span class="line">    template.setConnectionFactory(factory);</span><br><span class="line">    template.afterPropertiesSet();</span><br><span class="line">    return template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-key前面会有一堆-xac-xed-x00-x05t-x00-tb"><a href="#2-key前面会有一堆-xac-xed-x00-x05t-x00-tb" class="headerlink" title="2:key前面会有一堆\xac\xed\x00\x05t\x00\tb"></a>2:key前面会有一堆\xac\xed\x00\x05t\x00\tb</h2><p>1-1:背景:使用SpringData对redis进行操作</p><p>1-2:分析</p><blockquote><p>分析spring-data的org.springframework.data.redis.core.RedisTemplate源代码以后发现.Spring默认采用defaultSerializer = new JdkSerializationRedisSerializer();<strong>来对key,value进行序列化操作，在经过查看JdkSerializationRedisSerializer中对序列化的一系列操作,即默认使用。</strong>由于spring操作redis是在jedis客户端基础上进行的，而jedis客户端与redis交互的时候协议中定义是用byte类型交互，jedis中提供了string类型转为byte[]类型.<br>原因其实就出现在这里，解决的办法就是手动定义序列化的方法。</p></blockquote><p>1-3:解决方法:</p><blockquote><p>建议redis key序列化使用StringRedisSerializer,redis value序列化使用Jackson2JsonRedisSerializer.</p></blockquote><p>// 使用SpringBoot默认配置的redisTemplate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Standard Redis configuration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(name = <span class="string">"redisTemplate"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">RedisConnectionFactory redisConnectionFactory)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;Object, Object&gt;();</span><br><span class="line">template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"><span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(StringRedisTemplate.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">stringRedisTemplate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">RedisConnectionFactory redisConnectionFactory)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"><span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> RedisTemplate </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring中RestTemplate的使用</title>
      <link href="/2019/08/06/Spring%E4%B8%ADRestTemplate%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/08/06/Spring%E4%B8%ADRestTemplate%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring中RestTemplate的使用"><a href="#Spring中RestTemplate的使用" class="headerlink" title="Spring中RestTemplate的使用"></a>Spring中RestTemplate的使用</h2><h3 id="Get请求"><a href="#Get请求" class="headerlink" title="Get请求"></a>Get请求</h3><p>1:带参数的Get请求</p><blockquote><p>请求URL示例:<a href="http://localhost:8080/test/sendSms?phone=手机号&amp;msg=短信内容" target="_blank" rel="noopener">http://localhost:8080/test/sendSms?phone=手机号&amp;msg=短信内容</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//错误使用:</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private RestOperations restOperations;</span><br><span class="line"></span><br><span class="line">public void test() throws Exception&#123;</span><br><span class="line">    String url = &quot;http://localhost:8080/test/sendSms&quot;;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; uriVariables = new HashMap&lt;String, Object&gt;();</span><br><span class="line">    uriVariables.put(&quot;phone&quot;, &quot;151xxxxxxxx&quot;);</span><br><span class="line">    uriVariables.put(&quot;msg&quot;, &quot;测试短信内容&quot;);</span><br><span class="line"></span><br><span class="line">    String result = restOperations.getForObject(url, String.class, uriVariables);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**服务器接收的时候你会发现，接收的该请求时没有参数的**</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//正确使用:</span><br><span class="line">public void test() throws Exception&#123;</span><br><span class="line">    String url = &quot;http://localhost:8080/test/sendSms?phone=&#123;phone&#125;&amp;msg=&#123;phone&#125;&quot;;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; uriVariables = new HashMap&lt;String, Object&gt;();</span><br><span class="line">    uriVariables.put(&quot;phone&quot;, &quot;151xxxxxxxx&quot;);</span><br><span class="line">    uriVariables.put(&quot;msg&quot;, &quot;测试短信内容&quot;);</span><br><span class="line"></span><br><span class="line">    String result = restOperations.getForObject(url, String.class, uriVariables);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void test() throws Exception&#123;</span><br><span class="line">    String url = &quot;http://localhost:8080/test/sendSms?phone=&#123;phone&#125;&amp;msg=&#123;phone&#125;&quot;;</span><br><span class="line">    String result = restOperations.getForObject(url, String.class,  &quot;151xxxxxxxx&quot;, &quot;测试短信内容&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2:Spring提供的Get请求方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; T getForObject(URI url, Class&lt;T&gt; responseType) throws RestClientException;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(String url, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(URI url, Class&lt;T&gt; responseType) throws RestClientException;</span><br></pre></td></tr></table></figure><h3 id="Post请求"><a href="#Post请求" class="headerlink" title="Post请求"></a>Post请求</h3><h5 id="1-带参数的POST请求"><a href="#1-带参数的POST请求" class="headerlink" title="1:带参数的POST请求"></a>1:带参数的POST请求</h5><blockquote><p>带参数的URL示例:<a href="http://api.map.baidu.com/geodata/v3/poi/create" target="_blank" rel="noopener">http://api.map.baidu.com/geodata/v3/poi/create</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//正确使用:</span><br><span class="line"></span><br><span class="line">        HttpHeaders headers = new HttpHeaders();</span><br><span class="line">        MultiValueMap&lt;String, String&gt; createPostParams = new LinkedMultiValueMap&lt;&gt;(16);</span><br><span class="line">        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);</span><br><span class="line">        createPostParams.add(&quot;ak&quot;, PositionConstants.AK);</span><br><span class="line">        createPostParams.add(&quot;geotable_id&quot;, PositionConstants.GEOTABLE_ID);</span><br><span class="line">        createPostParams.add(&quot;coord_type&quot;, PositionConstants.COORD_TYPE);</span><br><span class="line">        createPostParams.add(&quot;latitude&quot;, String.valueOf(article.getPositionX()));</span><br><span class="line">        createPostParams.add(&quot;longitude&quot;, String.valueOf(article.getPositionY()));</span><br><span class="line">        createPostParams.add(&quot;address&quot;, article.getPositionName());</span><br><span class="line">        createPostParams.add(&quot;title&quot;, article.getArticleName());</span><br><span class="line">        createPostParams.add(&quot;article_img&quot;, articleImg);</span><br><span class="line">        createPostParams.add(&quot;article_id&quot;, article.getArticleId());</span><br><span class="line">        createPostParams.add(&quot;article_title&quot;, article.getArticleName());</span><br><span class="line">        createPostParams.add(&quot;article_time&quot;, String.valueOf(article.getArticleTime()));</span><br><span class="line">        createPostParams.add(&quot;article_username&quot;, userName);</span><br><span class="line">        HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; requestEntity = new HttpEntity&lt;&gt;(createPostParams, headers);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ResponseEntity&lt;String&gt; responseEntity = restTemplate.postForEntity(PositionConstants.CREATE_URL, requestEntity, String.class);</span><br></pre></td></tr></table></figure><h5 id="2-Spring提供的POST方法"><a href="#2-Spring提供的POST方法" class="headerlink" title="2:Spring提供的POST方法"></a>2:Spring提供的POST方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; T postForObject(String url, Object request, Class&lt;T&gt; responseType, Object... uriVariables)</span><br><span class="line">throws RestClientException;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; T postForObject(String url, Object request, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span><br><span class="line">throws RestClientException;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; T postForObject(URI url, Object request, Class&lt;T&gt; responseType) throws RestClientException;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(String url, Object request, Class&lt;T&gt; responseType, Object... uriVariables)</span><br><span class="line">throws RestClientException;</span><br><span class="line"></span><br><span class="line">`&lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(String url, Object request, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span><br><span class="line">throws RestClientException;`</span><br><span class="line">&lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(URI url, Object request, Class&lt;T&gt; responseType) throws RestClientException;`</span><br></pre></td></tr></table></figure><h3 id="PUT请求"><a href="#PUT请求" class="headerlink" title="PUT请求:"></a>PUT请求:</h3><blockquote><p>PUT请求和POST请求差不多.</p></blockquote><p>1:Spring提供的PUT方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void put(String url, Object request, Object... uriVariables) throws RestClientException;</span><br><span class="line"></span><br><span class="line">void put(String url, Object request, Map&lt;String, ?&gt; uriVariables) throws RestClientException;</span><br><span class="line"></span><br><span class="line">void put(URI url, Object request) throws RestClientException;</span><br></pre></td></tr></table></figure><h3 id="DELETE请求"><a href="#DELETE请求" class="headerlink" title="DELETE请求:"></a>DELETE请求:</h3><p>1:Spring提供的DELETE方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void delete(String url, Object... uriVariables) throws RestClientException;</span><br><span class="line"></span><br><span class="line">void delete(String url, Map&lt;String, ?&gt; uriVariables) throws RestClientException;</span><br><span class="line"></span><br><span class="line">void delete(URI url) throws RestClientException;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RestTemplate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> RestTemplate </tag>
            
            <tag> Restful请求 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring的Bean生命周期</title>
      <link href="/2019/08/06/Spring%E7%9A%84Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2019/08/06/Spring%E7%9A%84Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p><strong>一：生命周期执行的过程如下:</strong></p><p><strong>对于一个Bean对象来说,它的生命周期有实例化–&gt;初始化–&gt;销毁三大块组成。所以会有如下对三大块前后做定制化Bean。</strong></p><p><strong>而对于Bean对象另一份的Spring感知接口来说,会有如下代码和类进行支持。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContextAwareProcessor对一些感知接口处理。详细看invokeAwareInterfaces方法。</span><br><span class="line">class ApplicationContextAwareProcessor implements BeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">    private final ConfigurableApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    private final StringValueResolver embeddedValueResolver;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Create a new ApplicationContextAwareProcessor for the given context.</span><br><span class="line">     */</span><br><span class="line">    public ApplicationContextAwareProcessor(ConfigurableApplicationContext applicationContext) &#123;</span><br><span class="line">        this.applicationContext = applicationContext;</span><br><span class="line">        this.embeddedValueResolver = new EmbeddedValueResolver(applicationContext.getBeanFactory());</span><br><span class="line">    &#125;</span><br><span class="line">private void invokeAwareInterfaces(Object bean) &#123;</span><br><span class="line">        if (bean instanceof Aware) &#123;</span><br><span class="line">            if (bean instanceof EnvironmentAware) &#123;</span><br><span class="line">                ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());</span><br><span class="line">            &#125;</span><br><span class="line">            if (bean instanceof EmbeddedValueResolverAware) &#123;</span><br><span class="line">                ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);</span><br><span class="line">            &#125;</span><br><span class="line">            if (bean instanceof ResourceLoaderAware) &#123;</span><br><span class="line">                ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);</span><br><span class="line">            &#125;</span><br><span class="line">            if (bean instanceof ApplicationEventPublisherAware) &#123;</span><br><span class="line">                ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);</span><br><span class="line">            &#125;</span><br><span class="line">            if (bean instanceof MessageSourceAware) &#123;</span><br><span class="line">                ((MessageSourceAware) bean).setMessageSource(this.applicationContext);</span><br><span class="line">            &#125;</span><br><span class="line">            if (bean instanceof ApplicationContextAware) &#123;</span><br><span class="line">                ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Bean感知接口处理。</strong></p><p><strong>AbstractAutowireCapableBeanFactory.java的</strong>invokeAwareMethods(final String beanName, final Object bean)方法上处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void invokeAwareMethods(final String beanName, final Object bean) &#123;</span><br><span class="line">    if (bean instanceof Aware) &#123;</span><br><span class="line">        if (bean instanceof BeanNameAware) &#123;</span><br><span class="line">            ((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        if (bean instanceof BeanClassLoaderAware) &#123;</span><br><span class="line">            ClassLoader bcl = getBeanClassLoader();</span><br><span class="line">            if (bcl != null) &#123;</span><br><span class="line">                ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (bean instanceof BeanFactoryAware) &#123;</span><br><span class="line">            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1) spring对bean进行实例化,默认bean是单例。<br>2) spring对bean进行依赖注入。<br>3) 如果bean实现了BeanNameAware接口,spring将bean的id传给setBeanName()方法。<br>4) 如果bean实现了BeanFactoryAware接口,spring将调用setBeanFactory方法,将BeanFactory实例传进来。<br>5) 如果bean实现了ApplicationContextAware()接口,spring将调用setApplicationContext()方法将应用上下文的引用传入。<br>6) 如果bean实现了BeanPostProcessor接口,spring将调用它们的postProcessBeforeInitialization接口方法。<br>7) 如果bean实现了InitializingBean接口,spring将调用它们的afterPropertiesSet接口方法,类似的如果bean使用了init-method属性声明了初始化方法,改方法也会被调用。<br>8) 如果bean实现了BeanPostProcessor接口,spring将调用它们的postProcessAfterInitialization接口方法。<br>9) 此时bean已经准备就绪,可以被应用程序使用了,他们将一直驻留在应用上下文中,直到该应用上下文被销毁。<br>10) 若bean实现了DisposableBean接口,spring将调用它的distroy()接口方法。同样的,如果bean使用了destroy-method属性声明了销毁方法,则该方法被调用。</p><p>这里一用仓颉的一幅图说明流程：</p><p><img src="https://img-blog.csdnimg.cn/20190904221407948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70" alt="Bean生命周期1"></p><p>第二幅图解释：</p><p><img src="https://img-blog.csdnimg.cn/20190904221657379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70" alt="Bean生命周期2"></p><p><strong>二：代码测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/** * <span class="doctag">@see</span> org.springframework.beans.factory.config.BeanFactoryPostProcessor * <span class="doctag">@see</span> org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter * <span class="doctag">@see</span> org.springframework.beans.factory.InitializingBean * <span class="doctag">@see</span> org.springframework.beans.factory.DisposableBean * <span class="doctag">@see</span> org.springframework.beans.factory.BeanNameAware * <span class="doctag">@see</span> org.springframework.beans.factory.BeanFactoryAware * <span class="doctag">@see</span> org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean(String, RootBeanDefinition, Object[]) **/</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBean</span> <span class="keyword">implements</span> <span class="title">BeanNameAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">InitializingBean</span>, <span class="title">ApplicationContextAware</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpringBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"new SpringBean......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext context)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"ApplicationContextAware-setApplicationContext......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"InitializingBean-afterPropertiesSet......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory bf)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"BeanFactoryAware-setBeanFactory......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"BeanNameAware-setBeanName......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"DisposableBean-destroy....."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object o, String s)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> SpringBean) &#123;</span><br><span class="line">            log.info(<span class="string">"BeanPostProcessor-postProcessBeforeInitialization......"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object o, String s)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> SpringBean) &#123;</span><br><span class="line">            log.info(<span class="string">"BeanPostProcessor-postProcessAfterInitialization......"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果展示</strong></p><p><img src="https://img-blog.csdnimg.cn/20190904221849596.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Bean生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内省机制</title>
      <link href="/2019/08/06/Java%E5%86%85%E7%9C%81%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/08/06/Java%E5%86%85%E7%9C%81%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h4 id="一-内省"><a href="#一-内省" class="headerlink" title="一. 内省"></a>一. 内省</h4><h5 id="1-维基百科解释"><a href="#1-维基百科解释" class="headerlink" title="1:维基百科解释"></a>1:维基百科解释</h5><blockquote><p>在计算机科学中，内省是指计算机程序在运行时（Run time）检查对象（Object）类型的一种能力，通常也可以称作运行时类型检查。 不应该将内省和反射混淆。相对于内省，反射更进一步，是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力。</p></blockquote><h5 id="2-Java语言中解释"><a href="#2-Java语言中解释" class="headerlink" title="2:Java语言中解释"></a>2:Java语言中解释</h5><blockquote><p>内省(Introspector) 是Java 语言对 JavaBean 类属性、事件的一种缺省处理方法。JavaBean是一种特殊的类，主要用于传递数据信息，这种类中的方法主要用于访问私有的字段，且方法名符合某种命名规则。如果在两个模块之间传递信息，可以将信息封装进JavaBean中，这种对象称为“值对象”(Value Object)，或“VO”，方法比较少，这些信息储存在类的私有变量中，通过set()、get()获得</p></blockquote><h4 id="二-内省和反射的区别"><a href="#二-内省和反射的区别" class="headerlink" title="二:内省和反射的区别"></a>二:内省和反射的区别</h4><blockquote><p>1: 反射是在运行状态把Java类中的各种成分映射成相应的Java类，可以动态的获取所有的属性以及动态调用任意一个方法，强调的是运行状态。</p><p>2: 内省(Introspector)是Java 语言对 Bean 类属性、事件的一种缺省处理方法。　JavaBean是一种特殊的类，主要用于传递数据信息，这种类中的方法主要用于访问私有的字段，且方法名符合某种命名规则。如果在两个模块之间传递信息，可以将信息封装进JavaBean中，这种对象称为“值对象”(Value Object)，或“VO”。方法比较少。这些信息储存在类的私有变量中，通过set()、get()获得。内省机制是通过反射来实现的，BeanInfo用来暴露一个bean的属性、方法和事件，以后我们就可以操纵该JavaBean的属性。</p><p>3:比较</p><p><img src="https://img2018.cnblogs.com/blog/1268938/201901/1268938-20190109120602148-1027189775.png" alt="img"></p></blockquote><h4 id="三-JDK内省类库"><a href="#三-JDK内省类库" class="headerlink" title="三:JDK内省类库"></a>三:JDK内省类库</h4><blockquote><ul><li>java.beans.Introspector：Introspector 类为通过工具学习有关受目标 Java Bean 支持的属性、事件和方法的知识提供了一个标准方法。</li><li>java.beans.BeanInfo接口：希望提供有关其 bean 的显式信息的 bean 实现者可以提供某个 BeanInfo 类，该类实现此 BeanInfo 接口并提供有关其 bean 的方法、属性、事件等显式信息。</li><li>java.beans.PropertyDescriptor：PropertyDescriptor 描述 Java Bean 通过一对存储器方法导出的一个属性</li></ul></blockquote><h4 id="四-内省代码测试"><a href="#四-内省代码测试" class="headerlink" title="四:内省代码测试"></a>四:内省代码测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java内省机制测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.beans.BeanInfo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.beans.Introspector</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.beans.PropertyDescriptor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.beans.MethodDescriptor</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntrospectorTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setAge(<span class="number">20</span>);</span><br><span class="line">        user.setId(UUID.randomUUID().toString());</span><br><span class="line">        user.setName(<span class="string">"刘恩源"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIntrospector</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//get BeanInfo</span></span><br><span class="line">        BeanInfo beanInfo = Introspector.getBeanInfo(User.class);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//PropertyDescriptor</span></span><br><span class="line">        PropertyDescriptor[] pds = beanInfo.getPropertyDescriptors();</span><br><span class="line">        <span class="keyword">for</span> (PropertyDescriptor pd : pds) &#123;</span><br><span class="line">            Method method = pd.getReadMethod();</span><br><span class="line">            String methodName = method.getName();</span><br><span class="line">            Object result = method.invoke(user);</span><br><span class="line">            System.out.println(methodName + <span class="string">"--&gt;"</span> + result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//get name property descriptor</span></span><br><span class="line">        PropertyDescriptor namePropertyDescriptor = <span class="keyword">new</span> PropertyDescriptor(<span class="string">"name"</span>, User.class);</span><br><span class="line">        <span class="comment">//得到name属性的getter方法</span></span><br><span class="line">        Method readMethod = namePropertyDescriptor.getReadMethod();</span><br><span class="line">        <span class="comment">//执行getter方法，获取返回值，即name属性的值</span></span><br><span class="line">        String result = (String) readMethod.invoke(user);</span><br><span class="line">        System.out.println(<span class="string">"user.name"</span> + <span class="string">"--&gt;"</span> + result);</span><br><span class="line">        <span class="comment">//得到name属性的setter方法</span></span><br><span class="line">        Method writeMethod = namePropertyDescriptor.getWriteMethod();</span><br><span class="line">        <span class="comment">//执行setter方法，修改name属性的值</span></span><br><span class="line">        writeMethod.invoke(user, <span class="string">"刘恩源1"</span>);</span><br><span class="line">        System.out.println(<span class="string">"user.name"</span> + <span class="string">"--&gt;"</span> + user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java内省机制 </tag>
            
            <tag> Java反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT认证详解</title>
      <link href="/2019/08/06/JWT%E8%AE%A4%E8%AF%81%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/08/06/JWT%E8%AE%A4%E8%AF%81%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="JWT-Json-web-token-认证详解"><a href="#JWT-Json-web-token-认证详解" class="headerlink" title="JWT(Json web token) 认证详解"></a>JWT(Json web token) 认证详解</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1:概述"></a>1:概述</h3><p><code>JWT声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息,以便从资源服务器获取资源,增加一些额外的其他业务所必须的声明信息</code>。</p><p><strong><code>特别适用于分布式站点的单点登录(SSO)场景</code></strong></p><h3 id="2-起源"><a href="#2-起源" class="headerlink" title="2:起源"></a>2:起源</h3><p>基于token的认证和传统的session认证区别。</p><h5 id="1-传统的session认证"><a href="#1-传统的session认证" class="headerlink" title="(1):传统的session认证"></a>(1):传统的session认证</h5><p><strong><code>概述</code></strong></p><p><code>http协议本身是一种无状态的协议</code>,而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证,那么下一次请求时,用户还要再一次进行用户认证才行,<code>因为根据http协议,我们并不能知道是哪个用户发出的请求,所以为了让我们的应用能识别是哪个用户发出的请求,我们只能在服务器存储一份用户登录的信息</code>,这份登录信息会在响应时传递给浏览器,告诉其保存为cookie,以便下次请求时发送给我们的应用,这样我们的应用就能识别请求来自哪个用户了,这就是传统的基于session认证。</p><p><strong><code>基于session认证所显露的问题</code></strong></p><ul><li><code>session存储问题</code>:由于用户的信息存储在服务端,而且session都是保存在内存中,随之认证用户增多,服务端开销明显增大。</li><li><code>扩展性</code>:用户认证之后,服务端做认证记录,如果认证记录被保存在内存中,<code>意味着用户下次请求还必须要请求这台服务器,才能拿到授权资源</code>。在分布式应用中,相应的限制了负载均衡器的能力。</li><li><code>CSRF</code>:因为<code>基于cookie来进行用户识别</code>,如果cookie被截获,用户就会很容易受到<code>跨站请求伪造攻击</code>。</li><li><strong>分布式session共享</strong>可以使用<code>spring session data redis</code>实现</li></ul><h5 id="2-基于token的鉴权机制"><a href="#2-基于token的鉴权机制" class="headerlink" title="(2):基于token的鉴权机制"></a>(2):基于token的鉴权机制</h5><p><strong><code>概述</code></strong></p><p>基于token的鉴权机制类似于http协议也是无状态的,它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了,这就为应用的扩展提供了便利。</p><p><strong><code>流程</code></strong></p><ul><li>用户使用用户名密码来请求服务器。</li><li>服务器进行验证用户的信息。</li><li>服务器通过验证发送给用户一个token。</li><li>客户端存储token,并在每次请求时附送上这个token值。</li><li>服务端验证token值,并返回数据。</li></ul><p>这个<code>token</code>必须要在<code>每次请求时传递给服务端</code>,应该保存在<code>请求头里</code>。例外,服务端要支持<code>CORS(跨域请求)</code>。</p><h3 id="3-JWT"><a href="#3-JWT" class="headerlink" title="3:JWT"></a>3:JWT</h3><h5 id="1-设计"><a href="#1-设计" class="headerlink" title="(1):设计"></a>(1):设计</h5><p>jwt(json web token)有三部分构成。</p><ul><li><p><strong><code>header(头部)</code></strong></p><ul><li><p>声明类型:<code>jwt</code></p></li><li><p>加密算法:<code>HMAC</code>,<code>SHA256</code></p></li><li><p><strong><code>头部进行base64加密</code></strong>。</p></li><li><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//头部json</span><br><span class="line">&#123; </span><br><span class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">   <span class="attr">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>payload</code></strong>:存储有效信息。</p><ul><li>标准中注册声明(建议单不强制使用)<ul><li><strong>iss</strong>: jwt签发者</li><li><strong><code>sub</code></strong>: <code>jwt所面向的用户</code></li><li><strong>aud</strong>: 接收jwt的一方</li><li><strong>exp</strong>: jwt的过期时间，这个过期时间必须要大于签发时间</li><li><strong>nbf</strong>: 定义在什么时间之前，该jwt都是不可用的.</li><li><strong>iat</strong>: jwt的签发时间</li><li><strong>jti</strong>: jwt的唯一身份标识,主要用来作为一次性token,从而回避重放攻击。</li></ul></li><li>公共声明<ul><li>添加任何信息,一般添加用户的相关信息或者其他业务需要的必要信息。<code>不建议添加敏感信息。(可以在客户端进行解密)</code></li></ul></li><li>私有声明<ul><li><code>提供者和消费者所共同定义的声明,一般不建议存放敏感信息</code>,因为base64是对称解密的，意味着该部分信息可以归类为明文信息。</li></ul></li></ul></li><li><p><strong><code>signature</code></strong>:签证信息</p><ul><li><p>head(base64后的)</p></li><li><p>payload(base64后的)</p></li><li><p>secret:<code>保存在服务端,jwt签发生成也是在服务端。它是用来进行jwt签发和jwt验证,就是服务端的私钥。</code></p><blockquote><p>这个部分需要base64加密后的header和payload使用。连接组成的字符串,然后通过header中声明的加密方式进行加盐secret组合加密,构成jwt第三部分。</p></blockquote></li></ul></li></ul><h5 id="2-应用"><a href="#2-应用" class="headerlink" title="(2):应用"></a>(2):应用</h5><p>一般是在请求头里加入<code>Authorization</code>,并加上<code>Bearer</code>标注:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'api/user/1'</span>, &#123;</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Authorization'</span>: <span class="string">'Bearer '</span> + token</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://images2017.cnblogs.com/blog/1277635/201711/1277635-20171116141211968-1715750540.png" alt="img"></p><h5 id="3-总结"><a href="#3-总结" class="headerlink" title="(3):总结"></a>(3):总结</h5><p><strong><code>优点</code></strong></p><ul><li>由于json通用性,所以JWT可以跨语言。</li><li>因为有payload,所以jwt可以在自身存储一些其他业务所必要的非敏感信息。</li><li>便于传输,字节占用很小</li><li>不需要在服务端保存会话信息,易于扩展,特别适用于分布式微服务。</li></ul><p><strong><code>安全相关</code></strong></p><ul><li><code>不应该在jwt的payload部分存放敏感信息</code>,因为这部分客户端可解密的部分</li><li><code>保护好secret私钥</code>,该私钥非常重要。</li><li><code>如果可以,请使用https协议</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> jwt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON Web Token认证 </tag>
            
            <tag> Session认证 </tag>
            
            <tag> 分布式单点登录(SSO)场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot自定义注解加载yml或者yaml文件</title>
      <link href="/2019/08/06/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%8A%A0%E8%BD%BDyml%E6%88%96%E8%80%85yaml%E6%96%87%E4%BB%B6/"/>
      <url>/2019/08/06/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%8A%A0%E8%BD%BDyml%E6%88%96%E8%80%85yaml%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot自定义注解加载yml或者yaml文件"><a href="#SpringBoot自定义注解加载yml或者yaml文件" class="headerlink" title="SpringBoot自定义注解加载yml或者yaml文件"></a>SpringBoot自定义注解加载yml或者yaml文件</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1:概述"></a>1:概述</h3><p>SpringBoot的<code>@PropertySource</code>注解只支持加载    properties结尾的文件。当使用@ConfigurationProperties</p><p>注解配合<code>@EnableConfigurationProperties</code>注解将配置转换为JavaBean时,可能需要配合@PropertySource</p><p>注解加载指定的配置文件。所以为了支持以<code>yml或者yaml</code>文件,我自定义了注解<code>@YmlPropertySource</code>。</p><h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2:实现"></a>2:实现</h3><p><strong>声明注解@YamlPropertySource</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PropertySourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * yaml property source and extension &#123;<span class="doctag">@link</span> PropertySource&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.annotation.PropertySource</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Repeatable</span>(YamlPropertySources.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> YamlPropertySource &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicate the name of this property source. If omitted, a name will</span></span><br><span class="line"><span class="comment">     * be generated based on the description of the underlying resource.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.core.env.PropertySource#getName()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.core.io.Resource#getDescription()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicate the resource location(s) of the properties file to be loaded.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Both traditional and XML-based properties file formats are supported</span></span><br><span class="line"><span class="comment">     * &amp;mdash; for example, &#123;<span class="doctag">@code</span> "classpath:/com/myco/app.properties"&#125;</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@code</span> "file:/path/to/file.xml"&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Resource location wildcards (e.g. *&amp;#42;/*.properties) are not permitted;</span></span><br><span class="line"><span class="comment">     * each location must evaluate to exactly one &#123;<span class="doctag">@code</span> .properties&#125; resource.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;$&#123;...&#125; placeholders will be resolved against any/all property sources already</span></span><br><span class="line"><span class="comment">     * registered with the &#123;<span class="doctag">@code</span> Environment&#125;. See &#123;<span class="doctag">@linkplain</span> PropertySource above&#125;</span></span><br><span class="line"><span class="comment">     * for examples.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Each location will be added to the enclosing &#123;<span class="doctag">@code</span> Environment&#125; as its own</span></span><br><span class="line"><span class="comment">     * property source, and in the order declared.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicate if failure to find the a &#123;<span class="doctag">@link</span> #value() property resource&#125; should be</span></span><br><span class="line"><span class="comment">     * ignored.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&#123;<span class="doctag">@code</span> true&#125; is appropriate if the properties file is completely optional.</span></span><br><span class="line"><span class="comment">     * Default is &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 4.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">ignoreResourceNotFound</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A specific character encoding for the given resources, e.g. "UTF-8".</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 4.3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">encoding</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Specify a custom &#123;<span class="doctag">@link</span> PropertySourceFactory&#125;, if any.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;By default, a default factory for standard resource files will be used.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.core.io.support.DefaultPropertySourceFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.core.io.support.ResourcePropertySource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 4.3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? extends PropertySourceFactory&gt; factory() <span class="keyword">default</span> YamlPropertySourceFactory.class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> YamlPropertySource</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> YamlPropertySources &#123;</span><br><span class="line"></span><br><span class="line">    YamlPropertySource[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体实现如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.YamlPropertiesFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.EnvironmentAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ResourceLoaderAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.AnnotationUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ResourceLoader;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.Assert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类描述: &#123;<span class="doctag">@link</span> YamlPropertySource&#125; bean post processor.this class convert the yml or yaml file &#123;<span class="doctag">@link</span> YamlPropertySource#value()&#125; to &#123;<span class="doctag">@link</span> PropertiesPropertySource&#125;,and add the property source</span></span><br><span class="line"><span class="comment"> * named &#123;<span class="doctag">@link</span> YmlPropertySource#name()&#125; into &#123;<span class="doctag">@link</span> Environment&#125;.When you use this annotation,you</span></span><br><span class="line"><span class="comment"> * must for follow example:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@link</span> <span class="doctag">@ConfigurationProperties</span>(prefix = "person")</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@link</span> <span class="doctag">@YmlPropertySource</span>(value = &#123;"classpath:/hello.yml"&#125;, name = "hello")</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@link</span> <span class="doctag">@Data</span></span></span><br><span class="line"><span class="comment"> * public class PersonProperties &#123;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * private String name;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * private Integer age;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * private String school;</span></span><br><span class="line"><span class="comment"> * &#125;&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/6/16 20:13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> YamlPropertySource</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> InstantiationAwareBeanPostProcessorAdapter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnvironmentAware</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ResourceLoaderAware</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Configuration</span>(value = YamlPropertySourceAnnotationPostProcessor.BEAN_NAME)</span><br><span class="line"><span class="meta">@Order</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YamlPropertySourceAnnotationPostProcessor</span> <span class="keyword">extends</span> <span class="title">InstantiationAwareBeanPostProcessorAdapter</span> <span class="keyword">implements</span> <span class="title">EnvironmentAware</span>, <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String BEAN_NAME = <span class="string">"yamlPropertySourceAnnotationPostProcessor"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; propertySourceNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> PropertySourceFactory DEFAULT_PROPERTY_SOURCE_FACTORY = <span class="keyword">new</span> YamlPropertySourceFactory();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        Assert.isInstanceOf(ConfigurableEnvironment.class, environment, <span class="string">"environment must be instance of ConfigurableEnvironment."</span>);</span><br><span class="line">        <span class="keyword">this</span>.environment = environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// Process any @PropertySource annotations</span></span><br><span class="line">        Set&lt;YamlPropertySource&gt; yamlPropertySources = AnnotationUtils.getRepeatableAnnotations(bean.getClass(),</span><br><span class="line">                YamlPropertySource.class, YamlPropertySources.class);</span><br><span class="line">        <span class="keyword">if</span> (!yamlPropertySources.isEmpty()) &#123;</span><br><span class="line">            Set&lt;AnnotationAttributes&gt; attributesSet = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(yamlPropertySources.size());</span><br><span class="line">            <span class="keyword">for</span> (YamlPropertySource yamlPropertySource : yamlPropertySources) &#123;</span><br><span class="line">                AnnotationAttributes attributes = AnnotationUtils.getAnnotationAttributes(bean.getClass(),</span><br><span class="line">                        yamlPropertySource);</span><br><span class="line">                attributesSet.add(attributes);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (AnnotationAttributes propertySource : attributesSet) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        processPropertySource(propertySource);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        log.warn(<span class="string">"exception message: &#123;&#125;"</span>, e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.warn(<span class="string">"Ignoring @YamlPropertySource annotation on ["</span> + bean.getClass() +</span><br><span class="line">                            <span class="string">"]. Reason: Environment must implement ConfigurableEnvironment"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processPropertySource</span><span class="params">(AnnotationAttributes propertySource)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String name = propertySource.getString(<span class="string">"name"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasLength(name)) &#123;</span><br><span class="line">            name = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String encoding = propertySource.getString(<span class="string">"encoding"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasLength(encoding)) &#123;</span><br><span class="line">            encoding = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] locations = propertySource.getStringArray(<span class="string">"value"</span>);</span><br><span class="line">        Assert.isTrue(locations.length &gt; <span class="number">0</span>, <span class="string">"At least one @YamlPropertySource(value) location is required"</span>);</span><br><span class="line">        <span class="keyword">boolean</span> ignoreResourceNotFound = propertySource.getBoolean(<span class="string">"ignoreResourceNotFound"</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;? extends PropertySourceFactory&gt; factoryClass = propertySource.getClass(<span class="string">"factory"</span>);</span><br><span class="line">        PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?</span><br><span class="line">                DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String location : locations) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String resolvedLocation = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(location);</span><br><span class="line">                Resource resource = <span class="keyword">this</span>.resourceLoader.getResource(resolvedLocation);</span><br><span class="line">                addPropertySource(factory.createPropertySource(name, <span class="keyword">new</span> EncodedResource(resource, encoding)));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) &#123;</span><br><span class="line">                <span class="comment">// Placeholders not resolvable or resource not found when trying to open it</span></span><br><span class="line">                <span class="keyword">if</span> (ignoreResourceNotFound) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">                        log.info(<span class="string">"Properties or Yml or Yaml location ["</span> + location + <span class="string">"] not resolvable: "</span> + ex.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addPropertySource</span><span class="params">(PropertySource&lt;?&gt; propertySource)</span> </span>&#123;</span><br><span class="line">        String name = propertySource.getName();</span><br><span class="line">        MutablePropertySources propertySources = ((ConfigurableEnvironment) <span class="keyword">this</span>.environment).getPropertySources();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.propertySourceNames.contains(name)) &#123;</span><br><span class="line">            <span class="comment">// We've already added a version, we need to extend it</span></span><br><span class="line">            PropertySource&lt;?&gt; existing = propertySources.get(name);</span><br><span class="line">            <span class="keyword">if</span> (existing != <span class="keyword">null</span>) &#123;</span><br><span class="line">                PropertySource&lt;?&gt; newSource = (propertySource <span class="keyword">instanceof</span> ResourcePropertySource ?</span><br><span class="line">                        ((ResourcePropertySource) propertySource).withResourceName() : propertySource);</span><br><span class="line">                <span class="keyword">if</span> (existing <span class="keyword">instanceof</span> CompositePropertySource) &#123;</span><br><span class="line">                    ((CompositePropertySource) existing).addFirstPropertySource(newSource);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (existing <span class="keyword">instanceof</span> ResourcePropertySource) &#123;</span><br><span class="line">                        existing = ((ResourcePropertySource) existing).withResourceName();</span><br><span class="line">                    &#125;</span><br><span class="line">                    CompositePropertySource composite = <span class="keyword">new</span> CompositePropertySource(name);</span><br><span class="line">                    composite.addPropertySource(newSource);</span><br><span class="line">                    composite.addPropertySource(existing);</span><br><span class="line">                    propertySources.replace(name, composite);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.propertySourceNames.isEmpty()) &#123;</span><br><span class="line">            propertySources.addLast(propertySource);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String firstProcessed = <span class="keyword">this</span>.propertySourceNames.get(<span class="keyword">this</span>.propertySourceNames.size() - <span class="number">1</span>);</span><br><span class="line">            propertySources.addBefore(firstProcessed, propertySource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.propertySourceNames.add(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>想法</strong></p><p>使用<code>InstantiationAwareBeanPostProcessorAdapter</code>的postProcessAfterInstantiation(Object bean, String beanName)方法,然后通过<code>YamlPropertiesFactoryBean</code>将yml|yaml文件转换为properties文件,然后通过</p><p>实现<code>EnvironmentAware</code>接口,将配置文件属性写入到spring的<code>Environment</code>环境中。但是该实现有点</p><p>缺陷,就是如果使用<code>@ConfigurationProperties</code>和<code>@EnableConfigurationProperties</code>将配置属性</p><p>转换为<code>JavaBean</code>时,需要将<code>@YmlProperySource</code>注解标注到该<code>JavaBean</code>上。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 外部化配置 </tag>
            
            <tag> yml|yaml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring类型转换</title>
      <link href="/2019/08/06/Spring%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2019/08/06/Spring%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Type-Conversion-Spring类型转换"><a href="#Spring-Type-Conversion-Spring类型转换" class="headerlink" title="Spring Type Conversion(Spring类型转换)"></a>Spring Type Conversion(Spring类型转换)</h2><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1:概述:"></a>1:概述:</h4><p><code>Spring3</code>引入了<code>core.convert</code>包,提供了<code>通用类型转换系统</code>,定义了实现<code>类型转换和运行时执行类型的SPI</code>。</p><p>在<code>Spring3.0</code>之前,提供的<code>PropertyEditor</code>来将外部化bean属性值字符串转换成必需的实现类型。</p><h4 id="2-Converter-SPI"><a href="#2-Converter-SPI" class="headerlink" title="2:Converter SPI"></a>2:<code>Converter SPI</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A converter converts a source object of type &#123;<span class="doctag">@code</span> S&#125; to a target of type &#123;<span class="doctag">@code</span> T&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Implementations of this interface are thread-safe and can be shared.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Implementations may additionally implement &#123;<span class="doctag">@link</span> ConditionalConverter&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;S&gt; the source type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the target type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert the source object of type &#123;<span class="doctag">@code</span> S&#125; to target type &#123;<span class="doctag">@code</span> T&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> source the source object to convert, which must be an instance of &#123;<span class="doctag">@code</span> S&#125; (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the converted object, which must be an instance of &#123;<span class="doctag">@code</span> T&#125; (potentially &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the source cannot be converted to the desired target type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">T <span class="title">convert</span><span class="params">(S source)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   实现自定义的类型转换可以实现<code>Converter</code>接口。但是如果S是<code>集合或者数组</code>转换为<code>T的集合或者数组</code>,</p><p>建议参考诸如<code>ArrayToCollectionConverter</code>实现。前提是已经注册了委托<code>数组或集合转换器</code>。例如,</p><p><code>DefaultConversionService</code>实现。</p><p>  <code>Converter.convert(S source)中source确保不能为null,否则转换器可能抛出异常如果转换失败。</code>具体</p><p>说,应该会抛出<code>IllegalArgumentException</code>报告不合理的转换源。确保<code>Converter</code>实现是<code>线程安全</code>。</p><p>   在<code>core.convert.support</code>包下,注册了常见了类型转换器。例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Converts from a String any JDK-standard Number implementation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Support Number classes including Byte, Short, Integer, Float, Double, Long, BigInteger, BigDecimal. This class</span></span><br><span class="line"><span class="comment"> * delegates to &#123;<span class="doctag">@link</span> NumberUtils#parseNumber(String, Class)&#125; to perform the conversion.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Byte</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Short</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Integer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.math.BigInteger</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Float</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Double</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.math.BigDecimal</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> NumberUtils</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToNumberConverterFactory</span> <span class="keyword">implements</span> <span class="title">ConverterFactory</span>&lt;<span class="title">String</span>, <span class="title">Number</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Number&gt; <span class="function">Converter&lt;String, T&gt; <span class="title">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> StringToNumber&lt;&gt;(targetType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToNumber</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; targetType;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringToNumber</span><span class="params">(Class&lt;T&gt; targetType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.targetType = targetType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (source.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NumberUtils.parseNumber(source, <span class="keyword">this</span>.targetType);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-ConverterFactory"><a href="#3-ConverterFactory" class="headerlink" title="3:ConverterFactory"></a>3:<code>ConverterFactory</code></h4><p><code>当你需要集中整理类层次结构的类型转换器,可以使用ConverterFactory</code>。例如StringToNumberConverterFactory,</p><p>该接口定义如下,<code>当你需要范围转换器,可以转换这些对象从S类型转换成R的子类型。使用该接口</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A factory for "ranged" converters that can convert objects from S to subtypes of R.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Implementations may additionally implement &#123;<span class="doctag">@link</span> ConditionalConverter&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConditionalConverter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;S&gt; the source type converters created by this factory can convert from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;R&gt; the target range (or base) type converters created by this factory can convert to;</span></span><br><span class="line"><span class="comment"> * for example &#123;<span class="doctag">@link</span> Number&#125; for a set of number subtypes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConverterFactory</span>&lt;<span class="title">S</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the converter to convert from S to target type T, where T is also an instance of R.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the target type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetType the target type to convert to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a converter from S to T</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;T extends R&gt; <span class="function">Converter&lt;S, T&gt; <span class="title">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Converts from a String any JDK-standard Number implementation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Support Number classes including Byte, Short, Integer, Float, Double, Long, BigInteger, BigDecimal. This class</span></span><br><span class="line"><span class="comment"> * delegates to &#123;<span class="doctag">@link</span> NumberUtils#parseNumber(String, Class)&#125; to perform the conversion.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Byte</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Short</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Integer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.math.BigInteger</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Float</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Double</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.math.BigDecimal</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> NumberUtils</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToNumberConverterFactory</span> <span class="keyword">implements</span> <span class="title">ConverterFactory</span>&lt;<span class="title">String</span>, <span class="title">Number</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Number&gt; <span class="function">Converter&lt;String, T&gt; <span class="title">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> StringToNumber&lt;&gt;(targetType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToNumber</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; targetType;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringToNumber</span><span class="params">(Class&lt;T&gt; targetType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.targetType = targetType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (source.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NumberUtils.parseNumber(source, <span class="keyword">this</span>.targetType);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-GenericConverter"><a href="#4-GenericConverter" class="headerlink" title="4:GenericConverter"></a>4:<code>GenericConverter</code></h4><p>  <code>GenericConverter</code>提供<code>多种源和目标类型之间转换</code>,比<code>Converter更灵活但是对类型要求不高</code>。它提供了实现</p><p>转换逻辑的<code>源和目标上下文</code>。 这样的上下文允许类型转换由字段注释或在字段签名上声明的通用信息驱动。接口</p><p>如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="title">getConvertibleTypes</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConvertiblePair</code>持有<code>转换源和目标类型对</code>。<code>convert(Object, TypeDescriptor, TypeDescriptor)</code>。</p><p><code>源TypeDescriptor</code>提供对保存正在转换的值的源字段的访问。 <code>目标TypeDescriptor</code>提供对要设置转换值的目标字段的访问。<code>TypeDescriptor</code>类是<code>关于要转换类型的上下文</code>。</p><p>  一个好的实例是<code>GenericConverter</code>在Java数组和集合之间转换。例如<code>ArrayToCollectionConverter</code>。</p><p><strong><code>注意</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为GenericConverter是一个更复杂的SPI接口,所以只有在需要时才应该使用它.喜欢Converter或ConverterFactory以满足基本的类型转换需求。</span><br></pre></td></tr></table></figure><h4 id="5-ConditionalGenericConverter"><a href="#5-ConditionalGenericConverter" class="headerlink" title="5:ConditionalGenericConverter"></a>5:<code>ConditionalGenericConverter</code></h4><p>该接口是一个带有判断条件的类型转换器。该接口是<code>GenericConverter</code>和<code>ConditionalConverter</code>的组合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@link</span> GenericConverter&#125; that may conditionally execute based on attributes</span></span><br><span class="line"><span class="comment"> * of the &#123;<span class="doctag">@code</span> source&#125; and &#123;<span class="doctag">@code</span> target&#125; &#123;<span class="doctag">@link</span> TypeDescriptor&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;See &#123;<span class="doctag">@link</span> ConditionalConverter&#125; for details.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Phillip Webb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> GenericConverter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConditionalConverter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConditionalGenericConverter</span> <span class="keyword">extends</span> <span class="title">GenericConverter</span>, <span class="title">ConditionalConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConditionalGenericConverter</code> 的一个好示例是<code>StringToCollectionConverter</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Converts a comma-delimited String to a Collection.</span></span><br><span class="line"><span class="comment"> * If the target collection element type is declared, only matches if</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> String.class&#125; can be converted to it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToCollectionConverter</span> <span class="keyword">implements</span> <span class="title">ConditionalGenericConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConversionService conversionService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringToCollectionConverter</span><span class="params">(ConversionService conversionService)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.conversionService = conversionService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="title">getConvertibleTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> ConvertiblePair(String.class, Collection.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (targetType.getElementTypeDescriptor() == <span class="keyword">null</span> ||</span><br><span class="line"><span class="keyword">this</span>.conversionService.canConvert(sourceType, targetType.getElementTypeDescriptor()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">convert</span><span class="params">(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (source == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">String string = (String) source;</span><br><span class="line"></span><br><span class="line">String[] fields = StringUtils.commaDelimitedListToStringArray(string);</span><br><span class="line">TypeDescriptor elementDesc = targetType.getElementTypeDescriptor();</span><br><span class="line">Collection&lt;Object&gt; target = CollectionFactory.createCollection(targetType.getType(),</span><br><span class="line">(elementDesc != <span class="keyword">null</span> ? elementDesc.getType() : <span class="keyword">null</span>), fields.length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (elementDesc == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String field : fields) &#123;</span><br><span class="line">target.add(field.trim());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (String field : fields) &#123;</span><br><span class="line">Object targetElement = <span class="keyword">this</span>.conversionService.convert(field.trim(), sourceType, elementDesc);</span><br><span class="line">target.add(targetElement);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-ConversionService-API"><a href="#6-ConversionService-API" class="headerlink" title="6:ConversionService API"></a>6:<code>ConversionService API</code></h4><p><code>ConversionService定义了一个统一的API,用于在运行时执行类型转换逻辑</code>. 转换器通常在以下Facade接口后面执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConversionService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">convert</span><span class="params">(Object source, Class&lt;T&gt; targetType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  大多数ConversionService实现,同样也实现了<code>ConverterRegistry</code>,该接口提供了<code>SPI</code>来注册<code>Converters</code>.</p><p>在内部,<code>ConversionService</code>的实现,容器委托它来注册转换器来执行转换逻辑。</p><p>  <code>core.convert.support</code>提供一个强大的<code>ConversionService</code>实现,该实现是<code>GenericConversionSer</code></p><p>,它适用于大多数转换器环境实现。<code>ConversionServiceFactory</code> 来创建普通的<code>ConversionService</code></p><p>配置。</p><h4 id="7-配置ConversionService"><a href="#7-配置ConversionService" class="headerlink" title="7:配置ConversionService"></a>7:配置<code>ConversionService</code></h4><p>  <code>ConversionService</code>被设计成<code>无状态对象</code>,在<code>容器</code>启动时被实例化,在多线程间进行共享(线程安全)。</p><p>在Spring应用中,可以自定义<code>类型转换器</code>。当需要框架进行类型转换时,Spring会选择<code>合适的类型转换器</code></p><p>使用。你也可以注入<code>ConversionService</code>到beans或者直接调用。</p><p>   <strong><code>注意</code></strong></p><blockquote><p>如果没有<code>ConversionService</code>注册到Spring容器,基于的<code>PropertyEditor</code>实现的类型转换会被使用。</p></blockquote><p>​    使用如下的方式,注册默认<code>ConversionService进</code>Spring容器中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertersConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"conversionService"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConversionServiceFactoryBean <span class="title">conversionServiceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ConversionServiceFactoryBean conversionServiceFactoryBean = <span class="keyword">new</span> ConversionServiceFactoryBean();</span><br><span class="line">        <span class="keyword">return</span> conversionServiceFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   默认的<code>ConversionService</code>可以在<code>字符串，数字，枚举，集合，映射和其他常见类型之间进行转换</code>。要使用您自己的自定义转换器补充或覆盖默认转换器,请设置converter属性.属性值可以实现任何Converter,ConverterFactory或GenericConverter接口。默认<code>ConversionService</code>实现是<code>DefaultConversionService</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertersConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"conversionService"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConversionServiceFactoryBean <span class="title">conversionServiceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ConversionServiceFactoryBean conversionServiceFactoryBean = <span class="keyword">new</span> ConversionServiceFactoryBean();</span><br><span class="line">        <span class="comment">//实现自定义的类型转换器</span></span><br><span class="line">        conversionServiceFactoryBean.setConverters(Collections.singleton(<span class="keyword">new</span> StringToDateConverter()));</span><br><span class="line">        <span class="keyword">return</span> conversionServiceFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   也可以使用<code>ConversionService</code>在Spring MVC应用中,参考<code>WebMvcConfigurationSupport</code>类,该类方法</p><p><code>addFormatters(FormatterRegistry registry)</code>可以注册自定义的<code>converters</code>。</p><p>   在某些情况,希望在类型转换期间需要格式化,参考<code>FormatterRegistry</code>。</p><p>   <strong>在程序中使用<code>ConversionService</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(ConversionService conversionService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.conversionService = conversionService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doIt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.conversionService.convert(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-Spring域属性格式化"><a href="#8-Spring域属性格式化" class="headerlink" title="8:Spring域属性格式化"></a>8:Spring域属性格式化</h4><p>   <code>core.convert</code>是一个<code>通用的类型转换系统</code>.它提供了统一的ConversionService API以及强类型转换器SPI,用于实现从一种类型到另一种类型的转换逻辑.Spring容器使用这个系统来<code>绑定bean属性值</code>。额外的,还要<code>SpEL</code>和</p><p><code>DataBinder</code>。<code>Spring3</code>引入了<code>Formatter SPI</code>来实现格式化属性值。<code>ConversionService</code>为两个SPI提供统一的类型转换API。</p><h5 id="1-Formatter-SPI"><a href="#1-Formatter-SPI" class="headerlink" title="(1):Formatter SPI"></a>(1):<code>Formatter SPI</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Formats objects of type T.</span></span><br><span class="line"><span class="comment"> * A Formatter is both a Printer &lt;i&gt;and&lt;/i&gt; a Parser for an object type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of object this Formatter formats</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Formatter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Printer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Parser</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parses text strings to produce instances of T.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of object this Parser produces</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Parser</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse a text String to produce a T.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text the text string</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> locale the current user locale</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an instance of T</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ParseException when a parse exception occurs in a java.text parsing library</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException when a parse exception occurs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">T <span class="title">parse</span><span class="params">(String text, Locale locale)</span> <span class="keyword">throws</span> ParseException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prints objects of type T for display.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of object this Printer prints</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Printer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Print the object of type T for display.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> object the instance to print</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> locale the current user locale</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the printed text string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">print</span><span class="params">(T object, Locale locale)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-Annotation-Driven-Formatting"><a href="#2-Annotation-Driven-Formatting" class="headerlink" title="(2):Annotation-Driven Formatting"></a>(2):<code>Annotation-Driven Formatting</code></h5><p>域格式化可以通过<code>域类型或者注解配置.</code>为了绑定注解在一个<code>Formatter</code>,实现<code>AnnotationFormatterFactory</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.format;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A factory that creates formatters to format values of fields annotated with a particular</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Annotation&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;For example, a &#123;<span class="doctag">@code</span> DateTimeFormatAnnotationFormatterFactory&#125; might create a formatter</span></span><br><span class="line"><span class="comment"> * that formats &#123;<span class="doctag">@code</span> Date&#125; values set on fields annotated with &#123;<span class="doctag">@code</span> <span class="doctag">@DateTimeFormat</span>&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;A&gt; the annotation type that should trigger formatting</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnnotationFormatterFactory</span>&lt;<span class="title">A</span> <span class="keyword">extends</span> <span class="title">Annotation</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; getFieldTypes();</span><br><span class="line"></span><br><span class="line">    Printer&lt;?&gt; getPrinter(A annotation, Class&lt;?&gt; fieldType);</span><br><span class="line"></span><br><span class="line">    Parser&lt;?&gt; getParser(A annotation, Class&lt;?&gt; fieldType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如实现<code>NumberFormatAnnotationFormatterFactory</code>,绑定<code>@NumberFormat</code>注解到<code>Formatter</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberFormatAnnotationFormatterFactory</span> <span class="keyword">extends</span> <span class="title">EmbeddedValueResolutionSupport</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">AnnotationFormatterFactory</span>&lt;<span class="title">NumberFormat</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getFieldTypes() &#123;</span><br><span class="line"><span class="keyword">return</span> NumberUtils.STANDARD_NUMBER_TYPES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Printer&lt;Number&gt; <span class="title">getPrinter</span><span class="params">(NumberFormat annotation, Class&lt;?&gt; fieldType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> configureFormatterFrom(annotation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Parser&lt;Number&gt; <span class="title">getParser</span><span class="params">(NumberFormat annotation, Class&lt;?&gt; fieldType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> configureFormatterFrom(annotation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Formatter&lt;Number&gt; <span class="title">configureFormatterFrom</span><span class="params">(NumberFormat annotation)</span> </span>&#123;</span><br><span class="line">String pattern = resolveEmbeddedValue(annotation.pattern());</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(pattern)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> NumberStyleFormatter(pattern);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Style style = annotation.style();</span><br><span class="line"><span class="keyword">if</span> (style == Style.CURRENCY) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> CurrencyStyleFormatter();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (style == Style.PERCENT) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> PercentStyleFormatter();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> NumberStyleFormatter();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-格式化注解API"><a href="#3-格式化注解API" class="headerlink" title="(3):格式化注解API"></a>(3):格式化注解API</h5><p><code>DateTimeFormat</code>和<code>NumberFormat</code>。</p><h5 id="4-FormatterRegistry-SPI"><a href="#4-FormatterRegistry-SPI" class="headerlink" title="(4):FormatterRegistry SPI"></a>(4):<code>FormatterRegistry SPI</code></h5><p><code>FormatterRegistry</code>是用来注册<code>formatters 和 converters</code>的<code>SPI</code>。<code>FormattingConversionService</code></p><p>是<code>FormatterRegistry</code> 一个实现,可以支持大多数环境。可以通过FormattingConversionServiceFactoryBean</p><p>来配置。也可以通过Spring’s <code>DataBinder</code>和<code>SpEL</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.format;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FormatterRegistry</span> <span class="keyword">extends</span> <span class="title">ConverterRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFormatterForFieldType</span><span class="params">(Class&lt;?&gt; fieldType, Printer&lt;?&gt; printer, Parser&lt;?&gt; parser)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFormatterForFieldType</span><span class="params">(Class&lt;?&gt; fieldType, Formatter&lt;?&gt; formatter)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFormatterForFieldType</span><span class="params">(Formatter&lt;?&gt; formatter)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFormatterForAnnotation</span><span class="params">(AnnotationFormatterFactory&lt;?, ?&gt; factory)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-FormatterRegistrar-SPI"><a href="#5-FormatterRegistrar-SPI" class="headerlink" title="(5):FormatterRegistrar SPI"></a>(5):<code>FormatterRegistrar SPI</code></h5><p><code>FormatterRegistrar</code>是通过<code>FormatterRegistry</code>注册formatters和converters的<code>SPI</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.format;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FormatterRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerFormatters</span><span class="params">(FormatterRegistry registry)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-在Spring-MVC配置Formatting"><a href="#9-在Spring-MVC配置Formatting" class="headerlink" title="9:在Spring MVC配置Formatting"></a>9:在Spring MVC配置Formatting</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Configuration</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addFormatters</span><span class="params">(FormatterRegistry registry)</span> </span>&#123;</span><br><span class="line">       registry.addConverter(<span class="keyword">new</span> StringToDateConverter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-配置全局的Date和时间Format"><a href="#10-配置全局的Date和时间Format" class="headerlink" title="10:配置全局的Date和时间Format"></a>10:配置全局的Date和时间Format</h4><p><code>JodaTimeFormatterRegistrar</code>和<code>DateFormatterRegistrar</code>,使用Joda需要引入joda库</p><p>配置如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FormattingConversionService <span class="title">conversionService</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use the DefaultFormattingConversionService but do not register defaults</span></span><br><span class="line">        DefaultFormattingConversionService conversionService = <span class="keyword">new</span> DefaultFormattingConversionService(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ensure @NumberFormat is still supported</span></span><br><span class="line">        conversionService.addFormatterForFieldAnnotation(<span class="keyword">new</span> NumberFormatAnnotationFormatterFactory());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Register date conversion with a specific global format</span></span><br><span class="line">        DateFormatterRegistrar registrar = <span class="keyword">new</span> DateFormatterRegistrar();</span><br><span class="line">        registrar.setFormatter(<span class="keyword">new</span> DateFormatter(<span class="string">"yyyyMMdd"</span>));</span><br><span class="line">        registrar.registerFormatters(conversionService);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> conversionService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><blockquote><p>Joda-Time提供不同类型表示日期<code>date,time,datetime</code>,需要通过<code>JodaTimeFormatterRegistrar</code>进行</p><p>注册。或者使用<code>DateTimeFormatterFactoryBean</code>来进行创建formatters。</p></blockquote><blockquote><p>如果您使用Spring MVC,请记住明确配置使用的转换服务.对于基于Java的@Configuration,这意味着扩展WebMvcConfigurationSupport类并覆盖mvcConversionService()方法.对于XML,您应该使用mvc:annotation-driven元素的conversion-service属性。 有关详细信息，请参阅转换和格式。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> Spring Type Converter </tag>
            
            <tag> 单例设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring注解属性覆盖</title>
      <link href="/2019/08/06/Spring%E6%B3%A8%E8%A7%A3%E5%B1%9E%E6%80%A7%E8%A6%86%E7%9B%96/"/>
      <url>/2019/08/06/Spring%E6%B3%A8%E8%A7%A3%E5%B1%9E%E6%80%A7%E8%A6%86%E7%9B%96/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring注解属性覆盖"><a href="#Spring注解属性覆盖" class="headerlink" title="Spring注解属性覆盖"></a>Spring注解属性覆盖</h2><h3 id="1-隐性覆盖"><a href="#1-隐性覆盖" class="headerlink" title="1:隐性覆盖"></a>1:隐性覆盖</h3><p>较低层次的注解覆盖其元注解的同名属性</p><p>AnnotationAttributes采用注解就近覆盖的设计原则。</p><blockquote><p>@Component</p><p>​    | -@Service</p><p>​           | -@TransactionalService</p><p>@Service较@Component,距离@TransactionalService注解更近，属于较低层次的注解。</p></blockquote><h3 id="2-显性覆盖"><a href="#2-显性覆盖" class="headerlink" title="2:显性覆盖"></a>2:显性覆盖</h3><p>@AliasFor提供的属性覆盖能力。</p><h5 id="1-理解Spring注解属性别名-Aliases"><a href="#1-理解Spring注解属性别名-Aliases" class="headerlink" title="(1):理解Spring注解属性别名(Aliases)"></a>(1):理解Spring注解属性别名(Aliases)</h5><ul><li>@AliasFor可用于同一注解属性方法之间相互别名。<strong>同一注解两个属性方法需要相互</strong></li></ul><p><strong>“@AliasFor”，默认值必须相等</strong>。</p><ul><li>多层次注解属性之间的@AliasFor关系只能由较低层次向较高层次建立。即<strong>就近原则</strong>。</li><li>AnnotatedElementUtils.getMergedAnnotationAttributes方法也符合属性别名完整语义。</li><li>Spring为Spring元注解和@AliasFor提供了属性覆盖和别名特性，最终由AnnotationAttributes</li></ul><p>对象表达语义。</p><h5 id="2-代码实例"><a href="#2-代码实例" class="headerlink" title="(2):代码实例"></a>(2):代码实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类描述:组合注解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/4/25 20:11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="comment">//表明注解属性覆盖符合就近原则,由低层次向高层次建立。</span></span><br><span class="line"><span class="meta">@Service</span>(value = <span class="string">"transactionalService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TransactionalService &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 服务Bean名称</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> "txManager"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆盖&#123;<span class="doctag">@link</span> Transactional#transactionManager()&#125;默认值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> org.springframework.transaction.PlatformTransactionManager&#125;Bean名称,默认关联</span></span><br><span class="line"><span class="comment">     * &lt;br/&gt;</span></span><br><span class="line"><span class="comment">     * "txManager"Bean</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * String transactionManager() default "txManager";</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"name"</span>)</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "txManager"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立&#123;<span class="doctag">@link</span> Transactional#transactionManager()&#125;别名</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> org.springframework.transaction.PlatformTransactionManager&#125;Bean名称,默认关联</span></span><br><span class="line"><span class="comment">     * "txManager"Bean.</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(annotation = Transactional.class, attribute = <span class="string">"transactionManager"</span>)</span><br><span class="line">    <span class="function">String <span class="title">manager</span><span class="params">()</span> <span class="keyword">default</span> "txManager"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-重要的类"><a href="#3-重要的类" class="headerlink" title="3:重要的类"></a>3:重要的类</h3><p>1：ClassPathBeanDefinitionScanner</p><p>   读取类路径下的候选Bean，默认选取@Component，@Service，@Repository，@Controller注解的类。继承了ClassPathScanningCandidateComponentProvider。在该类BeanDefinition集合的候选条件由includeFilters和excludeFilters字段决定，在方法isCandidateComponent里实现。</p><p>  该类允许自定义类型过滤规则。常见的TypeFilter类。</p><ul><li>AnnotationTypeFilter：匹配类是否还有指定注解</li><li>AssignableTypeFilter：判定此 <code>Class</code> 对象所表示的类或接口与指定的 <code>Class</code> 参数所表示的类或接口是否相同，或是否是其超类或超接口。</li><li>RegexPatternTypeFilter：匹配全类限定名是否符合指定正则表达式。</li><li>AspectJTypeFilter：使用AspectJ类型模式进行匹配</li></ul><p>2：类元信息读取</p><p>(1)：MetadataReaderFactory：生成MetadataReader工厂</p><ul><li>SimpleMetadataReaderFactory：使用ASM字节码操作技术</li><li>CachingMetadataReaderFactory：使用ASM字节码操作技术和带缓存。</li></ul><p>(2)：使用Java反射获取类元信息</p><ul><li>StandardClassMetadata：读取Class元信息</li><li>StandardAnnotationMetadata：读取注解元信息</li><li>StandardMethodMetadata：读取方法</li></ul><p>(3)：使用ASM操作</p><ul><li>AnnotationMetadataReadingVisitor：查找类上元注解信息</li><li>MethodMetadataReadingVisitor：查找方法上元注解信息</li><li>AnnotationAttributesReadingVisitor：元注解属性读取</li></ul><p>(4)：类注解元信息读取接口</p><ul><li>AnnotationMetadata：读取注解。通过getAnnotationTypes(String)获取”元注解”</li></ul><p>信息，提供getAnnotationAttributes(String)方法获取指定注解的属性方法。</p><ul><li>ClassMetadata：类注解</li><li>AnnotatedTypeMetadata：注解的元注解</li></ul><p>3：Spring注解属性抽象</p><ul><li>AnnotationAttributes</li><li>AnnotatedElementUtils：对查找注解，元注解等注解的工具类</li><li>AnnotationUtils：用于处理注解的工具类。</li><li>ReflectionUtils：反射工具类。</li></ul><p>代码示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类描述: 组合注解启动类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/4/25 20:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@TransactionalService</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComposeAnnotationApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String className = ComposeAnnotationApplication.class.getName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建MetadataReaderFactory</span></span><br><span class="line">        MetadataReaderFactory metadataReaderFactory = <span class="keyword">new</span> CachingMetadataReaderFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取@TransactionalService MetadataReader信息</span></span><br><span class="line">        MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取@TransactionalService AnnotationMetadata信息</span></span><br><span class="line">        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();</span><br><span class="line"></span><br><span class="line">        annotationMetadata.getAnnotationTypes().forEach(annotationType -&gt; &#123;</span><br><span class="line">            Set&lt;String&gt; metaAnnotationTypes = annotationMetadata.getMetaAnnotationTypes(annotationType);</span><br><span class="line"></span><br><span class="line">            metaAnnotationTypes.forEach(metaAnnotationType -&gt; System.out.println(String.format(</span><br><span class="line">                    <span class="string">"注解 %s 元标注; %s\n"</span>, annotationType, metaAnnotationType)));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">springStandardAnnotationMetadata</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//读取@TransactionalService AnnotationMetadata信息</span></span><br><span class="line">        AnnotationMetadata annotationMetadata = <span class="keyword">new</span> StandardAnnotationMetadata(ComposeAnnotationReflectionApplication.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有的元注解(全类名)集合</span></span><br><span class="line">        Set&lt;String&gt; metaAnnotationTypes = annotationMetadata.getAnnotationTypes()</span><br><span class="line">                .stream()</span><br><span class="line">                <span class="comment">//读取单注解元注解类型集合</span></span><br><span class="line">                .map(annotationMetadata::getMetaAnnotationTypes)</span><br><span class="line">                <span class="comment">//合并元注解类型集合</span></span><br><span class="line">                .collect(LinkedHashSet::<span class="keyword">new</span>, Set::addAll, Set::addAll);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取所有元注解类型</span></span><br><span class="line">        metaAnnotationTypes.forEach(metaAnnotation -&gt; &#123;</span><br><span class="line">            <span class="comment">//读取元注解属性</span></span><br><span class="line">            Map&lt;String, Object&gt; annotationAttributes = annotationMetadata.getAnnotationAttributes(metaAnnotation);</span><br><span class="line">            <span class="keyword">if</span> (!CollectionUtils.isEmpty(annotationAttributes)) &#123;</span><br><span class="line">                annotationAttributes.forEach((name, value) -&gt; System.out.printf(<span class="string">"注解 %s 属性 %s = %s\n"</span>,</span><br><span class="line">                        ClassUtils.getShortName(metaAnnotation), name, value));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>Spring从4.0.0.RELEASE版本开始支持多层次@Component派生性。</strong></p><p>1:Spring中@Component,@Repository,@Service,@Controller就属于<strong>@Component派生注解</strong>。</p><p>称之为<strong>Spring模式注解</strong>。</p><h3 id="4-注解驱动过渡时代：Spring-Framework-2-x"><a href="#4-注解驱动过渡时代：Spring-Framework-2-x" class="headerlink" title="4:注解驱动过渡时代：Spring Framework 2.x"></a>4:注解驱动过渡时代：Spring Framework 2.x</h3><p>新引入了一些骨架式的Annotation</p><ul><li>依赖注入Annotation：@Autowired(可注入单个Bean，也可注入集合)—&gt;限定类型Class方式。</li><li>依赖查找Annotation：@Qualifier</li><li>组件声明Annotation：@Component,@Service</li><li>Spring MVC Annotation：@Controller,@RequestMapping,@ModelAttributes等。</li></ul><p>支持<strong>可扩展的XML编写</strong>。即Spring的Schema和Handlers机制。</p><p>支持<strong>JSR-250</strong>规范@Resource注入，@PostConstruct，@PreDestroy等。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>Spring2.5允许自定义Spring模式注解，不过该版本仅支持单层次的模式注解<strong>“派生”</strong>。但是编程手段不多，**主要</p><p>的原因在于框架层次仍未<strong>注解</strong>提供驱动注解的Spring应用上下文，并且仍需要XML配置驱动，即XML元素&lt;context:annotation-config&gt;和&lt;context-component-scan&gt;。</p><h3 id="5-注解驱动黄金时代：Spring-Framework-3-x"><a href="#5-注解驱动黄金时代：Spring-Framework-3-x" class="headerlink" title="5:注解驱动黄金时代：Spring Framework 3.x"></a>5:注解驱动黄金时代：Spring Framework 3.x</h3><p>全面拥抱Java5(泛型,变量参数等)，以及Spring Annotation引入。例如引入了配置类注解@Configuration,AnnotationConfigApplicationContext。但是没有引入替换&lt;context:component-scan/&gt;注解。</p><p>选择过渡方案@Import,@ImportResource(需要标注@Configuration注解)。Spring3.1引入注解@ComponentScan。<strong>引入了REST开发</strong>。</p><p>SpringWeb整合了<strong>Servlet3.0+</strong>按规范，利用<strong>javax.servlet.ServletContainerInitialier</strong> API实现传统Servlet容器</p><p><strong>自动装配</strong>的能力，替换了传统的web.xml。</p><p>1:Spring3.1抽象了一套全新并统一配置属性API,包括<strong>配置属性存储接口Environment,以及配置属性源抽象PropertySource</strong>，这两个核心API奠定了<strong>SpringBoot外部化配置的基础，也是SpringCloud分布式配置基石</strong>。</p><p>2:然后是<strong>缓存抽象</strong>，主要API包括<strong>缓存Cache和缓存管理器CacheManager</strong>。配套注解<strong>Caching和Cacheable等</strong></p><p>极大简化了数据缓存开发。</p><p>3:异步支持，引入了异步操作注解<strong>@Async,周期异步操作@Scheduled及异步Web请求处理操作DefferedResult</strong>。</p><p>4:校验方面，新增了注解<strong>@Validated</strong>，整合JSR-303和适配了Spring早期的Validator抽象。</p><p>5:<strong>Enabled模块驱动</strong>特性。将<strong>相同职责功能组件以模块化的方式装配</strong>。例如<strong>EnabledWebMvc</strong>。</p><h3 id="6-注解驱动完善时代-Spring-Framework-4-x"><a href="#6-注解驱动完善时代-Spring-Framework-4-x" class="headerlink" title="6:注解驱动完善时代:Spring Framework 4.x"></a>6:注解驱动完善时代:Spring Framework 4.x</h3><p>引入了<strong>条件化注解@Conditional</strong>，通过与自定义Condition实现配合，弥补之前版本条件化配置装配的</p><p>短板。SpringBoot的所有@ConditionalOn<em>注解均基于@Conditional派生注解，其抽象类*</em>SpringBootCondition**也是Condition的实现。</p><p>Spring4.x兼容了Java Time API(JSR-310),@Repeatable及参数名称发现。Java8的@Repeatable出现，解决了</p><p>以往Annotation无法重复标注同一个类的限制。<strong>Spring4.2引入了事件监听器注解@EventListener</strong>。</p><p>Spring的<strong>派生</strong>特性需要确保<strong>注解之间属性方法签名一致</strong>。限制在Spring4.2新注解<strong>@AliasFor</strong>解除，实现了</p><p>同一注解类属性方法之间的别名。Spring4.3引入<strong>REST请求注解</strong>。</p><p>Spring4.x在Web注解驱动编程也有提示，例如<strong>@RestController,@RestControllerAdvice(对RestController AOP拦截通知)</strong>。</p><h3 id="7-注解驱动当下时代-Spring-Framework5-x"><a href="#7-注解驱动当下时代-Spring-Framework5-x" class="headerlink" title="7:注解驱动当下时代:Spring Framework5.x"></a>7:注解驱动当下时代:Spring Framework5.x</h3><p>在SpringBoot应用场景中，大量使用注解@ComponentScan扫描指定package,当扫描package所包含的类越多时,</p><p>Spring模式注解耗费时间越长。针对这个问题,Spring5.x新引入了注解<strong>@Indexed</strong>,为Spring模式注解添加索引，提升启动性能。需要引入<strong>spring-context-indexer</strong>依赖。</p><h5 id="7-1-Spring核心注解场景分类"><a href="#7-1-Spring核心注解场景分类" class="headerlink" title="7-1:Spring核心注解场景分类"></a>7-1:Spring核心注解场景分类</h5><p><strong>Spring模式注解:</strong></p><table><thead><tr><th align="center">Spring注解</th><th align="center">场景说明</th><th align="center">起始版本</th></tr></thead><tbody><tr><td align="center">@Repository</td><td align="center">数据仓库模式注解</td><td align="center">2.0</td></tr><tr><td align="center">@Component</td><td align="center">通用组件模式注解</td><td align="center">2.5</td></tr><tr><td align="center">@Service</td><td align="center">服务模式</td><td align="center">2.5</td></tr><tr><td align="center">@Controller</td><td align="center">Web控制器模式注解</td><td align="center">2.5</td></tr><tr><td align="center">@Configuration</td><td align="center">配置类模式注解</td><td align="center">3.0</td></tr></tbody></table><p><strong>装配注解</strong></p><table><thead><tr><th align="center">Spring注解</th><th align="center">场景说明</th><th align="center">起始版本</th></tr></thead><tbody><tr><td align="center">@ImportResource</td><td align="center">替换XML元素&lt;import&gt;</td><td align="center">2.5</td></tr><tr><td align="center">@Import</td><td align="center">限定@Autowired依赖注解范围</td><td align="center">2.5</td></tr><tr><td align="center">@ComponentScan</td><td align="center">扫描指定package下标注Spring模式注解</td><td align="center">3.1</td></tr></tbody></table><p><strong>依赖注入注解</strong></p><table><thead><tr><th align="center">Spring注解</th><th align="center">场景说明</th><th align="center">起始版本</th></tr></thead><tbody><tr><td align="center">@Autowired</td><td align="center">Bean依赖注解,支持多种依赖查找方式</td><td align="center">2.5</td></tr><tr><td align="center">@Qualifier</td><td align="center">细粒度的@Autowired依赖查找</td><td align="center">2.5</td></tr><tr><td align="center">Java注解</td><td align="center">场景说明</td><td align="center">起始版本</td></tr><tr><td align="center">@Resource</td><td align="center">Bean依赖注入,仅支持名称依赖查找</td><td align="center">2.5</td></tr></tbody></table><p><strong>Bean定义注解</strong></p><table><thead><tr><th align="center">Spring注解</th><th align="center">场景说明</th><th align="center">起始版本</th></tr></thead><tbody><tr><td align="center">@Bean</td><td align="center">替换XML元素&lt;bean&gt;</td><td align="center">3.0</td></tr><tr><td align="center">@DependsOn</td><td align="center">替换XML属性&lt;bean depends-on=”…”/&gt;</td><td align="center">3.0</td></tr><tr><td align="center">@Lazy</td><td align="center">替换XML属性&lt;bean lazy-init=”trus|false”/&gt;</td><td align="center">3.0</td></tr><tr><td align="center">@Primary</td><td align="center">替换XML元素&lt;bean primary=”true|false”/&gt;</td><td align="center">3.0</td></tr><tr><td align="center">@Role</td><td align="center">替换XML元素&lt;bean role=”…”/&gt;</td><td align="center">3.1</td></tr><tr><td align="center">@Lookup</td><td align="center">替换XML属性&lt;bean lookup-method=”…”&gt;</td><td align="center">4.1</td></tr></tbody></table><p><strong>Spring条件装配注解</strong></p><table><thead><tr><th align="center">Spring注解</th><th align="center">场景说明</th><th align="center">起始版本</th></tr></thead><tbody><tr><td align="center">@Profile</td><td align="center">配置化条件装配</td><td align="center">3.1</td></tr><tr><td align="center">@Conditional</td><td align="center">编程条件装配</td><td align="center">3.1</td></tr></tbody></table><p><strong>配置属性注解</strong></p><table><thead><tr><th align="center">Spring注解</th><th align="center">场景说明</th><th align="center">起始版本</th></tr></thead><tbody><tr><td align="center">@PropertySource</td><td align="center">配置属性抽象PropertySource注解</td><td align="center">3.1</td></tr><tr><td align="center">@PropertySources</td><td align="center">@PropertySource集合注解</td><td align="center">4.0</td></tr></tbody></table><p><strong>生命周期回调注解</strong></p><table><thead><tr><th align="center">Java注解</th><th align="center">场景说明</th><th align="center">起始版本</th></tr></thead><tbody><tr><td align="center">@PostContruct</td><td align="center">替换XML元素&lt;bean init-method=”…”/&gt;</td><td align="center">2.5</td></tr><tr><td align="center">@PreDestroy</td><td align="center">替换XML元素&lt;bean destroy-method=”…”/&gt;</td><td align="center">2.5</td></tr></tbody></table><p><strong>注解属性注解</strong></p><table><thead><tr><th align="center">Spring注解</th><th align="center">场景说明</th><th align="center">起始版本</th></tr></thead><tbody><tr><td align="center">@AliasFor</td><td align="center">别名注解属性,实现复用目的</td><td align="center">4.2</td></tr></tbody></table><p><strong>性能注解</strong></p><table><thead><tr><th align="center">Spring注解</th><th align="center">场景说明</th><th align="center">起始版本</th></tr></thead><tbody><tr><td align="center">@Indexed</td><td align="center">提升Spring模式注解扫描效率</td><td align="center">5.0</td></tr></tbody></table><h5 id="8-AnnotationMetadata注解的实现"><a href="#8-AnnotationMetadata注解的实现" class="headerlink" title="8:AnnotationMetadata注解的实现"></a>8:AnnotationMetadata注解的实现</h5><blockquote><p>在AnnotationMetadata语义上,基于<code>Java反射StandardAnnotationMetadata</code>和<code>AnnotationMetadataReadingVisitor</code>保持一致。基于Java反射API实现必然需要<code>反射的Class被ClassLoader加载</code>，当指定Java Package扫描Spring模式注解时,StandardAnnotationMetadata显然不适应。</p><p>因为<code>应用不需要将指定Package下的Class全部加载</code>。基于ASM实现的<code>AnnotationMetadataReadingVisitor</code>更适合这种场景，解释了为什么该类出现ClassPathScanningCandidateComponentProvider实现中。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Annotation </tag>
            
            <tag> Spring注解属性覆盖 </tag>
            
            <tag> Spring核心注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Guava简介</title>
      <link href="/2019/08/06/Guava%E7%AE%80%E4%BB%8B/"/>
      <url>/2019/08/06/Guava%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h2><p>Guava工程包含了若干被Google的 Java项目广泛依赖 的核心库，例如：<strong>集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [common annotations] 、字符串处理 [string processing] 、I/O 等等</strong>。 所有这些工具每天都在被Google的工程师应用在产品服务中。</p><h2 id="2-基本工具"><a href="#2-基本工具" class="headerlink" title="2.基本工具"></a>2.基本工具</h2><ol><li><strong>使用和避免null: Optional</strong></li><li><strong>前置条件: Preconditions</strong></li><li><strong>常见Object方法: Objects</strong></li><li><strong>排序: Guava强大的”流畅风格比较器”:</strong> <strong>Ordering</strong></li><li><a href="http://ifeve.com/google-guava-throwables/" target="_blank" rel="noopener"><strong>Throwables</strong></a>: 简化了异常和错误的传播与检查 :  <strong>Throwables</strong></li><li><strong>编码类型:</strong> Charsets</li></ol><h2 id="3-集合"><a href="#3-集合" class="headerlink" title="3.集合"></a>3.集合</h2><ol><li><a href="http://ifeve.com/google-guava-immutablecollections/" target="_blank" rel="noopener"><strong>不可变集合</strong></a>: 用不变的集合进行防御性编程和性能提升:  Immutable开头。</li><li><a href="http://ifeve.com/google-guava-newcollectiontypes/" target="_blank" rel="noopener"><strong>新集合类型</strong></a>: multisets, multimaps, tables, bidirectional maps等</li><li><a href="http://ifeve.com/google-guava-collectionutilities/" target="_blank" rel="noopener"><strong>强大的集合工具类</strong></a>: 提供java.util.Collections中没有的集合工具</li><li><a href="http://ifeve.com/google-guava-collectionhelpersexplained/" target="_blank" rel="noopener"><strong>扩展工具类</strong></a>：让实现和扩展集合类变得更容易，比如创建Collection的装饰器，或实现迭代器</li></ol><h2 id="4-缓存-Caches"><a href="#4-缓存-Caches" class="headerlink" title="4.缓存[Caches]"></a>4.<a href="http://ifeve.com/google-guava-cachesexplained" target="_blank" rel="noopener">缓存</a>[Caches]</h2><p>Guava Cache: 本地缓存实现,支持多种缓存过期策略。</p><h2 id="5-函数式风格-Functional-idioms"><a href="#5-函数式风格-Functional-idioms" class="headerlink" title="5.函数式风格[Functional idioms]"></a>5.<a href="http://ifeve.com/google-guava-functional/" target="_blank" rel="noopener">函数式风格</a>[Functional idioms]</h2><p><strong>Guava函数式支持可以显著简化代码,但请谨慎使用。</strong></p><h2 id="6-并发-Concurrency"><a href="#6-并发-Concurrency" class="headerlink" title="6.并发[Concurrency]"></a>6.并发[Concurrency]</h2><ol><li><a href="http://ifeve.com/google-guava-listenablefuture/" target="_blank" rel="noopener"><strong>ListenableFuture</strong></a>：完成后触发回调的Future</li><li><a href="http://ifeve.com/google-guava-serviceexplained/" target="_blank" rel="noopener"><strong>Service框架</strong></a>：抽象可开启和关闭的服务，帮助你维护服务的状态逻辑</li></ol><h2 id="7-字符串处理-Strings"><a href="#7-字符串处理-Strings" class="headerlink" title="7.字符串处理[Strings]"></a>7.<a href="http://ifeve.com/google-guava-strings/" target="_blank" rel="noopener">字符串处理</a>[Strings]</h2><p>非常有用的字符串工具，包括分割、连接、填充等操作</p><h2 id="8-原生类型-Primitives"><a href="#8-原生类型-Primitives" class="headerlink" title="8.原生类型[Primitives]"></a>8.<a href="http://ifeve.com/google-guava-primitives/" target="_blank" rel="noopener">原生类型</a>[Primitives]</h2><p>扩展 JDK 未提供的原生类型（如int、char）操作， 包括某些类型的无符号形式</p><h2 id="9-区间-Ranges"><a href="#9-区间-Ranges" class="headerlink" title="9.区间[Ranges]"></a>9.<a href="http://ifeve.com/google-guava-ranges/" target="_blank" rel="noopener">区间</a>[Ranges]</h2><p>可比较类型的区间API，包括连续和离散类型</p><h2 id="10-I-O"><a href="#10-I-O" class="headerlink" title="10.I/O"></a>10.<a href="http://ifeve.com/google-guava-io/" target="_blank" rel="noopener">I/O</a></h2><p>简化I/O尤其是I/O流和文件的操作，<strong>针对Java5和6版本</strong></p><h2 id="11-散列-Hash"><a href="#11-散列-Hash" class="headerlink" title="11.散列[Hash]"></a>11.<a href="http://ifeve.com/google-guava-hashing/" target="_blank" rel="noopener">散列</a>[Hash]</h2><p>提供比Object.hashCode()更复杂的散列实现，<strong>并提供布鲁姆过滤器的实现</strong></p><h2 id="12-事件总线-EventBus"><a href="#12-事件总线-EventBus" class="headerlink" title="12. 事件总线[EventBus]"></a>12. <a href="http://ifeve.com/google-guava-eventbus/" target="_blank" rel="noopener">事件总线</a>[EventBus]</h2><p>发布-订阅模式的组件通信，但组件不需要显式地注册到其他组件中</p><h2 id="13-数学运算-Math"><a href="#13-数学运算-Math" class="headerlink" title="13.数学运算[Math]"></a>13.<a href="http://ifeve.com/google-guava-math/" target="_blank" rel="noopener">数学运算</a>[Math]</h2><p>优化的、充分测试的数学工具类</p><h2 id="14-反射-Reflection"><a href="#14-反射-Reflection" class="headerlink" title="14.反射[Reflection]"></a>14.<a href="http://ifeve.com/guava-reflection/" target="_blank" rel="noopener">反射</a>[Reflection]</h2><p>Guava 的 Java 反射机制工具类</p>]]></content>
      
      
      <categories>
          
          <category> Guava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Guava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot自动配置原理</title>
      <link href="/2019/08/05/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/"/>
      <url>/2019/08/05/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot自动配置原理"><a href="#SpringBoot自动配置原理" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h2><h4 id="1-产生背景"><a href="#1-产生背景" class="headerlink" title="1:产生背景"></a>1:产生背景</h4><p>  在Spring Framework时代,当Spring应用的@Component或者@Configuration Class需要被装配</p><p>时,应用需要借助@Import或者@ComponentScan的能力。由于应用依赖的Jar存在变化的可能,</p><p>因此其中的@Component或者@Configuration Class所在的包路径也会发生变化。</p><p>  <code>不鼓励开发人员通过@ComponentScan或者@SpringApplication</code>注解方式扫描默认包。<strong>因为</strong></p><p><strong>它读取所有JAR中类,并且可能会造成默认Spring Boot错误</strong></p><p>   当Spring应用自动装配某些组件时,它需要一种综合性技术手段,<strong>重新深度结合Spring注解编程</strong></p><p><strong>模型,@Enable模块驱动和条件装配等Spring Framework原生特性,这种技术就是Spring Boot</strong></p><p><strong>自动装配。</strong></p><h4 id="2-理解Spring-Boot自动装配"><a href="#2-理解Spring-Boot自动装配" class="headerlink" title="2:理解Spring Boot自动装配"></a>2:理解Spring Boot自动装配</h4><p>(1):理解@EnableAutoConfiguration</p><p>用于激活Spring Boot自动装配特性。</p><p>(2):优雅的替换自动装配</p><p>开发人员可在任意一处定义配置类,从而覆盖那些被自动装配的组件。<code>SpringBoot优先解析</code></p><p><code>自定义配置类。内建的配置类,一旦应用存在自定义实现，就不会再装配</code>。</p><p>(3):失效自动装配</p><p>SpringBoot提供两种失效手段</p><ul><li>代码配置方式<ul><li>配置类型安全属性方法:@EnableAutoConfiguration.exclude()</li><li>配置排除类名方式:@EnableAutoConfiguration.excludeName()</li></ul></li><li>外部化配置方式<ul><li>配置属性:spring.autoconfigure.exclude</li></ul></li></ul><h4 id="3-自动装配原理"><a href="#3-自动装配原理" class="headerlink" title="3:自动装配原理"></a>3:自动装配原理</h4><p>  依照@Enable模块驱动设计模式，@EnableAutoConguration必然是@Import 类ImportSelector</p><p>或者ImportBeanDefinitionRegistrar的实现类。</p><p><strong>AutoConfigurationImportSelector主要执行逻辑:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line"><span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line"><span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//读取自动装配元信息配置文件</span></span><br><span class="line">       <span class="comment">//"META-INF/"+ "spring-autoconfigure-metadata.properties"</span></span><br><span class="line">AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">.loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">       <span class="comment">//获取@EnableAutoConfiguration注解属性</span></span><br><span class="line">AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">       <span class="comment">//获取自动装配Class候选列表</span></span><br><span class="line">List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">attributes);</span><br><span class="line">       <span class="comment">//移除重复的自动装配类名</span></span><br><span class="line">configurations = removeDuplicates(configurations);</span><br><span class="line">       <span class="comment">//排除自动装配组件</span></span><br><span class="line">Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">       <span class="comment">//检查排除类名集合是否合法</span></span><br><span class="line">checkExcludedClasses(configurations, exclusions);</span><br><span class="line">configurations.removeAll(exclusions);</span><br><span class="line">       <span class="comment">//过滤候选自动装配组件集合中Class不存在成员</span></span><br><span class="line">configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">       <span class="comment">//触发自动装配导入事件</span></span><br><span class="line">fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line"><span class="keyword">return</span> StringUtils.toStringArray(configurations);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(1):读取候选装配组件</p><p>使用了Spring工厂加载类<code>SpringFactoriesLoader</code>。原理如下</p><ul><li><p>搜索指定ClassLoader下所有的META-INF/spring.factories资源内容。</p></li><li><p>将一个或者多个META-INF/spring.factories资源内容作为Properties文件读取,并合并为</p><p>一个Key为接口的全类限定名,Value是实现类的全类名列表的Map,作为返回值。</p></li><li><p>再从上一步返回Map中查找并返回方法指定类名所映射的实现类全类名列表。</p></li></ul><p>SpringBoot自动装配列表存在地方</p><ul><li>spring-boot-autoconfigure模块</li><li>spring-boot-actuator-autoconfigure模块</li><li>spring-boot-devtools模块(可选)</li></ul><p>由于@EnableAutoConfiguration配置可能存在配置组件类名重复定义情况,当获取所有候选类,</p><p>立即执行removeDuplicates(List)方法,利用Set不可重复性达到去重的目的。</p><p>(2):排除自动装配组件</p><p>当<code>getExclusions(AnnotationMetadata metadata,AnnotationAttributes attributes)</code></p><p>执行后,程序将获取到一个自动装配Class排除列表。随后检查排除类名集合是否合法。当排除类</p><p>存在于当前的ClassLoader但是不在自动装配名单中,将触发排除类非法异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkExcludedClasses</span><span class="params">(List&lt;String&gt; configurations,</span></span></span><br><span class="line"><span class="function"><span class="params">Set&lt;String&gt; exclusions)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; invalidExcludes = <span class="keyword">new</span> ArrayList&lt;&gt;(exclusions.size());</span><br><span class="line"><span class="keyword">for</span> (String exclusion : exclusions) &#123;</span><br><span class="line">           <span class="comment">//存在当前ClassLoader但是不在自动装配列表名单</span></span><br><span class="line"><span class="keyword">if</span> (ClassUtils.isPresent(exclusion, getClass().getClassLoader())</span><br><span class="line">&amp;&amp; !configurations.contains(exclusion)) &#123;</span><br><span class="line">invalidExcludes.add(exclusion);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!invalidExcludes.isEmpty()) &#123;</span><br><span class="line">handleInvalidExcludes(invalidExcludes);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3):过滤自动装配组件</p><p>移除排除类名单后Configurations配合AutoConfigurationMetadata对象执行过滤操作。</p><p>(4):@EnableAutoConfiguration自动装配事件</p><p> SpringBoot1.5开始引入<code>AutoConfigurationImportListener</code>接口,自定义Java EventListener</p><p>,仅监听AutoConfigurationImportEvent,然后实例同样被SpringFactoriesLoader加载。其中,</p><p><code>ConditionEvaluationReportAutoConfigurationImportListener</code>就是内建实现,用于</p><p>记录自动装配组件的条件评估详情。</p><p>(5):EnableAutoConfiguration自动装配生命周期</p><p><code>DeferredImportSelector</code>作为<code>ImportSelector</code>变种,它在@Configuration Bean处理完毕</p><p>后才运作。在<code>@Conditional</code>场景尤为有用，同时该实现类可通过Ordered接口或者@Order</p><p>方式调整其优先顺序。</p><p> 该接口提供两类方法: process()和selectImports()。前者二次处理selectImports()方法返回</p><p>的结果，后者负责决定本组应该导入的Configuration Class作为实际导入的结果。</p><p>(6):EnableAutoConfiguration排序自动装配组件</p><p> SpringBoot提供两种自动装配组件排序手段:</p><ul><li>绝对自动装配顺序:@AutoConfigurationOrder</li><li>相对自动装配顺序:@AutoConfigurationBefore和@AutoConfigurationAfter。(常用)</li></ul><p>(7):EnableAutoConfiguration自动装配BasePackages</p><p> SpringBoot1.3开始引用注解@AutoConfigurationPackage。</p><p> 该注解的实现类常常用于默认包获取。例如JPA实现获取默认包。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 自动配置原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring @Enable模块驱动原理</title>
      <link href="/2019/08/05/Enable%E6%A8%A1%E5%9D%97%E9%A9%B1%E5%8A%A8%E5%8E%9F%E7%90%86/"/>
      <url>/2019/08/05/Enable%E6%A8%A1%E5%9D%97%E9%A9%B1%E5%8A%A8%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Enable模块驱动原理"><a href="#Spring-Enable模块驱动原理" class="headerlink" title="Spring @Enable模块驱动原理"></a>Spring @Enable模块驱动原理</h2><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1:概述"></a>1:概述</h4><p><strong>@Enable模块驱动</strong>在<em>Spring3.1</em>后开始支持。这里的<em>模块指具备相同领域的功能组件集合,组合所形成的一个独立的单元</em>。例如Web MVC模块,AspectJ代理模块,Caching模块,JMX模块,Async模块等。通过@Enable模块驱动,可以开启响应的模块功能。</p><p>@Enable模块驱动可以分为”注解驱动”和”接口编程”两种实现方式。<strong>都需要配合@Import注解。</strong></p><blockquote><ul><li>注解驱动:通过@Configuration类和@Bean方法声明类。例如Web MVC模块实现,即@EnableWebMvc注解通过导入DelegatingWebMvcConfiguration来实现。</li><li>接口编程:ImportSelector和ImportBeanDefinitionRegistrar的实现类。例如Caching模块实现,即</li></ul><p>@EnableCaching注解通过导入CachingConfigurationSelector实现。</p></blockquote><h4 id="2-实现示例"><a href="#2-实现示例" class="headerlink" title="2:实现示例"></a>2:实现示例</h4><h5 id="1-注解驱动"><a href="#1-注解驱动" class="headerlink" title="(1):注解驱动"></a>(1):注解驱动</h5><p><strong>基于ImportSelector接口</strong></p><p>@EnableWebMvc模块实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(DelegatingWebMvcConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableWebMvc &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注解通过<em>@Import<em>导入一个配置类</em>DelegatingWebMvcConfiguration</em>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line">      ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该配置类又继承自<em>WebMvcConfigurationSupport</em>,里面定义一些Web Mvc必须Bean声明。</p><blockquote><p>所以，基于注解驱动的<code>@Enable</code>模块驱动其实就是通过<code>@Import</code>来导入一个配置类，以此实现相应模块的组件注册，当这些组件注册到IOC容器中，这个模块对应的功能也就可以使用了。</p></blockquote><h5 id="2-接口编程"><a href="#2-接口编程" class="headerlink" title="(2):接口编程"></a>(2):接口编程</h5><p>@EnableCaching模块实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(CachingConfigurationSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableCaching &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">AdviceMode <span class="title">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>@EnableCaching*注解通过</em>@Import<em>导入</em>CachingConfigurationSelector<em>类,该类间接实现了</em>ImportSelector*。</p><blockquote><p><strong>ImportSelector</strong>使用Spring<code>注解元信息抽象AnnotationMetadata</code>作为方法参数,该参数内容为导入ImportSelector实现的@Configuration类元信息,进而动态的选择一个或者多个其他@Configuration类进行导入。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Interface to be implemented by types that determine which @&#123;<span class="doctag">@link</span> Configuration&#125;</span></span><br><span class="line"><span class="comment">* class(es) should be imported based on a given selection criteria, usually one or more</span></span><br><span class="line"><span class="comment">* annotation attributes.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Select and return the names of which class(es) should be imported based on</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@link</span> AnnotationMetadata&#125; of the importing @&#123;<span class="doctag">@link</span> Configuration&#125; class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] selectImports(AnnotationMetadata importingClassMetadata);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基于ImportBeanDefinitionRegistrar接口</strong></p><p>@MapperScan模块实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperScannerRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AnnotationAttributes annoAttrs = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));</span><br><span class="line">    ClassPathMapperScanner scanner = <span class="keyword">new</span> ClassPathMapperScanner(registry);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationClass = annoAttrs.getClass(<span class="string">"annotationClass"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!Annotation.class.equals(annotationClass)) &#123;</span><br><span class="line">      scanner.setAnnotationClass(annotationClass);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    scanner.registerFilters();</span><br><span class="line">    scanner.doScan(StringUtils.toStringArray(basePackages));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口的编程复杂度相比较于ImportSelector更高,接口将Bean定义的注册交给开发人员。常常配合<code>ClassPathBeanDefinitionScanner</code>类进行批量注册BeanDefinition。</p><blockquote><p><strong>ImportBeanDefinitionRegistrar</strong>:除注解元信息AnnotationMetadata作为入参外,接口将</p><p>Bean定义注册交给开发人员。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Interface to be implemented by types that register additional bean definitions when</span></span><br><span class="line"><span class="comment">* processing @&#123;<span class="doctag">@link</span> Configuration&#125; classes. Useful when operating at the bean definition</span></span><br><span class="line"><span class="comment">* level (as opposed to &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; method/instance level) is desired or necessary.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register bean definitions as necessary based on the given annotation metadata of</span></span><br><span class="line"><span class="comment"> * the importing &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that &#123;<span class="doctag">@link</span> BeanDefinitionRegistryPostProcessor&#125; types may &lt;em&gt;not&lt;/em&gt; be</span></span><br><span class="line"><span class="comment"> * registered here, due to lifecycle constraints related to &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125;</span></span><br><span class="line"><span class="comment"> * class processing.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> importingClassMetadata annotation metadata of the importing class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry current bean definition registry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Enable模块驱动原理"><a href="#3-Enable模块驱动原理" class="headerlink" title="3:@Enable模块驱动原理"></a>3:@Enable模块驱动原理</h4><p>1:概述</p><p>@Enable模块驱动,模块无论来自于Spring内建,还是自定义,均使用<code>@Import</code>实现,<strong>并且该注解的职责在于装载导入类,将其定义为Spring Bean。导入主要为@Configuration Class,ImportSelector实现及ImportBeanDefinitionRegistrar实现。</strong></p><p>2:源码实现</p><p>(1):装载@Configuration Class。</p><p>@Configuration从Spring3.0开始引入,<em>该版本还未引入@ComponentScan</em>。因此,开发人员经常看到XML元素&lt;context:component-scan/&gt;与&lt;context:annotation-config&gt;同时存在。根据Spring的”可扩展XML编写”特性,可以知道&lt;context:annotation-config&gt;所对应的BeanDefinitionParser实现为AnnotationConfigBeanDefinitionParser。</p><p>AnnotationConfigBeanDefinitionParser</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parser for the &amp;lt;context:annotation-config/&amp;gt; element.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mark Fisher</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Christian Dupuis</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> AnnotationConfigUtils</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationConfigBeanDefinitionParser</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">Object source = parserContext.extractSource(element);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Obtain bean definitions for all relevant BeanPostProcessors.</span></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; processorDefinitions =</span><br><span class="line">AnnotationConfigUtils.registerAnnotationConfigProcessors(parserContext.getRegistry(), source);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AnnotationConfigUtils在Spring3.0增加了@Configuration Class的处理实现ConfigurationClassPostProcessor:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class AnnotationConfigUtils &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The bean name of the internally managed Configuration annotation processor.</span><br><span class="line"> */</span><br><span class="line">public static final String CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME =</span><br><span class="line">&quot;org.springframework.context.annotation.internalConfigurationAnnotationProcessor&quot;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The bean name of the internally managed BeanNameGenerator for use when processing</span><br><span class="line"> * &#123;@link Configuration&#125; classes. Set by &#123;@link AnnotationConfigApplicationContext&#125;</span><br><span class="line"> * and &#123;@code AnnotationConfigWebApplicationContext&#125; during bootstrap in order to make</span><br><span class="line"> * any custom name generation strategy available to the underlying</span><br><span class="line"> * &#123;@link ConfigurationClassPostProcessor&#125;.</span><br><span class="line"> * @since 3.1.1</span><br><span class="line"> */</span><br><span class="line">public static final String CONFIGURATION_BEAN_NAME_GENERATOR =</span><br><span class="line">&quot;org.springframework.context.annotation.internalConfigurationBeanNameGenerator&quot;;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Register all relevant annotation post processors in the given registry.</span><br><span class="line"> * @param registry the registry to operate on</span><br><span class="line"> */</span><br><span class="line">public static void registerAnnotationConfigProcessors(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">registerAnnotationConfigProcessors(registry, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static Set&lt;BeanDefinitionHolder&gt; registerAnnotationConfigProcessors(</span><br><span class="line">BeanDefinitionRegistry registry, Object source) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; beanDefs = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(4);</span><br><span class="line"></span><br><span class="line">if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);</span><br><span class="line">def.setSource(source);</span><br><span class="line">beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">return beanDefs;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的说,ConfigurationClassPostProcessor无论实在XML配置驱动还是在注解驱动使用场景下,均通过AnnotationConfigUtils.registerAnnotationConfigProcessors(registry,source)方法执行得到装载,且为最高优先级。不但处理了@Configuration Class,也负责@Bean方法的Bean定义。</p><p>(2):ConfigurationClassPostProcessor处理</p><p>//主要处理方法落在processConfigBeanDefinitions(registry)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationClassPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>,</span></span><br><span class="line"><span class="class"><span class="title">PriorityOrdered</span>, <span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prepare the Configuration classes for servicing bean requests at runtime</span></span><br><span class="line"><span class="comment"> * by replacing them with CGLIB-enhanced subclasses.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> factoryId = System.identityHashCode(beanFactory);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.factoriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="string">"postProcessBeanFactory already called on this post-processor against "</span> + beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.factoriesPostProcessed.add(factoryId);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.registriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line"><span class="comment">// BeanDefinitionRegistryPostProcessor hook apparently not supported...</span></span><br><span class="line"><span class="comment">// Simply call processConfigurationClasses lazily at this point then.</span></span><br><span class="line">processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enhanceConfigurationClasses(beanFactory);</span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ImportAwareBeanPostProcessor(beanFactory));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Build and validate a configuration model based on the registry of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Configuration&#125; classes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> ArrayList&lt;BeanDefinitionHolder&gt;();</span><br><span class="line">String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">BeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class="line"><span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||</span><br><span class="line">ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) &#123;</span><br><span class="line">                ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">configCandidates.add(<span class="keyword">new</span> BeanDefinitionHolder(beanDef, beanName));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return immediately if no @Configuration classes were found</span></span><br><span class="line"><span class="keyword">if</span> (configCandidates.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort by previously determined @Order value, if applicable</span></span><br><span class="line">Collections.sort(configCandidates, <span class="keyword">new</span> Comparator&lt;BeanDefinitionHolder&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line"><span class="keyword">int</span> i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line"><span class="keyword">return</span> (i1 &lt; i2) ? -<span class="number">1</span> : (i1 &gt; i2) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detect any custom bean name generation strategy supplied through the enclosing application context</span></span><br><span class="line">SingletonBeanRegistry sbr = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) &#123;</span><br><span class="line">sbr = (SingletonBeanRegistry) registry;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.localBeanNameGeneratorSet &amp;&amp; sbr.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) &#123;</span><br><span class="line">BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line"><span class="keyword">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line"><span class="keyword">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parse each @Configuration class</span></span><br><span class="line">ConfigurationClassParser parser = <span class="keyword">new</span> ConfigurationClassParser(</span><br><span class="line"><span class="keyword">this</span>.metadataReaderFactory, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.environment,</span><br><span class="line"><span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinitionHolder&gt;(configCandidates);</span><br><span class="line">Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> HashSet&lt;ConfigurationClass&gt;(configCandidates.size());</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">parser.parse(candidates);</span><br><span class="line">parser.validate();</span><br><span class="line"></span><br><span class="line">Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> LinkedHashSet&lt;ConfigurationClass&gt;(parser.getConfigurationClasses());</span><br><span class="line">configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read the model and create bean definitions based on its content</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.reader == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.reader = <span class="keyword">new</span> ConfigurationClassBeanDefinitionReader(</span><br><span class="line">registry, <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.environment,</span><br><span class="line"><span class="keyword">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">alreadyParsed.addAll(configClasses);</span><br><span class="line"></span><br><span class="line">candidates.clear();</span><br><span class="line"><span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">Set&lt;String&gt; oldCandidateNames = <span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(candidateNames));</span><br><span class="line">Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"><span class="keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class="line">alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String candidateName : newCandidateNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line">BeanDefinition bd = registry.getBeanDefinition(candidateName);</span><br><span class="line"><span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="keyword">this</span>.metadataReaderFactory) &amp;&amp;</span><br><span class="line">!alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line">candidates.add(<span class="keyword">new</span> BeanDefinitionHolder(bd, candidateName));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">candidateNames = newCandidateNames;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span></span><br><span class="line"><span class="keyword">if</span> (sbr != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class="line">sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.metadataReaderFactory <span class="keyword">instanceof</span> CachingMetadataReaderFactory) &#123;</span><br><span class="line">((CachingMetadataReaderFactory) <span class="keyword">this</span>.metadataReaderFactory).clearCache();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Post-processes a BeanFactory in search of Configuration class BeanDefinitions;</span></span><br><span class="line"><span class="comment"> * any candidates are then enhanced by a &#123;<span class="doctag">@link</span> ConfigurationClassEnhancer&#125;.</span></span><br><span class="line"><span class="comment"> * Candidate status is determined by BeanDefinition attribute metadata.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurationClassEnhancer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enhanceConfigurationClasses</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = <span class="keyword">new</span> LinkedHashMap&lt;String, AbstractBeanDefinition&gt;();</span><br><span class="line"><span class="keyword">for</span> (String beanName : beanFactory.getBeanDefinitionNames()) &#123;</span><br><span class="line">BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);</span><br><span class="line"><span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(beanDef <span class="keyword">instanceof</span> AbstractBeanDefinition)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Cannot enhance @Configuration bean definition '"</span> +</span><br><span class="line">beanName + <span class="string">"' since it is not stored in an AbstractBeanDefinition subclass"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (configBeanDefs.isEmpty()) &#123;</span><br><span class="line"><span class="comment">// nothing to enhance -&gt; return immediately</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ConfigurationClassEnhancer enhancer = <span class="keyword">new</span> ConfigurationClassEnhancer();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) &#123;</span><br><span class="line">AbstractBeanDefinition beanDef = entry.getValue();</span><br><span class="line"><span class="comment">// If a @Configuration class gets proxied, always proxy the target class</span></span><br><span class="line">beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Set enhanced subclass of the user-specified bean class</span></span><br><span class="line">Class&lt;?&gt; configClass = beanDef.resolveBeanClass(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, <span class="keyword">this</span>.beanClassLoader);</span><br><span class="line"><span class="keyword">if</span> (configClass != enhancedClass) &#123;</span><br><span class="line">    ...</span><br><span class="line">beanDef.setBeanClass(enhancedClass);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行期间,最重要的组件莫过于ConfigurationClassParser</strong>,它将已注册的Spring BeanDefinition进行注解元信息解析,其中两个parse重载方法分别采用CGLIB实现的AnnotationMetadataReadingVisitor和Java反射实现的</p><p>StandardAnnotationMetadata。</p><p>ConfigurationClassParser</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigurationClassParser</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processConfigurationClass</span><span class="params">(ConfigurationClass configClass)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConfigurationClass existingClass = <span class="keyword">this</span>.configurationClasses.get(configClass);</span><br><span class="line"><span class="keyword">if</span> (existingClass != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line"><span class="keyword">if</span> (existingClass.isImported()) &#123;</span><br><span class="line">existingClass.mergeImportedBy(configClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Otherwise ignore new imported config class; existing non-imported class overrides it.</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Explicit bean definition found, probably replacing an import.</span></span><br><span class="line"><span class="comment">// Let's remove the old one and go with the new one.</span></span><br><span class="line"><span class="keyword">this</span>.configurationClasses.remove(configClass);</span><br><span class="line"><span class="keyword">for</span> (Iterator&lt;ConfigurationClass&gt; it = <span class="keyword">this</span>.knownSuperclasses.values().iterator(); it.hasNext();) &#123;</span><br><span class="line"><span class="keyword">if</span> (configClass.equals(it.next())) &#123;</span><br><span class="line">it.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Recursively process the configuration class and its superclass hierarchy.</span></span><br><span class="line">SourceClass sourceClass = asSourceClass(configClass);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">sourceClass = doProcessConfigurationClass(configClass, sourceClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (sourceClass != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doProcessConfigurationClass处理以下问题:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Recursively process any member (nested) classes first</span></span><br><span class="line">processMemberClasses(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process any @PropertySource annotations</span></span><br><span class="line"><span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">sourceClass.getMetadata(), PropertySources.class,</span><br><span class="line">org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">processPropertySource(propertySource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.warn(<span class="string">"Ignoring @PropertySource annotation on ["</span> + sourceClass.getMetadata().getClassName() +</span><br><span class="line"><span class="string">"]. Reason: Environment must implement ConfigurableEnvironment"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process any @ComponentScan annotations</span></span><br><span class="line">Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line"><span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">!<span class="keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line"><span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line"><span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line"><span class="keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line"><span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line"><span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line"><span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(</span><br><span class="line">holder.getBeanDefinition(), <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process any @Import annotations</span></span><br><span class="line">processImports(configClass, sourceClass, getImports(sourceClass), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process any @ImportResource annotations</span></span><br><span class="line"><span class="keyword">if</span> (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) &#123;</span><br><span class="line">AnnotationAttributes importResource =</span><br><span class="line">AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line">String[] resources = importResource.getStringArray(<span class="string">"locations"</span>);</span><br><span class="line">Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(<span class="string">"reader"</span>);</span><br><span class="line"><span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">String resolvedResource = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process individual @Bean methods</span></span><br><span class="line">Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line"><span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">configClass.addBeanMethod(<span class="keyword">new</span> BeanMethod(methodMetadata, configClass));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process default methods on interfaces</span></span><br><span class="line">processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process superclass, if any</span></span><br><span class="line"><span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">String superclass = sourceClass.getMetadata().getSuperClassName();</span><br><span class="line"><span class="keyword">if</span> (!superclass.startsWith(<span class="string">"java"</span>) &amp;&amp; !<span class="keyword">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line"><span class="keyword">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line"><span class="comment">// Superclass found, return its annotation metadata and recurse</span></span><br><span class="line"><span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No superclass -&gt; processing is complete</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理<strong>@PropertySource</strong>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processPropertySource</span><span class="params">(AnnotationAttributes propertySource)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">String name = propertySource.getString(<span class="string">"name"</span>);</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(name)) &#123;</span><br><span class="line">name = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">String encoding = propertySource.getString(<span class="string">"encoding"</span>);</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(encoding)) &#123;</span><br><span class="line">encoding = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">String[] locations = propertySource.getStringArray(<span class="string">"value"</span>);</span><br><span class="line">Assert.isTrue(locations.length &gt; <span class="number">0</span>, <span class="string">"At least one @PropertySource(value) location is required"</span>);</span><br><span class="line"><span class="keyword">boolean</span> ignoreResourceNotFound = propertySource.getBoolean(<span class="string">"ignoreResourceNotFound"</span>);</span><br><span class="line"></span><br><span class="line">Class&lt;? extends PropertySourceFactory&gt; factoryClass = propertySource.getClass(<span class="string">"factory"</span>);</span><br><span class="line">PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?</span><br><span class="line">DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String location : locations) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String resolvedLocation = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(location);</span><br><span class="line">Resource resource = <span class="keyword">this</span>.resourceLoader.getResource(resolvedLocation);</span><br><span class="line">addPropertySource(factory.createPropertySource(name, <span class="keyword">new</span> EncodedResource(resource, encoding)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line"><span class="comment">// Placeholders not resolvable</span></span><br><span class="line"><span class="keyword">if</span> (ignoreResourceNotFound) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Properties location ["</span> + location + <span class="string">"] not resolvable: "</span> + ex.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="comment">// Resource not found when trying to open it</span></span><br><span class="line"><span class="keyword">if</span> (ignoreResourceNotFound &amp;&amp;</span><br><span class="line">(ex <span class="keyword">instanceof</span> FileNotFoundException || ex <span class="keyword">instanceof</span> UnknownHostException)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Properties location ["</span> + location + <span class="string">"] not resolvable: "</span> + ex.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addPropertySource</span><span class="params">(PropertySource&lt;?&gt; propertySource)</span> </span>&#123;</span><br><span class="line">String name = propertySource.getName();</span><br><span class="line">MutablePropertySources propertySources = ((ConfigurableEnvironment) <span class="keyword">this</span>.environment).getPropertySources();</span><br><span class="line"><span class="keyword">if</span> (propertySources.contains(name) &amp;&amp; <span class="keyword">this</span>.propertySourceNames.contains(name)) &#123;</span><br><span class="line"><span class="comment">// We've already added a version, we need to extend it</span></span><br><span class="line">PropertySource&lt;?&gt; existing = propertySources.get(name);</span><br><span class="line">PropertySource&lt;?&gt; newSource = (propertySource <span class="keyword">instanceof</span> ResourcePropertySource ?</span><br><span class="line">((ResourcePropertySource) propertySource).withResourceName() : propertySource);</span><br><span class="line"><span class="keyword">if</span> (existing <span class="keyword">instanceof</span> CompositePropertySource) &#123;</span><br><span class="line">((CompositePropertySource) existing).addFirstPropertySource(newSource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (existing <span class="keyword">instanceof</span> ResourcePropertySource) &#123;</span><br><span class="line">existing = ((ResourcePropertySource) existing).withResourceName();</span><br><span class="line">&#125;</span><br><span class="line">CompositePropertySource composite = <span class="keyword">new</span> CompositePropertySource(name);</span><br><span class="line">composite.addPropertySource(newSource);</span><br><span class="line">composite.addPropertySource(existing);</span><br><span class="line">propertySources.replace(name, composite);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.propertySourceNames.isEmpty()) &#123;</span><br><span class="line">propertySources.addLast(propertySource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">String firstProcessed = <span class="keyword">this</span>.propertySourceNames.get(<span class="keyword">this</span>.propertySourceNames.size() - <span class="number">1</span>);</span><br><span class="line">propertySources.addBefore(firstProcessed, propertySource);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.propertySourceNames.add(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理<strong>@ComponentScan</strong>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Process any @ComponentScan annotations</span></span><br><span class="line">Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line"><span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">!<span class="keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line"><span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line"><span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line"><span class="keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line"><span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line"><span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line"><span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(</span><br><span class="line">holder.getBeanDefinition(), <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理@Import注解,@ImportResource,@Bean注解。其中@Import处理方法processImports与processConfigurationClass(ConfigurationClass configClass)形成递归调用。实现多层次@Import元标注的ConfigurationClass解析。解析后的ConfigurationClass将会被ConfigurationClassBeanDefinitionReader再次注册为SpringBean。ConfigurationClassBeanDefinitionReader将@Import,@ImportResource,@Bean所关联的Bean定义一并注册了。</p><p>(3):ConfigurationClassBeanDefinitionReader:将解析的Configuration Classs注册为Spring Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigurationClassBeanDefinitionReader</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(Set&lt;ConfigurationClass&gt; configurationModel)</span> </span>&#123;</span><br><span class="line">TrackedConditionEvaluator trackedConditionEvaluator = <span class="keyword">new</span> TrackedConditionEvaluator();</span><br><span class="line"><span class="keyword">for</span> (ConfigurationClass configClass : configurationModel) &#123;</span><br><span class="line">loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Read a particular &#123;<span class="doctag">@link</span> ConfigurationClass&#125;, registering bean definitions</span></span><br><span class="line"><span class="comment"> * for the class itself and all of its &#123;<span class="doctag">@link</span> Bean&#125; methods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitionsForConfigurationClass</span><span class="params">(ConfigurationClass configClass,</span></span></span><br><span class="line"><span class="function"><span class="params">TrackedConditionEvaluator trackedConditionEvaluator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">registerBeanDefinitionForImportedConfigurationClass(configClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (BeanMethod beanMethod : configClass.getBeanMethods()) &#123;</span><br><span class="line">loadBeanDefinitionsForBeanMethod(beanMethod);</span><br><span class="line">&#125;</span><br><span class="line">loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());</span><br><span class="line">loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register the &#123;<span class="doctag">@link</span> Configuration&#125; class itself as a bean definition.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitionForImportedConfigurationClass</span><span class="params">(ConfigurationClass configClass)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Read the given &#123;<span class="doctag">@link</span> BeanMethod&#125;, registering bean definitions</span></span><br><span class="line"><span class="comment"> * with the BeanDefinitionRegistry based on its contents.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitionsForBeanMethod</span><span class="params">(BeanMethod beanMethod)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitionsFromImportedResources</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Map&lt;String, Class&lt;? extends BeanDefinitionReader&gt;&gt; importedResources)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitionsFromRegistrars</span><span class="params">(Map&lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&gt; registrars)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&gt; entry : registrars.entrySet()) &#123;</span><br><span class="line">entry.getKey().registerBeanDefinitions(entry.getValue(), <span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4):ConfigurationClassUtils:判定Configuration Class的级别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationClassUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIGURATION_CLASS_FULL = <span class="string">"full"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIGURATION_CLASS_LITE = <span class="string">"lite"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIGURATION_CLASS_ATTRIBUTE =</span><br><span class="line">Conventions.getQualifiedAttributeName(ConfigurationClassPostProcessor.class, <span class="string">"configurationClass"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ORDER_ATTRIBUTE =</span><br><span class="line">Conventions.getQualifiedAttributeName(ConfigurationClassPostProcessor.class, <span class="string">"order"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(ConfigurationClassUtils.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; candidateIndicators = <span class="keyword">new</span> HashSet&lt;String&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">candidateIndicators.add(Component.class.getName());</span><br><span class="line">candidateIndicators.add(ComponentScan.class.getName());</span><br><span class="line">candidateIndicators.add(Import.class.getName());</span><br><span class="line">candidateIndicators.add(ImportResource.class.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check the given metadata for a configuration class candidate</span></span><br><span class="line"><span class="comment"> * (or nested component class declared within a configuration/component class).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> metadata the metadata of the annotated class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the given class is to be registered as a</span></span><br><span class="line"><span class="comment"> * reflection-detected bean definition; &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isConfigurationCandidate</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (isFullConfigurationCandidate(metadata) || isLiteConfigurationCandidate(metadata));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check the given metadata for a full configuration class candidate</span></span><br><span class="line"><span class="comment"> * (i.e. a class annotated with &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125;).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> metadata the metadata of the annotated class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the given class is to be processed as a full</span></span><br><span class="line"><span class="comment"> * configuration class, including cross-method call interception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFullConfigurationCandidate</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> metadata.isAnnotated(Configuration.class.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check the given metadata for a lite configuration class candidate</span></span><br><span class="line"><span class="comment"> * (e.g. a class annotated with &#123;<span class="doctag">@code</span> <span class="doctag">@Component</span>&#125; or just having</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Import</span>&#125; declarations or &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span> methods&#125;).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> metadata the metadata of the annotated class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the given class is to be processed as a lite</span></span><br><span class="line"><span class="comment"> * configuration class, just registering it and scanning it for &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; methods</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLiteConfigurationCandidate</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Do not consider an interface or an annotation...</span></span><br><span class="line"><span class="keyword">if</span> (metadata.isInterface()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Any of the typical annotations found?</span></span><br><span class="line"><span class="keyword">for</span> (String indicator : candidateIndicators) &#123;</span><br><span class="line"><span class="keyword">if</span> (metadata.isAnnotated(indicator)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally, let's look for @Bean methods...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> metadata.hasAnnotatedMethods(Bean.class.getName());</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine whether the given bean definition indicates a full &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125;</span></span><br><span class="line"><span class="comment"> * class, through checking &#123;<span class="doctag">@link</span> #checkConfigurationClassCandidate&#125;'s metadata marker.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFullConfigurationClass</span><span class="params">(BeanDefinition beanDef)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> CONFIGURATION_CLASS_FULL.equals(beanDef.getAttribute(CONFIGURATION_CLASS_ATTRIBUTE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine whether the given bean definition indicates a lite &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125;</span></span><br><span class="line"><span class="comment"> * class, through checking &#123;<span class="doctag">@link</span> #checkConfigurationClassCandidate&#125;'s metadata marker.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLiteConfigurationClass</span><span class="params">(BeanDefinition beanDef)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> CONFIGURATION_CLASS_LITE.equals(beanDef.getAttribute(CONFIGURATION_CLASS_ATTRIBUTE));</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Enable模块驱动 </tag>
            
            <tag> ImportSelector </tag>
            
            <tag> ImportBeanDefinitionRegistrar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事件监听机制</title>
      <link href="/2019/08/05/Spring%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/08/05/Spring%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="Spring提供的基本事件"><a href="#Spring提供的基本事件" class="headerlink" title="Spring提供的基本事件"></a>Spring提供的基本事件</h3><h4 id="1-ContextRefreshEvent-上下文刷新事件"><a href="#1-ContextRefreshEvent-上下文刷新事件" class="headerlink" title="1: ContextRefreshEvent: 上下文刷新事件"></a>1: ContextRefreshEvent: 上下文刷新事件</h4><p>当ApplicationContext容器<code>初始化完成或者被刷新</code>的时候，就会发布该事件。比如调用ConfigurableApplicationContext接口中的refresh()方法。此处的<code>容器初始化指的是所有的Bean都被成功装载，后处理（post-processor）Bean被检测到并且激活，所有单例Bean都被预实例化，ApplicationContext容器已经可以使用</code>。只要上下文没有被关闭，刷新可以被多次触发。<code>XMLWebApplicationContext支持热刷新，GenericApplicationContext不支持热刷新。</code></p><h4 id="2-ContextStartedEvent-上下文启动事件"><a href="#2-ContextStartedEvent-上下文启动事件" class="headerlink" title="2: ContextStartedEvent: 上下文启动事件"></a>2: ContextStartedEvent: 上下文启动事件</h4><p>当ApplicationContext启动的时候发布事件，即<code>调用ConfigurableApplicationContext接口的start方法的时候</code>。这里的<code>启动是指，所有的被容器管理生命周期的Bean接受到一个明确的启动信号</code>。在经常需要停止后重新启动的场合比较适用。</p><h4 id="3-ContextStoppedEvent-上下文停止事件"><a href="#3-ContextStoppedEvent-上下文停止事件" class="headerlink" title="3: ContextStoppedEvent: 上下文停止事件"></a>3: ContextStoppedEvent: 上下文停止事件</h4><p>当ApplicationContext容器停止的时候发布事件，调用ConfigurableApplicationContext的close方法的时候。这里的<code>停止是指，所有被容器管理生命周期的Bean接到一个明确的停止信号。</code></p><h4 id="4-ContextClosedEvent-上下文关闭事件"><a href="#4-ContextClosedEvent-上下文关闭事件" class="headerlink" title="4: ContextClosedEvent: 上下文关闭事件"></a>4: ContextClosedEvent: 上下文关闭事件</h4><p>当ApplicationContext关闭的时候发布事件，即调用ConfigurableApplicationContext的close方法的时候，<code>关闭指的是所有的单例Bean都被销毁。关闭上下后，不能重新刷新或者重新启动。</code></p><h4 id="5-RequestHandledEvent-Spring处理Web请求结束事件"><a href="#5-RequestHandledEvent-Spring处理Web请求结束事件" class="headerlink" title="5: RequestHandledEvent: Spring处理Web请求结束事件"></a>5: RequestHandledEvent: Spring处理Web请求结束事件</h4><p>只能用于<code>DispatcherServlet的web应用，Spring处理用户请求结束后，系统会触发该事件。</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">publishRequestHandledEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletRequest request, HttpServletResponse response, <span class="keyword">long</span> startTime, Throwable failureCause)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.publishEvents) &#123;</span><br><span class="line"><span class="comment">// Whether or not we succeeded, publish an event.</span></span><br><span class="line"><span class="keyword">long</span> processingTime = System.currentTimeMillis() - startTime;</span><br><span class="line"><span class="keyword">int</span> statusCode = (responseGetStatusAvailable ? response.getStatus() : -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">this</span>.webApplicationContext.publishEvent(</span><br><span class="line"><span class="keyword">new</span> ServletRequestHandledEvent(<span class="keyword">this</span>,</span><br><span class="line">request.getRequestURI(), request.getRemoteAddr(),</span><br><span class="line">request.getMethod(), getServletConfig().getServletName(),</span><br><span class="line">WebUtils.getSessionId(request), getUsernameForRequest(request),</span><br><span class="line">processingTime, failureCause, statusCode));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><blockquote><p>ApplicationEvent，容器事件，必须被ApplicationContext发布。ApplicationListener，监听器，可由容器中任何监听器Bean担任。实现了ApplicationListener接口之后，需要实现方法onApplicationEvent()，在容器将所有的Bean都初始化完成之后，就会执行该方法。</p></blockquote><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p><code>观察者模式，Observer Pattern。定义对象间一对多的依赖关系，使得每当一个对象改变状态，则所有依赖与它的对象都会得到通知，并被自动更新。</code></p><p>观察者模式的角色名称：</p><ul><li><code>Subject被观察者</code>:定义被观察者必须实现的职责，它能动态的增加取消观察者，它一般是抽象类或者是实现类，仅仅完成作为被观察者必须实现的职责：管理观察者并通知观察者。</li><li><code>Observer观察者</code>:观察者接受到消息后，即进行更新操作，对接收到的信息进行处理。</li><li><code>ConcreteSubject具体的被观察者</code>:定义被观察者自己的业务逻辑，同时定义对哪些事件进行通知。</li><li><code>ConcreteObserver具体的观察者</code>:每个观察者接收到消息后的处理反应是不同的，每个观察者都有自己的处理逻辑。</li><li><img src="https://pic2.zhimg.com/80/v2-0a7ef7d1a328dc37eadefb29e0ea705d_hd.jpg" alt="img"></li></ul><h5 id="观察者模式的优点"><a href="#观察者模式的优点" class="headerlink" title="观察者模式的优点"></a>观察者模式的优点</h5><ul><li>观察者和被观察者之间是抽象耦合，不管是增加观察者还是被观察者都非常容易扩展。<code>实现松耦合</code></li><li>建立一套触发机制。</li></ul><h5 id="观察者模式的缺点"><a href="#观察者模式的缺点" class="headerlink" title="观察者模式的缺点"></a>观察者模式的缺点</h5><p>观察者模式需要考虑开发效率和运行效率问题，一个被观察者，多个观察者，开发和调试比较复杂，<code>Java消息的通知默认是顺序执行的，一个观察者卡壳，会影响整体的执行效率。这种情况一般考虑异步的方式。</code>例如考虑使用消息队列(发布/订阅模式)。</p><h5 id="观察者模式和发布订阅模式区别"><a href="#观察者模式和发布订阅模式区别" class="headerlink" title="观察者模式和发布订阅模式区别"></a>观察者模式和发布订阅模式区别</h5><p>虽然两种模式都存在订阅者和发布者（具体观察者可认为是订阅者、具体目标可认为是发布者），但是<code>观察者模式是由具体目标调度的，即观察者和被观察者彼此相识，而发布/订阅模式是统一由调度中心调的，所以观察者模式的订阅者与发布者之间是存在依赖的，而发布/订阅模式则不会(完全解耦)</code>。</p><p><strong>使用场景</strong></p><ul><li><code>观察者模式，多用于单个应用内部</code></li><li><code>发布订阅模式，则更多的是一种跨应用的模式(cross-application pattern)，比如我们常用的消息中间件</code></li></ul><p><img src="https://pic2.zhimg.com/80/v2-b6ed65f370a766620718ad4227d5d4e5_hd.jpg" alt="img"></p><h3 id="Spring中观察者模式"><a href="#Spring中观察者模式" class="headerlink" title="Spring中观察者模式"></a>Spring中观察者模式</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Spring在事件处理机制中使用了观察者模式：</p><ul><li><code>事件，ApplicationEvent</code>，该抽象类继承了EventObject，EventObject是JDK中的类，并建议所有的事件都应该继承自EventObject。</li><li><code>事件监听器，ApplicationListener</code>，是一个接口，该接口继承了EventListener接口。EventListener接口是JDK中的，建议所有的事件监听器都应该继承EventListener。</li><li><code>事件发布，ApplicationEventPublisher</code>，ApplicationContext继承了该接口，在ApplicationContext的抽象实现类AbstractApplicationContext中做了实现</li></ul><p>AbstractApplicationContext类中publishEvent方法实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">Assert.notNull(event, <span class="string">"Event must not be null"</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Publishing event in "</span> + getDisplayName() + <span class="string">": "</span> + event);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//事件发布委托给ApplicationEventMulticaster来执行</span></span><br><span class="line">getApplicationEventMulticaster().multicastEvent(event);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.parent.publishEvent(event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ApplicationEventMulticaster的multicastEvent方法的实现在SimpleApplicationEventMulticaster类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event)</span> </span>&#123;</span><br><span class="line"><span class="comment">//获得监听器集合，遍历监听器，可支持同步和异步的广播事件</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">final</span> ApplicationListener listener : getApplicationListeners(event)) &#123;</span><br><span class="line">Executor executor = getTaskExecutor();</span><br><span class="line"><span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">listener.onApplicationEvent(event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">listener.onApplicationEvent(event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就执行了了onApplicationEvent方法，这里是事件发生的地方。</p><h4 id="Spring如何根据事件找到事件对应的监听器"><a href="#Spring如何根据事件找到事件对应的监听器" class="headerlink" title="Spring如何根据事件找到事件对应的监听器"></a>Spring如何根据事件找到事件对应的监听器</h4><p>在Spring容器初始化的时候，也就是在refresh方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line"><span class="comment">//初始化一个事件注册表</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line">......</span><br><span class="line"><span class="comment">// Check for listener beans and register them.</span></span><br><span class="line"><span class="comment">//注册事件监听器</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>initApplicationEventMulticaster方法初始化事件注册表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//获得beanFactory</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="comment">//先查找BeanFactory中是否有ApplicationEventMulticaster</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line"><span class="keyword">this</span>.applicationEventMulticaster =</span><br><span class="line">beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//如果BeanFactory中不存在，就创建一个SimpleApplicationEventMulticaster</span></span><br><span class="line"><span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在AbstractApplicationEventMulticaster类中有如下属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ListenerRetriever defaultRetriever = <span class="keyword">new</span> ListenerRetriever(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//注册表的缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ListenerCacheKey, ListenerRetriever&gt; retrieverCache = <span class="keyword">new</span> ConcurrentHashMap&lt;ListenerCacheKey, ListenerRetriever&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> BeanFactory beanFactory;</span><br></pre></td></tr></table></figure><p>ListenerRetriever的结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用来存放监听事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Set&lt;ApplicationListener&gt; applicationListeners;</span><br><span class="line"><span class="comment">//存放监听事件的类名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Set&lt;String&gt; applicationListenerBeans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> preFiltered;</span><br></pre></td></tr></table></figure><p>初始化注册表之后，就会把事件注册到注册表中，registerListeners()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取所有的Listener，把事件的bean放到ApplicationEventMulticaster中</span></span><br><span class="line"><span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line"><span class="comment">// uninitialized to let post-processors apply to them!</span></span><br><span class="line">String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//把事件的名称放到ApplicationListenerBean里去。</span></span><br><span class="line"><span class="keyword">for</span> (String lisName : listenerBeanNames) &#123;</span><br><span class="line">getApplicationEventMulticaster().addApplicationListenerBean(lisName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring使用反射机制，通过方法getBeansOfType获取所有继承了ApplicationListener接口的监听器，然后把监听器放到注册表中，所以我们可以在Spring配置文件中配置自定义监听器，在Spring初始化的时候，会把监听器自动注册到注册表中去。</p><p>ApplicationContext发布事件可以参考上面的内容。发布事件的时候的一个方法，getApplicationListeners：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Collection&lt;ApplicationListener&gt; <span class="title">getApplicationListeners</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取事件类型</span></span><br><span class="line">Class&lt;? extends ApplicationEvent&gt; eventType = event.getClass();</span><br><span class="line"><span class="comment">//或去事件源类型</span></span><br><span class="line">Class sourceType = event.getSource().getClass();</span><br><span class="line">ListenerCacheKey cacheKey = <span class="keyword">new</span> ListenerCacheKey(eventType, sourceType);</span><br><span class="line"><span class="comment">//从缓存中查找ListenerRetriever</span></span><br><span class="line">ListenerRetriever retriever = <span class="keyword">this</span>.retrieverCache.get(cacheKey);</span><br><span class="line"><span class="comment">//缓存中存在，直接返回对应的Listener</span></span><br><span class="line"><span class="keyword">if</span> (retriever != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> retriever.getApplicationListeners();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//缓存中不存在，就获取相应的Listener</span></span><br><span class="line">retriever = <span class="keyword">new</span> ListenerRetriever(<span class="keyword">true</span>);</span><br><span class="line">LinkedList&lt;ApplicationListener&gt; allListeners = <span class="keyword">new</span> LinkedList&lt;ApplicationListener&gt;();</span><br><span class="line">Set&lt;ApplicationListener&gt; listeners;</span><br><span class="line">Set&lt;String&gt; listenerBeans;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.defaultRetriever) &#123;</span><br><span class="line">listeners = <span class="keyword">new</span> LinkedHashSet&lt;ApplicationListener&gt;(<span class="keyword">this</span>.defaultRetriever.applicationListeners);</span><br><span class="line">listenerBeans = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(<span class="keyword">this</span>.defaultRetriever.applicationListenerBeans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据事件类型，事件源类型，获取所需要的监听事件</span></span><br><span class="line"><span class="keyword">for</span> (ApplicationListener listener : listeners) &#123;</span><br><span class="line"><span class="keyword">if</span> (supportsEvent(listener, eventType, sourceType)) &#123;</span><br><span class="line">retriever.applicationListeners.add(listener);</span><br><span class="line">allListeners.add(listener);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!listenerBeans.isEmpty()) &#123;</span><br><span class="line">BeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="keyword">for</span> (String listenerBeanName : listenerBeans) &#123;</span><br><span class="line">ApplicationListener listener = beanFactory.getBean(listenerBeanName, ApplicationListener.class);</span><br><span class="line"><span class="keyword">if</span> (!allListeners.contains(listener) &amp;&amp; supportsEvent(listener, eventType, sourceType)) &#123;</span><br><span class="line">retriever.applicationListenerBeans.add(listenerBeanName);</span><br><span class="line">allListeners.add(listener);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">OrderComparator.sort(allListeners);</span><br><span class="line"><span class="keyword">this</span>.retrieverCache.put(cacheKey, retriever);</span><br><span class="line"><span class="keyword">return</span> allListeners;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据事件类型，事件源类型获取所需要的监听器supportsEvent(listener, eventType, sourceType)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">supportsEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ApplicationListener listener, Class&lt;? extends ApplicationEvent&gt; eventType, Class sourceType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">SmartApplicationListener smartListener = (listener <span class="keyword">instanceof</span> SmartApplicationListener ?</span><br><span class="line">(SmartApplicationListener) listener : <span class="keyword">new</span> GenericApplicationListenerAdapter(listener));</span><br><span class="line"><span class="keyword">return</span> (smartListener.supportsEventType(eventType) &amp;&amp; smartListener.supportsSourceType(sourceType));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里没有进行实际的处理，实际处理在smartListener.supportsEventType(eventType)和smartListener.supportsSourceType(sourceType)方法中。</p><p>smartListener.supportsEventType(eventType)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsEventType</span><span class="params">(Class&lt;? extends ApplicationEvent&gt; eventType)</span> </span>&#123;</span><br><span class="line">Class typeArg = GenericTypeResolver.resolveTypeArgument(<span class="keyword">this</span>.delegate.getClass(), ApplicationListener.class);</span><br><span class="line"><span class="keyword">if</span> (typeArg == <span class="keyword">null</span> || typeArg.equals(ApplicationEvent.class)) &#123;</span><br><span class="line">Class targetClass = AopUtils.getTargetClass(<span class="keyword">this</span>.delegate);</span><br><span class="line"><span class="keyword">if</span> (targetClass != <span class="keyword">this</span>.delegate.getClass()) &#123;</span><br><span class="line">typeArg = GenericTypeResolver.resolveTypeArgument(targetClass, ApplicationListener.class);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (typeArg == <span class="keyword">null</span> || typeArg.isAssignableFrom(eventType));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要的逻辑就是根据事件类型判断是否和监听器参数泛型的类型是否一致。</p><p>smartListener.supportsSourceType(sourceType)方法的实现为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsSourceType</span><span class="params">(Class&lt;?&gt; sourceType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义自己的监听器要明确指定参数泛型，表明该监听器支持的事件，如果不指明具体的泛型，则没有监听器监听事件。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring事件监听机制 </tag>
            
            <tag> 观察者模式 </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 发布订阅模式 </tag>
            
            <tag> Spring提供基本事件 </tag>
            
            <tag> Spring事件源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义SpringBoot自动装配</title>
      <link href="/2019/08/05/%E8%87%AA%E5%AE%9A%E4%B9%89SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"/>
      <url>/2019/08/05/%E8%87%AA%E5%AE%9A%E4%B9%89SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="自定义SpringBoot自动装配"><a href="#自定义SpringBoot自动装配" class="headerlink" title="自定义SpringBoot自动装配"></a>自定义SpringBoot自动装配</h2><h3 id="1：自动装配Class命名规则"><a href="#1：自动装配Class命名规则" class="headerlink" title="1：自动装配Class命名规则"></a>1：自动装配Class命名规则</h3><p><em>AutoConfiguration，其中\</em>代表功能或者模块名。</p><h3 id="2：自动装配package命名规则"><a href="#2：自动装配package命名规则" class="headerlink" title="2：自动装配package命名规则"></a>2：自动装配package命名规则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$&#123;root-package&#125;</span><br><span class="line"> |- autoconfigure</span><br><span class="line">  |- $&#123;module-package&#125;</span><br><span class="line">   |- *AutoConfiguration</span><br><span class="line">    |- $&#123;sub-module-package&#125;</span><br><span class="line">     |- ...</span><br></pre></td></tr></table></figure><p>其中${root_package}是根模块，如com.ley。</p><p>${module_package}是功能模块，如web.servlet。</p><p>而${sub_module_package}是子模块，如error。</p><h3 id="3：自定义SpringBootStarter"><a href="#3：自定义SpringBootStarter" class="headerlink" title="3：自定义SpringBootStarter"></a>3：自定义SpringBootStarter</h3><p>官方建议将自动装配模块代码存放到autoconfigure模块中，starter模块依赖该模块，并且附加其他需要依赖。当然也可以将autoconfigure和stater合并到单模块。</p><p>(1)：Spring Boot Starter命名规则</p><p>开发人员将Starter发布为${module}-spring-boot-autoconfigure和${module}-spring-boot-starter两个jar文件。</p><p><strong>开发人员不要使用server,management,spring等作为配置Key命名空间。尽量采用独立的命名空间。</strong></p><p>(2)：实现Spring Boot Starter</p><p>(a)：新建Spring Boot Starter工程—–formatter-spring-boot-autoconfigure。</p><p>构建一个Maven功能，pom.xml如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Compile dependencies --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- @ConfigurationProperties annotation processing (metadata for IDEs) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(b)：实现DefaultFormatter自动装配—-FormatterAutoConfiguration</p><p>(c)：META-INF/spring.factories资源声明FormatterAutoConfiguration</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># FormatterAutoConfiguration 自动装配声明</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">  com.ley.formatter.autoconfigure.FormatterAutoConfiguration</span><br></pre></td></tr></table></figure><p>(d)：构建Spring Boot Starter—-formatter-spring-boot-starter</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--formatter spring boot autoconfigure--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.gitee.ley1996<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>formatter-spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--spring boot 基础依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            说明formatter-spring-boot-starter不应该</span></span><br><span class="line"><span class="comment">            传递spring-boot-starter依赖。</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在开发Spring Boot Starter的过程中，请保持spring-boot-starter等相关依赖声明为 、&lt;optional&gt;true&lt;/optional&gt;。</p><h3 id="4：Spring-Boot-提交化自动装配"><a href="#4：Spring-Boot-提交化自动装配" class="headerlink" title="4：Spring Boot 提交化自动装配"></a>4：Spring Boot 提交化自动装配</h3><p>条件注解总结：</p><ul><li>Class Conditions</li><li>Bean Conditions</li><li>Property Conditions</li><li>Resource Conditions</li><li>Web Application Conditions</li><li>SpEL Expression Conditions</li></ul><p>4.1：Class条件注解</p><ul><li>ConditionalOnClass：当指定类存在时，在Sprign Boot 1.0~2.0稳定。</li><li>ConditionalOnMissingClass：当指定类不存在时，从Spring Boot 1.4开始才保持稳定。推荐使用value()替代。当指定类不存在时，并不需要该类显示地依赖到当前工程或者Starter。</li></ul><p>4.2：Bean条件注解</p><ul><li>ConditionalOnBean：匹配BeanFactory中Bean的类型和名称。 其中Bean查找策略为SearchStrategy，包含当前，父类及所有。</li><li>ConditionalOnMissingBean：当指定Bean不存在时。从Spring Boot 1.2.5开始，增加ignored()和ignoredType()两个方法，用于忽略或者排除指定Bean。</li></ul><p>4.3：属性条件注解</p><p>  ConditionalOnProperty为属性条件注解，其属性来源于Spring Environment。其中Java系统属性(systemProperties)和环境变量(systemEnvironment)是典型的Spring Environment属性来源。在SpringBoot环境中，application.properties或者application.yml也是其中来源之一。</p><p> 当自动装配组件需要默认装配时，可以使用matchIfMissing()属性值调整为true。</p><p>4.4：Resource条件注解</p><p> ConditionOnResource为Resource条件注解。其中resources()指定只有资源必须存在方可成立。</p><p>4.5：Web应用条件注解。</p><ul><li>ConditionalOnWebApplication：判断当前应用是Web类型。</li><li>ConditionalOnNotWebApplication：当前应用不是Web类型。</li></ul><p>4.6：Spring表达式条件注解</p><p> ConditionalOnExpression，其中value()用于评估表达式的真伪。当表达多组配置属性时，可以使用@ConditionalOnExpression。例如${formatter.enabled:true}</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用Spring Boot提供的条件注解,以及自动装配顺序注解,实现自己的配置类,然后在META-INF/</p><p>spring.factories中声明该类即可。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># FormatterAutoConfiguration 自动装配声明</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">  com.ley.formatter.autoconfigure.FormatterAutoConfiguration</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> SpringBoot自动装配 </tag>
            
            <tag> 条件化注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring整合Mybatis原理探索</title>
      <link href="/2019/08/05/Spring%E6%95%B4%E5%90%88Mybatis%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/"/>
      <url>/2019/08/05/Spring%E6%95%B4%E5%90%88Mybatis%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring整合Mybatis原理探索"><a href="#Spring整合Mybatis原理探索" class="headerlink" title="Spring整合Mybatis原理探索"></a>Spring整合Mybatis原理探索</h2><p><code>@MapperScan</code>注解实现</p><p>1:<code>MapperScannerRegistrar</code>类</p><p>实现<code>ImportBeanDefinitionRegistrar</code>接口,注册默认<code>@Mapper</code>注解标注的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//获取@MapperScan注解上属性</span></span><br><span class="line">   AnnotationAttributes mapperScanAttrs = AnnotationAttributes</span><br><span class="line">       .fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));</span><br><span class="line">   <span class="keyword">if</span> (mapperScanAttrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">     registerBeanDefinitions(mapperScanAttrs, registry);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationAttributes annoAttrs, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">//扫描指定包下包含默认Mybatis注解@Mapper的接口,并注册到Spring Bean工厂中</span></span><br><span class="line">   ClassPathMapperScanner scanner = <span class="keyword">new</span> ClassPathMapperScanner(registry);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// this check is needed in Spring 3.1</span></span><br><span class="line">   Optional.ofNullable(resourceLoader).ifPresent(scanner::setResourceLoader);</span><br><span class="line"></span><br><span class="line">   Class&lt;? extends Annotation&gt; annotationClass = annoAttrs.getClass(<span class="string">"annotationClass"</span>);</span><br><span class="line">   <span class="keyword">if</span> (!Annotation.class.equals(annotationClass)) &#123;</span><br><span class="line">     scanner.setAnnotationClass(annotationClass);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Class&lt;?&gt; markerInterface = annoAttrs.getClass(<span class="string">"markerInterface"</span>);</span><br><span class="line">   <span class="keyword">if</span> (!Class.class.equals(markerInterface)) &#123;</span><br><span class="line">     scanner.setMarkerInterface(markerInterface);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Class&lt;? extends BeanNameGenerator&gt; generatorClass = annoAttrs.getClass(<span class="string">"nameGenerator"</span>);</span><br><span class="line">   <span class="keyword">if</span> (!BeanNameGenerator.class.equals(generatorClass)) &#123;</span><br><span class="line">     scanner.setBeanNameGenerator(BeanUtils.instantiateClass(generatorClass));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass = annoAttrs.getClass(<span class="string">"factoryBean"</span>);</span><br><span class="line">   <span class="keyword">if</span> (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) &#123;</span><br><span class="line">     scanner.setMapperFactoryBean(BeanUtils.instantiateClass(mapperFactoryBeanClass));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   scanner.setSqlSessionTemplateBeanName(annoAttrs.getString(<span class="string">"sqlSessionTemplateRef"</span>));</span><br><span class="line">   scanner.setSqlSessionFactoryBeanName(annoAttrs.getString(<span class="string">"sqlSessionFactoryRef"</span>));</span><br><span class="line"></span><br><span class="line">   List&lt;String&gt; basePackages = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   basePackages.addAll(</span><br><span class="line">       Arrays.stream(annoAttrs.getStringArray(<span class="string">"value"</span>))</span><br><span class="line">           .filter(StringUtils::hasText)</span><br><span class="line">           .collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">   basePackages.addAll(</span><br><span class="line">       Arrays.stream(annoAttrs.getStringArray(<span class="string">"basePackages"</span>))</span><br><span class="line">           .filter(StringUtils::hasText)</span><br><span class="line">           .collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">   basePackages.addAll(</span><br><span class="line">       Arrays.stream(annoAttrs.getClassArray(<span class="string">"basePackageClasses"</span>))</span><br><span class="line">           .map(ClassUtils::getPackageName)</span><br><span class="line">           .collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">   scanner.registerFilters();</span><br><span class="line">   scanner.doScan(StringUtils.toStringArray(basePackages));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>2:<code>ClassPathMapperScanner</code></p><p>继承了<code>ClassPathBeanDefinitionScanner</code>类,该类扫描指定包下的模式注解,并注册到Spring Bean工厂中。</p><p>实现主要方法研究</p><p><strong>注册BeanDefinition过滤接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Configures parent scanner to search for the right interfaces. It can search</span></span><br><span class="line"><span class="comment"> * for all interfaces or just for those that extends a markerInterface or/and</span></span><br><span class="line"><span class="comment"> * those annotated with the annotationClass</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerFilters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> acceptAllInterfaces = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if specified, use the given annotation and / or marker interface</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.annotationClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">    addIncludeFilter(<span class="keyword">new</span> AnnotationTypeFilter(<span class="keyword">this</span>.annotationClass));</span><br><span class="line">    acceptAllInterfaces = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// override AssignableTypeFilter to ignore matches on the actual marker interface</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.markerInterface != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//由于生成的BeanDefinition为MapperFactoryBean,所以BeanClass不是原来的类名</span></span><br><span class="line">    addIncludeFilter(<span class="keyword">new</span> AssignableTypeFilter(<span class="keyword">this</span>.markerInterface) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">matchClassName</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    acceptAllInterfaces = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (acceptAllInterfaces) &#123;</span><br><span class="line">    <span class="comment">// default include filter that accepts all classes</span></span><br><span class="line">    addIncludeFilter((metadataReader, metadataReaderFactory) -&gt; <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// exclude package-info.java</span></span><br><span class="line">  addExcludeFilter((metadataReader, metadataReaderFactory) -&gt; &#123;</span><br><span class="line">    String className = metadataReader.getClassMetadata().getClassName();</span><br><span class="line">    <span class="keyword">return</span> className.endsWith(<span class="string">"package-info"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注册MapperFactoryBean</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processBeanDefinitions</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; beanDefinitions)</span> </span>&#123;</span><br><span class="line">   GenericBeanDefinition definition;</span><br><span class="line">   <span class="keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">     definition = (GenericBeanDefinition) holder.getBeanDefinition();</span><br><span class="line">     String beanClassName = definition.getBeanClassName();</span><br><span class="line">     LOGGER.debug(() -&gt; <span class="string">"Creating MapperFactoryBean with name '"</span> + holder.getBeanName()</span><br><span class="line">         + <span class="string">"' and '"</span> + beanClassName + <span class="string">"' mapperInterface"</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// the mapper interface is the original class of the bean</span></span><br><span class="line">     <span class="comment">// but, the actual class of the bean is MapperFactoryBean</span></span><br><span class="line">     <span class="comment">//添加要与类型匹配的通用参数值注意：单个通用参数值将只使用一次*，而不是多次匹配。</span></span><br><span class="line">     <span class="comment">//MapperFactoryBean是个泛型类,泛型参数是Mybatis的DAO全类限定名</span></span><br><span class="line">     definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); /</span><br><span class="line">     definition.setBeanClass(<span class="keyword">this</span>.mapperFactoryBean.getClass());</span><br><span class="line"></span><br><span class="line">     definition.getPropertyValues().add(<span class="string">"addToConfig"</span>, <span class="keyword">this</span>.addToConfig);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">boolean</span> explicitFactoryUsed = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.sqlSessionFactoryBeanName)) &#123;</span><br><span class="line">       <span class="comment">//如果配置了SqlSesiionFactoryBean,获取运行期间的SqlSessionFactory Bean引用  </span></span><br><span class="line">       definition.getPropertyValues().add(<span class="string">"sqlSessionFactory"</span>, <span class="keyword">new</span> RuntimeBeanReference(<span class="keyword">this</span>.sqlSessionFactoryBeanName));</span><br><span class="line">       explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sqlSessionFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">       definition.getPropertyValues().add(<span class="string">"sqlSessionFactory"</span>, <span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">       explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.sqlSessionTemplateBeanName)) &#123;</span><br><span class="line">       <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">         LOGGER.warn(() -&gt; <span class="string">"Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored."</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       definition.getPropertyValues().add(<span class="string">"sqlSessionTemplate"</span>, <span class="keyword">new</span> RuntimeBeanReference(<span class="keyword">this</span>.sqlSessionTemplateBeanName));</span><br><span class="line">       explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sqlSessionTemplate != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">         LOGGER.warn(() -&gt; <span class="string">"Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored."</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       definition.getPropertyValues().add(<span class="string">"sqlSessionTemplate"</span>, <span class="keyword">this</span>.sqlSessionTemplate);</span><br><span class="line">       explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!explicitFactoryUsed) &#123;</span><br><span class="line">       LOGGER.debug(() -&gt; <span class="string">"Enabling autowire by type for MapperFactoryBean with name '"</span> + holder.getBeanName() + <span class="string">"'."</span>);</span><br><span class="line">       definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>设置候选BeanDefinition条件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断候选的BeanDefinition是否是接口和独立类</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(AnnotatedBeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> beanDefinition.getMetadata().isInterface() &amp;&amp; beanDefinition.getMetadata().isIndependent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>相关类</strong></p><ul><li><code>ClassPathMapperScanner</code>:扫描Bean并注册Bean工厂中</li><li><code>MapperFactoryBean</code>:Mapper Bean工程</li><li><code>MapperScannerRegistrar</code>:提供解析<code>MapperScan</code>注解和批量注册Bean</li><li><code>SqlSessionDaoSupport</code>:提供SqlSession</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>实现批量注册Bean时,提供<code>扫描包注解+标注候选注解+实现ImportBeanDefinitionRegistrar接口+</code></p><p><code>继承ClassPathBeanDefinitionScanner+实现FactoryBean接口</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
            <tag> Spring </tag>
            
            <tag> MapperScan注解实现原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Environment抽象</title>
      <link href="/2019/08/05/Spring%20Environment%E6%8A%BD%E8%B1%A1/"/>
      <url>/2019/08/05/Spring%20Environment%E6%8A%BD%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Environment抽象"><a href="#Spring-Environment抽象" class="headerlink" title="Spring Environment抽象"></a>Spring Environment抽象</h2><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1:概述"></a>1:概述</h4><p>Spring中<code>Environment</code>是<code>Spring3.1</code>版本引入的,是<code>Spring</code>核心框架定义的一个接口,用来<strong><code>表示整个应用运行时环境</code>。</strong>该环境模型只接受两种应用环境<strong><code>profiles(配置文件)</code>和<code>properties(属性)</code></strong>。<strong>与属性访问相关的方法通过<code>PropertyResolver</code>超接口访问。</strong></p><p><strong><code>建模关键</code></strong></p><p><code>profile(配置文件)</code></p><ul><li>一个<code>profile</code>是一组<code>Bean</code>定义的逻辑分组,只有当配置文件被激活的时候,才会将对应逻辑上组织的Bean定义注册到容器中。</li><li><code>Bean</code>添加到<code>profile</code>可以通过<code>XML或者Annotation</code>方式。</li><li><code>Environment</code>对象对于<code>profile</code>机制所扮演的角色是用来指定哪些<code>profile</code>是<code>当前活跃或者缺省活跃</code>。可以通过<code>getActiveProfiles</code>或者<code>getDefaultProfiles</code>获取。</li></ul><p><code>proprety(属性)</code></p><ul><li>一个应用属性有很多来源:属性文件(properties files),JVM系统属性(<code>getSystemProperties</code>),系统变量属性(<code>getSystemEnvironment</code>),<code>JNDI</code>,<code>servlet上下文参数</code>,<code>临时属性对象,Maps</code>等。</li><li><code>Environment</code>对于<code>property</code>所扮演的角色提供给使用一个方便服务接口用于<ul><li>配置属性源</li><li>从属性源解析和获取属性</li></ul></li></ul><p>容器上下文(<code>ApplicationContext</code>)所获取的<code>bean</code>,如果想直接使用<code>Environment</code>对象访问<code>profile</code>状态或者获取属性。有以下方式。</p><ul><li><code>EnvironmentAware</code>接口</li><li><code>@Inject</code> 或者 <code>@Autowired</code>注入一个 <code>Environment</code>对象</li></ul><p>绝大多数情况,bean都不需要直接访问<code>Environment</code>对象,而是通过类似<code>@Value</code>注解方式把属性值注入进来。</p><p>这个接口定义在包 <code>org.springframework.core.env</code> 中。下面是<code>Spring</code>围绕环境抽象<code>Environment</code>各个接口/类之间的继承关系: </p><p><img src="https://img-blog.csdnimg.cn/20181124170340612.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FuZHlfemhhbmcyMDA3,size_16,color_FFFFFF,t_70" alt="Spring Environment"> </p><h4 id="2-Environment接口相关类介绍"><a href="#2-Environment接口相关类介绍" class="headerlink" title="2:Environment接口相关类介绍"></a>2:<code>Environment</code>接口相关类介绍</h4><table><thead><tr><th align="center">接口|类</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center"><code>PropertyResolver</code></td><td align="center">接口,抽象对属性源的访问比如是否包含某个属性，读取属性，解析占位符，将读取到的属性转换成指定类型 (<code>提供读操作)默认实现PropertySourcesPropertyResolver</code></td></tr><tr><td align="center"><code>Environment</code></td><td align="center">接口,继承自<code>PropertyResolver</code>,对环境属性访问和<code>default/active profile</code>访问的抽象 。</td></tr><tr><td align="center"><code>ConfigurablePropertyResolver</code></td><td align="center">接口，为<code>PropertyResolver</code>接口抽象的属性源访问做了配置方面的增强。(<code>提供写操作。</code>)</td></tr><tr><td align="center"><code>ConfigurableEnvironment</code></td><td align="center">接口，在所继承的接口之上增加了设置<code>defaut/active profile</code>的能力，增加/删除环境对象中属性源的能力</td></tr><tr><td align="center"><code>ConfigurableWebEnvironment</code></td><td align="center">接口，向接口<code>ConfigurableEnvironment</code>增强了根据Servlet上下文/配置初始化属性源的能力</td></tr><tr><td align="center"><code>AbstractEnvironment</code></td><td align="center"><code>Environment</code>抽象基类，实现了<code>ConfigurableEnvironment</code></td></tr><tr><td align="center"><code>StandardEnvironment</code></td><td align="center">实现类,针对标准Spring应用(非Web应用)环境, 在<code>AbstractEnvironment</code>基础上提供了属性源<code>systemEnvironment</code>(来自<code>System.getenv()</code>)和<code>systemProperties</code>(来自<code>System.getProperties()</code>)</td></tr><tr><td align="center"><code>StandardServletEnvironment</code></td><td align="center">实现类,针对标准Spring Servlet Web应用的环境， 增加了<code>servletContextInitParams</code>/<code>servletConfigInitParams</code>/<code>jndiProperties</code></td></tr></tbody></table><h4 id="3-外部化配置抽象相关类"><a href="#3-外部化配置抽象相关类" class="headerlink" title="3:外部化配置抽象相关类"></a>3:<code>外部化配置抽象相关类</code></h4><table><thead><tr><th align="center">接口|类</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center"><code>PropertySource</code></td><td align="center"><code>用来抽象属性键值对(外部化配置,即属性源)配置基类</code>。例如<code>Map,Properties,ServletConfig,ServletContext</code></td></tr><tr><td align="center"><code>PropertySources</code></td><td align="center">对<code>PropertySource</code>抽象属性键值对外部化配置提供集合操作。</td></tr><tr><td align="center"><code>MutablePropertySources</code></td><td align="center"><code>PropertySources</code>默认实现。</td></tr><tr><td align="center"><code>MapPropertySource</code></td><td align="center"><code>Map对象中读取属性键值对</code></td></tr><tr><td align="center"><code>PropertiesPropertySource</code></td><td align="center"><code>Properties对象中读取属性键值对</code></td></tr><tr><td align="center"><code>ResourcePropertySource</code></td><td align="center"><code>Resource对象读取中读取属性键值对。只支持.xml和.properties文件。</code>底层实现使用了工具类<code>PropertiesLoaderUtils</code>。</td></tr><tr><td align="center"><code>CompositePropertySource</code></td><td align="center"><code>聚合一组PropertySource</code>。</td></tr><tr><td align="center">Web环境实现类和JNDI实现类和随机数实现类</td><td align="center"><code>ServletConfigPropertySource</code>,<code>ServletContextPropertySource</code>,  <code>JndiPropertySource</code>,<code>RandomValuePropertySource</code></td></tr><tr><td align="center">命令行参数实现类</td><td align="center"><code>CommandLinePropertySource</code></td></tr></tbody></table><h4 id="4-混淆定义"><a href="#4-混淆定义" class="headerlink" title="4:混淆定义"></a>4:混淆定义</h4><ul><li>上下文:用来处理分层传递抽象,代表着<code>应用</code>。</li><li>环境:<code>当前上下文运行环境</code>,存储各种<code>全局变量</code>。比如JDK信息,内存信息等等。</li></ul><h4 id="5-核心API"><a href="#5-核心API" class="headerlink" title="5:核心API"></a>5:核心API</h4><ul><li><strong>PropertySource:</strong>属性源。key-value属性对抽象</li><li><strong>PropertyResolver:</strong>属性解析器。用于解析相应key的value</li><li><strong>Profile:</strong>配置。<strong>只有激活的配置profile</strong>的组件/配置才会注册到Spring容器,类似于maven中profile。</li><li><strong>Environment:</strong>环境，本身也是个属性解析器<code>PropertyResolver</code>。 </li></ul><h4 id="6-属性解析器相关类详细介绍"><a href="#6-属性解析器相关类详细介绍" class="headerlink" title="6:属性解析器相关类详细介绍"></a>6:属性解析器相关类详细介绍</h4><h5 id="PropertySourcesPropertyResolver"><a href="#PropertySourcesPropertyResolver" class="headerlink" title="PropertySourcesPropertyResolver"></a><code>PropertySourcesPropertyResolver</code></h5><p>该类是Spring内建提供的<code>PropertyResolver</code>唯一实现类。环境抽象<code>Environment</code>属性解析委托给该类。包括对属性类型之间必要转换。<code>Converter</code>和<code>ConverterService</code>。实际的占位符解析委托给<code>PropertyPlaceholderHelper</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertySourcesPropertyResolver</span> <span class="keyword">extends</span> <span class="title">AbstractPropertyResolver</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PropertySources propertySources; <span class="comment">//内部持有一组PropertySource</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由此可以看出propertySources的顺序很重要~~~</span></span><br><span class="line"><span class="comment">// 并且还能处理占位符~~~~~ resolveNestedPlaceholders支持内嵌、嵌套占位符</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">getProperty</span><span class="params">(String key, Class&lt;T&gt; targetValueType, <span class="keyword">boolean</span> resolveNestedPlaceholders)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.propertySources != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (PropertySource&lt;?&gt; propertySource : <span class="keyword">this</span>.propertySources) &#123;</span><br><span class="line">Object value = propertySource.getProperty(key);</span><br><span class="line"><span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (resolveNestedPlaceholders &amp;&amp; value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">value = resolveNestedPlaceholders((String) value);</span><br><span class="line">&#125;</span><br><span class="line">logKeyFound(key, propertySource, value);</span><br><span class="line"><span class="keyword">return</span> convertValueIfNecessary(value, targetValueType);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPropertyResolver</span> <span class="keyword">implements</span> <span class="title">ConfigurablePropertyResolver</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ConfigurableConversionService conversionService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> PropertyPlaceholderHelper nonStrictHelper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> PropertyPlaceholderHelper strictHelper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> ignoreUnresolvableNestedPlaceholders = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String placeholderPrefix = SystemPropertyUtils.PLACEHOLDER_PREFIX;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String placeholderSuffix = SystemPropertyUtils.PLACEHOLDER_SUFFIX;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> String valueSeparator = SystemPropertyUtils.VALUE_SEPARATOR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; requiredProperties = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-应用环境抽象Environment"><a href="#7-应用环境抽象Environment" class="headerlink" title="7:应用环境抽象Environment"></a>7:应用环境抽象<code>Environment</code></h4><p><code>Environment</code>接口:环境的读操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Environment</span> <span class="keyword">extends</span> <span class="title">PropertyResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the set of profiles explicitly made active for this environment. Profiles</span></span><br><span class="line"><span class="comment"> * are used for creating logical groupings of bean definitions to be registered</span></span><br><span class="line"><span class="comment"> * conditionally, for example based on deployment environment.  Profiles can be</span></span><br><span class="line"><span class="comment"> * activated by setting &#123;<span class="doctag">@linkplain</span> AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME</span></span><br><span class="line"><span class="comment"> * "spring.profiles.active"&#125; as a system property or by calling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ConfigurableEnvironment#setActiveProfiles(String...)&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If no profiles have explicitly been specified as active, then any</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> #getDefaultProfiles() default profiles&#125; will automatically be activated.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getDefaultProfiles</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurableEnvironment#setActiveProfiles</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] getActiveProfiles();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the set of profiles to be active by default when no active profiles have</span></span><br><span class="line"><span class="comment"> * been set explicitly.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getActiveProfiles</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurableEnvironment#setDefaultProfiles</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> AbstractEnvironment#DEFAULT_PROFILES_PROPERTY_NAME</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] getDefaultProfiles();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return whether one or more of the given profiles is active or, in the case of no</span></span><br><span class="line"><span class="comment"> * explicit active profiles, whether one or more of the given profiles is included in</span></span><br><span class="line"><span class="comment"> * the set of default profiles. If a profile begins with '!' the logic is inverted,</span></span><br><span class="line"><span class="comment"> * i.e. the method will return true if the given profile is &lt;em&gt;not&lt;/em&gt; active.</span></span><br><span class="line"><span class="comment"> * For example, &lt;pre class="code"&gt;env.acceptsProfiles("p1", "!p2")&lt;/pre&gt; will</span></span><br><span class="line"><span class="comment"> * return &#123;<span class="doctag">@code</span> true&#125; if profile 'p1' is active or 'p2' is not active.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if called with zero arguments</span></span><br><span class="line"><span class="comment"> * or if any profile is &#123;<span class="doctag">@code</span> null&#125;, empty or whitespace-only</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getActiveProfiles</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getDefaultProfiles</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">acceptsProfiles</span><span class="params">(String... profiles)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConfigurableEnvironment</code>:增加环境的写操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurableEnvironment</span> <span class="keyword">extends</span> <span class="title">Environment</span>, <span class="title">ConfigurablePropertyResolver</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指定该环境下的 profile 集</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setActiveProfiles</span><span class="params">(String... profiles)</span></span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 增加此环境的 profile</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addActiveProfile</span><span class="params">(String profile)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置默认的 profile</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDefaultProfiles</span><span class="params">(String... profiles)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回此环境的 PropertySources</span></span><br><span class="line">    <span class="function">MutablePropertySources <span class="title">getPropertySources</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 尝试返回 System.getenv() 的值，若失败则返回通过 System.getenv(string) 的来访问各个键的映射</span></span><br><span class="line">    <span class="function">Map&lt;String, Object&gt; <span class="title">getSystemEnvironment</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 尝试返回 System.getProperties() 的值，若失败则返回通过 System.getProperties(string) 的来访问各个键的映射</span></span><br><span class="line">    <span class="function">Map&lt;String, Object&gt; <span class="title">getSystemProperties</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(ConfigurableEnvironment parent)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AbstractEnvironment</code>:作为环境接口抽象实现,主要实现了<code>profile</code>相关功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractEnvironment</span> <span class="keyword">implements</span> <span class="title">ConfigurableEnvironment</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String IGNORE_GETENV_PROPERTY_NAME = <span class="string">"spring.getenv.ignore"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请参考：ConfigurableEnvironment#setActiveProfiles</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACTIVE_PROFILES_PROPERTY_NAME = <span class="string">"spring.profiles.active"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请参考：ConfigurableEnvironment#setDefaultProfiles</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PROFILES_PROPERTY_NAME = <span class="string">"spring.profiles.default"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; defaultProfiles = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(getReservedDefaultProfiles());</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 默认的profile名称</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String RESERVED_DEFAULT_PROFILE_NAME = <span class="string">"default"</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;String&gt; <span class="title">doGetActiveProfiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.activeProfiles) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.activeProfiles.isEmpty()) &#123;</span><br><span class="line">String profiles = getProperty(ACTIVE_PROFILES_PROPERTY_NAME);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(profiles)) &#123;</span><br><span class="line">setActiveProfiles(StringUtils.commaDelimitedListToStringArray(</span><br><span class="line">StringUtils.trimAllWhitespace(profiles)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.activeProfiles;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>activeProfiles</code> 为空,则从 <code>Properties</code> 中获取 <code>spring.profiles.active</code> 配置;如果不为空，则调用 <code>setActiveProfiles()</code> 设置 profile,最后返回。 </p><blockquote><p>从这里可以知道，API设置的activeProfiles优先级第一，其次才是属性配置。</p></blockquote><h4 id="8-应用环境配置激活-Profile和ProfileCondition"><a href="#8-应用环境配置激活-Profile和ProfileCondition" class="headerlink" title="8:应用环境配置激活(@Profile和ProfileCondition)"></a>8:应用环境配置激活(@Profile和ProfileCondition)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Conditional</span>(ProfileCondition.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Profile &#123;</span><br><span class="line"></span><br><span class="line">String[] value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>从Spring4.0</code>开始提供<code>Conditional</code>接口,该注解实现原理基于<code>Condition</code>条件接口,<code>Condition</code>条件接口计算结果实现类为<code>ConditionEvaluator</code>,该类是个内部类。</p><p><code>ProfileCondition</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProfileCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 因为value值是个数组，所以此处有多个值 用的MultiValueMap</span></span><br><span class="line">MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());</span><br><span class="line"><span class="keyword">if</span> (attrs != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (Object value : attrs.get(<span class="string">"value"</span>)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个值中，但凡只要有一个acceptsProfiles了，那就返回true~</span></span><br><span class="line"><span class="keyword">if</span> (context.getEnvironment().acceptsProfiles(Profiles.of((String[]) value))) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Profile</code>的value可以指定多个值,并且只需要有一个值符合了条件,<code>@Profile</code>标注的方法、类就会生效，就会被加入到容器内。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Environment抽象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git分支的创建与合并</title>
      <link href="/2019/08/05/Git%E5%88%86%E6%94%AF%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6/"/>
      <url>/2019/08/05/Git%E5%88%86%E6%94%AF%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Git分支的创建与合并"><a href="#Git分支的创建与合并" class="headerlink" title="Git分支的创建与合并"></a>Git分支的创建与合并</h1><h2 id="Git管理项目代码，常见流程。"><a href="#Git管理项目代码，常见流程。" class="headerlink" title="Git管理项目代码，常见流程。"></a>Git管理项目代码，常见流程。</h2><p>1.开发公司网站。</p><p>2.为了开发某个新功能新建一个分支（假如叫develop），并在该分支上进行开发。</p><p>3.接到测试组的Bug反馈，返回主分支，新建一个新的分支（bugFix），在该分支上修复Bug，然后与主分支master合并。</p><p>4.将分支切换回develop，继续开发新功能，结束后和主分支master合并。</p><h2 id="分支的新建与切换"><a href="#分支的新建与切换" class="headerlink" title="分支的新建与切换"></a>分支的新建与切换</h2><p>假如公司网站项目已经开发了一段时间，并且使用Git提交了几次更新，提交历史如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1564850183032-b09e5025-ebca-4b9d-8c8d-7f15295b3874.png" alt="img"></p><p>为了开发新的功能，新建分支develop并切换到该分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch develop</span><br><span class="line"></span><br><span class="line">$ git checkout develop</span><br><span class="line">Switched to branch <span class="string">'develop'</span></span><br></pre></td></tr></table></figure><p>也可以使用命令 <strong><em>git checkout -b</em></strong> 直接新建并切换：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b develop</span><br><span class="line">Switched to a new branch <span class="string">'develop'</span></span><br></pre></td></tr></table></figure><p>执行完上述命令后，仓库历史大致如下所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1564850266347-b3a8d859-2863-491a-8a44-c312b6be87eb.png" alt="img"></p><p>Git新建了一个分支指针develop，然后将HEAD指向develop。</p><p>接下来在该分支上开心的开发新功能，比如新建了公司网站About页面，添加了内容然后提交了此次修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ vim About.html</span><br><span class="line"></span><br><span class="line">$ git add About.html</span><br><span class="line"></span><br><span class="line">$ git commit -a -m <span class="string">"add About.html page"</span></span><br><span class="line">[develop b462691] add About.html page</span><br><span class="line"> 1 file changed, 12 insertions(+)</span><br><span class="line"> create mode 100644 About.html</span><br></pre></td></tr></table></figure><p>此时，仓库历史如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1564850293014-6b3c4cd9-8af7-4c22-92d8-caa3f00fbe18.png" alt="img"></p><p>这时候接到测试组公司网站主页index.html的Bug反馈，于是将分支切换回主分支master，然后新建分支bugFix，修复Bug，并提交该修复：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line"></span><br><span class="line">$ git checkout -b <span class="string">"bugFix"</span></span><br><span class="line">Switched to a new branch <span class="string">'bugFix'</span></span><br><span class="line"></span><br><span class="line">$ vim index.html</span><br><span class="line"></span><br><span class="line">$ git  commit -a -m <span class="string">"update index.html page"</span></span><br><span class="line">[bugFix 11a3074] update index.html page</span><br><span class="line"> 1 file changed, 2 insertions(+), 2 deletions(-)</span><br></pre></td></tr></table></figure><p>此时，仓库历史如下图所示：</p><p>`<img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1564850338214-4d62fbb7-4fe4-4a46-b4ad-f07a6897274c.png" alt="img"></p><p>假如确定<strong>Bug</strong>修复后，可以切换回<strong>master</strong>分支，然后将<strong>bugFix</strong>和<strong>master</strong>分支合并：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge bugFix</span><br><span class="line">Updating e7ad858..11a3074</span><br><span class="line">Fast-forward</span><br><span class="line"> index.html | 4 ++--</span><br><span class="line"> 1 file changed, 2 insertions(+), 2 deletions(-)</span><br></pre></td></tr></table></figure><p>合并时出现了“<strong>Fast forward</strong>”的提示。如果顺着一个分支走下去可以到达另一个分支的话，那么Git在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（<strong>Fast forward</strong>）。</p><p>此时<strong>bugFix</strong>分支已经完成了历史使命，可以使用命令 <strong><em>git branch -d</em></strong> 将其删除：</p><p>合并<strong>master</strong>与<strong>bugFix</strong>，并删除<strong>bugFix</strong>分支后，仓库历史如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1564850437440-6d477607-a8df-4f3b-b8ac-30c16e876de8.png" alt="img"></p><p><strong>Bug</strong>修复后，切换回<strong>develop</strong>分支继续开发新的功能，并且提交：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1564850459181-df04d3be-ed07-4103-9a67-947f16c8b6b6.png" alt="img"></p><h2 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h2><p>和合并<strong>master</strong>分支与<strong>bugFix</strong>分支那样，合并<strong>master</strong>与<strong>develop</strong>分支过程也差不多：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line"></span><br><span class="line">$ git merge develop</span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> About.html | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>由于master指向的C4并不是develop指向C5的直接祖先C2，所以合并方式不是“Fast forward”，Git 会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算。</p><p>合并master和develop后，仓库历史如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1564850520992-d529f6e1-5437-4575-983d-dd1ade41518c.png" alt="img"></p><h2 id="解决合并冲突"><a href="#解决合并冲突" class="headerlink" title="解决合并冲突"></a>解决合并冲突</h2><p>假如在不同分支中都对同一个文件进行了修改，那么合并的时候就会发生冲突。比如在master分支和develop分支上都修改了About.html页面，然后进行分支合并：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge develop</span><br><span class="line">Auto-merging About.html</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> About.html</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure><p>Git作了合并，但没有提交，它会停下来等你解决冲突。</p><p>可是使用命令 <strong><em>git status</em></strong> 查看哪些文件存在冲突：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">"git commit"</span>)</span><br><span class="line">  (use <span class="string">"git merge --abort"</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to mark resolution)</span><br><span class="line"></span><br><span class="line">        both modified:   About.html</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><p>任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出。编辑About.html页面，可看到文件包含类似下面部分的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">  &lt;footer&gt;2016~2017 All Rights Reserved&lt;/footer&gt;</span><br><span class="line">=======</span><br><span class="line">  &lt;footer&gt;&amp;copy;2016~2017&lt;/footer&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; develop</span><br></pre></td></tr></table></figure><p>可以看到 ======= 隔开的上半部分，是<strong>HEAD</strong>（即 <strong>master</strong> 分支，<strong>在运行merge命令时所切换到的分支</strong>）中的内容，下半部分是在develop分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;footer&gt;&amp;copy; 2016~2017 All Rights Reserved&lt;/footer&gt;</span><br></pre></td></tr></table></figure><p><strong>转载</strong>:<a href="http://mrbird.cc/Git分支的创建与合并.html" target="_blank" rel="noopener">http://mrbird.cc/Git分支的创建与合并.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>@Component注解派生性原理</title>
      <link href="/2019/08/04/Component%E6%B3%A8%E8%A7%A3%E6%B4%BE%E7%94%9F%E6%80%A7%E5%8E%9F%E7%90%86/"/>
      <url>/2019/08/04/Component%E6%B3%A8%E8%A7%A3%E6%B4%BE%E7%94%9F%E6%80%A7%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Component注解的派生性原理"><a href="#Component注解的派生性原理" class="headerlink" title="@Component注解的派生性原理"></a>@Component注解的派生性原理</h2><h4 id="1-模式注解"><a href="#1-模式注解" class="headerlink" title="1:模式注解"></a>1:模式注解</h4><p><code>Stereotype Annotation</code>俗称为模式注解。Spring核心部分提供了几种内建的<code>模式注解</code>,如<em>@Component,@Repository,@Service,@Controller,@Configuration等</em>。这些注解均<code>派生于@Component</code>。</p><p>由于<em>Java语言规定,Annotation不允许继承,没有类派生子类的特性</em>,因此<em><code>Spring采用元标注的方式实现注解之间的派生</code></em>。</p><h4 id="2-Component派生性"><a href="#2-Component派生性" class="headerlink" title="2:@Component派生性"></a>2:@Component派生性</h4><p>@Component注解作为Spring容器托管的通用模式组件,<em>任何被@Component标注的组件均为组件扫描的候选对象。</em></p><blockquote><p>任何论证过程离不开所处的环境,需要开发人员具备一定工程意识,包括<strong>软件版本,特性范围,兼容情况等</strong>。因此,<em>论证过程从最低版本开始推导,逐步证明不同版本得提升和差异。</em></p></blockquote><h4 id="3-Component注解派生性原理"><a href="#3-Component注解派生性原理" class="headerlink" title="3:@Component注解派生性原理"></a>3:@Component注解派生性原理</h4><p>当<code>ClassPathBeanDefinitionScanner#doScan(String... basePackages)</code>调用时,它利用basePackages参数迭代执行的<code>findCandidateComponents(String basePackage)</code>,每次执行结果都生成候选的BeanDefinition集合,即candidates变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathBeanDefinitionScanner</span> <span class="keyword">extends</span> <span class="title">ClassPathScanningCandidateComponentProvider</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"> <span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">        <span class="comment">//获取候选的BeanDefinition集合</span></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinitionHolder&gt;();</span><br><span class="line"><span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;   </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而findCandidateComponents(String basePackage)从父类ClassPathScanningCandidateComponentProvider</p><p>中继承。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathScanningCandidateComponentProvider</span> <span class="keyword">implements</span> <span class="title">EnvironmentCapable</span>, <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"> <span class="function"><span class="keyword">public</span> Set&lt;BeanDefinition&gt; <span class="title">findCandidateComponents</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line">Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinition&gt;();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取查询的package,并处理占位符情况$&#123;...&#125;,转换为ClassLoader资源(.class)搜索路径</span></span><br><span class="line">String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class="line">resolveBasePackage(basePackage) + <span class="string">'/'</span> + <span class="keyword">this</span>.resourcePattern;</span><br><span class="line">Resource[] resources = <span class="keyword">this</span>.resourcePatternResolver.getResources(packageSearchPath);</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//resource迭代执行,当资源可读取时,获取该资源的MetadataReader对象</span></span><br><span class="line"><span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (resource.isReadable()) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//包含了类和注解元信息读取方法</span></span><br><span class="line">MetadataReader metadataReader = <span class="keyword">this</span>.metadataReaderFactory.getMetadataReader(resource);</span><br><span class="line">                        <span class="comment">//判断资源是否为候选的组件,通过excludeFilters和includeFilters进行判断</span></span><br><span class="line"><span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">                            <span class="comment">//基于ASM,支持AnnotatedBeanDefinition接口</span></span><br><span class="line">ScannedGenericBeanDefinition sbd = <span class="keyword">new</span> ScannedGenericBeanDefinition(metadataReader);</span><br><span class="line">sbd.setResource(resource);</span><br><span class="line">sbd.setSource(resource);</span><br><span class="line">                            <span class="comment">//判断BeanDefinition是否候选组件</span></span><br><span class="line"><span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line">...</span><br><span class="line">candidates.add(sbd);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> candidates;</span><br><span class="line">&#125;   </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine whether the given class does not match any exclude filter</span></span><br><span class="line"><span class="comment"> * and does match at least one include filter.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> metadataReader the ASM ClassReader for the class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> whether the class qualifies as a candidate component</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(MetadataReader metadataReader)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.excludeFilters) &#123;</span><br><span class="line"><span class="keyword">if</span> (tf.match(metadataReader, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.includeFilters) &#123;</span><br><span class="line"><span class="keyword">if</span> (tf.match(metadataReader, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line"><span class="keyword">return</span> isConditionMatch(metadataReader);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine whether the given bean definition qualifies as candidate.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The default implementation checks whether the class is not an interface</span></span><br><span class="line"><span class="comment"> * and not dependent on an enclosing class.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Can be overridden in subclasses.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanDefinition the bean definition to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> whether the bean definition qualifies as a candidate component</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(AnnotatedBeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">AnnotationMetadata metadata = beanDefinition.getMetadata();</span><br><span class="line"><span class="keyword">return</span> (metadata.isIndependent() &amp;&amp; (metadata.isConcrete() ||</span><br><span class="line">(metadata.isAbstract() &amp;&amp; metadata.hasAnnotatedMethods(Lookup.class.getName()))));</span><br><span class="line">&#125;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register the default filter for &#123;<span class="doctag">@link</span> Component <span class="doctag">@Component</span>&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This will implicitly register all annotations that have the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Component <span class="doctag">@Component</span>&#125; meta-annotation including the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Repository <span class="doctag">@Repository</span>&#125;, &#123;<span class="doctag">@link</span> Service <span class="doctag">@Service</span>&#125;, and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Controller <span class="doctag">@Controller</span>&#125; stereotype annotations.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Also supports Java EE 6's &#123;<span class="doctag">@link</span> javax.annotation.ManagedBean&#125; and</span></span><br><span class="line"><span class="comment"> * JSR-330's &#123;<span class="doctag">@link</span> javax.inject.Named&#125; annotations, if available.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerDefaultFilters</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(Component.class));</span><br><span class="line">ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">((Class&lt;? extends Annotation&gt;) ClassUtils.forName(<span class="string">"javax.annotation.ManagedBean"</span>, cl)), <span class="keyword">false</span>));</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">((Class&lt;? extends Annotation&gt;) ClassUtils.forName(<span class="string">"javax.inject.Named"</span>, cl)), <span class="keyword">false</span>));</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下,ClassPathScanningCandidateComponentProvider构造参数<code>useDefaultFilters为true</code>,并且显示传递给父类构造参数。该方法给属性<code>includeFilters</code>增添了<code>@Component</code>类型AnnotationTypeFilter的TypeFilter。</p><p>ClassPathBeanDefinitionScanner默认过滤器引入标注@Component,@Repository,@Service或者@Controller等类。<code>同理,它也能够标注所有@Component的&quot;派生&quot;注解。</code></p><blockquote><p><code>@Component</code>注解只包含一个value属性定义，所以其“派生”的注解也只能包含一个vlaue属性定义。 </p></blockquote><p>Dubbo实现<code>@Service</code>注解扫描实例:</p><blockquote><p><strong>ClassPathBeanDefinitionScanner</strong>允许自定义类型过滤规则。因此,Dubbo的@Service没有标注@Component情况下，通过scanner.addIncludeFilter(new AnnotationTypeFilter(Service.class))方式达到识别@Service标注类情况。但是没有使用<code>@Component</code>注解的派生性。</p></blockquote><p>Mybatis实现<code>@Mapper</code>注解扫描实例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathMapperScanner</span> <span class="keyword">extends</span> <span class="title">ClassPathBeanDefinitionScanner</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ClassPathMapperScanner</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(registry, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Configures parent scanner to search for the right interfaces. It can search</span></span><br><span class="line"><span class="comment">   * for all interfaces or just for those that extends a markerInterface or/and</span></span><br><span class="line"><span class="comment">   * those annotated with the annotationClass</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerFilters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> acceptAllInterfaces = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if specified, use the given annotation and / or marker interface</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.annotationClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">      addIncludeFilter(<span class="keyword">new</span> AnnotationTypeFilter(<span class="keyword">this</span>.annotationClass));</span><br><span class="line">      acceptAllInterfaces = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// override AssignableTypeFilter to ignore matches on the actual marker interface</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.markerInterface != <span class="keyword">null</span>) &#123;</span><br><span class="line">      addIncludeFilter(<span class="keyword">new</span> AssignableTypeFilter(<span class="keyword">this</span>.markerInterface) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">matchClassName</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      acceptAllInterfaces = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (acceptAllInterfaces) &#123;</span><br><span class="line">      <span class="comment">// default include filter that accepts all classes</span></span><br><span class="line">      addIncludeFilter(<span class="keyword">new</span> TypeFilter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exclude package-info.java</span></span><br><span class="line">    addExcludeFilter(<span class="keyword">new</span> TypeFilter() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String className = metadataReader.getClassMetadata().getClassName();</span><br><span class="line">        <span class="keyword">return</span> className.endsWith(<span class="string">"package-info"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(AnnotatedBeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> beanDefinition.getMetadata().isInterface() &amp;&amp; beanDefinition.getMetadata().isIndependent();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processBeanDefinitions</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; beanDefinitions)</span> </span>&#123;</span><br><span class="line">    GenericBeanDefinition definition;</span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">      definition = (GenericBeanDefinition) holder.getBeanDefinition();</span><br><span class="line">     </span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">      <span class="comment">//复杂对象构建考虑使用FactoryBean接口           </span></span><br><span class="line">      <span class="comment">// the mapper interface is the original class of the bean</span></span><br><span class="line">      <span class="comment">// but, the actual class of the bean is MapperFactoryBean</span></span><br><span class="line">     <span class="comment">//添加泛型参数         </span></span><br><span class="line">           definition.getConstructorArgumentValues().addGenericArgumentValue(definition.getBeanClassName());</span><br><span class="line">     <span class="comment">// issue #59</span></span><br><span class="line">      definition.setBeanClass(<span class="keyword">this</span>.mapperFactoryBean.getClass());</span><br><span class="line"></span><br><span class="line">      definition.getPropertyValues().add(<span class="string">"addToConfig"</span>, <span class="keyword">this</span>.addToConfig);</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-思考扩展"><a href="#4-思考扩展" class="headerlink" title="4:思考扩展"></a>4:思考扩展</h4><p>思考1:利用<code>ClassPathBeanDefinitionScanner</code>类配合<code>includeFilters</code>和<code>excludeFilters</code>定制化批量注册Bean到Spring容器中。常常可以通过注解方式来包含或者排除候选类。</p><p><em>TypeFilter常用实现</em></p><ul><li>AnnotationTypeFilter:注解类型过滤器</li><li>AssignableTypeFilter:确定此对象表示的类或者接口是否为给定类或者接口相同。</li><li>RegexPatternTypeFilter:判断给定的类名是否符合指定正则表达式。</li></ul><p>思考2:复杂对象构建考虑使用<code>FactoryBean</code>实现类。</p><p>思考3:如果是读取类和注解信息可以考虑基于ASM或者反射,使用方式往下可以获取。当获取已加载的类信息可以考虑反射(<code>反射大前提是被反射的Class被ClassLoader加载</code>),ASM用于不需要将类路径package下的Class全部加载,Spring应用指定Java package扫描Spring模式注解时,利用的就是基于ASM方式获取类或者注解信息。基于ASM获取会获得更大性能。</p><p>思考4:资源读取考虑使用<code>ResourcePatternResolver</code>,这个对象的获取可以通过Spring提供的工具类</p><p><code>ResourcePatternUtils.getResourcePatternResolver(resourceLoader)</code>。在使用的时候,考虑处理</p><p><code>占位符${...}</code>的情况,注意资源是否可读。</p><h4 id="5-多层次-Component派生性"><a href="#5-多层次-Component派生性" class="headerlink" title="5:多层次@Component派生性"></a>5:多层次@Component<code>派生性</code></h4><p>(1):具体发展过程不再细说,详解请看<code>SpringBoot编程思想这本书</code>。其多层次@Component注解派生性构建在<code>Spring4.x</code>。其核心处理类为<code>AnnotationMetadataReadingVisitor</code>,<code>其采用递归的方式查找元注解</code>。</p><p>(2):Spring中,MetadataReader接口唯一实现非公开类<code>SimpleMetadataReader</code>。可以通过<br><code>SimpleMetadataReaderFactory(ASM字节码操作)</code>和<code>CachingMetadataReaderFactory</code>获取。</p><p>其中在SimpleMetadataReader实现上看,<code>ClassMetadataReadingVisitor</code>和<code>AnnotationMetadataReadingVisitor</code>分别是<code>ClassMetadatta</code>和<code>AnnotationMetadata</code>实现类。</p><p>由于<code>ClassPathBeanDefinitionScanner</code>在寻找候选的BeanDefinition过程中,将指定basePackage参数下</p><p>的*.class资源进行元信息解析,也就是<code>ClassMetadata</code>和<code>AnnotationMetadata</code>对象。</p><p><code>AnnotationMetadataReadingVisitor</code>实现上使用了<code>AnnotationAttributesReadingVisitor</code>，该类主要实现方法是<code>visitEnd()</code>。<em>Spring2.5实现未采用层次递归获取Annotation[],所以仅支持单层次的@Component派生。Spring3.x实现仅两层@Component派生。Spring4.x开始采用递归方式查找元注解。</em></p><p>(3):<strong><code>思考扩展</code></strong></p><ul><li><code>考虑使用ASM的方式读取类或者注解相关信息。(不需要全部将指定路径下的类加载)</code><ul><li>MetadataReaderFactory:获取MetadataReader工厂<ul><li>SimpleMetadataReaderFactory:简单获取MetadataReader工厂实现<ul><li>ClassReader:基于ASM读取类相关信息,公开类,不建议单独使用。</li><li>AnnotationMetadataReadingVisitor:基于ASM读取注解元数据相关信息,不建议单独使用。</li><li>MethodMetadataReadingVisitor:基于ASM读取方法相关信息,不建议单独使用。</li></ul></li><li>CachingMetadataReaderFactory:继承SimpleMetadataReaderFactory,增加缓存MetadataReader资源功能。</li></ul></li><li>MetadataReader:获取访问类和注解相关信息。通过MetadataReaderFactory获取。<ul><li>Resource getResource():获取类文件资源引用</li><li>ClassMetadata getClassMetadata():读取基础类的基本元数据</li><li>AnnotationMetadata getAnnotationMetadata():读取底层类完整注解元数据,包含注解方法的注解元数据。</li></ul></li></ul></li><li><code>考虑使用反射的方式读取类或者注解相关信息(比较费时而且该类必须被ClassLoader加载)</code><ul><li>StandardClassMetadata:基于反射读取类元数据,可建议单独使用。</li><li>StandardAnnotationMetadata:基于反射读取注解元数据,可建议单独使用</li><li>StandardMethodMetadata:基于反射读取方法元数据,可建议单独使用</li></ul></li><li><code>考虑使用Spring内部支持的有用工具类</code>,都是来自于spring-core包中。<code>多使用spring内建API,学习他们的长处。</code><ul><li>ClassUtils:类工具类</li><li>CollectionUtils:集合工具类</li><li>NumberUtils:Number工具类</li><li>MimeTypeUtils:媒体类型工具类</li><li>IdGenerator:Id生成器</li><li>StringUtils:字符串工具类</li><li>ResourceUtils:资源工具类</li><li>ReflectionUtils:反射工具类</li><li>MethodIntrospector:方法自省工具类(EventListenerMethodProcessor#processBean中有使用)</li><li>PatternMatchUtils:正则资源匹配工具类</li><li>ObjectUtils:对象工具类</li></ul></li></ul><h5 id="3-组合注解"><a href="#3-组合注解" class="headerlink" title="3:组合注解"></a>3:组合注解</h5><p><code>组合注解</code>指某个注解”元标注”一个或多个其他注解，其目的在于将这些关联的注解行为组合成单个自定义注解。</p><p>Spring Framework的类加载通过ASM实现，如<code>ClassReader</code>。相对于ClassLoader体系，Spring ASM更为底层，读取的是<code>类资源</code>，直接操作其中的字节码，获取相关元信息。如<code>MetadataReader接口</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Simple facade for accessing class metadata,</span></span><br><span class="line"><span class="comment"> * as read by an ASM &#123;<span class="doctag">@link</span> org.springframework.asm.ClassReader&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MetadataReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the resource reference for the class file.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Resource <span class="title">getResource</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Read basic class metadata for the underlying class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ClassMetadata <span class="title">getClassMetadata</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Read full annotation metadata for the underlying class,</span></span><br><span class="line"><span class="comment"> * including metadata for annotated methods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">AnnotationMetadata <span class="title">getAnnotationMetadata</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AnnotationMetadataReadingVisitor</code>同时实现了ClassMetadata及AnnotationMetadata。因此，元注解的实现集中到<code>AnnotationMetadataReadingVisitor</code>和<code>AnnotationAttributesReadingVisitor</code>之中。</p><p><code>MetadataReader</code>对象通过<code>MetadataReaderFactory</code>对象获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Factory interface for &#123;<span class="doctag">@link</span> MetadataReader&#125; instances.</span></span><br><span class="line"><span class="comment"> * Allows for caching a MetadataReader per original resource.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> SimpleMetadataReaderFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> CachingMetadataReaderFactory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MetadataReaderFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Obtain a MetadataReader for the given class name.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> className the class name (to be resolved to a ".class" file)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a holder for the ClassReader instance (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException in case of I/O failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">MetadataReader <span class="title">getMetadataReader</span><span class="params">(String className)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Obtain a MetadataReader for the given resource.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resource the resource (pointing to a ".class" file)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a holder for the ClassReader instance (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException in case of I/O failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">MetadataReader <span class="title">getMetadataReader</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体某个注解的<code>元注解</code>信息则通过<code>getMetaAnnotationTypes(String)</code>方法查询。</p><p><code>AnnotationMetadata</code>实现<code>AnnotationMetadataReadingVisitor(ASM实现)</code>，<code>StandardAnnotationMetadata(反射)</code>。</p><ul><li>注解元信息抽象:<code>AnnotationMetadata</code><ul><li><code>AnnotationMetadataReadingVisitor</code><ul><li><code>AnnotationAttributesReadingVisitor</code>(递归查找元注解)</li></ul></li></ul></li><li>类元信息抽象:<code>ClassMetadata</code></li><li>方法元信息抽象:<code>MethodMetadata</code></li><li>注解属性抽象:<code>AnnotationAttributes</code></li><li>属性环境抽象:<code>Environment</code></li><li>属性文件抽象:<code>PropertySource</code></li><li>元信息读取抽象:<code>MetadataReader</code><ul><li>通过<code>MetadataReaderFactory</code>获取</li></ul></li></ul><p>方法内省:<code>MethodIntrospector</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Method, EventListener&gt; annotatedMethods = <span class="keyword">null</span>;</span><br><span class="line">   annotatedMethods = MethodIntrospector.selectMethods(targetType,</span><br><span class="line">(MethodIntrospector.MetadataLookup&lt;EventListener&gt;) method -&gt;</span><br><span class="line">AnnotatedElementUtils.findMergedAnnotation(method, EventListener.class));</span><br></pre></td></tr></table></figure><p>注解工具类:<code>AnnotationUtils</code></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring注解属性抽象AnnotationAttributes </tag>
            
            <tag> 模式注解 </tag>
            
            <tag> Component注解派生性原理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

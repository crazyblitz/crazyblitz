<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ListenableFuture的使用心得]]></title>
    <url>%2F2019%2F08%2F06%2FListenableFuture%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[1.由来​ ListenableFuture是可以监听的Future任务执行情况，是执行成功还是执行失败，并提供响应接口用于对不同结果进行处理。如果异步任务完成自动调用回调函数，减少并发程序复杂度。 ​ Future以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。阻塞的方式显然和我们的异步编程的初衷相违背，轮询的方式又会耗费无谓的CPU资源，而且也不能及时地得到计算结果，为什么不能用观察者设计模式当计算结果完成及时通知监听者呢？ 2.适用场景 如果一个主任务开始执行，然后需要执行各个小任务，并且需要等待返回结果，统一返回给前端，此时Future和ListenableFuture作用几乎差不多，都是通过get()方法阻塞等待每个任务执行完毕返回。 如果一个主任务开始执行，然后执行各个小任务，主任务不需要等待每个小任务执行完，不需要每个小任务的结果，此时用ListenableFuture非常合适，它提供的FutureCallBack接口可以对每个任务的成功或失败单独做出响应。 3.使用示例(1):使用Future示例: 需要阻塞轮训，查看异步任务是否完成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * @author denny.zhang * @ClassName: FutureDemo * @Description: Future多线程并发任务结果归集 * @date 2016年11月4日 下午1:50:32 */public class FutureDemo &#123; public static void main(String[] args) &#123; Long start = System.currentTimeMillis();//开启多线程 ExecutorService exs = Executors.newFixedThreadPool(10); try &#123;//结果集 List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); List&lt;Future&lt;Integer&gt;&gt; futureList = new ArrayList&lt;Future&lt;Integer&gt;&gt;();//1.高速提交10个任务，每个任务返回一个Future入list for (int i = 0; i &lt; 10; i++) &#123; futureList.add(exs.submit(new CallableTask(i + 1))); &#125; Long getResultStart = System.currentTimeMillis(); System.out.println("结果归集开始时间=" + new Date());//2.结果归集，遍历futureList,高速轮询（模拟实现了并发）获取future状态成功完成后获取结果，退出当前循环 for (Future&lt;Integer&gt; future : futureList) &#123; while (true) &#123;//CPU高速轮询：每个future都并发轮循，判断完成状态然后获取结果，这一行，是本实现方案的精髓所在。即有10个future在高速轮询，完成一个future的获取结果，就关闭一个轮询 if (future.isDone() &amp;&amp; !future.isCancelled()) &#123;//获取future成功完成状态，如果想要限制每个任务的超时时间，取消本行的状态判断+future.get(1000*1, TimeUnit.MILLISECONDS)+catch超时异常使用即可。 Integer i = future.get();//获取结果 System.out.println("任务i=" + i + "获取完成!" + new Date()); list.add(i); break;//当前future获取结果完毕，跳出while &#125; else &#123; Thread.sleep(1);//每次轮询休息1毫秒（CPU纳秒级），避免CPU高速轮循耗空CPU---》新手别忘记这个 &#125; &#125; &#125; System.out.println("list=" + list); System.out.println("总耗时=" + (System.currentTimeMillis() - start) + ",取结果归集耗时=" + (System.currentTimeMillis() - getResultStart)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; exs.shutdown(); &#125; &#125; static class CallableTask implements Callable&lt;Integer&gt; &#123; Integer i; public CallableTask(Integer i) &#123; super(); this.i = i; &#125; @Override public Integer call() throws Exception &#123; if (i == 1) &#123; Thread.sleep(3000);//任务1耗时3秒 &#125; else if (i == 5) &#123; Thread.sleep(5000);//任务5耗时5秒 &#125; else &#123; Thread.sleep(1000);//其它任务耗时1秒 &#125; System.out.println("task线程：" + Thread.currentThread().getName() + "任务i=" + i + ",完成！"); return i; &#125; &#125;&#125; (2):使用**CompletionService，**任务先完成优先获取到，结果按照任务的完成先后顺序排序。内部通过阻塞队列+FutureTask。 (3):使用ListenableFuture，异步任务完成之后进行回调，不用在主线程进行等待 123456789101112131415161718192021222324252627282930313233// Guava 和 spring4.0public class TestListenableFuture &#123; // 创建线程池 final static ListeningExecutorService service = MoreExecutors.listeningDecorator(Executors.newCachedThreadPool()); public static void main(String[] args) throws Exception &#123; // 任务1 ListenableFuture&lt;Boolean&gt; booleanTask = service.submit(new Callable&lt;Boolean&gt;() &#123; @Override public Boolean call() throws Exception &#123; return true; &#125; &#125;); // 增加回调函数 Futures.addCallback(booleanTask, new FutureCallback&lt;Boolean&gt;() &#123; // 成功处理 @Override public void onSuccess(Boolean result) &#123; System.err.println("BooleanTask: " + result); &#125; // 失败处理 @Override public void onFailure(Throwable t) &#123; &#125; &#125;); // 任务2 ListenableFuture&lt;String&gt; stringTask = service.submit(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return "Hello World"; &#125; &#125;&#125; 4.原理分析(1):Future增加监听机制相关类 ListenableFuture：增加扩展功能使用，addCallback()方法为了支持增加回调函数 ListenableFutureCallback：Future回调函数接口 ListenableFutureTask：FutureTask子类，主要是为了增加回调函数注册和回调函数调用功能。该类重写了done()方法，执行对回调函数队列的调用。 ListenableFutureCallbackRegistry：回调函数注册类，调用addCallback()注册ListenableFutureTask。 (2):ListenableFutureTask该类继承了FutureTask，重写了done()方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * Extension of &#123;@link FutureTask&#125; that implements &#123;@link ListenableFuture&#125;. * * @author Arjen Poutsma * @since 4.0 */public class ListenableFutureTask&lt;T&gt; extends FutureTask&lt;T&gt; implements ListenableFuture&lt;T&gt; &#123; // 并发编程,尽量使用final关键字,让变量不可变. private final ListenableFutureCallbackRegistry&lt;T&gt; callbacks = new ListenableFutureCallbackRegistry&lt;&gt;(); /** * Create a new &#123;@code ListenableFutureTask&#125; that will, upon running, * execute the given &#123;@link Callable&#125;. * @param callable the callable task */ public ListenableFutureTask(Callable&lt;T&gt; callable) &#123; super(callable); &#125; /** * Create a &#123;@code ListenableFutureTask&#125; that will, upon running, * execute the given &#123;@link Runnable&#125;, and arrange that &#123;@link #get()&#125; * will return the given result on successful completion. * @param runnable the runnable task * @param result the result to return on successful completion */ public ListenableFutureTask(Runnable runnable, @Nullable T result) &#123; super(runnable, result); &#125; ... ... ... @Override protected void done() &#123; Throwable cause; try &#123; // 成功 T result = get(); this.callbacks.success(result); return; &#125; // 第一处捕获异常 catch (InterruptedException ex) &#123; // 异常,则中断线程 Thread.currentThread().interrupt(); return; &#125; // 第二处捕获异常 catch (ExecutionException ex) &#123; // JUC并发异常,需要捕获ExecutionException异常 cause = ex.getCause(); if (cause == null) &#123; cause = ex; &#125; &#125; // 第三处捕获异常 catch (Throwable ex) &#123; cause = ex; &#125; // 失败添加 this.callbacks.failure(cause); &#125;&#125; (3):ListenableFutureCallbackRegistry：回调函数注册类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106public class ListenableFutureCallbackRegistry&lt;T&gt; &#123; private final Queue&lt;SuccessCallback&lt;? super T&gt;&gt; successCallbacks = new LinkedList&lt;&gt;(); private final Queue&lt;FailureCallback&gt; failureCallbacks = new LinkedList&lt;&gt;(); private State state = State.NEW; @Nullable private Object result; /** 互斥锁,控制并发变量,这里需要控制线程执行状态。NEW,SUCCESS,FAILURE **/ private final Object mutex = new Object(); public void addCallback(ListenableFutureCallback&lt;? super T&gt; callback) &#123; Assert.notNull(callback, "'callback' must not be null"); synchronized (this.mutex) &#123; switch (this.state) &#123; case NEW: this.successCallbacks.add(callback); this.failureCallbacks.add(callback); break; case SUCCESS: notifySuccess(callback); break; case FAILURE: notifyFailure(callback); break; &#125; &#125; &#125; private void notifySuccess(SuccessCallback&lt;? super T&gt; callback) &#123; try &#123; callback.onSuccess((T) this.result); &#125; catch (Throwable ex) &#123; // Ignore &#125; &#125; private void notifyFailure(FailureCallback callback) &#123; Assert.state(this.result instanceof Throwable, "No Throwable result for failure state"); try &#123; callback.onFailure((Throwable) this.result); &#125; catch (Throwable ex) &#123; // Ignore &#125; &#125; public void addSuccessCallback(SuccessCallback&lt;? super T&gt; callback) &#123; Assert.notNull(callback, "'callback' must not be null"); synchronized (this.mutex) &#123; switch (this.state) &#123; case NEW: this.successCallbacks.add(callback); break; case SUCCESS: notifySuccess(callback); break; &#125; &#125; &#125; public void addFailureCallback(FailureCallback callback) &#123; Assert.notNull(callback, "'callback' must not be null"); synchronized (this.mutex) &#123; switch (this.state) &#123; case NEW: this.failureCallbacks.add(callback); break; case FAILURE: notifyFailure(callback); break; &#125; &#125; &#125; public void success(@Nullable T result) &#123; synchronized (this.mutex) &#123; this.state = State.SUCCESS; this.result = result; SuccessCallback&lt;? super T&gt; callback; while ((callback = this.successCallbacks.poll()) != null) &#123; notifySuccess(callback); &#125; &#125; &#125; public void failure(Throwable ex) &#123; synchronized (this.mutex) &#123; this.state = State.FAILURE; this.result = ex; FailureCallback callback; while ((callback = this.failureCallbacks.poll()) != null) &#123; notifyFailure(callback); &#125; &#125; &#125; private enum State &#123;NEW, SUCCESS, FAILURE&#125;&#125; 5：设计模式运用(1):适配器模式：FutureAdapter(对象适配器,使用聚合的方式)，ListenableFutureAdapter(类适配器,使用继承的方式)。对象适配器：**FutureAdapter** 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public abstract class FutureAdapter&lt;T, S&gt; implements Future&lt;T&gt; &#123; private final Future&lt;S&gt; adaptee; @Nullable private Object result; private State state = State.NEW; private final Object mutex = new Object(); /** * Constructs a new &#123;@code FutureAdapter&#125; with the given adaptee. * @param adaptee the future to delegate to */ protected FutureAdapter(Future&lt;S&gt; adaptee) &#123; Assert.notNull(adaptee, "Delegate must not be null"); this.adaptee = adaptee; &#125; /** * Returns the adaptee. */ protected Future&lt;S&gt; getAdaptee() &#123; return this.adaptee; &#125; ... ... ... @SuppressWarnings("unchecked") @Nullable final T adaptInternal(S adapteeResult) throws ExecutionException &#123; synchronized (this.mutex) &#123; switch (this.state) &#123; ... ... ... case NEW: try &#123; T adapted = adapt(adapteeResult); this.result = adapted; this.state = State.SUCCESS; return adapted; &#125; ... ... ... &#125; &#125; &#125; /** * Adapts the given adaptee's result into T. * @return the adapted result */ @Nullable protected abstract T adapt(S adapteeResult) throws ExecutionException; ... ...&#125; 类适配器：**ListenableFutureAdapter** 12345678910111213141516171819202122232425262728293031323334353637383940public abstract class ListenableFutureAdapter&lt;T, S&gt; extends FutureAdapter&lt;T, S&gt; implements ListenableFuture&lt;T&gt; &#123; /** * Construct a new &#123;@code ListenableFutureAdapter&#125; with the given adaptee. * @param adaptee the future to adapt to */ protected ListenableFutureAdapter(ListenableFuture&lt;S&gt; adaptee) &#123; super(adaptee); &#125; ... ... ... @Override public void addCallback(final SuccessCallback&lt;? super T&gt; successCallback, final FailureCallback failureCallback) &#123; ListenableFuture&lt;S&gt; listenableAdaptee = (ListenableFuture&lt;S&gt;) getAdaptee(); listenableAdaptee.addCallback(new ListenableFutureCallback&lt;S&gt;() &#123; @Override public void onSuccess(@Nullable S result) &#123; T adapted = null; if (result != null) &#123; try &#123; adapted = adaptInternal(result); &#125; ... ... ... &#125; successCallback.onSuccess(adapted); &#125; @Override public void onFailure(Throwable ex) &#123; failureCallback.onFailure(ex); &#125; &#125;); &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
        <category>并发</category>
        <category>Guava</category>
      </categories>
      <tags>
        <tag>Guava</tag>
        <tag>Spring</tag>
        <tag>ListenableFuture</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lamdba表达式学习(Java8)]]></title>
    <url>%2F2019%2F08%2F06%2FLamdba%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0-Java8%2F</url>
    <content type="text"><![CDATA[1：lamdba语法java8新增了一个操作符-&gt;，称为lambda操作符或箭头操作符，它将lambda表达式分为两部分，箭头之前的是参数，箭头之后的是动作。例如： (Integer n1,Integer n2) -&gt; n1 + n2 这个就相当于 1234&gt; Integer method(Integer n1, Integer n2) &#123;&gt; return n1 + n2;&gt; &#125;&gt; 参数类型可以忽略，可以推断出来。 (n1,n2) -&gt; n1 + n2 如果只有一个参数的话，圆括号也可以省略，像这样 n1 -&gt; n1 * n1 如果没有参数，如下所示： 12&gt; () -&gt; 5; //固定返回5&gt; 箭头符号右侧是动作，除了我们看到的这种单行的形式之外，还可以声明一个代码段作为动作，像下面这样 1234&gt; n -&gt; &#123;&gt; return n * n;&gt; &#125;&gt; 这个代码段可以写的很长很长。如果有返回值的话，需要使用return语句返回。 2:函数接口: FunctionInterface在java中，lambda表达式一定要结合functional interface来使用，functional interface是指一个只包含一个抽象方法的接口，可以包含默认实现default。下面来看一个例子。这是一个functional interface： 123456789101112131415161718192021222324252627@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; /** * Performs this operation on the given argument. * * @param t the input argument */ void accept(T t); /** * Returns a composed &#123;@code Consumer&#125; that performs, in sequence, this * operation followed by the &#123;@code after&#125; operation. If performing either * operation throws an exception, it is relayed to the caller of the * composed operation. If performing this operation throws an exception, * the &#123;@code after&#125; operation will not be performed. * * @param after the operation to perform after this operation * @return a composed &#123;@code Consumer&#125; that performs in sequence this * operation followed by the &#123;@code after&#125; operation * @throws NullPointerException if &#123;@code after&#125; is null */ default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) &#123; Objects.requireNonNull(after); return (T t) -&gt; &#123; accept(t); after.accept(t); &#125;; &#125;&#125; 3:变量捕获说到lambda表达式，有一个话题是绕不开的，就是闭包。但这个问题在java中被简化了好多。这个问题可以分为两种情况来讨论： lambda表达式可以访问到所在的类中定义的字段(filed)，也可以修改这个字段。 lambda表达式可以访问到外层代码块(enclosing scope)中定义的局部变量(local varable)，但不能修改他们，并且，如果一个局部变量在lambda表达式中被读取的话，这个变量必须是final或事实上final（变量赋值以后就不能再任何地方再修改了）。如果在匿名类或 Lambda 表达式中访问的局部变量，如果不是 final 类型的话，编译器自动加上 final 修饰符。 为什么 Lambda 表达式(匿名类) 不能访问非 final 的局部变量呢？ 因为实例变量存在堆中，而局部变量是在栈上分配，Lambda 表达(匿名类) 会在另一个线程中执行。如果在线程中要直接访问一个局部变量，可能线程执行时该局部变量已经被销毁了，而 final 类型的局部变量在 Lambda 表达式(匿名类) 中其实是局部变量的一个拷贝。 4.局部变量类型 (1):对象类型，则对象的引用地址不可改变。 (2):基本类型,，则对象的值不能改变。 123456789101112131415public class App &#123; private int filed1 = 10; void method1() &#123; int varable1 = 10; MyInterface myInterface = n -&gt; &#123; filed1 += 2; //可读取，可修改 int m = varable1; //可读取 //varable1 += 2; //不可修改 return 1; &#125;; //varable1 += 2; //已经在lambda表达式中被读取了，就是final了，不能被修改。 &#125;&#125; 4:方法引用lambda表达式的本质是一个匿名方法，但如果有一个方法的签名（参数列表和返回值）和functional interface的签名一样并且逻辑正好是你需要的，那么你可以使用方法引用的方式来将它赋值给你的functional interface，而无需再编写lambda表达式。 方法引用类型： 静态方法: 语法: ClassName::methodName 12myInterface = MyClass::staticMethod;myInterface.doSomething(5); 实例方法: 语法: instance::methodName 123MyClass myClass = new MyClass();myInterface = myClass::instanceMethod;myInterface.doSomething(5); 泛型方法: 语法：instace::methodName 123MyClass myClass = new MyClass();myInterface = myClass::&lt;integer&gt;genericMethod;myInterface.doSomething(5);&lt;/integer&gt; 构造方法: 语法: ClassName::new 123456789101112131415public class Foo &#123; String msg1, msg2; public Foo(String msg1, String msg2) &#123; this.msg1 = msg1; this.msg2 = msg2; &#125;&#125;interface FooInterface &#123; Foo fooMethod(String m1, String m2);&#125;FooInterface fooInterface = Foo::new;Foo fooObj = fooInterface.fooMethod("hello", "world");]]></content>
      <categories>
        <category>Java基础</category>
        <category>lamdba编程</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>lamdba</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot配置篇]]></title>
    <url>%2F2019%2F08%2F06%2FSpring-Boot%E9%85%8D%E7%BD%AE%E7%AF%87%2F</url>
    <content type="text"><![CDATA[1:概述SpringBoot支持外部化配置,配置文件格式如下所示: properties files yaml files environment variables command-line arguments 使用外部化配置方式: @Value注解 Environment抽象(Spring环境接口抽象) @ConfigurationProperties PropertySource(文件属性抽象) 2:自定义属性 POM内容如下 123456789101112131415161718&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--生成spring-configuration-metadata.json文件,提示属性--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 当使用Spring Boot开发项目时,Spring Boot会默认读取classpath下application.properties application.yml文件,详情请查看源码ConfigFileApplicationListener。这种自定义少量 属性常常通过@Value注解进行加载,但是@Value所在类必须在Spring IOC容器中。 application.yml自定义属性 123hello: user: name: "刘恩源" 读取该属性常常通过@Value注解进行读取。 12345678@Component@Datapublic class HelloUser &#123; //hello.user.name:default==&gt;&gt;表示当时该属性在 //spring Environment没有找到取默认值default @Value("$&#123;hello.user.name:default&#125;") private String userName;&#125; ​ 123456789101112131415161718192021222324/** * 类描述: spring boot config * * @author liuenyuan * @date 2019/6/16 11:36 * @describe * @see org.springframework.beans.factory.annotation.Value * @see org.springframework.context.annotation.PropertySource * @see org.springframework.boot.context.properties.ConfigurationProperties * @see org.springframework.boot.context.properties.EnableConfigurationProperties * @see org.springframework.core.env.Environment * @see org.springframework.context.annotation.Profile * @see org.springframework.context.support.PropertySourcesPlaceholderConfigurer */@SpringBootApplicationpublic class ConfigApplication &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext context = SpringApplication.run(ConfigApplication.class, args); HelloUser helloUser = context.getBean(HelloUser.class); System.out.println(String.format("通过@Value注解读取自定义的少量属性: %s", helloUser.getUserName())); context.close(); &#125;&#125; @Value注解注入使用情况 转载自:https://www.cnblogs.com/wangbin2188/p/9014837.html 注入普通字符串 注入操作系统属性 注入表达式结果 注入其他Bean属性 注入文件资源 注入URL资源 注入${…}来处理placeholder。 1234567891011121314151617@Value("normal")private String normal; // 注入普通字符串@Value("#&#123;systemProperties['os.name']&#125;")private String systemPropertiesName; // 注入操作系统属性@Value("#&#123; T(java.lang.Math).random() * 100.0 &#125;")private double randomNumber; //注入表达式结果@Value("#&#123;beanInject.another&#125;")private String fromAnotherBean; // 注入其他Bean属性：注入beanInject对象的属性another，类具体定义见下面@Value("classpath:com/hry/spring/configinject/config.txt")private Resource resourceFile; // 注入文件资源@Value("http://www.baidu.com")private Resource testUrl; // 注入URL资源 3:将配置文件属性赋给实体类当有许多配置属性(建议超过5这样),可以将这些属性作为字段来创建一个JavaBean,并将属性赋给他们。例如 在application.yml配置属性如下: person: name: &quot;刘恩源&quot; age: 21 school: &quot;天津师范大学&quot;配置属性类PersonProperties @ConfigurationProperties注解是将properties配置文件转换为bean使用,默认是将application.yml 或者application.properties属性转换成bean使用。@PropertySource只支持properties结尾的文件。 @EnableConfigurationProperties注解的作用是@ConfigurationProperties注解生效,并将属性 配置类注册到Spring IOC容器中。 如果需要加载指定配置文件,可以使用@PropertySource注解。 12345678910111213141516171819202122232425 @ConfigurationProperties(prefix = "person")@Datapublic class PersonProperties &#123; private String name; private Integer age; private String school;&#125;@EnableConfigurationProperties(&#123;PersonProperties.class&#125;)@Configurationpublic class PersonConfiguration &#123; private final PersonProperties personProperties; public PersonConfiguration(PersonProperties personProperties) &#123; this.personProperties = personProperties; System.out.println(String.format("PersonProperties: %s", this.personProperties)); &#125; public PersonProperties getPersonProperties() &#123; return personProperties; &#125;&#125; 4:自定义配置文件上面介绍了读取默认配置文件application.yml|application.properties中的配置属性。当然,我们也可以读取 自定义的配置文件中属性。目前官方使用@PropertySource注解导入自定义的配置文件属性。 建立hello.properties #load config properties person.name=刘恩源 person.age=20 person.school=天津师范大学建立PersonProperties.java 123456789101112//建立声明加载properties配置文件的encoding和name@ConfigurationProperties(prefix = "person")@Data@PropertySource(value = &#123;"classpath:/hello.properties"&#125;, encoding = "UTF-8", name = "hello")public class PersonProperties &#123; private String name; private Integer age; private String school;&#125; 建立PersonConfiguration,使用@EnableConfigurationProperties激活@ConfigurationProperties 注解,将其标注的JavaBean注入到Spring IOC容器中。 1234567891011121314@EnableConfigurationProperties(&#123;PersonProperties.class&#125;)@Configurationpublic class PersonConfiguration &#123; private final PersonProperties personProperties public PersonConfiguration(PersonProperties personProperties) &#123; this.personProperties = personProperties; System.out.println(String.format("PersonProperties: %s", this.personProperties)); &#125; public PersonProperties getPersonProperties() &#123; return personProperties; &#125;&#125; 加载指定yml|yaml文件 配置如下: 1234567891011public class YamlPropertiesConfiguration &#123; @Bean public static PropertySourcesPlaceholderConfigurer properties() &#123; PropertySourcesPlaceholderConfigurer configurer = new PropertySourcesPlaceholderConfigurer(); YamlPropertiesFactoryBean yml = new YamlPropertiesFactoryBean(); yml.setResources(new ClassPathResource("/hello.yml")); configurer.setProperties(yml.getObject()); return configurer; &#125;&#125; 可以参照我实现的自定义注解@YmlPropertySource,加载yml|yaml文件,可以大致实现和@PropertySource 注解同样的功能。 @YmlPropertySource实现加载yml|yaml文件 5:多环境配置在企业开发环境中,需要不同的配置环境.SpringBoot使用spring.profiles.active属性加载不同环境的配置文件,配置文件格式为application-{profile}.properties|yml|yaml。{profile}对应环境标识。 application-test.yml:测试环境 application-dev.yml:开发环境 application.prod:生产环境 可以在springboot默认配置文件application.yml通过配置spring.profiles.active激活环境。也可以在 特定的类使用@Profile注解激活环境。该注解可以使用逻辑运算符。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>外部化配置</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强大JSON解析工具gson]]></title>
    <url>%2F2019%2F08%2F06%2F%E5%BC%BA%E5%A4%A7JSON%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7gson%2F</url>
    <content type="text"><![CDATA[1:GsonUtils工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * google json utils * **/public class GsonUtils &#123; public static final String DATE_FORMAT="yyyy-MM-dd HH:mm:ss"; /** * get google json * @see Gson * **/ public static Gson getGson() &#123; return (new GsonBuilder()).serializeNulls().setDateFormat(GsonUtils.DATE_FORMAT).create(); &#125; /** * object to json * **/ public static String toJson(Object obj) &#123; return getGson().toJson(obj); &#125; /** * json to type * @see Gson#toJson(Object, Type) * **/ public static String toJson(Object obj, Type type) &#123; return getGson().toJson(obj, type); &#125; /** * generic t to json * **/ public static &lt;T&gt; String t2Json(T t) &#123; return getGson().toJson(t); &#125; /** * json to generic t * **/ public static &lt;T&gt; T json2T(String jsonString, Class&lt;T&gt; clazz) &#123; return getGson().fromJson(jsonString, clazz); &#125; /** * json to collection * **/ public static &lt;T&gt; List&lt;T&gt; json2Collection(String jsonStr, Type type) &#123; return (List&lt;T&gt;) getGson().fromJson(jsonStr, type); &#125; /** * json to type * @see Gson#fromJson(String, Type) * **/ public static &lt;T&gt; T fromJson(String jsonStr, Type type) &#123; return getGson().fromJson(jsonStr, type); &#125; /** * json to class type * **/ public static &lt;T&gt; T fromJson(String jsonStr, Class&lt;T&gt; clazz) &#123; return getGson().fromJson(jsonStr, clazz); &#125;&#125; 1:java bean对象转换成json123456789101112//实体类@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private Integer id; private String name; private Integer age;&#125; 1234@Testpublic void testBean2Json() &#123; System.out.println(GsonUtils.toJson(new User(1, "王旭", 22)));&#125; 2:List对象转换成json1234567891011121314151617181920 //方法1 @Test public void testBeanList2Json() &#123; System.out.println(GsonUtils.toJson(Arrays.asList( new User(1, "王旭", 22), new User(2, "王旭1", 23), new User(3, "王旭2", 24) ) )); &#125;//方法2,指定具体的泛型@Test public void testBeanList2Json2() &#123; System.out.println(GsonUtils.toJson(Arrays.asList( new User(1, "王旭", 22), new User(2, "王旭1", 23), new User(3, "王旭2", 24) ), new TypeToken&lt;List&lt;User&gt;&gt;() &#123; &#125;.getType())); &#125; 3:Map对象转换成json1234567891011private static Map&lt;String, User&gt; userMap = new HashMap&lt;&gt;();static &#123; userMap.put("1", new User(1, "王旭", 22)); userMap.put("2", new User(2, "王旭", 23));&#125;@Testpublic void testMap2Json() &#123; System.out.println(GsonUtils.toJson(userMap));&#125; 4:Json转成java bean对象12345@Testpublic void testJson2Bean() &#123; User user = GsonUtils.fromJson("&#123;\"id\":1,\"name\":\"王旭\",\"age\":22&#125;", User.class); System.out.println(user);&#125; 5:Json转成List对象12345678//TypeToken用来获取转换出来的泛型类型,如果转换成泛型请使用该类 @Test public void testJson2List() &#123; String jsonList = "[&#123;\"id\":1,\"name\":\"王旭\",\"age\":22&#125;,&#123;\"id\":2,\"name\":\"王旭1\",\"age\":23&#125;,&#123;\"id\":3,\"name\":\"王旭2\",\"age\":24&#125;]"; List&lt;User&gt; userList = GsonUtils.fromJson(jsonList, new TypeToken&lt;List&lt;User&gt;&gt;() &#123; &#125;.getType()); System.out.println(userList); &#125; 6:Json转成map对象1234567891011121314151617181920212223//其中,使用TypeToken可以将json转换成对应的Java类型 @Test public void testJson2Map() &#123; TypeToken&lt;Map&lt;String, User&gt;&gt; typeToken = new TypeToken&lt;Map&lt;String, User&gt;&gt;() &#123; &#125;; Map&lt;String, User&gt; map = GsonUtils.fromJson("&#123;\"1\":&#123;\"id\":1,\"name\":\"王旭\",\"age\":22&#125;,\"2\":&#123;\"id\":2,\"name\":\"王旭\",\"age\":23&#125;&#125;", typeToken.getType()); System.out.println(map); &#125;//在转换json的时候//第一步:知道json是什么构造的//第二步:转换出相应的Java类型@Test public void testJson2Map() &#123; TypeToken&lt;TreeMap&lt;String, User&gt;&gt; typeToken = new TypeToken&lt;TreeMap&lt;String, User&gt;&gt;() &#123; &#125;; TreeMap&lt;String, User&gt; map = GsonUtils.fromJson("&#123;\"1\":&#123;\"id\":1,\"name\":\"王旭\",\"age\":22&#125;,\"2\":&#123;\"id\":2,\"name\":\"王旭\",\"age\":23&#125;&#125;", typeToken.getType()); for (Map.Entry&lt;String, User&gt; entry : map.entrySet()) &#123; System.out.println(entry.getKey()+":"+entry.getValue()); &#125; &#125;]]></content>
      <categories>
        <category>json解析</category>
        <category>gson</category>
      </categories>
      <tags>
        <tag>gson</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Request header is too large 的问题解决]]></title>
    <url>%2F2019%2F08%2F06%2FRequest-header-is-too-large-%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[1:问题原因: 后台接受前台传入的内容字符串,由于内容字符串太大,导致打印台报错. 1-1:错误描述: 123456789101112java.lang.IllegalArgumentException: Request header is too large at org.apache.coyote.http11.Http11InputBuffer.fill(Http11InputBuffer.java:701) at org.apache.coyote.http11.Http11InputBuffer.parseRequestLine(Http11InputBuffer.java:455) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:667) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:798) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1434) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:745) 1-2:解决方案(服务器容器:tomcat): 1:请求头超过了tomcat的限值。本来post请求是没有参数大小限制，但是服务器有自己的默认大小。2:配置 tomcat的server.xml文件,增加请求字段长度 1234&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; maxHttpHeaderSize=&quot;102400&quot; maxPostSize=&quot;0&quot; URIEncoding=&quot;UTF-8&quot;/&gt; 增加maxHttpHeaderSize参数配置,当maxPostSize=0时,表示不限制. 1-3:SpringBoot项目: 在application.yml文件中,配置server.max-http-header-size=102400参数,即可改变内嵌tomcat容器的最大头大小. 1-4:详细错误原因: 在tomcat的org.apache.coyote.http11.AbstractHttp11Protocol类中定义了其默认值: 12345/** * Maximum size of the HTTP message header. */private int maxHttpHeaderSize = 8 * 1024;//所以当请求头大于8*1024时,就会报错.增对大数据量的请求,需要单独配置maxHttpHeaderSize参数属性.]]></content>
      <categories>
        <category>tomcat</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>maxHttpHeaderSize</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot中RedisTemplate注意问题]]></title>
    <url>%2F2019%2F08%2F06%2FSpringBoot%E4%B8%ADRedisTemplate%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1:ERR value is not an integer or out of range1-1:背景:使用redisTemplate.opsForValue().increment(key, delat)方法。 1-2:分析:redis对任何不合法的值,都称为ERR。只有使用StringRedisSerializer序列化器才能使用incrment或者decrement方法。 1-3:问题解决: GenericJackson2JsonRedisSerializer、Jackson2JsonRedisSerializer是先将对象转为json，然后再保存到redis，所以，1在redis中是字符串1，所以无法进行加1 JdkSerializationRedisSerializer使用的jdk对象序列化，序列化后的值有类信息、版本号等，所以是一个包含很多字母的字符串，所以根本无法加1,这个序列化器跟memcache的序列化规则很像memcache怎样存储的对象 GenericToStringSerializer、StringRedisSerializer将字符串的值直接转为字节数组，所以保存到redis中是数字，所以可以进行加1 1-4:总结: 使用GenericToStringSerializer、StringRedisSerializer序列化器，都可以使用increment方法. 1-5:建议redis key序列化使用StringRedisSerializer,redis value序列化使用Jackson2JsonRedisSerializer。 1234567891011121314151617/** * key redis serializer: &#123;@link StringRedisSerializer&#125; and * key redis serializer: &#123;@link Jackson2JsonRedisSerializer&#125; **/@Bean(name = &quot;genericRedisTemplate&quot;)public RedisTemplate&lt;String, String&gt; redisTemplate3(RedisConnectionFactory factory) &#123; RedisTemplate&lt;String, String&gt; template = new RedisTemplate&lt;&gt;(); RedisSerializer valueRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); RedisSerializer keyRedisSerializer = new StringRedisSerializer(); template.setKeySerializer(keyRedisSerializer); template.setValueSerializer(valueRedisSerializer); template.setHashKeySerializer(keyRedisSerializer); template.setHashValueSerializer(valueRedisSerializer); template.setConnectionFactory(factory); template.afterPropertiesSet(); return template;&#125; 2:key前面会有一堆\xac\xed\x00\x05t\x00\tb1-1:背景:使用SpringData对redis进行操作 1-2:分析 分析spring-data的org.springframework.data.redis.core.RedisTemplate源代码以后发现.Spring默认采用defaultSerializer = new JdkSerializationRedisSerializer();来对key,value进行序列化操作，在经过查看JdkSerializationRedisSerializer中对序列化的一系列操作,即默认使用。由于spring操作redis是在jedis客户端基础上进行的，而jedis客户端与redis交互的时候协议中定义是用byte类型交互，jedis中提供了string类型转为byte[]类型.原因其实就出现在这里，解决的办法就是手动定义序列化的方法。 1-3:解决方法: 建议redis key序列化使用StringRedisSerializer,redis value序列化使用Jackson2JsonRedisSerializer. // 使用SpringBoot默认配置的redisTemplate 1234567891011121314151617181920212223242526/** * Standard Redis configuration. */@Configurationprotected static class RedisConfiguration &#123; @Bean @ConditionalOnMissingBean(name = "redisTemplate") public RedisTemplate&lt;Object, Object&gt; redisTemplate( RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;Object, Object&gt;(); template.setConnectionFactory(redisConnectionFactory); return template; &#125; @Bean @ConditionalOnMissingBean(StringRedisTemplate.class) public StringRedisTemplate stringRedisTemplate( RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123; StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>RedisTemplate</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中RestTemplate的使用]]></title>
    <url>%2F2019%2F08%2F06%2FSpring%E4%B8%ADRestTemplate%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Spring中RestTemplate的使用Get请求1:带参数的Get请求 请求URL示例:http://localhost:8080/test/sendSms?phone=手机号&amp;msg=短信内容 12345678910111213141516//错误使用:@Autowiredprivate RestOperations restOperations;public void test() throws Exception&#123; String url = &quot;http://localhost:8080/test/sendSms&quot;; Map&lt;String, Object&gt; uriVariables = new HashMap&lt;String, Object&gt;(); uriVariables.put(&quot;phone&quot;, &quot;151xxxxxxxx&quot;); uriVariables.put(&quot;msg&quot;, &quot;测试短信内容&quot;); String result = restOperations.getForObject(url, String.class, uriVariables);&#125;**服务器接收的时候你会发现，接收的该请求时没有参数的** 123456789101112131415//正确使用:public void test() throws Exception&#123; String url = &quot;http://localhost:8080/test/sendSms?phone=&#123;phone&#125;&amp;msg=&#123;phone&#125;&quot;; Map&lt;String, Object&gt; uriVariables = new HashMap&lt;String, Object&gt;(); uriVariables.put(&quot;phone&quot;, &quot;151xxxxxxxx&quot;); uriVariables.put(&quot;msg&quot;, &quot;测试短信内容&quot;); String result = restOperations.getForObject(url, String.class, uriVariables);&#125;public void test() throws Exception&#123; String url = &quot;http://localhost:8080/test/sendSms?phone=&#123;phone&#125;&amp;msg=&#123;phone&#125;&quot;; String result = restOperations.getForObject(url, String.class, &quot;151xxxxxxxx&quot;, &quot;测试短信内容&quot;);&#125; 2:Spring提供的Get请求方法 1234567891011&lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException;&lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException;&lt;T&gt; T getForObject(URI url, Class&lt;T&gt; responseType) throws RestClientException;&lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(String url, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException;&lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException;&lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(URI url, Class&lt;T&gt; responseType) throws RestClientException; Post请求1:带参数的POST请求 带参数的URL示例:http://api.map.baidu.com/geodata/v3/poi/create 123456789101112131415161718192021//正确使用: HttpHeaders headers = new HttpHeaders(); MultiValueMap&lt;String, String&gt; createPostParams = new LinkedMultiValueMap&lt;&gt;(16); headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED); createPostParams.add(&quot;ak&quot;, PositionConstants.AK); createPostParams.add(&quot;geotable_id&quot;, PositionConstants.GEOTABLE_ID); createPostParams.add(&quot;coord_type&quot;, PositionConstants.COORD_TYPE); createPostParams.add(&quot;latitude&quot;, String.valueOf(article.getPositionX())); createPostParams.add(&quot;longitude&quot;, String.valueOf(article.getPositionY())); createPostParams.add(&quot;address&quot;, article.getPositionName()); createPostParams.add(&quot;title&quot;, article.getArticleName()); createPostParams.add(&quot;article_img&quot;, articleImg); createPostParams.add(&quot;article_id&quot;, article.getArticleId()); createPostParams.add(&quot;article_title&quot;, article.getArticleName()); createPostParams.add(&quot;article_time&quot;, String.valueOf(article.getArticleTime())); createPostParams.add(&quot;article_username&quot;, userName); HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; requestEntity = new HttpEntity&lt;&gt;(createPostParams, headers); ResponseEntity&lt;String&gt; responseEntity = restTemplate.postForEntity(PositionConstants.CREATE_URL, requestEntity, String.class); 2:Spring提供的POST方法1234567891011121314&lt;T&gt; T postForObject(String url, Object request, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException;&lt;T&gt; T postForObject(String url, Object request, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException;&lt;T&gt; T postForObject(URI url, Object request, Class&lt;T&gt; responseType) throws RestClientException;&lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(String url, Object request, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException;`&lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(String url, Object request, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException;`&lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(URI url, Object request, Class&lt;T&gt; responseType) throws RestClientException;` PUT请求: PUT请求和POST请求差不多. 1:Spring提供的PUT方法 12345void put(String url, Object request, Object... uriVariables) throws RestClientException;void put(String url, Object request, Map&lt;String, ?&gt; uriVariables) throws RestClientException;void put(URI url, Object request) throws RestClientException; DELETE请求:1:Spring提供的DELETE方法 12345void delete(String url, Object... uriVariables) throws RestClientException;void delete(String url, Map&lt;String, ?&gt; uriVariables) throws RestClientException;void delete(URI url) throws RestClientException;]]></content>
      <categories>
        <category>Spring</category>
        <category>RestTemplate</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>RestTemplate</tag>
        <tag>Restful请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring的Bean生命周期]]></title>
    <url>%2F2019%2F08%2F06%2FSpring%E7%9A%84Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[一：生命周期执行的过程如下: 对于一个Bean对象来说,它的生命周期有实例化–&gt;初始化–&gt;销毁三大块组成。所以会有如下对三大块前后做定制化Bean。 而对于Bean对象另一份的Spring感知接口来说,会有如下代码和类进行支持。 1234567891011121314151617181920212223242526272829303132333435363738ApplicationContextAwareProcessor对一些感知接口处理。详细看invokeAwareInterfaces方法。class ApplicationContextAwareProcessor implements BeanPostProcessor &#123; private final ConfigurableApplicationContext applicationContext; private final StringValueResolver embeddedValueResolver; /** * Create a new ApplicationContextAwareProcessor for the given context. */ public ApplicationContextAwareProcessor(ConfigurableApplicationContext applicationContext) &#123; this.applicationContext = applicationContext; this.embeddedValueResolver = new EmbeddedValueResolver(applicationContext.getBeanFactory()); &#125;private void invokeAwareInterfaces(Object bean) &#123; if (bean instanceof Aware) &#123; if (bean instanceof EnvironmentAware) &#123; ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment()); &#125; if (bean instanceof EmbeddedValueResolverAware) &#123; ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver); &#125; if (bean instanceof ResourceLoaderAware) &#123; ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext); &#125; if (bean instanceof ApplicationEventPublisherAware) &#123; ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext); &#125; if (bean instanceof MessageSourceAware) &#123; ((MessageSourceAware) bean).setMessageSource(this.applicationContext); &#125; if (bean instanceof ApplicationContextAware) &#123; ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext); &#125; &#125; &#125;&#125; Bean感知接口处理。 AbstractAutowireCapableBeanFactory.java的invokeAwareMethods(final String beanName, final Object bean)方法上处理 12345678910111213141516private void invokeAwareMethods(final String beanName, final Object bean) &#123; if (bean instanceof Aware) &#123; if (bean instanceof BeanNameAware) &#123; ((BeanNameAware) bean).setBeanName(beanName); &#125; if (bean instanceof BeanClassLoaderAware) &#123; ClassLoader bcl = getBeanClassLoader(); if (bcl != null) &#123; ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl); &#125; &#125; if (bean instanceof BeanFactoryAware) &#123; ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this); &#125; &#125;&#125; 1) spring对bean进行实例化,默认bean是单例。2) spring对bean进行依赖注入。3) 如果bean实现了BeanNameAware接口,spring将bean的id传给setBeanName()方法。4) 如果bean实现了BeanFactoryAware接口,spring将调用setBeanFactory方法,将BeanFactory实例传进来。5) 如果bean实现了ApplicationContextAware()接口,spring将调用setApplicationContext()方法将应用上下文的引用传入。6) 如果bean实现了BeanPostProcessor接口,spring将调用它们的postProcessBeforeInitialization接口方法。7) 如果bean实现了InitializingBean接口,spring将调用它们的afterPropertiesSet接口方法,类似的如果bean使用了init-method属性声明了初始化方法,改方法也会被调用。8) 如果bean实现了BeanPostProcessor接口,spring将调用它们的postProcessAfterInitialization接口方法。9) 此时bean已经准备就绪,可以被应用程序使用了,他们将一直驻留在应用上下文中,直到该应用上下文被销毁。10) 若bean实现了DisposableBean接口,spring将调用它的distroy()接口方法。同样的,如果bean使用了destroy-method属性声明了销毁方法,则该方法被调用。 这里一用仓颉的一幅图说明流程： 转载自 https://www.cnblogs.com/xrq730/p/6363055.html 第二幅图解释： 二：代码测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 /** * @see org.springframework.beans.factory.config.BeanFactoryPostProcessor * @see org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter * @see org.springframework.beans.factory.InitializingBean * @see org.springframework.beans.factory.DisposableBean * @see org.springframework.beans.factory.BeanNameAware * @see org.springframework.beans.factory.BeanFactoryAware * @see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean(String, RootBeanDefinition, Object[]) **/@Slf4j@Componentpublic class SpringBean implements BeanNameAware, BeanFactoryAware, InitializingBean, ApplicationContextAware, DisposableBean &#123; public SpringBean() &#123; log.info("new SpringBean......"); &#125; @Override public void setApplicationContext(ApplicationContext context) throws BeansException &#123; log.info("ApplicationContextAware-setApplicationContext......"); &#125; @Override public void afterPropertiesSet() throws Exception &#123; log.info("InitializingBean-afterPropertiesSet......"); &#125; @Override public void setBeanFactory(BeanFactory bf) throws BeansException &#123; log.info("BeanFactoryAware-setBeanFactory......"); &#125; @Override public void setBeanName(String name) &#123; log.info("BeanNameAware-setBeanName......"); &#125; @Override public void destroy() throws Exception &#123; log.info("DisposableBean-destroy....."); &#125;&#125;@Component@Slf4jpublic class SpringBeanPostProcessor implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object o, String s) throws BeansException &#123; if (o instanceof SpringBean) &#123; log.info("BeanPostProcessor-postProcessBeforeInitialization......"); &#125; return o; &#125; @Override public Object postProcessAfterInitialization(Object o, String s) throws BeansException &#123; if (o instanceof SpringBean) &#123; log.info("BeanPostProcessor-postProcessAfterInitialization......"); &#125; return o; &#125;&#125; 结果展示]]></content>
      <categories>
        <category>Spring</category>
        <category>对象生命周期</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Bean生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内省机制]]></title>
    <url>%2F2019%2F08%2F06%2FJava%E5%86%85%E7%9C%81%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一. 内省1:维基百科解释 在计算机科学中，内省是指计算机程序在运行时（Run time）检查对象（Object）类型的一种能力，通常也可以称作运行时类型检查。 不应该将内省和反射混淆。相对于内省，反射更进一步，是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力。 2:Java语言中解释 内省(Introspector) 是Java 语言对 JavaBean 类属性、事件的一种缺省处理方法。JavaBean是一种特殊的类，主要用于传递数据信息，这种类中的方法主要用于访问私有的字段，且方法名符合某种命名规则。如果在两个模块之间传递信息，可以将信息封装进JavaBean中，这种对象称为“值对象”(Value Object)，或“VO”，方法比较少，这些信息储存在类的私有变量中，通过set()、get()获得 二:内省和反射的区别 1: 反射是在运行状态把Java类中的各种成分映射成相应的Java类，可以动态的获取所有的属性以及动态调用任意一个方法，强调的是运行状态。 2: 内省(Introspector)是Java 语言对 Bean 类属性、事件的一种缺省处理方法。 JavaBean是一种特殊的类，主要用于传递数据信息，这种类中的方法主要用于访问私有的字段，且方法名符合某种命名规则。如果在两个模块之间传递信息，可以将信息封装进JavaBean中，这种对象称为“值对象”(Value Object)，或“VO”。方法比较少。这些信息储存在类的私有变量中，通过set()、get()获得。内省机制是通过反射来实现的，BeanInfo用来暴露一个bean的属性、方法和事件，以后我们就可以操纵该JavaBean的属性。 3:比较 三:JDK内省类库 java.beans.Introspector：Introspector 类为通过工具学习有关受目标 Java Bean 支持的属性、事件和方法的知识提供了一个标准方法。 java.beans.BeanInfo接口：希望提供有关其 bean 的显式信息的 bean 实现者可以提供某个 BeanInfo 类，该类实现此 BeanInfo 接口并提供有关其 bean 的方法、属性、事件等显式信息。 java.beans.PropertyDescriptor：PropertyDescriptor 描述 Java Bean 通过一对存储器方法导出的一个属性 四:内省代码测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Java内省机制测试 * * @see java.beans.BeanInfo * @see java.beans.Introspector * @see java.beans.PropertyDescriptor * @see java.beans.MethodDescriptor **/public class IntrospectorTest &#123; private User user; @Before public void init() &#123; user = new User(); user.setAge(20); user.setId(UUID.randomUUID().toString()); user.setName("刘恩源"); &#125; @Test public void testIntrospector() throws Exception &#123; //get BeanInfo BeanInfo beanInfo = Introspector.getBeanInfo(User.class); //PropertyDescriptor PropertyDescriptor[] pds = beanInfo.getPropertyDescriptors(); for (PropertyDescriptor pd : pds) &#123; Method method = pd.getReadMethod(); String methodName = method.getName(); Object result = method.invoke(user); System.out.println(methodName + "--&gt;" + result); &#125; //get name property descriptor PropertyDescriptor namePropertyDescriptor = new PropertyDescriptor("name", User.class); //得到name属性的getter方法 Method readMethod = namePropertyDescriptor.getReadMethod(); //执行getter方法，获取返回值，即name属性的值 String result = (String) readMethod.invoke(user); System.out.println("user.name" + "--&gt;" + result); //得到name属性的setter方法 Method writeMethod = namePropertyDescriptor.getWriteMethod(); //执行setter方法，修改name属性的值 writeMethod.invoke(user, "刘恩源1"); System.out.println("user.name" + "--&gt;" + user.getName()); &#125;&#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java内省机制</tag>
        <tag>Java反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JWT认证详解]]></title>
    <url>%2F2019%2F08%2F06%2FJWT%E8%AE%A4%E8%AF%81%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[JWT(Json web token) 认证详解1:概述JWT声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息,以便从资源服务器获取资源,增加一些额外的其他业务所必须的声明信息。 特别适用于分布式站点的单点登录(SSO)场景 2:起源基于token的认证和传统的session认证区别。 (1):传统的session认证概述 http协议本身是一种无状态的协议,而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证,那么下一次请求时,用户还要再一次进行用户认证才行,因为根据http协议,我们并不能知道是哪个用户发出的请求,所以为了让我们的应用能识别是哪个用户发出的请求,我们只能在服务器存储一份用户登录的信息,这份登录信息会在响应时传递给浏览器,告诉其保存为cookie,以便下次请求时发送给我们的应用,这样我们的应用就能识别请求来自哪个用户了,这就是传统的基于session认证。 基于session认证所显露的问题 session存储问题:由于用户的信息存储在服务端,而且session都是保存在内存中,随之认证用户增多,服务端开销明显增大。 扩展性:用户认证之后,服务端做认证记录,如果认证记录被保存在内存中,意味着用户下次请求还必须要请求这台服务器,才能拿到授权资源。在分布式应用中,相应的限制了负载均衡器的能力。 CSRF:因为基于cookie来进行用户识别,如果cookie被截获,用户就会很容易受到跨站请求伪造攻击。 (2):基于token的鉴权机制概述 基于token的鉴权机制类似于http协议也是无状态的,它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了,这就为应用的扩展提供了便利。 流程 用户使用用户名密码来请求服务器。 服务器进行验证用户的信息。 服务器通过验证发送给用户一个token。 客户端存储token,并在每次请求时附送上这个token值。 服务端验证token值,并返回数据。 这个token必须要在每次请求时传递给服务端,应该保存在请求头里。例外,服务端要支持CORS(跨域请求)。 3:JWT(1):设计jwt(json web token)有三部分构成。 header(头部) 声明类型:jwt 加密算法:HMAC,SHA256 头部进行base64加密。 12345//头部json&#123; "alg": "HS256", "typ": "JWT"&#125; payload:存储有效信息。 标准中注册声明(建议单不强制使用) iss: jwt签发者 sub: jwt所面向的用户 aud: 接收jwt的一方 exp: jwt的过期时间，这个过期时间必须要大于签发时间 nbf: 定义在什么时间之前，该jwt都是不可用的. iat: jwt的签发时间 jti: jwt的唯一身份标识,主要用来作为一次性token,从而回避重放攻击。 公共声明 添加任何信息,一般添加用户的相关信息或者其他业务需要的必要信息。不建议添加敏感信息。(可以在客户端进行解密) 私有声明 提供者和消费者所共同定义的声明,一般不建议存放敏感信息,因为base64是对称解密的，意味着该部分信息可以归类为明文信息。 signature:签证信息 head(base64后的) payload(base64后的) secret:保存在服务端,jwt签发生成也是在服务端。它是用来进行jwt签发和jwt验证,就是服务端的私钥。 这个部分需要base64加密后的header和payload使用。连接组成的字符串,然后通过header中声明的加密方式进行加盐secret组合加密,构成jwt第三部分。 (2):应用一般是在请求头里加入Authorization,并加上Bearer标注: 12345fetch('api/user/1', &#123; headers: &#123; 'Authorization': 'Bearer ' + token &#125;&#125;) (3):总结优点 由于json通用性,所以JWT可以跨语言。 因为有payload,所以jwt可以在自身存储一些其他业务所必要的非敏感信息。 便于传输,字节占用很小 不需要在服务端保存会话信息,易于扩展,特别适用于分布式微服务。 安全相关 不应该在jwt的payload部分存放敏感信息,因为这部分客户端可解密的部分 保护好secret私钥,该私钥非常重要。 如果可以,请使用https协议。]]></content>
      <categories>
        <category>JWT</category>
        <category>SSO</category>
      </categories>
      <tags>
        <tag>JSON Web Token认证</tag>
        <tag>Session认证</tag>
        <tag>分布式单点登录(SSO)场景</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot自定义注解加载yml或者yaml文件]]></title>
    <url>%2F2019%2F08%2F06%2FSpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%8A%A0%E8%BD%BDyml%E6%88%96%E8%80%85yaml%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[SpringBoot自定义注解加载yml或者yaml文件1:概述SpringBoot的@PropertySource注解只支持加载 properties结尾的文件。当使用@ConfigurationProperties 注解配合@EnableConfigurationProperties注解将配置转换为JavaBean时,可能需要配合@PropertySource 注解加载指定的配置文件。所以为了支持以yml或者yaml文件,我自定义了注解@YmlPropertySource。 2:实现声明注解@YamlPropertySource 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import org.springframework.context.annotation.PropertySource;import org.springframework.core.io.support.PropertySourceFactory;import java.lang.annotation.*;/** * yaml property source and extension &#123;@link PropertySource&#125; * * @author liuenyuan * @see org.springframework.context.annotation.PropertySource **/@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Repeatable(YamlPropertySources.class)public @interface YamlPropertySource &#123; /** * Indicate the name of this property source. If omitted, a name will * be generated based on the description of the underlying resource. * * @see org.springframework.core.env.PropertySource#getName() * @see org.springframework.core.io.Resource#getDescription() */ String name() default ""; /** * Indicate the resource location(s) of the properties file to be loaded. * &lt;p&gt;Both traditional and XML-based properties file formats are supported * &amp;mdash; for example, &#123;@code "classpath:/com/myco/app.properties"&#125; * or &#123;@code "file:/path/to/file.xml"&#125;. * &lt;p&gt;Resource location wildcards (e.g. *&amp;#42;/*.properties) are not permitted; * each location must evaluate to exactly one &#123;@code .properties&#125; resource. * &lt;p&gt;$&#123;...&#125; placeholders will be resolved against any/all property sources already * registered with the &#123;@code Environment&#125;. See &#123;@linkplain PropertySource above&#125; * for examples. * &lt;p&gt;Each location will be added to the enclosing &#123;@code Environment&#125; as its own * property source, and in the order declared. */ String[] value(); /** * Indicate if failure to find the a &#123;@link #value() property resource&#125; should be * ignored. * &lt;p&gt;&#123;@code true&#125; is appropriate if the properties file is completely optional. * Default is &#123;@code false&#125;. * * @since 4.0 */ boolean ignoreResourceNotFound() default false; /** * A specific character encoding for the given resources, e.g. "UTF-8". * * @since 4.3 */ String encoding() default ""; /** * Specify a custom &#123;@link PropertySourceFactory&#125;, if any. * &lt;p&gt;By default, a default factory for standard resource files will be used. * * @see org.springframework.core.io.support.DefaultPropertySourceFactory * @see org.springframework.core.io.support.ResourcePropertySource * @since 4.3 */ Class&lt;? extends PropertySourceFactory&gt; factory() default YamlPropertySourceFactory.class;&#125;/** * @author liuenyuan * @see YamlPropertySource **/@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface YamlPropertySources &#123; YamlPropertySource[] value();&#125; 具体实现如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167import lombok.extern.slf4j.Slf4j;import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter;import org.springframework.beans.factory.config.YamlPropertiesFactoryBean;import org.springframework.context.EnvironmentAware;import org.springframework.context.ResourceLoaderAware;import org.springframework.context.annotation.Configuration;import org.springframework.core.Ordered;import org.springframework.core.annotation.AnnotationUtils;import org.springframework.core.annotation.Order;import org.springframework.core.env.*;import org.springframework.core.io.Resource;import org.springframework.core.io.ResourceLoader;import org.springframework.util.Assert;import java.io.IOException;import java.util.*;/** * 类描述: &#123;@link YamlPropertySource&#125; bean post processor.this class convert the yml or yaml file &#123;@link YamlPropertySource#value()&#125; to &#123;@link PropertiesPropertySource&#125;,and add the property source * named &#123;@link YmlPropertySource#name()&#125; into &#123;@link Environment&#125;.When you use this annotation,you * must for follow example: * &lt;pre&gt;&#123;@code * @link @ConfigurationProperties(prefix = "person") * @link @YmlPropertySource(value = &#123;"classpath:/hello.yml"&#125;, name = "hello") * @link @Data * public class PersonProperties &#123; * * private String name; * * private Integer age; * * private String school; * &#125;&#125;&lt;/pre&gt; * * @author liuenyuan * @date 2019/6/16 20:13 * @describe * @see YamlPropertySource * @see InstantiationAwareBeanPostProcessorAdapter * @see EnvironmentAware * @see ResourceLoaderAware */@Slf4j@Configuration(value = YamlPropertySourceAnnotationPostProcessor.BEAN_NAME)@Order(Ordered.HIGHEST_PRECEDENCE)public class YamlPropertySourceAnnotationPostProcessor extends InstantiationAwareBeanPostProcessorAdapter implements EnvironmentAware, ResourceLoaderAware &#123; public final static String BEAN_NAME = "yamlPropertySourceAnnotationPostProcessor"; private Environment environment; private ResourceLoader resourceLoader; private final List&lt;String&gt; propertySourceNames = new ArrayList&lt;&gt;(); private static final PropertySourceFactory DEFAULT_PROPERTY_SOURCE_FACTORY = new YamlPropertySourceFactory(); @Override public void setEnvironment(Environment environment) &#123; Assert.isInstanceOf(ConfigurableEnvironment.class, environment, "environment must be instance of ConfigurableEnvironment."); this.environment = environment; &#125; @Override public void setResourceLoader(ResourceLoader resourceLoader) &#123; this.resourceLoader = resourceLoader; &#125; @Override public boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException &#123; // Process any @PropertySource annotations Set&lt;YamlPropertySource&gt; yamlPropertySources = AnnotationUtils.getRepeatableAnnotations(bean.getClass(), YamlPropertySource.class, YamlPropertySources.class); if (!yamlPropertySources.isEmpty()) &#123; Set&lt;AnnotationAttributes&gt; attributesSet = new LinkedHashSet&lt;&gt;(yamlPropertySources.size()); for (YamlPropertySource yamlPropertySource : yamlPropertySources) &#123; AnnotationAttributes attributes = AnnotationUtils.getAnnotationAttributes(bean.getClass(), yamlPropertySource); attributesSet.add(attributes); &#125; for (AnnotationAttributes propertySource : attributesSet) &#123; if (this.environment instanceof ConfigurableEnvironment) &#123; try &#123; processPropertySource(propertySource); &#125; catch (IOException e) &#123; log.warn("exception message: &#123;&#125;", e.getMessage()); &#125; &#125; else &#123; log.warn("Ignoring @YamlPropertySource annotation on [" + bean.getClass() + "]. Reason: Environment must implement ConfigurableEnvironment"); &#125; &#125; &#125; return true; &#125; private void processPropertySource(AnnotationAttributes propertySource) throws IOException &#123; String name = propertySource.getString("name"); if (!StringUtils.hasLength(name)) &#123; name = null; &#125; String encoding = propertySource.getString("encoding"); if (!StringUtils.hasLength(encoding)) &#123; encoding = null; &#125; String[] locations = propertySource.getStringArray("value"); Assert.isTrue(locations.length &gt; 0, "At least one @YamlPropertySource(value) location is required"); boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound"); Class&lt;? extends PropertySourceFactory&gt; factoryClass = propertySource.getClass("factory"); PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ? DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass)); for (String location : locations) &#123; try &#123; String resolvedLocation = this.environment.resolveRequiredPlaceholders(location); Resource resource = this.resourceLoader.getResource(resolvedLocation); addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding))); &#125; catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) &#123; // Placeholders not resolvable or resource not found when trying to open it if (ignoreResourceNotFound) &#123; if (log.isInfoEnabled()) &#123; log.info("Properties or Yml or Yaml location [" + location + "] not resolvable: " + ex.getMessage()); &#125; &#125; else &#123; throw ex; &#125; &#125; &#125; &#125; private void addPropertySource(PropertySource&lt;?&gt; propertySource) &#123; String name = propertySource.getName(); MutablePropertySources propertySources = ((ConfigurableEnvironment) this.environment).getPropertySources(); if (this.propertySourceNames.contains(name)) &#123; // We've already added a version, we need to extend it PropertySource&lt;?&gt; existing = propertySources.get(name); if (existing != null) &#123; PropertySource&lt;?&gt; newSource = (propertySource instanceof ResourcePropertySource ? ((ResourcePropertySource) propertySource).withResourceName() : propertySource); if (existing instanceof CompositePropertySource) &#123; ((CompositePropertySource) existing).addFirstPropertySource(newSource); &#125; else &#123; if (existing instanceof ResourcePropertySource) &#123; existing = ((ResourcePropertySource) existing).withResourceName(); &#125; CompositePropertySource composite = new CompositePropertySource(name); composite.addPropertySource(newSource); composite.addPropertySource(existing); propertySources.replace(name, composite); &#125; return; &#125; &#125; if (this.propertySourceNames.isEmpty()) &#123; propertySources.addLast(propertySource); &#125; else &#123; String firstProcessed = this.propertySourceNames.get(this.propertySourceNames.size() - 1); propertySources.addBefore(firstProcessed, propertySource); &#125; this.propertySourceNames.add(name); &#125;&#125; 想法 使用InstantiationAwareBeanPostProcessorAdapter的postProcessAfterInstantiation(Object bean, String beanName)方法,然后通过YamlPropertiesFactoryBean将yml|yaml文件转换为properties文件,然后通过 实现EnvironmentAware接口,将配置文件属性写入到spring的Environment环境中。但是该实现有点 缺陷,就是如果使用@ConfigurationProperties和@EnableConfigurationProperties将配置属性 转换为JavaBean时,需要将@YmlProperySource注解标注到该JavaBean上。]]></content>
      <categories>
        <category>SpringBoot</category>
        <category>外部化配置</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>外部化配置</tag>
        <tag>yml|yaml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring类型转换]]></title>
    <url>%2F2019%2F08%2F06%2FSpring%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[Spring Type Conversion(Spring类型转换)1:概述:Spring3引入了core.convert包,提供了通用类型转换系统,定义了实现类型转换和运行时执行类型的SPI。 在Spring3.0之前,提供的PropertyEditor来将外部化bean属性值字符串转换成必需的实现类型。 2:Converter SPI12345678910111213141516171819202122232425/** * A converter converts a source object of type &#123;@code S&#125; to a target of type &#123;@code T&#125;. * * &lt;p&gt;Implementations of this interface are thread-safe and can be shared. * * &lt;p&gt;Implementations may additionally implement &#123;@link ConditionalConverter&#125;. * * @author Keith Donald * @since 3.0 * @param &lt;S&gt; the source type * @param &lt;T&gt; the target type */@FunctionalInterfacepublic interface Converter&lt;S, T&gt; &#123; /** * Convert the source object of type &#123;@code S&#125; to target type &#123;@code T&#125;. * @param source the source object to convert, which must be an instance of &#123;@code S&#125; (never &#123;@code null&#125;) * @return the converted object, which must be an instance of &#123;@code T&#125; (potentially &#123;@code null&#125;) * @throws IllegalArgumentException if the source cannot be converted to the desired target type */ @Nullable T convert(S source);&#125; 实现自定义的类型转换可以实现Converter接口。但是如果S是集合或者数组转换为T的集合或者数组, 建议参考诸如ArrayToCollectionConverter实现。前提是已经注册了委托数组或集合转换器。例如, DefaultConversionService实现。 Converter.convert(S source)中source确保不能为null,否则转换器可能抛出异常如果转换失败。具体 说,应该会抛出IllegalArgumentException报告不合理的转换源。确保Converter实现是线程安全。 在core.convert.support包下,注册了常见了类型转换器。例如: 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Converts from a String any JDK-standard Number implementation. * * &lt;p&gt;Support Number classes including Byte, Short, Integer, Float, Double, Long, BigInteger, BigDecimal. This class * delegates to &#123;@link NumberUtils#parseNumber(String, Class)&#125; to perform the conversion. * * @author Keith Donald * @since 3.0 * @see java.lang.Byte * @see java.lang.Short * @see java.lang.Integer * @see java.lang.Long * @see java.math.BigInteger * @see java.lang.Float * @see java.lang.Double * @see java.math.BigDecimal * @see NumberUtils */final class StringToNumberConverterFactory implements ConverterFactory&lt;String, Number&gt; &#123; @Override public &lt;T extends Number&gt; Converter&lt;String, T&gt; getConverter(Class&lt;T&gt; targetType) &#123; return new StringToNumber&lt;&gt;(targetType); &#125; private static final class StringToNumber&lt;T extends Number&gt; implements Converter&lt;String, T&gt; &#123; private final Class&lt;T&gt; targetType; public StringToNumber(Class&lt;T&gt; targetType) &#123; this.targetType = targetType; &#125; @Override public T convert(String source) &#123; if (source.isEmpty()) &#123; return null; &#125; return NumberUtils.parseNumber(source, this.targetType); &#125; &#125;&#125; 3:ConverterFactory当你需要集中整理类层次结构的类型转换器,可以使用ConverterFactory。例如StringToNumberConverterFactory, 该接口定义如下,当你需要范围转换器,可以转换这些对象从S类型转换成R的子类型。使用该接口。 1234567891011121314151617181920212223/** * A factory for "ranged" converters that can convert objects from S to subtypes of R. * * &lt;p&gt;Implementations may additionally implement &#123;@link ConditionalConverter&#125;. * * @author Keith Donald * @since 3.0 * @see ConditionalConverter * @param &lt;S&gt; the source type converters created by this factory can convert from * @param &lt;R&gt; the target range (or base) type converters created by this factory can convert to; * for example &#123;@link Number&#125; for a set of number subtypes. */public interface ConverterFactory&lt;S, R&gt; &#123; /** * Get the converter to convert from S to target type T, where T is also an instance of R. * @param &lt;T&gt; the target type * @param targetType the target type to convert to * @return a converter from S to T */ &lt;T extends R&gt; Converter&lt;S, T&gt; getConverter(Class&lt;T&gt; targetType);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Converts from a String any JDK-standard Number implementation. * * &lt;p&gt;Support Number classes including Byte, Short, Integer, Float, Double, Long, BigInteger, BigDecimal. This class * delegates to &#123;@link NumberUtils#parseNumber(String, Class)&#125; to perform the conversion. * * @author Keith Donald * @since 3.0 * @see java.lang.Byte * @see java.lang.Short * @see java.lang.Integer * @see java.lang.Long * @see java.math.BigInteger * @see java.lang.Float * @see java.lang.Double * @see java.math.BigDecimal * @see NumberUtils */final class StringToNumberConverterFactory implements ConverterFactory&lt;String, Number&gt; &#123; @Override public &lt;T extends Number&gt; Converter&lt;String, T&gt; getConverter(Class&lt;T&gt; targetType) &#123; return new StringToNumber&lt;&gt;(targetType); &#125; private static final class StringToNumber&lt;T extends Number&gt; implements Converter&lt;String, T&gt; &#123; private final Class&lt;T&gt; targetType; public StringToNumber(Class&lt;T&gt; targetType) &#123; this.targetType = targetType; &#125; @Override public T convert(String source) &#123; if (source.isEmpty()) &#123; return null; &#125; return NumberUtils.parseNumber(source, this.targetType); &#125; &#125;&#125; 4:GenericConverter GenericConverter提供多种源和目标类型之间转换,比Converter更灵活但是对类型要求不高。它提供了实现 转换逻辑的源和目标上下文。 这样的上下文允许类型转换由字段注释或在字段签名上声明的通用信息驱动。接口 如下: 12345678package org.springframework.core.convert.converter;public interface GenericConverter &#123; public Set&lt;ConvertiblePair&gt; getConvertibleTypes(); Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);&#125; ConvertiblePair持有转换源和目标类型对。convert(Object, TypeDescriptor, TypeDescriptor)。 源TypeDescriptor提供对保存正在转换的值的源字段的访问。 目标TypeDescriptor提供对要设置转换值的目标字段的访问。TypeDescriptor类是关于要转换类型的上下文。 一个好的实例是GenericConverter在Java数组和集合之间转换。例如ArrayToCollectionConverter。 注意 1因为GenericConverter是一个更复杂的SPI接口,所以只有在需要时才应该使用它.喜欢Converter或ConverterFactory以满足基本的类型转换需求。 5:ConditionalGenericConverter该接口是一个带有判断条件的类型转换器。该接口是GenericConverter和ConditionalConverter的组合。 123456789101112131415/** * A &#123;@link GenericConverter&#125; that may conditionally execute based on attributes * of the &#123;@code source&#125; and &#123;@code target&#125; &#123;@link TypeDescriptor&#125;. * * &lt;p&gt;See &#123;@link ConditionalConverter&#125; for details. * * @author Keith Donald * @author Phillip Webb * @since 3.0 * @see GenericConverter * @see ConditionalConverter */public interface ConditionalGenericConverter extends GenericConverter, ConditionalConverter &#123;&#125; ConditionalGenericConverter 的一个好示例是StringToCollectionConverter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Converts a comma-delimited String to a Collection. * If the target collection element type is declared, only matches if * &#123;@code String.class&#125; can be converted to it. * * @author Keith Donald * @author Juergen Hoeller * @since 3.0 */final class StringToCollectionConverter implements ConditionalGenericConverter &#123; private final ConversionService conversionService; public StringToCollectionConverter(ConversionService conversionService) &#123; this.conversionService = conversionService; &#125; @Override public Set&lt;ConvertiblePair&gt; getConvertibleTypes() &#123; return Collections.singleton(new ConvertiblePair(String.class, Collection.class)); &#125; @Override public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) &#123; return (targetType.getElementTypeDescriptor() == null || this.conversionService.canConvert(sourceType, targetType.getElementTypeDescriptor())); &#125; @Override @Nullable public Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) &#123; if (source == null) &#123; return null; &#125; String string = (String) source; String[] fields = StringUtils.commaDelimitedListToStringArray(string); TypeDescriptor elementDesc = targetType.getElementTypeDescriptor(); Collection&lt;Object&gt; target = CollectionFactory.createCollection(targetType.getType(), (elementDesc != null ? elementDesc.getType() : null), fields.length); if (elementDesc == null) &#123; for (String field : fields) &#123; target.add(field.trim()); &#125; &#125; else &#123; for (String field : fields) &#123; Object targetElement = this.conversionService.convert(field.trim(), sourceType, elementDesc); target.add(targetElement); &#125; &#125; return target; &#125;&#125; 6:ConversionService APIConversionService定义了一个统一的API,用于在运行时执行类型转换逻辑. 转换器通常在以下Facade接口后面执行。 12345678910111213package org.springframework.core.convert;public interface ConversionService &#123; boolean canConvert(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType); &lt;T&gt; T convert(Object source, Class&lt;T&gt; targetType); boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType); Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);&#125; 大多数ConversionService实现,同样也实现了ConverterRegistry,该接口提供了SPI来注册Converters. 在内部,ConversionService的实现,容器委托它来注册转换器来执行转换逻辑。 core.convert.support提供一个强大的ConversionService实现,该实现是GenericConversionSer ,它适用于大多数转换器环境实现。ConversionServiceFactory 来创建普通的ConversionService 配置。 7:配置ConversionService ConversionService被设计成无状态对象,在容器启动时被实例化,在多线程间进行共享(线程安全)。 在Spring应用中,可以自定义类型转换器。当需要框架进行类型转换时,Spring会选择合适的类型转换器 使用。你也可以注入ConversionService到beans或者直接调用。 注意 如果没有ConversionService注册到Spring容器,基于的PropertyEditor实现的类型转换会被使用。 ​ 使用如下的方式,注册默认ConversionService进Spring容器中: 12345678public class ConvertersConfiguration &#123; @Bean(name = "conversionService") public ConversionServiceFactoryBean conversionServiceFactory() &#123; ConversionServiceFactoryBean conversionServiceFactoryBean = new ConversionServiceFactoryBean(); return conversionServiceFactoryBean; &#125;&#125; 默认的ConversionService可以在字符串，数字，枚举，集合，映射和其他常见类型之间进行转换。要使用您自己的自定义转换器补充或覆盖默认转换器,请设置converter属性.属性值可以实现任何Converter,ConverterFactory或GenericConverter接口。默认ConversionService实现是DefaultConversionService。 12345678910public class ConvertersConfiguration &#123; @Bean(name = "conversionService") public ConversionServiceFactoryBean conversionServiceFactory() &#123; ConversionServiceFactoryBean conversionServiceFactoryBean = new ConversionServiceFactoryBean(); //实现自定义的类型转换器 conversionServiceFactoryBean.setConverters(Collections.singleton(new StringToDateConverter())); return conversionServiceFactoryBean; &#125;&#125; 也可以使用ConversionService在Spring MVC应用中,参考WebMvcConfigurationSupport类,该类方法 addFormatters(FormatterRegistry registry)可以注册自定义的converters。 在某些情况,希望在类型转换期间需要格式化,参考FormatterRegistry。 在程序中使用ConversionService 123456789101112@Servicepublic class MyService &#123; @Autowired public MyService(ConversionService conversionService) &#123; this.conversionService = conversionService; &#125; public void doIt() &#123; this.conversionService.convert(...) &#125;&#125; 8:Spring域属性格式化 core.convert是一个通用的类型转换系统.它提供了统一的ConversionService API以及强类型转换器SPI,用于实现从一种类型到另一种类型的转换逻辑.Spring容器使用这个系统来绑定bean属性值。额外的,还要SpEL和 DataBinder。Spring3引入了Formatter SPI来实现格式化属性值。ConversionService为两个SPI提供统一的类型转换API。 (1):Formatter SPI12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Formats objects of type T. * A Formatter is both a Printer &lt;i&gt;and&lt;/i&gt; a Parser for an object type. * * @author Keith Donald * @since 3.0 * @param &lt;T&gt; the type of object this Formatter formats */public interface Formatter&lt;T&gt; extends Printer&lt;T&gt;, Parser&lt;T&gt; &#123;&#125;/** * Parses text strings to produce instances of T. * * @author Keith Donald * @since 3.0 * @param &lt;T&gt; the type of object this Parser produces */@FunctionalInterfacepublic interface Parser&lt;T&gt; &#123; /** * Parse a text String to produce a T. * @param text the text string * @param locale the current user locale * @return an instance of T * @throws ParseException when a parse exception occurs in a java.text parsing library * @throws IllegalArgumentException when a parse exception occurs */ T parse(String text, Locale locale) throws ParseException;&#125;/** * Prints objects of type T for display. * * @author Keith Donald * @since 3.0 * @param &lt;T&gt; the type of object this Printer prints */@FunctionalInterfacepublic interface Printer&lt;T&gt; &#123; /** * Print the object of type T for display. * @param object the instance to print * @param locale the current user locale * @return the printed text string */ String print(T object, Locale locale);&#125; (2):Annotation-Driven Formatting域格式化可以通过域类型或者注解配置.为了绑定注解在一个Formatter,实现AnnotationFormatterFactory. 123456789101112131415161718192021package org.springframework.format;/** * A factory that creates formatters to format values of fields annotated with a particular * &#123;@link Annotation&#125;. * * &lt;p&gt;For example, a &#123;@code DateTimeFormatAnnotationFormatterFactory&#125; might create a formatter * that formats &#123;@code Date&#125; values set on fields annotated with &#123;@code @DateTimeFormat&#125;. * * @author Keith Donald * @since 3.0 * @param &lt;A&gt; the annotation type that should trigger formatting */public interface AnnotationFormatterFactory&lt;A extends Annotation&gt; &#123; Set&lt;Class&lt;?&gt;&gt; getFieldTypes(); Printer&lt;?&gt; getPrinter(A annotation, Class&lt;?&gt; fieldType); Parser&lt;?&gt; getParser(A annotation, Class&lt;?&gt; fieldType);&#125; 例如实现NumberFormatAnnotationFormatterFactory,绑定@NumberFormat注解到Formatter。 1234567891011121314151617181920212223242526272829303132333435363738public class NumberFormatAnnotationFormatterFactory extends EmbeddedValueResolutionSupport implements AnnotationFormatterFactory&lt;NumberFormat&gt; &#123; @Override public Set&lt;Class&lt;?&gt;&gt; getFieldTypes() &#123; return NumberUtils.STANDARD_NUMBER_TYPES; &#125; @Override public Printer&lt;Number&gt; getPrinter(NumberFormat annotation, Class&lt;?&gt; fieldType) &#123; return configureFormatterFrom(annotation); &#125; @Override public Parser&lt;Number&gt; getParser(NumberFormat annotation, Class&lt;?&gt; fieldType) &#123; return configureFormatterFrom(annotation); &#125; private Formatter&lt;Number&gt; configureFormatterFrom(NumberFormat annotation) &#123; String pattern = resolveEmbeddedValue(annotation.pattern()); if (StringUtils.hasLength(pattern)) &#123; return new NumberStyleFormatter(pattern); &#125; else &#123; Style style = annotation.style(); if (style == Style.CURRENCY) &#123; return new CurrencyStyleFormatter(); &#125; else if (style == Style.PERCENT) &#123; return new PercentStyleFormatter(); &#125; else &#123; return new NumberStyleFormatter(); &#125; &#125; &#125;&#125; (3):格式化注解APIDateTimeFormat和NumberFormat。 (4):FormatterRegistry SPIFormatterRegistry是用来注册formatters 和 converters的SPI。FormattingConversionService 是FormatterRegistry 一个实现,可以支持大多数环境。可以通过FormattingConversionServiceFactoryBean 来配置。也可以通过Spring’s DataBinder和SpEL。 123456789101112package org.springframework.format;public interface FormatterRegistry extends ConverterRegistry &#123; void addFormatterForFieldType(Class&lt;?&gt; fieldType, Printer&lt;?&gt; printer, Parser&lt;?&gt; parser); void addFormatterForFieldType(Class&lt;?&gt; fieldType, Formatter&lt;?&gt; formatter); void addFormatterForFieldType(Formatter&lt;?&gt; formatter); void addFormatterForAnnotation(AnnotationFormatterFactory&lt;?, ?&gt; factory);&#125; (5):FormatterRegistrar SPIFormatterRegistrar是通过FormatterRegistry注册formatters和converters的SPI。 123456package org.springframework.format;public interface FormatterRegistrar &#123; void registerFormatters(FormatterRegistry registry);&#125; 9:在Spring MVC配置Formatting12345678910Configuration@Slf4jpublic class WebConfiguration extends WebMvcConfigurationSupport &#123; @Override protected void addFormatters(FormatterRegistry registry) &#123; registry.addConverter(new StringToDateConverter()); &#125;&#125; 10:配置全局的Date和时间FormatJodaTimeFormatterRegistrar和DateFormatterRegistrar,使用Joda需要引入joda库 配置如下: 1234567891011121314151617181920@Configurationpublic class AppConfig &#123; @Bean public FormattingConversionService conversionService() &#123; // Use the DefaultFormattingConversionService but do not register defaults DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService(false); // Ensure @NumberFormat is still supported conversionService.addFormatterForFieldAnnotation(new NumberFormatAnnotationFormatterFactory()); // Register date conversion with a specific global format DateFormatterRegistrar registrar = new DateFormatterRegistrar(); registrar.setFormatter(new DateFormatter("yyyyMMdd")); registrar.registerFormatters(conversionService); return conversionService; &#125;&#125; 注意 Joda-Time提供不同类型表示日期date,time,datetime,需要通过JodaTimeFormatterRegistrar进行 注册。或者使用DateTimeFormatterFactoryBean来进行创建formatters。 如果您使用Spring MVC,请记住明确配置使用的转换服务.对于基于Java的@Configuration,这意味着扩展WebMvcConfigurationSupport类并覆盖mvcConversionService()方法.对于XML,您应该使用mvc:annotation-driven元素的conversion-service属性。 有关详细信息，请参阅转换和格式。]]></content>
      <categories>
        <category>Spring</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Spring Type Converter</tag>
        <tag>单例设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring注解属性覆盖]]></title>
    <url>%2F2019%2F08%2F06%2FSpring%E6%B3%A8%E8%A7%A3%E5%B1%9E%E6%80%A7%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[Spring注解属性覆盖1:隐性覆盖较低层次的注解覆盖其元注解的同名属性 AnnotationAttributes采用注解就近覆盖的设计原则。 @Component ​ | -@Service ​ | -@TransactionalService @Service较@Component,距离@TransactionalService注解更近，属于较低层次的注解。 2:显性覆盖@AliasFor提供的属性覆盖能力。 (1):理解Spring注解属性别名(Aliases) @AliasFor可用于同一注解属性方法之间相互别名。同一注解两个属性方法需要相互 “@AliasFor”，默认值必须相等。 多层次注解属性之间的@AliasFor关系只能由较低层次向较高层次建立。即就近原则。 AnnotatedElementUtils.getMergedAnnotationAttributes方法也符合属性别名完整语义。 Spring为Spring元注解和@AliasFor提供了属性覆盖和别名特性，最终由AnnotationAttributes 对象表达语义。 (2):代码实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 类描述:组合注解 * * @author liuenyuan * @date 2019/4/25 20:11 * @describe */@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Transactional//表明注解属性覆盖符合就近原则,由低层次向高层次建立。@Service(value = "transactionalService")public @interface TransactionalService &#123; /** * @return 服务Bean名称 **/ @AliasFor("value") String name() default "txManager"; /** * 覆盖&#123;@link Transactional#transactionManager()&#125;默认值 * * @return &#123;@link org.springframework.transaction.PlatformTransactionManager&#125;Bean名称,默认关联 * &lt;br/&gt; * "txManager"Bean **/ /** * String transactionManager() default "txManager"; **/ @AliasFor("name") String value() default "txManager"; /** * 建立&#123;@link Transactional#transactionManager()&#125;别名 * * @return &#123;@link org.springframework.transaction.PlatformTransactionManager&#125;Bean名称,默认关联 * "txManager"Bean. **/ @AliasFor(annotation = Transactional.class, attribute = "transactionManager") String manager() default "txManager";&#125; 3:重要的类1：ClassPathBeanDefinitionScanner 读取类路径下的候选Bean，默认选取@Component，@Service，@Repository，@Controller注解的类。继承了ClassPathScanningCandidateComponentProvider。在该类BeanDefinition集合的候选条件由includeFilters和excludeFilters字段决定，在方法isCandidateComponent里实现。 该类允许自定义类型过滤规则。常见的TypeFilter类。 AnnotationTypeFilter：匹配类是否还有指定注解 AssignableTypeFilter：判定此 Class 对象所表示的类或接口与指定的 Class 参数所表示的类或接口是否相同，或是否是其超类或超接口。 RegexPatternTypeFilter：匹配全类限定名是否符合指定正则表达式。 AspectJTypeFilter：使用AspectJ类型模式进行匹配 2：类元信息读取 (1)：MetadataReaderFactory：生成MetadataReader工厂 SimpleMetadataReaderFactory：使用ASM字节码操作技术 CachingMetadataReaderFactory：使用ASM字节码操作技术和带缓存。 (2)：使用Java反射获取类元信息 StandardClassMetadata：读取Class元信息 StandardAnnotationMetadata：读取注解元信息 StandardMethodMetadata：读取方法 (3)：使用ASM操作 AnnotationMetadataReadingVisitor：查找类上元注解信息 MethodMetadataReadingVisitor：查找方法上元注解信息 AnnotationAttributesReadingVisitor：元注解属性读取 (4)：类注解元信息读取接口 AnnotationMetadata：读取注解。通过getAnnotationTypes(String)获取”元注解” 信息，提供getAnnotationAttributes(String)方法获取指定注解的属性方法。 ClassMetadata：类注解 AnnotatedTypeMetadata：注解的元注解 3：Spring注解属性抽象 AnnotationAttributes AnnotatedElementUtils：对查找注解，元注解等注解的工具类 AnnotationUtils：用于处理注解的工具类。 ReflectionUtils：反射工具类。 代码示例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 类描述: 组合注解启动类 * * @author liuenyuan * @date 2019/4/25 20:14 * @describe */@TransactionalServicepublic class ComposeAnnotationApplication &#123; public static void main(String[] args) throws IOException &#123; String className = ComposeAnnotationApplication.class.getName(); //构建MetadataReaderFactory MetadataReaderFactory metadataReaderFactory = new CachingMetadataReaderFactory(); //读取@TransactionalService MetadataReader信息 MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className); //读取@TransactionalService AnnotationMetadata信息 AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); annotationMetadata.getAnnotationTypes().forEach(annotationType -&gt; &#123; Set&lt;String&gt; metaAnnotationTypes = annotationMetadata.getMetaAnnotationTypes(annotationType); metaAnnotationTypes.forEach(metaAnnotationType -&gt; System.out.println(String.format( "注解 %s 元标注; %s\n", annotationType, metaAnnotationType))); &#125;); &#125;&#125; @Test public void springStandardAnnotationMetadata() &#123; //读取@TransactionalService AnnotationMetadata信息 AnnotationMetadata annotationMetadata = new StandardAnnotationMetadata(ComposeAnnotationReflectionApplication.class); //获取所有的元注解(全类名)集合 Set&lt;String&gt; metaAnnotationTypes = annotationMetadata.getAnnotationTypes() .stream() //读取单注解元注解类型集合 .map(annotationMetadata::getMetaAnnotationTypes) //合并元注解类型集合 .collect(LinkedHashSet::new, Set::addAll, Set::addAll); //读取所有元注解类型 metaAnnotationTypes.forEach(metaAnnotation -&gt; &#123; //读取元注解属性 Map&lt;String, Object&gt; annotationAttributes = annotationMetadata.getAnnotationAttributes(metaAnnotation); if (!CollectionUtils.isEmpty(annotationAttributes)) &#123; annotationAttributes.forEach((name, value) -&gt; System.out.printf("注解 %s 属性 %s = %s\n", ClassUtils.getShortName(metaAnnotation), name, value)); &#125; &#125;); &#125; Spring从4.0.0.RELEASE版本开始支持多层次@Component派生性。 1:Spring中@Component,@Repository,@Service,@Controller就属于@Component派生注解。 称之为Spring模式注解。 4:注解驱动过渡时代：Spring Framework 2.x新引入了一些骨架式的Annotation 依赖注入Annotation：@Autowired(可注入单个Bean，也可注入集合)—&gt;限定类型Class方式。 依赖查找Annotation：@Qualifier 组件声明Annotation：@Component,@Service Spring MVC Annotation：@Controller,@RequestMapping,@ModelAttributes等。 支持可扩展的XML编写。即Spring的Schema和Handlers机制。 支持JSR-250规范@Resource注入，@PostConstruct，@PreDestroy等。 总结Spring2.5允许自定义Spring模式注解，不过该版本仅支持单层次的模式注解“派生”。但是编程手段不多，**主要 的原因在于框架层次仍未注解提供驱动注解的Spring应用上下文，并且仍需要XML配置驱动，即XML元素&lt;context:annotation-config&gt;和&lt;context-component-scan&gt;。 5:注解驱动黄金时代：Spring Framework 3.x全面拥抱Java5(泛型,变量参数等)，以及Spring Annotation引入。例如引入了配置类注解@Configuration,AnnotationConfigApplicationContext。但是没有引入替换&lt;context:component-scan/&gt;注解。 选择过渡方案@Import,@ImportResource(需要标注@Configuration注解)。Spring3.1引入注解@ComponentScan。引入了REST开发。 SpringWeb整合了Servlet3.0+按规范，利用javax.servlet.ServletContainerInitialier API实现传统Servlet容器 自动装配的能力，替换了传统的web.xml。 1:Spring3.1抽象了一套全新并统一配置属性API,包括配置属性存储接口Environment,以及配置属性源抽象PropertySource，这两个核心API奠定了SpringBoot外部化配置的基础，也是SpringCloud分布式配置基石。 2:然后是缓存抽象，主要API包括缓存Cache和缓存管理器CacheManager。配套注解Caching和Cacheable等 极大简化了数据缓存开发。 3:异步支持，引入了异步操作注解@Async,周期异步操作@Scheduled及异步Web请求处理操作DefferedResult。 4:校验方面，新增了注解@Validated，整合JSR-303和适配了Spring早期的Validator抽象。 5:Enabled模块驱动特性。将相同职责功能组件以模块化的方式装配。例如EnabledWebMvc。 6:注解驱动完善时代:Spring Framework 4.x引入了条件化注解@Conditional，通过与自定义Condition实现配合，弥补之前版本条件化配置装配的 短板。SpringBoot的所有@ConditionalOn注解均基于@Conditional派生注解，其抽象类*SpringBootCondition**也是Condition的实现。 Spring4.x兼容了Java Time API(JSR-310),@Repeatable及参数名称发现。Java8的@Repeatable出现，解决了 以往Annotation无法重复标注同一个类的限制。Spring4.2引入了事件监听器注解@EventListener。 Spring的派生特性需要确保注解之间属性方法签名一致。限制在Spring4.2新注解@AliasFor解除，实现了 同一注解类属性方法之间的别名。Spring4.3引入REST请求注解。 Spring4.x在Web注解驱动编程也有提示，例如@RestController,@RestControllerAdvice(对RestController AOP拦截通知)。 7:注解驱动当下时代:Spring Framework5.x在SpringBoot应用场景中，大量使用注解@ComponentScan扫描指定package,当扫描package所包含的类越多时, Spring模式注解耗费时间越长。针对这个问题,Spring5.x新引入了注解@Indexed,为Spring模式注解添加索引，提升启动性能。需要引入spring-context-indexer依赖。 7-1:Spring核心注解场景分类Spring模式注解: Spring注解 场景说明 起始版本 @Repository 数据仓库模式注解 2.0 @Component 通用组件模式注解 2.5 @Service 服务模式 2.5 @Controller Web控制器模式注解 2.5 @Configuration 配置类模式注解 3.0 装配注解 Spring注解 场景说明 起始版本 @ImportResource 替换XML元素&lt;import&gt; 2.5 @Import 限定@Autowired依赖注解范围 2.5 @ComponentScan 扫描指定package下标注Spring模式注解 3.1 依赖注入注解 Spring注解 场景说明 起始版本 @Autowired Bean依赖注解,支持多种依赖查找方式 2.5 @Qualifier 细粒度的@Autowired依赖查找 2.5 Java注解 场景说明 起始版本 @Resource Bean依赖注入,仅支持名称依赖查找 2.5 Bean定义注解 Spring注解 场景说明 起始版本 @Bean 替换XML元素&lt;bean&gt; 3.0 @DependsOn 替换XML属性&lt;bean depends-on=”…”/&gt; 3.0 @Lazy 替换XML属性&lt;bean lazy-init=”trus|false”/&gt; 3.0 @Primary 替换XML元素&lt;bean primary=”true|false”/&gt; 3.0 @Role 替换XML元素&lt;bean role=”…”/&gt; 3.1 @Lookup 替换XML属性&lt;bean lookup-method=”…”&gt; 4.1 Spring条件装配注解 Spring注解 场景说明 起始版本 @Profile 配置化条件装配 3.1 @Conditional 编程条件装配 3.1 配置属性注解 Spring注解 场景说明 起始版本 @PropertySource 配置属性抽象PropertySource注解 3.1 @PropertySources @PropertySource集合注解 4.0 生命周期回调注解 Java注解 场景说明 起始版本 @PostContruct 替换XML元素&lt;bean init-method=”…”/&gt; 2.5 @PreDestroy 替换XML元素&lt;bean destroy-method=”…”/&gt; 2.5 注解属性注解 Spring注解 场景说明 起始版本 @AliasFor 别名注解属性,实现复用目的 4.2 性能注解 Spring注解 场景说明 起始版本 @Indexed 提升Spring模式注解扫描效率 5.0 8:AnnotationMetadata注解的实现 在AnnotationMetadata语义上,基于Java反射StandardAnnotationMetadata和AnnotationMetadataReadingVisitor保持一致。基于Java反射API实现必然需要反射的Class被ClassLoader加载，当指定Java Package扫描Spring模式注解时,StandardAnnotationMetadata显然不适应。 因为应用不需要将指定Package下的Class全部加载。基于ASM实现的AnnotationMetadataReadingVisitor更适合这种场景，解释了为什么该类出现ClassPathScanningCandidateComponentProvider实现中。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Annotation</tag>
        <tag>Spring注解属性覆盖</tag>
        <tag>Spring核心注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Guava简介]]></title>
    <url>%2F2019%2F08%2F06%2FGuava%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[1.引言Guava工程包含了若干被Google的 Java项目广泛依赖 的核心库，例如：集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [common annotations] 、字符串处理 [string processing] 、I/O 等等。 所有这些工具每天都在被Google的工程师应用在产品服务中。 2.基本工具 使用和避免null: Optional 前置条件: Preconditions 常见Object方法: Objects 排序: Guava强大的”流畅风格比较器”: Ordering Throwables: 简化了异常和错误的传播与检查 : Throwables 编码类型: Charsets 3.集合 不可变集合: 用不变的集合进行防御性编程和性能提升: Immutable开头。 新集合类型: multisets, multimaps, tables, bidirectional maps等 强大的集合工具类: 提供java.util.Collections中没有的集合工具 扩展工具类：让实现和扩展集合类变得更容易，比如创建Collection的装饰器，或实现迭代器 4.缓存[Caches]Guava Cache: 本地缓存实现,支持多种缓存过期策略。 5.函数式风格[Functional idioms]Guava函数式支持可以显著简化代码,但请谨慎使用。 6.并发[Concurrency] ListenableFuture：完成后触发回调的Future Service框架：抽象可开启和关闭的服务，帮助你维护服务的状态逻辑 7.字符串处理[Strings]非常有用的字符串工具，包括分割、连接、填充等操作 8.原生类型[Primitives]扩展 JDK 未提供的原生类型（如int、char）操作， 包括某些类型的无符号形式 9.区间[Ranges]可比较类型的区间API，包括连续和离散类型 10.I/O简化I/O尤其是I/O流和文件的操作，针对Java5和6版本 11.散列[Hash]提供比Object.hashCode()更复杂的散列实现，并提供布鲁姆过滤器的实现 12. 事件总线[EventBus]发布-订阅模式的组件通信，但组件不需要显式地注册到其他组件中 13.数学运算[Math]优化的、充分测试的数学工具类 14.反射[Reflection]Guava 的 Java 反射机制工具类]]></content>
      <categories>
        <category>Guava</category>
      </categories>
      <tags>
        <tag>Guava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot自动配置原理]]></title>
    <url>%2F2019%2F08%2F05%2FSpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[SpringBoot自动配置原理1:产生背景 在Spring Framework时代,当Spring应用的@Component或者@Configuration Class需要被装配 时,应用需要借助@Import或者@ComponentScan的能力。由于应用依赖的Jar存在变化的可能, 因此其中的@Component或者@Configuration Class所在的包路径也会发生变化。 不鼓励开发人员通过@ComponentScan或者@SpringApplication注解方式扫描默认包。因为 它读取所有JAR中类,并且可能会造成默认Spring Boot错误 当Spring应用自动装配某些组件时,它需要一种综合性技术手段,重新深度结合Spring注解编程 模型,@Enable模块驱动和条件装配等Spring Framework原生特性,这种技术就是Spring Boot 自动装配。 2:理解Spring Boot自动装配(1):理解@EnableAutoConfiguration 用于激活Spring Boot自动装配特性。 (2):优雅的替换自动装配 开发人员可在任意一处定义配置类,从而覆盖那些被自动装配的组件。SpringBoot优先解析 自定义配置类。内建的配置类,一旦应用存在自定义实现，就不会再装配。 (3):失效自动装配 SpringBoot提供两种失效手段 代码配置方式 配置类型安全属性方法:@EnableAutoConfiguration.exclude() 配置排除类名方式:@EnableAutoConfiguration.excludeName() 外部化配置方式 配置属性:spring.autoconfigure.exclude 3:自动装配原理 依照@Enable模块驱动设计模式，@EnableAutoConguration必然是@Import 类ImportSelector 或者ImportBeanDefinitionRegistrar的实现类。 AutoConfigurationImportSelector主要执行逻辑: 1234567891011121314151617181920212223242526public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; //读取自动装配元信息配置文件 //"META-INF/"+ "spring-autoconfigure-metadata.properties" AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader .loadMetadata(this.beanClassLoader); //获取@EnableAutoConfiguration注解属性 AnnotationAttributes attributes = getAttributes(annotationMetadata); //获取自动装配Class候选列表 List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); //移除重复的自动装配类名 configurations = removeDuplicates(configurations); //排除自动装配组件 Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); //检查排除类名集合是否合法 checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); //过滤候选自动装配组件集合中Class不存在成员 configurations = filter(configurations, autoConfigurationMetadata); //触发自动装配导入事件 fireAutoConfigurationImportEvents(configurations, exclusions); return StringUtils.toStringArray(configurations);&#125; (1):读取候选装配组件 使用了Spring工厂加载类SpringFactoriesLoader。原理如下 搜索指定ClassLoader下所有的META-INF/spring.factories资源内容。 将一个或者多个META-INF/spring.factories资源内容作为Properties文件读取,并合并为 一个Key为接口的全类限定名,Value是实现类的全类名列表的Map,作为返回值。 再从上一步返回Map中查找并返回方法指定类名所映射的实现类全类名列表。 SpringBoot自动装配列表存在地方 spring-boot-autoconfigure模块 spring-boot-actuator-autoconfigure模块 spring-boot-devtools模块(可选) 由于@EnableAutoConfiguration配置可能存在配置组件类名重复定义情况,当获取所有候选类, 立即执行removeDuplicates(List)方法,利用Set不可重复性达到去重的目的。 (2):排除自动装配组件 当getExclusions(AnnotationMetadata metadata,AnnotationAttributes attributes) 执行后,程序将获取到一个自动装配Class排除列表。随后检查排除类名集合是否合法。当排除类 存在于当前的ClassLoader但是不在自动装配名单中,将触发排除类非法异常。 1234567891011121314private void checkExcludedClasses(List&lt;String&gt; configurations, Set&lt;String&gt; exclusions) &#123; List&lt;String&gt; invalidExcludes = new ArrayList&lt;&gt;(exclusions.size()); for (String exclusion : exclusions) &#123; //存在当前ClassLoader但是不在自动装配列表名单 if (ClassUtils.isPresent(exclusion, getClass().getClassLoader()) &amp;&amp; !configurations.contains(exclusion)) &#123; invalidExcludes.add(exclusion); &#125; &#125; if (!invalidExcludes.isEmpty()) &#123; handleInvalidExcludes(invalidExcludes); &#125;&#125; (3):过滤自动装配组件 移除排除类名单后Configurations配合AutoConfigurationMetadata对象执行过滤操作。 (4):@EnableAutoConfiguration自动装配事件 SpringBoot1.5开始引入AutoConfigurationImportListener接口,自定义Java EventListener ,仅监听AutoConfigurationImportEvent,然后实例同样被SpringFactoriesLoader加载。其中, ConditionEvaluationReportAutoConfigurationImportListener就是内建实现,用于 记录自动装配组件的条件评估详情。 (5):EnableAutoConfiguration自动装配生命周期 DeferredImportSelector作为ImportSelector变种,它在@Configuration Bean处理完毕 后才运作。在@Conditional场景尤为有用，同时该实现类可通过Ordered接口或者@Order 方式调整其优先顺序。 该接口提供两类方法: process()和selectImports()。前者二次处理selectImports()方法返回 的结果，后者负责决定本组应该导入的Configuration Class作为实际导入的结果。 (6):EnableAutoConfiguration排序自动装配组件 SpringBoot提供两种自动装配组件排序手段: 绝对自动装配顺序:@AutoConfigurationOrder 相对自动装配顺序:@AutoConfigurationBefore和@AutoConfigurationAfter。(常用) (7):EnableAutoConfiguration自动装配BasePackages SpringBoot1.3开始引用注解@AutoConfigurationPackage。 该注解的实现类常常用于默认包获取。例如JPA实现获取默认包。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>自动配置原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[@Enable模块驱动原理]]></title>
    <url>%2F2019%2F08%2F05%2FEnable%E6%A8%A1%E5%9D%97%E9%A9%B1%E5%8A%A8%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[@Enable模块驱动原理1:概述@Enable模块驱动在Spring3.1后开始支持。这里的模块指具备相同领域的功能组件集合,组合所形成的一个独立的单元。例如Web MVC模块,AspectJ代理模块,Caching模块,JMX模块,Async模块等。通过@Enable模块驱动,可以开启响应的模块功能。 @Enable模块驱动可以分为”注解驱动”和”接口编程”两种实现方式。都需要配合@Import注解。 注解驱动:通过@Configuration类和@Bean方法声明类。例如Web MVC模块实现,即@EnableWebMvc注解通过导入DelegatingWebMvcConfiguration来实现。 接口编程:ImportSelector和ImportBeanDefinitionRegistrar的实现类。例如Caching模块实现,即 @EnableCaching注解通过导入CachingConfigurationSelector实现。 2:实现示例(1):注解驱动基于ImportSelector接口 @EnableWebMvc模块实现: 123456@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Documented@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc &#123;&#125; 该注解通过@Import导入一个配置类DelegatingWebMvcConfiguration: 1234@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; ......&#125; 该配置类又继承自WebMvcConfigurationSupport,里面定义一些Web Mvc必须Bean声明。 所以，基于注解驱动的@Enable模块驱动其实就是通过@Import来导入一个配置类，以此实现相应模块的组件注册，当这些组件注册到IOC容器中，这个模块对应的功能也就可以使用了。 (2):接口编程@EnableCaching模块实现。 123456789101112131415@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(CachingConfigurationSelector.class)public @interface EnableCaching &#123; boolean proxyTargetClass() default false; AdviceMode mode() default AdviceMode.PROXY; int order() default Ordered.LOWEST_PRECEDENCE;&#125; @EnableCaching*注解通过@Import导入CachingConfigurationSelector类,该类间接实现了ImportSelector*。 ImportSelector使用Spring注解元信息抽象AnnotationMetadata作为方法参数,该参数内容为导入ImportSelector实现的@Configuration类元信息,进而动态的选择一个或者多个其他@Configuration类进行导入。 1234567891011121314151617181920212223242526272829303132333435363738&gt; /**&gt; * Interface to be implemented by types that determine which @&#123;@link Configuration&#125;&gt; * class(es) should be imported based on a given selection criteria, usually one or more&gt; * annotation attributes.&gt; *&gt; * &lt;p&gt;An &#123;@link ImportSelector&#125; may implement any of the following&gt; * &#123;@link org.springframework.beans.factory.Aware Aware&#125; interfaces, and their respective&gt; * methods will be called prior to &#123;@link #selectImports&#125;:&gt; * &lt;ul&gt;&gt; * &lt;li&gt;&#123;@link org.springframework.context.EnvironmentAware EnvironmentAware&#125;&lt;/li&gt;&gt; * &lt;li&gt;&#123;@link org.springframework.beans.factory.BeanFactoryAware BeanFactoryAware&#125;&lt;/li&gt;&gt; * &lt;li&gt;&#123;@link org.springframework.beans.factory.BeanClassLoaderAware BeanClassLoaderAware&#125;&lt;/li&gt;&gt; * &lt;li&gt;&#123;@link org.springframework.context.ResourceLoaderAware ResourceLoaderAware&#125;&lt;/li&gt;&gt; * &lt;/ul&gt;&gt; *&gt; * &lt;p&gt;ImportSelectors are usually processed in the same way as regular &#123;@code @Import&#125;&gt; * annotations, however, it is also possible to defer selection of imports until all&gt; * &#123;@code @Configuration&#125; classes have been processed (see &#123;@link DeferredImportSelector&#125;&gt; * for details).&gt; *&gt; * @author Chris Beams&gt; * @since 3.1&gt; * @see DeferredImportSelector&gt; * @see Import&gt; * @see ImportBeanDefinitionRegistrar&gt; * @see Configuration&gt; */&gt; public interface ImportSelector &#123;&gt; &gt; /**&gt; * Select and return the names of which class(es) should be imported based on&gt; * the &#123;@link AnnotationMetadata&#125; of the importing @&#123;@link Configuration&#125; class.&gt; */&gt; String[] selectImports(AnnotationMetadata importingClassMetadata);&gt; &gt; &#125;&gt; &gt; 基于ImportBeanDefinitionRegistrar接口 @MapperScan模块实现 12345678910111213141516171819202122232425public class MapperScannerRegistrar implements ImportBeanDefinitionRegistrar, ResourceLoaderAware &#123; private ResourceLoader resourceLoader; /** * &#123;@inheritDoc&#125; */ @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; AnnotationAttributes annoAttrs = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName())); ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry); ... Class&lt;? extends Annotation&gt; annotationClass = annoAttrs.getClass("annotationClass"); if (!Annotation.class.equals(annotationClass)) &#123; scanner.setAnnotationClass(annotationClass); &#125; ... scanner.registerFilters(); scanner.doScan(StringUtils.toStringArray(basePackages)); &#125; ....&#125; 该接口的编程复杂度相比较于ImportSelector更高,接口将Bean定义的注册交给开发人员。常常配合ClassPathBeanDefinitionScanner类进行批量注册BeanDefinition。 ImportBeanDefinitionRegistrar:除注解元信息AnnotationMetadata作为入参外,接口将 Bean定义注册交给开发人员。 12345678910111213141516171819202122232425262728293031323334353637383940414243&gt; /**&gt; * Interface to be implemented by types that register additional bean definitions when&gt; * processing @&#123;@link Configuration&#125; classes. Useful when operating at the bean definition&gt; * level (as opposed to &#123;@code @Bean&#125; method/instance level) is desired or necessary.&gt; *&gt; * &lt;p&gt;Along with &#123;@code @Configuration&#125; and &#123;@link ImportSelector&#125;, classes of this type&gt; * may be provided to the @&#123;@link Import&#125; annotation (or may also be returned from an&gt; * &#123;@code ImportSelector&#125;).&gt; *&gt; * &lt;p&gt;An &#123;@link ImportBeanDefinitionRegistrar&#125; may implement any of the following&gt; * &#123;@link org.springframework.beans.factory.Aware Aware&#125; interfaces, and their respective&gt; * methods will be called prior to &#123;@link #registerBeanDefinitions&#125;:&gt; * &lt;ul&gt;&gt; * &lt;li&gt;&#123;@link org.springframework.context.EnvironmentAware EnvironmentAware&#125;&lt;/li&gt;&gt; * &lt;li&gt;&#123;@link org.springframework.beans.factory.BeanFactoryAware BeanFactoryAware&#125;&gt; * &lt;li&gt;&#123;@link org.springframework.beans.factory.BeanClassLoaderAware BeanClassLoaderAware&#125;&gt; * &lt;li&gt;&#123;@link org.springframework.context.ResourceLoaderAware ResourceLoaderAware&#125;&gt; * &lt;/ul&gt;&gt; *&gt; * &lt;p&gt;See implementations and associated unit tests for usage examples.&gt; *&gt; * @author Chris Beams&gt; * @since 3.1&gt; * @see Import&gt; * @see ImportSelector&gt; * @see Configuration&gt; */&gt; public interface ImportBeanDefinitionRegistrar &#123;&gt; &gt; /**&gt; * Register bean definitions as necessary based on the given annotation metadata of&gt; * the importing &#123;@code @Configuration&#125; class.&gt; * &lt;p&gt;Note that &#123;@link BeanDefinitionRegistryPostProcessor&#125; types may &lt;em&gt;not&lt;/em&gt; be&gt; * registered here, due to lifecycle constraints related to &#123;@code @Configuration&#125;&gt; * class processing.&gt; * @param importingClassMetadata annotation metadata of the importing class&gt; * @param registry current bean definition registry&gt; */&gt; public void registerBeanDefinitions(&gt; AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry);&gt; &gt; &#125;&gt; 3:@Enable模块驱动原理1:概述 @Enable模块驱动,模块无论来自于Spring内建,还是自定义,均使用@Import实现,并且该注解的职责在于装载导入类,将其定义为Spring Bean。导入主要为@Configuration Class,ImportSelector实现及ImportBeanDefinitionRegistrar实现。 2:源码实现 (1):装载@Configuration Class。 @Configuration从Spring3.0开始引入,该版本还未引入@ComponentScan。因此,开发人员经常看到XML元素&lt;context:component-scan/&gt;与&lt;context:annotation-config&gt;同时存在。根据Spring的”可扩展XML编写”特性,可以知道&lt;context:annotation-config&gt;所对应的BeanDefinitionParser实现为AnnotationConfigBeanDefinitionParser。 AnnotationConfigBeanDefinitionParser 1234567891011121314151617181920212223/** * Parser for the &amp;lt;context:annotation-config/&amp;gt; element. * * @author Mark Fisher * @author Juergen Hoeller * @author Christian Dupuis * @since 2.5 * @see AnnotationConfigUtils */public class AnnotationConfigBeanDefinitionParser implements BeanDefinitionParser &#123; @Override public BeanDefinition parse(Element element, ParserContext parserContext) &#123; Object source = parserContext.extractSource(element); // Obtain bean definitions for all relevant BeanPostProcessors. Set&lt;BeanDefinitionHolder&gt; processorDefinitions = AnnotationConfigUtils.registerAnnotationConfigProcessors(parserContext.getRegistry(), source); ... return null; &#125;&#125; AnnotationConfigUtils在Spring3.0增加了@Configuration Class的处理实现ConfigurationClassPostProcessor: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class AnnotationConfigUtils &#123; /** * The bean name of the internally managed Configuration annotation processor. */ public static final String CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME = &quot;org.springframework.context.annotation.internalConfigurationAnnotationProcessor&quot;; /** * The bean name of the internally managed BeanNameGenerator for use when processing * &#123;@link Configuration&#125; classes. Set by &#123;@link AnnotationConfigApplicationContext&#125; * and &#123;@code AnnotationConfigWebApplicationContext&#125; during bootstrap in order to make * any custom name generation strategy available to the underlying * &#123;@link ConfigurationClassPostProcessor&#125;. * @since 3.1.1 */ public static final String CONFIGURATION_BEAN_NAME_GENERATOR = &quot;org.springframework.context.annotation.internalConfigurationBeanNameGenerator&quot;; ... /** * Register all relevant annotation post processors in the given registry. * @param registry the registry to operate on */ public static void registerAnnotationConfigProcessors(BeanDefinitionRegistry registry) &#123; registerAnnotationConfigProcessors(registry, null); &#125; public static Set&lt;BeanDefinitionHolder&gt; registerAnnotationConfigProcessors( BeanDefinitionRegistry registry, Object source) &#123; ... Set&lt;BeanDefinitionHolder&gt; beanDefs = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(4); if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; ... return beanDefs; &#125; ...&#125; 简单的说,ConfigurationClassPostProcessor无论实在XML配置驱动还是在注解驱动使用场景下,均通过AnnotationConfigUtils.registerAnnotationConfigProcessors(registry,source)方法执行得到装载,且为最高优先级。不但处理了@Configuration Class,也负责@Bean方法的Bean定义。 (2):ConfigurationClassPostProcessor处理 //主要处理方法落在processConfigBeanDefinitions(registry) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173public class ConfigurationClassPostProcessor implements BeanDefinitionRegistryPostProcessor, PriorityOrdered, ResourceLoaderAware, BeanClassLoaderAware, EnvironmentAware &#123; ... /** * Prepare the Configuration classes for servicing bean requests at runtime * by replacing them with CGLIB-enhanced subclasses. */ @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123; int factoryId = System.identityHashCode(beanFactory); if (this.factoriesPostProcessed.contains(factoryId)) &#123; throw new IllegalStateException( "postProcessBeanFactory already called on this post-processor against " + beanFactory); &#125; this.factoriesPostProcessed.add(factoryId); if (!this.registriesPostProcessed.contains(factoryId)) &#123; // BeanDefinitionRegistryPostProcessor hook apparently not supported... // Simply call processConfigurationClasses lazily at this point then. processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory); &#125; enhanceConfigurationClasses(beanFactory); beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory)); &#125; /** * Build and validate a configuration model based on the registry of * &#123;@link Configuration&#125; classes. */ public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) &#123; List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;BeanDefinitionHolder&gt;(); String[] candidateNames = registry.getBeanDefinitionNames(); for (String beanName : candidateNames) &#123; BeanDefinition beanDef = registry.getBeanDefinition(beanName); if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) &#123; ... &#125; else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) &#123; configCandidates.add(new BeanDefinitionHolder(beanDef, beanName)); &#125; &#125; // Return immediately if no @Configuration classes were found if (configCandidates.isEmpty()) &#123; return; &#125; // Sort by previously determined @Order value, if applicable Collections.sort(configCandidates, new Comparator&lt;BeanDefinitionHolder&gt;() &#123; @Override public int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) &#123; int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition()); int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition()); return (i1 &lt; i2) ? -1 : (i1 &gt; i2) ? 1 : 0; &#125; &#125;); // Detect any custom bean name generation strategy supplied through the enclosing application context SingletonBeanRegistry sbr = null; if (registry instanceof SingletonBeanRegistry) &#123; sbr = (SingletonBeanRegistry) registry; if (!this.localBeanNameGeneratorSet &amp;&amp; sbr.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) &#123; BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR); this.componentScanBeanNameGenerator = generator; this.importBeanNameGenerator = generator; &#125; &#125; // Parse each @Configuration class ConfigurationClassParser parser = new ConfigurationClassParser( this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry); Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(configCandidates); Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;ConfigurationClass&gt;(configCandidates.size()); do &#123; parser.parse(candidates); parser.validate(); Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;ConfigurationClass&gt;(parser.getConfigurationClasses()); configClasses.removeAll(alreadyParsed); // Read the model and create bean definitions based on its content if (this.reader == null) &#123; this.reader = new ConfigurationClassBeanDefinitionReader( registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry()); &#125; this.reader.loadBeanDefinitions(configClasses); alreadyParsed.addAll(configClasses); candidates.clear(); if (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123; String[] newCandidateNames = registry.getBeanDefinitionNames(); Set&lt;String&gt; oldCandidateNames = new HashSet&lt;String&gt;(Arrays.asList(candidateNames)); Set&lt;String&gt; alreadyParsedClasses = new HashSet&lt;String&gt;(); for (ConfigurationClass configurationClass : alreadyParsed) &#123; alreadyParsedClasses.add(configurationClass.getMetadata().getClassName()); &#125; for (String candidateName : newCandidateNames) &#123; if (!oldCandidateNames.contains(candidateName)) &#123; BeanDefinition bd = registry.getBeanDefinition(candidateName); if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;&amp; !alreadyParsedClasses.contains(bd.getBeanClassName())) &#123; candidates.add(new BeanDefinitionHolder(bd, candidateName)); &#125; &#125; &#125; candidateNames = newCandidateNames; &#125; &#125; while (!candidates.isEmpty()); // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes if (sbr != null) &#123; if (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123; sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry()); &#125; &#125; if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) &#123; ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache(); &#125; &#125; /** * Post-processes a BeanFactory in search of Configuration class BeanDefinitions; * any candidates are then enhanced by a &#123;@link ConfigurationClassEnhancer&#125;. * Candidate status is determined by BeanDefinition attribute metadata. * @see ConfigurationClassEnhancer */ public void enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) &#123; Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = new LinkedHashMap&lt;String, AbstractBeanDefinition&gt;(); for (String beanName : beanFactory.getBeanDefinitionNames()) &#123; BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName); if (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) &#123; if (!(beanDef instanceof AbstractBeanDefinition)) &#123; throw new BeanDefinitionStoreException("Cannot enhance @Configuration bean definition '" + beanName + "' since it is not stored in an AbstractBeanDefinition subclass"); &#125; ... configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef); &#125; &#125; if (configBeanDefs.isEmpty()) &#123; // nothing to enhance -&gt; return immediately return; &#125; ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer(); for (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) &#123; AbstractBeanDefinition beanDef = entry.getValue(); // If a @Configuration class gets proxied, always proxy the target class beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE); try &#123; // Set enhanced subclass of the user-specified bean class Class&lt;?&gt; configClass = beanDef.resolveBeanClass(this.beanClassLoader); Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, this.beanClassLoader); if (configClass != enhancedClass) &#123; ... beanDef.setBeanClass(enhancedClass); &#125; &#125; ... &#125; &#125; &#125; ...&#125; 执行期间,最重要的组件莫过于ConfigurationClassParser,它将已注册的Spring BeanDefinition进行注解元信息解析,其中两个parse重载方法分别采用CGLIB实现的AnnotationMetadataReadingVisitor和Java反射实现的 StandardAnnotationMetadata。 ConfigurationClassParser 1234567891011121314151617181920212223242526272829303132333435363738class ConfigurationClassParser&#123; protected void processConfigurationClass(ConfigurationClass configClass) throws IOException &#123; if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123; return; &#125; ConfigurationClass existingClass = this.configurationClasses.get(configClass); if (existingClass != null) &#123; if (configClass.isImported()) &#123; if (existingClass.isImported()) &#123; existingClass.mergeImportedBy(configClass); &#125; // Otherwise ignore new imported config class; existing non-imported class overrides it. return; &#125; else &#123; // Explicit bean definition found, probably replacing an import. // Let's remove the old one and go with the new one. this.configurationClasses.remove(configClass); for (Iterator&lt;ConfigurationClass&gt; it = this.knownSuperclasses.values().iterator(); it.hasNext();) &#123; if (configClass.equals(it.next())) &#123; it.remove(); &#125; &#125; &#125; &#125; // Recursively process the configuration class and its superclass hierarchy. SourceClass sourceClass = asSourceClass(configClass); do &#123; sourceClass = doProcessConfigurationClass(configClass, sourceClass); &#125; while (sourceClass != null); ... &#125;&#125; doProcessConfigurationClass处理以下问题: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException &#123; // Recursively process any member (nested) classes first processMemberClasses(configClass, sourceClass); // Process any @PropertySource annotations for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable( sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) &#123; if (this.environment instanceof ConfigurableEnvironment) &#123; processPropertySource(propertySource); &#125; else &#123; logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() + "]. Reason: Environment must implement ConfigurableEnvironment"); &#125; &#125; // Process any @ComponentScan annotations Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable( sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class); if (!componentScans.isEmpty() &amp;&amp; !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123; for (AnnotationAttributes componentScan : componentScans) &#123; // The config class is annotated with @ComponentScan -&gt; perform the scan immediately Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName()); // Check the set of scanned definitions for any further config classes and parse recursively if needed for (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123; if (ConfigurationClassUtils.checkConfigurationClassCandidate( holder.getBeanDefinition(), this.metadataReaderFactory)) &#123; parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName()); &#125; &#125; &#125; &#125; // Process any @Import annotations processImports(configClass, sourceClass, getImports(sourceClass), true); // Process any @ImportResource annotations if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) &#123; AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class); String[] resources = importResource.getStringArray("locations"); Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass("reader"); for (String resource : resources) &#123; String resolvedResource = this.environment.resolveRequiredPlaceholders(resource); configClass.addImportedResource(resolvedResource, readerClass); &#125; &#125; // Process individual @Bean methods Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass); for (MethodMetadata methodMetadata : beanMethods) &#123; configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass)); &#125; // Process default methods on interfaces processInterfaces(configClass, sourceClass); // Process superclass, if any if (sourceClass.getMetadata().hasSuperClass()) &#123; String superclass = sourceClass.getMetadata().getSuperClassName(); if (!superclass.startsWith("java") &amp;&amp; !this.knownSuperclasses.containsKey(superclass)) &#123; this.knownSuperclasses.put(superclass, configClass); // Superclass found, return its annotation metadata and recurse return sourceClass.getSuperClass(); &#125; &#125; // No superclass -&gt; processing is complete return null; &#125; 处理@PropertySource注解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081private void processPropertySource(AnnotationAttributes propertySource) throws IOException &#123; String name = propertySource.getString("name"); if (!StringUtils.hasLength(name)) &#123; name = null; &#125; String encoding = propertySource.getString("encoding"); if (!StringUtils.hasLength(encoding)) &#123; encoding = null; &#125; String[] locations = propertySource.getStringArray("value"); Assert.isTrue(locations.length &gt; 0, "At least one @PropertySource(value) location is required"); boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound"); Class&lt;? extends PropertySourceFactory&gt; factoryClass = propertySource.getClass("factory"); PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ? DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass)); for (String location : locations) &#123; try &#123; String resolvedLocation = this.environment.resolveRequiredPlaceholders(location); Resource resource = this.resourceLoader.getResource(resolvedLocation); addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding))); &#125; catch (IllegalArgumentException ex) &#123; // Placeholders not resolvable if (ignoreResourceNotFound) &#123; if (logger.isInfoEnabled()) &#123; logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage()); &#125; &#125; else &#123; throw ex; &#125; &#125; catch (IOException ex) &#123; // Resource not found when trying to open it if (ignoreResourceNotFound &amp;&amp; (ex instanceof FileNotFoundException || ex instanceof UnknownHostException)) &#123; if (logger.isInfoEnabled()) &#123; logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage()); &#125; &#125; else &#123; throw ex; &#125; &#125; &#125; &#125; private void addPropertySource(PropertySource&lt;?&gt; propertySource) &#123; String name = propertySource.getName(); MutablePropertySources propertySources = ((ConfigurableEnvironment) this.environment).getPropertySources(); if (propertySources.contains(name) &amp;&amp; this.propertySourceNames.contains(name)) &#123; // We've already added a version, we need to extend it PropertySource&lt;?&gt; existing = propertySources.get(name); PropertySource&lt;?&gt; newSource = (propertySource instanceof ResourcePropertySource ? ((ResourcePropertySource) propertySource).withResourceName() : propertySource); if (existing instanceof CompositePropertySource) &#123; ((CompositePropertySource) existing).addFirstPropertySource(newSource); &#125; else &#123; if (existing instanceof ResourcePropertySource) &#123; existing = ((ResourcePropertySource) existing).withResourceName(); &#125; CompositePropertySource composite = new CompositePropertySource(name); composite.addPropertySource(newSource); composite.addPropertySource(existing); propertySources.replace(name, composite); &#125; &#125; else &#123; if (this.propertySourceNames.isEmpty()) &#123; propertySources.addLast(propertySource); &#125; else &#123; String firstProcessed = this.propertySourceNames.get(this.propertySourceNames.size() - 1); propertySources.addBefore(firstProcessed, propertySource); &#125; &#125; this.propertySourceNames.add(name); &#125; 处理@ComponentScan注解 123456789101112131415161718// Process any @ComponentScan annotationsSet&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable( sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);if (!componentScans.isEmpty() &amp;&amp; !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123; for (AnnotationAttributes componentScan : componentScans) &#123; // The config class is annotated with @ComponentScan -&gt; perform the scan immediately Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName()); // Check the set of scanned definitions for any further config classes and parse recursively if needed for (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123; if (ConfigurationClassUtils.checkConfigurationClassCandidate( holder.getBeanDefinition(), this.metadataReaderFactory)) &#123; parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName()); &#125; &#125; &#125;&#125; 处理@Import注解,@ImportResource,@Bean注解。其中@Import处理方法processImports与processConfigurationClass(ConfigurationClass configClass)形成递归调用。实现多层次@Import元标注的ConfigurationClass解析。解析后的ConfigurationClass将会被ConfigurationClassBeanDefinitionReader再次注册为SpringBean。ConfigurationClassBeanDefinitionReader将@Import,@ImportResource,@Bean所关联的Bean定义一并注册了。 (3):ConfigurationClassBeanDefinitionReader:将解析的Configuration Classs注册为Spring Bean。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class ConfigurationClassBeanDefinitionReader&#123; ... public void loadBeanDefinitions(Set&lt;ConfigurationClass&gt; configurationModel) &#123; TrackedConditionEvaluator trackedConditionEvaluator = new TrackedConditionEvaluator(); for (ConfigurationClass configClass : configurationModel) &#123; loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator); &#125; &#125; /** * Read a particular &#123;@link ConfigurationClass&#125;, registering bean definitions * for the class itself and all of its &#123;@link Bean&#125; methods. */ private void loadBeanDefinitionsForConfigurationClass(ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) &#123; ... if (configClass.isImported()) &#123; registerBeanDefinitionForImportedConfigurationClass(configClass); &#125; for (BeanMethod beanMethod : configClass.getBeanMethods()) &#123; loadBeanDefinitionsForBeanMethod(beanMethod); &#125; loadBeanDefinitionsFromImportedResources(configClass.getImportedResources()); loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars()); &#125; /** * Register the &#123;@link Configuration&#125; class itself as a bean definition. */ private void registerBeanDefinitionForImportedConfigurationClass(ConfigurationClass configClass) &#123; ... &#125; /** * Read the given &#123;@link BeanMethod&#125;, registering bean definitions * with the BeanDefinitionRegistry based on its contents. */ private void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) &#123; ... &#125; private void loadBeanDefinitionsFromImportedResources( Map&lt;String, Class&lt;? extends BeanDefinitionReader&gt;&gt; importedResources) &#123; ... &#125; private void loadBeanDefinitionsFromRegistrars(Map&lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&gt; registrars) &#123; for (Map.Entry&lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&gt; entry : registrars.entrySet()) &#123; entry.getKey().registerBeanDefinitions(entry.getValue(), this.registry); &#125; &#125;&#125; (4):ConfigurationClassUtils:判定Configuration Class的级别 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596abstract class ConfigurationClassUtils &#123; private static final String CONFIGURATION_CLASS_FULL = "full"; private static final String CONFIGURATION_CLASS_LITE = "lite"; private static final String CONFIGURATION_CLASS_ATTRIBUTE = Conventions.getQualifiedAttributeName(ConfigurationClassPostProcessor.class, "configurationClass"); private static final String ORDER_ATTRIBUTE = Conventions.getQualifiedAttributeName(ConfigurationClassPostProcessor.class, "order"); private static final Log logger = LogFactory.getLog(ConfigurationClassUtils.class); private static final Set&lt;String&gt; candidateIndicators = new HashSet&lt;String&gt;(4); static &#123; candidateIndicators.add(Component.class.getName()); candidateIndicators.add(ComponentScan.class.getName()); candidateIndicators.add(Import.class.getName()); candidateIndicators.add(ImportResource.class.getName()); &#125; ... /** * Check the given metadata for a configuration class candidate * (or nested component class declared within a configuration/component class). * @param metadata the metadata of the annotated class * @return &#123;@code true&#125; if the given class is to be registered as a * reflection-detected bean definition; &#123;@code false&#125; otherwise */ public static boolean isConfigurationCandidate(AnnotationMetadata metadata) &#123; return (isFullConfigurationCandidate(metadata) || isLiteConfigurationCandidate(metadata)); &#125; /** * Check the given metadata for a full configuration class candidate * (i.e. a class annotated with &#123;@code @Configuration&#125;). * @param metadata the metadata of the annotated class * @return &#123;@code true&#125; if the given class is to be processed as a full * configuration class, including cross-method call interception */ public static boolean isFullConfigurationCandidate(AnnotationMetadata metadata) &#123; return metadata.isAnnotated(Configuration.class.getName()); &#125; /** * Check the given metadata for a lite configuration class candidate * (e.g. a class annotated with &#123;@code @Component&#125; or just having * &#123;@code @Import&#125; declarations or &#123;@code @Bean methods&#125;). * @param metadata the metadata of the annotated class * @return &#123;@code true&#125; if the given class is to be processed as a lite * configuration class, just registering it and scanning it for &#123;@code @Bean&#125; methods */ public static boolean isLiteConfigurationCandidate(AnnotationMetadata metadata) &#123; // Do not consider an interface or an annotation... if (metadata.isInterface()) &#123; return false; &#125; // Any of the typical annotations found? for (String indicator : candidateIndicators) &#123; if (metadata.isAnnotated(indicator)) &#123; return true; &#125; &#125; // Finally, let's look for @Bean methods... try &#123; return metadata.hasAnnotatedMethods(Bean.class.getName()); &#125; ... &#125; /** * Determine whether the given bean definition indicates a full &#123;@code @Configuration&#125; * class, through checking &#123;@link #checkConfigurationClassCandidate&#125;'s metadata marker. */ public static boolean isFullConfigurationClass(BeanDefinition beanDef) &#123; return CONFIGURATION_CLASS_FULL.equals(beanDef.getAttribute(CONFIGURATION_CLASS_ATTRIBUTE)); &#125; /** * Determine whether the given bean definition indicates a lite &#123;@code @Configuration&#125; * class, through checking &#123;@link #checkConfigurationClassCandidate&#125;'s metadata marker. */ public static boolean isLiteConfigurationClass(BeanDefinition beanDef) &#123; return CONFIGURATION_CLASS_LITE.equals(beanDef.getAttribute(CONFIGURATION_CLASS_ATTRIBUTE)); &#125; ...&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Enable模块驱动</tag>
        <tag>ImportSelector</tag>
        <tag>ImportBeanDefinitionRegistrar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring事件监听机制]]></title>
    <url>%2F2019%2F08%2F05%2FSpring%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Spring事件监听机制1:Spring事件监听基础 Spring事件/监听机制属于事件/监听器模式,即观察者模式扩展。在Java中,事件源必须是java.util. EventObject对象。事件监听器必须是java.util.EventListener。通常API接口需要提供 监听接口的适配器实现,提供监听空实现的适配方法。当Java8 interface的default方法特性 能够解决以上问题。 ​ Spring事件监听器,仅抽象出单一方法onApplicationEvent(ApplicationEvent),用于监听Spring事件 ApplicationEvent。 ​ 在Spring3.0之前的ApplicationListener基本无解,必须监听所有的ApplicationEvent,如果要过滤 不同类型的事件,需要借助instanceof方式进行筛选。从Spring3.0开始,支持泛型监听。 12345678910@FunctionalInterfacepublic interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener &#123; /** * Handle an application event. * @param event the event to respond to */ void onApplicationEvent(E event);&#125; 由于泛型参数的限制,泛型化的ApplicationListener无法监听不同类型的ApplicationEvent。为此,Spring3.0 引入了SmartApplicationListener接口: 123456789101112131415public interface SmartApplicationListener extends ApplicationListener&lt;ApplicationEvent&gt;, Ordered &#123; /** * Determine whether this listener actually supports the given event type. * @param eventType the event type (never &#123;@code null&#125;) */ boolean supportsEventType(Class&lt;? extends ApplicationEvent&gt; eventType); /** * Determine whether this listener actually supports the given source type. * @param sourceType the source type, or &#123;@code null&#125; if no source */ boolean supportsSourceType(@Nullable Class&lt;?&gt; sourceType);&#125; 例如SpringBoot外部化应用配置文件application.properties的事件监听器ConfigFileApplicationListener 实现,监听了ApplicationEnvironmentPreparedEvent和ApplicationPreparedEvent两个事件. 12345@Overridepublic boolean supportsEventType(Class&lt;? extends ApplicationEvent&gt; eventType) &#123; return ApplicationEnvironmentPreparedEvent.class.isAssignableFrom(eventType) || ApplicationPreparedEvent.class.isAssignableFrom(eventType);&#125; 2:Spring事件发布 ApplicationEventMulticaster主要承担两种职责,一是关联ApplicationListener,二是广播 ApplicationEvent。 1):ApplicationEventMulticaster注册ApplicationListener AbstractApplicationEventMulticaster将ApplicationListener做了分类,再结合retrieverCache的定义, 它是一个ListenerCacheKey为key,ListenerRetriever为value的Map缓存。同时ListenerCacheKey 关联了事件类型和数据源类型。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Cache key for ListenerRetrievers, based on event type and source type. */private static final class ListenerCacheKey implements Comparable&lt;ListenerCacheKey&gt; &#123; private final ResolvableType eventType; @Nullable private final Class&lt;?&gt; sourceType; public ListenerCacheKey(ResolvableType eventType, @Nullable Class&lt;?&gt; sourceType) &#123; Assert.notNull(eventType, "Event type must not be null"); this.eventType = eventType; this.sourceType = sourceType; &#125; @Override public boolean equals(Object other) &#123; if (this == other) &#123; return true; &#125; ListenerCacheKey otherKey = (ListenerCacheKey) other; return (this.eventType.equals(otherKey.eventType) &amp;&amp; ObjectUtils.nullSafeEquals(this.sourceType, otherKey.sourceType)); &#125; @Override public int hashCode() &#123; return this.eventType.hashCode() * 29 + ObjectUtils.nullSafeHashCode(this.sourceType); &#125; @Override public String toString() &#123; return "ListenerCacheKey [eventType = " + this.eventType + ", sourceType = " + this.sourceType + "]"; &#125; @Override public int compareTo(ListenerCacheKey other) &#123; int result = this.eventType.toString().compareTo(other.eventType.toString()); if (result == 0) &#123; if (this.sourceType == null) &#123; return (other.sourceType == null ? 0 : -1); &#125; if (other.sourceType == null) &#123; return 1; &#125; result = this.sourceType.getName().compareTo(other.sourceType.getName()); &#125; return result; &#125;&#125; 实际上,AbstractApplicationEventMulticaster将ApplicationEvent和ApplicationListener集合进行关联。因此 AbstractApplicationEventMulticaster#getApplicationListeners()返回ApplicationEvent关联ApplicationListener集合。 2)ApplicationEventMulticaster广播事件 ​ 广播事件在SimpleApplicationEventMulticaster中实现,也是Spring内建唯一实现。 12345678910111213@Overridepublic void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) &#123; ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event)); for (final ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123; Executor executor = getTaskExecutor(); if (executor != null) &#123; executor.execute(() -&gt; invokeListener(listener, event)); &#125; else &#123; invokeListener(listener, event); &#125; &#125;&#125; //该方法从Spring4.2开始引入。尽管ResolvableType是从Spring4.0开始出现,它是Spring简化Java反射 API而提供的组件,能够轻松的获取泛型类型等。 3)ApplicationEventMulticaster和ApplicationContext之间关系 开发人员可使用ApplicationEventPublisher发布ApplicationEvent。 ApplicationEventPublisher接口被Spring上下文接口ApplicationContext扩展,因此,无论哪种Spring应用 上下文实例,均具备发布ApplicationEvent的能力。]]></content>
      <categories>
        <category>Spring</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring事件监听机制</tag>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义SpringBoot自动装配]]></title>
    <url>%2F2019%2F08%2F05%2F%E8%87%AA%E5%AE%9A%E4%B9%89SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%2F</url>
    <content type="text"><![CDATA[自定义SpringBoot自动装配1：自动装配Class命名规则AutoConfiguration，其中\代表功能或者模块名。 2：自动装配package命名规则123456$&#123;root-package&#125; |- autoconfigure |- $&#123;module-package&#125; |- *AutoConfiguration |- $&#123;sub-module-package&#125; |- ... 其中${root_package}是根模块，如com.ley。 ${module_package}是功能模块，如web.servlet。 而${sub_module_package}是子模块，如error。 3：自定义SpringBootStarter官方建议将自动装配模块代码存放到autoconfigure模块中，starter模块依赖该模块，并且附加其他需要依赖。当然也可以将autoconfigure和stater合并到单模块。 (1)：Spring Boot Starter命名规则 开发人员将Starter发布为${module}-spring-boot-autoconfigure和${module}-spring-boot-starter两个jar文件。 开发人员不要使用server,management,spring等作为配置Key命名空间。尽量采用独立的命名空间。 (2)：实现Spring Boot Starter (a)：新建Spring Boot Starter工程—–formatter-spring-boot-autoconfigure。 构建一个Maven功能，pom.xml如下。 123456789101112131415161718192021&lt;dependencies&gt; &lt;!-- Compile dependencies --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- @ConfigurationProperties annotation processing (metadata for IDEs) --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; (b)：实现DefaultFormatter自动装配—-FormatterAutoConfiguration (c)：META-INF/spring.factories资源声明FormatterAutoConfiguration 123# FormatterAutoConfiguration 自动装配声明org.springframework.boot.autoconfigure.EnableAutoConfiguration=\ com.ley.formatter.autoconfigure.FormatterAutoConfiguration (d)：构建Spring Boot Starter—-formatter-spring-boot-starter 1234567891011121314151617181920&lt;dependencies&gt; &lt;!--formatter spring boot autoconfigure--&gt; &lt;dependency&gt; &lt;groupId&gt;com.gitee.ley1996&lt;/groupId&gt; &lt;artifactId&gt;formatter-spring-boot-autoconfigure&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring boot 基础依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;!-- 说明formatter-spring-boot-starter不应该 传递spring-boot-starter依赖。 --&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在开发Spring Boot Starter的过程中，请保持spring-boot-starter等相关依赖声明为 、&lt;optional&gt;true&lt;/optional&gt;。 4：Spring Boot 提交化自动装配条件注解总结： Class Conditions Bean Conditions Property Conditions Resource Conditions Web Application Conditions SpEL Expression Conditions 4.1：Class条件注解 ConditionalOnClass：当指定类存在时，在Sprign Boot 1.0~2.0稳定。 ConditionalOnMissingClass：当指定类不存在时，从Spring Boot 1.4开始才保持稳定。推荐使用value()替代。当指定类不存在时，并不需要该类显示地依赖到当前工程或者Starter。 4.2：Bean条件注解 ConditionalOnBean：匹配BeanFactory中Bean的类型和名称。 其中Bean查找策略为SearchStrategy，包含当前，父类及所有。 ConditionalOnMissingBean：当指定Bean不存在时。从Spring Boot 1.2.5开始，增加ignored()和ignoredType()两个方法，用于忽略或者排除指定Bean。 4.3：属性条件注解 ConditionalOnProperty为属性条件注解，其属性来源于Spring Environment。其中Java系统属性(systemProperties)和环境变量(systemEnvironment)是典型的Spring Environment属性来源。在SpringBoot环境中，application.properties或者application.yml也是其中来源之一。 当自动装配组件需要默认装配时，可以使用matchIfMissing()属性值调整为true。 4.4：Resource条件注解 ConditionOnResource为Resource条件注解。其中resources()指定只有资源必须存在方可成立。 4.5：Web应用条件注解。 ConditionalOnWebApplication：判断当前应用是Web类型。 ConditionalOnNotWebApplication：当前应用不是Web类型。 4.6：Spring表达式条件注解 ConditionalOnExpression，其中value()用于评估表达式的真伪。当表达多组配置属性时，可以使用@ConditionalOnExpression。例如${formatter.enabled:true} 总结使用Spring Boot提供的条件注解,以及自动装配顺序注解,实现自己的配置类,然后在META-INF/ spring.factories中声明该类即可。如下所示： 123# FormatterAutoConfiguration 自动装配声明org.springframework.boot.autoconfigure.EnableAutoConfiguration=\ com.ley.formatter.autoconfigure.FormatterAutoConfiguration]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>SpringBoot自动装配</tag>
        <tag>条件化注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring整合Mybatis原理探索]]></title>
    <url>%2F2019%2F08%2F05%2FSpring%E6%95%B4%E5%90%88Mybatis%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[Spring整合Mybatis原理探索@MapperScan注解实现 1:MapperScannerRegistrar类 实现ImportBeanDefinitionRegistrar接口,注册默认@Mapper注解标注的接口。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; //获取@MapperScan注解上属性 AnnotationAttributes mapperScanAttrs = AnnotationAttributes .fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName())); if (mapperScanAttrs != null) &#123; registerBeanDefinitions(mapperScanAttrs, registry); &#125; &#125; void registerBeanDefinitions(AnnotationAttributes annoAttrs, BeanDefinitionRegistry registry) &#123;//扫描指定包下包含默认Mybatis注解@Mapper的接口,并注册到Spring Bean工厂中 ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry); // this check is needed in Spring 3.1 Optional.ofNullable(resourceLoader).ifPresent(scanner::setResourceLoader); Class&lt;? extends Annotation&gt; annotationClass = annoAttrs.getClass("annotationClass"); if (!Annotation.class.equals(annotationClass)) &#123; scanner.setAnnotationClass(annotationClass); &#125; Class&lt;?&gt; markerInterface = annoAttrs.getClass("markerInterface"); if (!Class.class.equals(markerInterface)) &#123; scanner.setMarkerInterface(markerInterface); &#125; Class&lt;? extends BeanNameGenerator&gt; generatorClass = annoAttrs.getClass("nameGenerator"); if (!BeanNameGenerator.class.equals(generatorClass)) &#123; scanner.setBeanNameGenerator(BeanUtils.instantiateClass(generatorClass)); &#125; Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass = annoAttrs.getClass("factoryBean"); if (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) &#123; scanner.setMapperFactoryBean(BeanUtils.instantiateClass(mapperFactoryBeanClass)); &#125; scanner.setSqlSessionTemplateBeanName(annoAttrs.getString("sqlSessionTemplateRef")); scanner.setSqlSessionFactoryBeanName(annoAttrs.getString("sqlSessionFactoryRef")); List&lt;String&gt; basePackages = new ArrayList&lt;&gt;(); basePackages.addAll( Arrays.stream(annoAttrs.getStringArray("value")) .filter(StringUtils::hasText) .collect(Collectors.toList())); basePackages.addAll( Arrays.stream(annoAttrs.getStringArray("basePackages")) .filter(StringUtils::hasText) .collect(Collectors.toList())); basePackages.addAll( Arrays.stream(annoAttrs.getClassArray("basePackageClasses")) .map(ClassUtils::getPackageName) .collect(Collectors.toList())); scanner.registerFilters(); scanner.doScan(StringUtils.toStringArray(basePackages)); &#125; 2:ClassPathMapperScanner 继承了ClassPathBeanDefinitionScanner类,该类扫描指定包下的模式注解,并注册到Spring Bean工厂中。 实现主要方法研究 注册BeanDefinition过滤接口 12345678910111213141516171819202122232425262728293031323334353637/** * Configures parent scanner to search for the right interfaces. It can search * for all interfaces or just for those that extends a markerInterface or/and * those annotated with the annotationClass */public void registerFilters() &#123; boolean acceptAllInterfaces = true; // if specified, use the given annotation and / or marker interface if (this.annotationClass != null) &#123; addIncludeFilter(new AnnotationTypeFilter(this.annotationClass)); acceptAllInterfaces = false; &#125; // override AssignableTypeFilter to ignore matches on the actual marker interface if (this.markerInterface != null) &#123; //由于生成的BeanDefinition为MapperFactoryBean,所以BeanClass不是原来的类名 addIncludeFilter(new AssignableTypeFilter(this.markerInterface) &#123; @Override protected boolean matchClassName(String className) &#123; return false; &#125; &#125;); acceptAllInterfaces = false; &#125; if (acceptAllInterfaces) &#123; // default include filter that accepts all classes addIncludeFilter((metadataReader, metadataReaderFactory) -&gt; true); &#125; // exclude package-info.java addExcludeFilter((metadataReader, metadataReaderFactory) -&gt; &#123; String className = metadataReader.getClassMetadata().getClassName(); return className.endsWith("package-info"); &#125;);&#125; 注册MapperFactoryBean 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private void processBeanDefinitions(Set&lt;BeanDefinitionHolder&gt; beanDefinitions) &#123; GenericBeanDefinition definition; for (BeanDefinitionHolder holder : beanDefinitions) &#123; definition = (GenericBeanDefinition) holder.getBeanDefinition(); String beanClassName = definition.getBeanClassName(); LOGGER.debug(() -&gt; "Creating MapperFactoryBean with name '" + holder.getBeanName() + "' and '" + beanClassName + "' mapperInterface"); // the mapper interface is the original class of the bean // but, the actual class of the bean is MapperFactoryBean //添加要与类型匹配的通用参数值注意：单个通用参数值将只使用一次*，而不是多次匹配。 //MapperFactoryBean是个泛型类,泛型参数是Mybatis的DAO全类限定名 definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); / definition.setBeanClass(this.mapperFactoryBean.getClass()); definition.getPropertyValues().add("addToConfig", this.addToConfig); boolean explicitFactoryUsed = false; if (StringUtils.hasText(this.sqlSessionFactoryBeanName)) &#123; //如果配置了SqlSesiionFactoryBean,获取运行期间的SqlSessionFactory Bean引用 definition.getPropertyValues().add("sqlSessionFactory", new RuntimeBeanReference(this.sqlSessionFactoryBeanName)); explicitFactoryUsed = true; &#125; else if (this.sqlSessionFactory != null) &#123; definition.getPropertyValues().add("sqlSessionFactory", this.sqlSessionFactory); explicitFactoryUsed = true; &#125; if (StringUtils.hasText(this.sqlSessionTemplateBeanName)) &#123; if (explicitFactoryUsed) &#123; LOGGER.warn(() -&gt; "Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored."); &#125; definition.getPropertyValues().add("sqlSessionTemplate", new RuntimeBeanReference(this.sqlSessionTemplateBeanName)); explicitFactoryUsed = true; &#125; else if (this.sqlSessionTemplate != null) &#123; if (explicitFactoryUsed) &#123; LOGGER.warn(() -&gt; "Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored."); &#125; definition.getPropertyValues().add("sqlSessionTemplate", this.sqlSessionTemplate); explicitFactoryUsed = true; &#125; if (!explicitFactoryUsed) &#123; LOGGER.debug(() -&gt; "Enabling autowire by type for MapperFactoryBean with name '" + holder.getBeanName() + "'."); definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE); &#125; &#125; &#125; 设置候选BeanDefinition条件 12345//判断候选的BeanDefinition是否是接口和独立类@Overrideprotected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) &#123; return beanDefinition.getMetadata().isInterface() &amp;&amp; beanDefinition.getMetadata().isIndependent();&#125; 相关类 ClassPathMapperScanner:扫描Bean并注册Bean工厂中 MapperFactoryBean:Mapper Bean工程 MapperScannerRegistrar:提供解析MapperScan注解和批量注册Bean SqlSessionDaoSupport:提供SqlSession 总结实现批量注册Bean时,提供扫描包注解+标注候选注解+实现ImportBeanDefinitionRegistrar接口+ 继承ClassPathBeanDefinitionScanner+实现FactoryBean接口。]]></content>
      <categories>
        <category>Spring</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Mybatis</tag>
        <tag>MapperScan注解实现原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Environment抽象]]></title>
    <url>%2F2019%2F08%2F05%2FSpring%20Environment%E6%8A%BD%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Spring Environment抽象1:概述Spring中Environment是Spring3.1版本引入的,是Spring核心框架定义的一个接口,用来表示整个应用运行时环境。该环境模型只接受两种应用环境profiles(配置文件)和properties(属性)。与属性访问相关的方法通过PropertyResolver超接口访问。 建模关键 profile(配置文件) 一个profile是一组Bean定义的逻辑分组,只有当配置文件被激活的时候,才会将对应逻辑上组织的Bean定义注册到容器中。 Bean添加到profile可以通过XML或者Annotation方式。 Environment对象对于profile机制所扮演的角色是用来指定哪些profile是当前活跃或者缺省活跃。可以通过getActiveProfiles或者getDefaultProfiles获取。 proprety(属性) 一个应用属性有很多来源:属性文件(properties files),JVM系统属性(getSystemProperties),系统变量属性(getSystemEnvironment),JNDI,servlet上下文参数,临时属性对象,Maps等。 Environment对于property所扮演的角色提供给使用一个方便服务接口用于 配置属性源 从属性源解析和获取属性 容器上下文(ApplicationContext)所获取的bean,如果想直接使用Environment对象访问profile状态或者获取属性。有以下方式。 EnvironmentAware接口 @Inject 或者 @Autowired注入一个 Environment对象 绝大多数情况,bean都不需要直接访问Environment对象,而是通过类似@Value注解方式把属性值注入进来。 这个接口定义在包 org.springframework.core.env 中。下面是Spring围绕环境抽象Environment各个接口/类之间的继承关系: 2:Environment接口相关类介绍 接口|类 介绍 PropertyResolver 接口,抽象对属性源的访问比如是否包含某个属性，读取属性，解析占位符，将读取到的属性转换成指定类型 (提供读操作)默认实现PropertySourcesPropertyResolver Environment 接口,继承自PropertyResolver,对环境属性访问和default/active profile访问的抽象 。 ConfigurablePropertyResolver 接口，为PropertyResolver接口抽象的属性源访问做了配置方面的增强。(提供写操作。) ConfigurableEnvironment 接口，在所继承的接口之上增加了设置defaut/active profile的能力，增加/删除环境对象中属性源的能力 ConfigurableWebEnvironment 接口，向接口ConfigurableEnvironment增强了根据Servlet上下文/配置初始化属性源的能力 AbstractEnvironment Environment抽象基类，实现了ConfigurableEnvironment StandardEnvironment 实现类,针对标准Spring应用(非Web应用)环境, 在AbstractEnvironment基础上提供了属性源systemEnvironment(来自System.getenv())和systemProperties(来自System.getProperties()) StandardServletEnvironment 实现类,针对标准Spring Servlet Web应用的环境， 增加了servletContextInitParams/servletConfigInitParams/jndiProperties 3:外部化配置抽象相关类 接口|类 介绍 PropertySource 用来抽象属性键值对(外部化配置,即属性源)配置基类。例如Map,Properties,ServletConfig,ServletContext PropertySources 对PropertySource抽象属性键值对外部化配置提供集合操作。 MutablePropertySources PropertySources默认实现。 MapPropertySource Map对象中读取属性键值对 PropertiesPropertySource Properties对象中读取属性键值对 ResourcePropertySource Resource对象读取中读取属性键值对。只支持.xml和.properties文件。底层实现使用了工具类PropertiesLoaderUtils。 CompositePropertySource 聚合一组PropertySource。 Web环境实现类和JNDI实现类和随机数实现类 ServletConfigPropertySource,ServletContextPropertySource, JndiPropertySource,RandomValuePropertySource 命令行参数实现类 CommandLinePropertySource 4:混淆定义 上下文:用来处理分层传递抽象,代表着应用。 环境:当前上下文运行环境,存储各种全局变量。比如JDK信息,内存信息等等。 5:核心API PropertySource:属性源。key-value属性对抽象 PropertyResolver:属性解析器。用于解析相应key的value Profile:配置。只有激活的配置profile的组件/配置才会注册到Spring容器,类似于maven中profile。 Environment:环境，本身也是个属性解析器PropertyResolver。 6:属性解析器相关类详细介绍PropertySourcesPropertyResolver该类是Spring内建提供的PropertyResolver唯一实现类。环境抽象Environment属性解析委托给该类。包括对属性类型之间必要转换。Converter和ConverterService。实际的占位符解析委托给PropertyPlaceholderHelper。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class PropertySourcesPropertyResolver extends AbstractPropertyResolver &#123; ... @Nullable private final PropertySources propertySources; //内部持有一组PropertySource // 由此可以看出propertySources的顺序很重要~~~ // 并且还能处理占位符~~~~~ resolveNestedPlaceholders支持内嵌、嵌套占位符 @Nullable protected &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetValueType, boolean resolveNestedPlaceholders) &#123; if (this.propertySources != null) &#123; for (PropertySource&lt;?&gt; propertySource : this.propertySources) &#123; Object value = propertySource.getProperty(key); if (value != null) &#123; if (resolveNestedPlaceholders &amp;&amp; value instanceof String) &#123; value = resolveNestedPlaceholders((String) value); &#125; logKeyFound(key, propertySource, value); return convertValueIfNecessary(value, targetValueType); &#125; &#125; &#125; return null; &#125; ...&#125;public abstract class AbstractPropertyResolver implements ConfigurablePropertyResolver &#123; ... @Nullable private volatile ConfigurableConversionService conversionService; @Nullable private PropertyPlaceholderHelper nonStrictHelper; @Nullable private PropertyPlaceholderHelper strictHelper; private boolean ignoreUnresolvableNestedPlaceholders = false; private String placeholderPrefix = SystemPropertyUtils.PLACEHOLDER_PREFIX; private String placeholderSuffix = SystemPropertyUtils.PLACEHOLDER_SUFFIX; @Nullable private String valueSeparator = SystemPropertyUtils.VALUE_SEPARATOR; private final Set&lt;String&gt; requiredProperties = new LinkedHashSet&lt;&gt;(); ...&#125; 7:应用环境抽象EnvironmentEnvironment接口:环境的读操作 1234567891011121314151617181920212223242526272829303132333435363738394041public interface Environment extends PropertyResolver &#123; /** * Return the set of profiles explicitly made active for this environment. Profiles * are used for creating logical groupings of bean definitions to be registered * conditionally, for example based on deployment environment. Profiles can be * activated by setting &#123;@linkplain AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME * "spring.profiles.active"&#125; as a system property or by calling * &#123;@link ConfigurableEnvironment#setActiveProfiles(String...)&#125;. * &lt;p&gt;If no profiles have explicitly been specified as active, then any * &#123;@linkplain #getDefaultProfiles() default profiles&#125; will automatically be activated. * @see #getDefaultProfiles * @see ConfigurableEnvironment#setActiveProfiles * @see AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME */ String[] getActiveProfiles(); /** * Return the set of profiles to be active by default when no active profiles have * been set explicitly. * @see #getActiveProfiles * @see ConfigurableEnvironment#setDefaultProfiles * @see AbstractEnvironment#DEFAULT_PROFILES_PROPERTY_NAME */ String[] getDefaultProfiles(); /** * Return whether one or more of the given profiles is active or, in the case of no * explicit active profiles, whether one or more of the given profiles is included in * the set of default profiles. If a profile begins with '!' the logic is inverted, * i.e. the method will return true if the given profile is &lt;em&gt;not&lt;/em&gt; active. * For example, &lt;pre class="code"&gt;env.acceptsProfiles("p1", "!p2")&lt;/pre&gt; will * return &#123;@code true&#125; if profile 'p1' is active or 'p2' is not active. * @throws IllegalArgumentException if called with zero arguments * or if any profile is &#123;@code null&#125;, empty or whitespace-only * @see #getActiveProfiles * @see #getDefaultProfiles */ boolean acceptsProfiles(String... profiles);&#125; ConfigurableEnvironment:增加环境的写操作 1234567891011121314151617181920public interface ConfigurableEnvironment extends Environment, ConfigurablePropertyResolver &#123; // 指定该环境下的 profile 集 void setActiveProfiles(String... profiles); // 增加此环境的 profile void addActiveProfile(String profile); // 设置默认的 profile void setDefaultProfiles(String... profiles); // 返回此环境的 PropertySources MutablePropertySources getPropertySources(); // 尝试返回 System.getenv() 的值，若失败则返回通过 System.getenv(string) 的来访问各个键的映射 Map&lt;String, Object&gt; getSystemEnvironment(); // 尝试返回 System.getProperties() 的值，若失败则返回通过 System.getProperties(string) 的来访问各个键的映射 Map&lt;String, Object&gt; getSystemProperties(); void merge(ConfigurableEnvironment parent);&#125; AbstractEnvironment:作为环境接口抽象实现,主要实现了profile相关功能 12345678910111213141516171819202122232425262728293031public abstract class AbstractEnvironment implements ConfigurableEnvironment &#123; public static final String IGNORE_GETENV_PROPERTY_NAME = "spring.getenv.ignore"; // 请参考：ConfigurableEnvironment#setActiveProfiles public static final String ACTIVE_PROFILES_PROPERTY_NAME = "spring.profiles.active"; // 请参考：ConfigurableEnvironment#setDefaultProfiles public static final String DEFAULT_PROFILES_PROPERTY_NAME = "spring.profiles.default"; private final Set&lt;String&gt; defaultProfiles = new LinkedHashSet&lt;&gt;(getReservedDefaultProfiles()); // 默认的profile名称 protected static final String RESERVED_DEFAULT_PROFILE_NAME = "default"; ... protected Set&lt;String&gt; doGetActiveProfiles() &#123; synchronized (this.activeProfiles) &#123; if (this.activeProfiles.isEmpty()) &#123; String profiles = getProperty(ACTIVE_PROFILES_PROPERTY_NAME); if (StringUtils.hasText(profiles)) &#123; setActiveProfiles(StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(profiles))); &#125; &#125; return this.activeProfiles; &#125; &#125; ...&#125; 如果 activeProfiles 为空,则从 Properties 中获取 spring.profiles.active 配置;如果不为空，则调用 setActiveProfiles() 设置 profile,最后返回。 从这里可以知道，API设置的activeProfiles优先级第一，其次才是属性配置。 8:应用环境配置激活(@Profile和ProfileCondition)123456789@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Conditional(ProfileCondition.class)public @interface Profile &#123; String[] value();&#125; 从Spring4.0开始提供Conditional接口,该注解实现原理基于Condition条件接口,Condition条件接口计算结果实现类为ConditionEvaluator,该类是个内部类。 ProfileCondition 1234567891011121314151617181920class ProfileCondition implements Condition &#123; @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; // 因为value值是个数组，所以此处有多个值 用的MultiValueMap MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName()); if (attrs != null) &#123; for (Object value : attrs.get("value")) &#123; // 多个值中，但凡只要有一个acceptsProfiles了，那就返回true~ if (context.getEnvironment().acceptsProfiles(Profiles.of((String[]) value))) &#123; return true; &#125; &#125; return false; &#125; return true; &#125;&#125; @Profile的value可以指定多个值,并且只需要有一个值符合了条件,@Profile标注的方法、类就会生效，就会被加入到容器内。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Environment抽象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git分支的创建与合并]]></title>
    <url>%2F2019%2F08%2F05%2FGit%E5%88%86%E6%94%AF%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[Git分支的创建与合并Git管理项目代码，常见流程。1.开发公司网站。 2.为了开发某个新功能新建一个分支（假如叫develop），并在该分支上进行开发。 3.接到测试组的Bug反馈，返回主分支，新建一个新的分支（bugFix），在该分支上修复Bug，然后与主分支master合并。 4.将分支切换回develop，继续开发新功能，结束后和主分支master合并。 分支的新建与切换假如公司网站项目已经开发了一段时间，并且使用Git提交了几次更新，提交历史如下图所示： 为了开发新的功能，新建分支develop并切换到该分支： 1234$ git branch develop$ git checkout developSwitched to branch 'develop' 也可以使用命令 git checkout -b 直接新建并切换： 12$ git checkout -b developSwitched to a new branch 'develop' 执行完上述命令后，仓库历史大致如下所示： Git新建了一个分支指针develop，然后将HEAD指向develop。 接下来在该分支上开心的开发新功能，比如新建了公司网站About页面，添加了内容然后提交了此次修改： 12345678$ vim About.html$ git add About.html$ git commit -a -m "add About.html page"[develop b462691] add About.html page 1 file changed, 12 insertions(+) create mode 100644 About.html 此时，仓库历史如下图所示： 这时候接到测试组公司网站主页index.html的Bug反馈，于是将分支切换回主分支master，然后新建分支bugFix，修复Bug，并提交该修复： 1234567891011$ git checkout masterSwitched to branch 'master'$ git checkout -b "bugFix"Switched to a new branch 'bugFix'$ vim index.html$ git commit -a -m "update index.html page"[bugFix 11a3074] update index.html page 1 file changed, 2 insertions(+), 2 deletions(-) 此时，仓库历史如下图所示： ` 假如确定Bug修复后，可以切换回master分支，然后将bugFix和master分支合并： 12345$ git merge bugFixUpdating e7ad858..11a3074Fast-forward index.html | 4 ++-- 1 file changed, 2 insertions(+), 2 deletions(-) 合并时出现了“Fast forward”的提示。如果顺着一个分支走下去可以到达另一个分支的话，那么Git在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。 此时bugFix分支已经完成了历史使命，可以使用命令 git branch -d 将其删除： 合并master与bugFix，并删除bugFix分支后，仓库历史如下图所示： Bug修复后，切换回develop分支继续开发新的功能，并且提交： 分支合并和合并master分支与bugFix分支那样，合并master与develop分支过程也差不多： 1234567$ git checkout masterSwitched to branch 'master'$ git merge developMerge made by the 'recursive' strategy. About.html | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) 由于master指向的C4并不是develop指向C5的直接祖先C2，所以合并方式不是“Fast forward”，Git 会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算。 合并master和develop后，仓库历史如下图所示： 解决合并冲突假如在不同分支中都对同一个文件进行了修改，那么合并的时候就会发生冲突。比如在master分支和develop分支上都修改了About.html页面，然后进行分支合并： 1234$ git merge developAuto-merging About.htmlCONFLICT (content): Merge conflict in About.htmlAutomatic merge failed; fix conflicts and then commit the result. Git作了合并，但没有提交，它会停下来等你解决冲突。 可是使用命令 git status 查看哪些文件存在冲突： 123456789101112$ git statusOn branch masterYou have unmerged paths. (fix conflicts and run "git commit") (use "git merge --abort" to abort the merge)Unmerged paths: (use "git add &lt;file&gt;..." to mark resolution) both modified: About.htmlno changes added to commit (use "git add" and/or "git commit -a") 任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出。编辑About.html页面，可看到文件包含类似下面部分的内容： 123456&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD &lt;footer&gt;2016~2017 All Rights Reserved&lt;/footer&gt;======= &lt;footer&gt;&amp;copy;2016~2017&lt;/footer&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; develop 可以看到 ======= 隔开的上半部分，是HEAD（即 master 分支，在运行merge命令时所切换到的分支）中的内容，下半部分是在develop分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。 1&lt;footer&gt;&amp;copy; 2016~2017 All Rights Reserved&lt;/footer&gt; 转载:http://mrbird.cc/Git分支的创建与合并.html]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[@Component注解派生性原理]]></title>
    <url>%2F2019%2F08%2F04%2FComponent%E6%B3%A8%E8%A7%A3%E6%B4%BE%E7%94%9F%E6%80%A7%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[@Component注解的派生性原理1:模式注解Stereotype Annotation俗称为模式注解。Spring核心部分提供了几种内建的模式注解,如@Component,@Repository,@Service,@Controller,@Configuration等。这些注解均派生于@Component。 由于Java语言规定,Annotation不允许继承,没有类派生子类的特性,因此Spring采用元标注的方式实现注解之间的派生。 2:@Component派生性@Component注解作为Spring容器托管的通用模式组件,任何被@Component标注的组件均为组件扫描的候选对象。 任何论证过程离不开所处的环境,需要开发人员具备一定工程意识,包括软件版本,特性范围,兼容情况等。因此,论证过程从最低版本开始推导,逐步证明不同版本得提升和差异。 3:@Component注解派生性原理当ClassPathBeanDefinitionScanner#doScan(String... basePackages)调用时,它利用basePackages参数迭代执行的findCandidateComponents(String basePackage),每次执行结果都生成候选的BeanDefinition集合,即candidates变量。 123456789101112131415 public class ClassPathBeanDefinitionScanner extends ClassPathScanningCandidateComponentProvider&#123; ... protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123; Assert.notEmpty(basePackages, "At least one base package must be specified"); //获取候选的BeanDefinition集合 Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(); for (String basePackage : basePackages) &#123; Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage); ... &#125; return beanDefinitions; &#125; ...&#125; 而findCandidateComponents(String basePackage)从父类ClassPathScanningCandidateComponentProvider 中继承。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100public class ClassPathScanningCandidateComponentProvider implements EnvironmentCapable, ResourceLoaderAware &#123; ... public Set&lt;BeanDefinition&gt; findCandidateComponents(String basePackage) &#123; Set&lt;BeanDefinition&gt; candidates = new LinkedHashSet&lt;BeanDefinition&gt;(); try &#123; //获取查询的package,并处理占位符情况$&#123;...&#125;,转换为ClassLoader资源(.class)搜索路径 String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + '/' + this.resourcePattern; Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath); ... //resource迭代执行,当资源可读取时,获取该资源的MetadataReader对象 for (Resource resource : resources) &#123; ... if (resource.isReadable()) &#123; try &#123; //包含了类和注解元信息读取方法 MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource); //判断资源是否为候选的组件,通过excludeFilters和includeFilters进行判断 if (isCandidateComponent(metadataReader)) &#123; //基于ASM,支持AnnotatedBeanDefinition接口 ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setResource(resource); sbd.setSource(resource); //判断BeanDefinition是否候选组件 if (isCandidateComponent(sbd)) &#123; ... candidates.add(sbd); &#125; ... &#125; &#125; ... return candidates; &#125; ... /** * Determine whether the given class does not match any exclude filter * and does match at least one include filter. * @param metadataReader the ASM ClassReader for the class * @return whether the class qualifies as a candidate component */ protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException&#123; for (TypeFilter tf : this.excludeFilters) &#123; if (tf.match(metadataReader, this.metadataReaderFactory)) &#123; return false; &#125; &#125; for (TypeFilter tf : this.includeFilters) &#123; if (tf.match(metadataReader, this.metadataReaderFactory)) &#123; return isConditionMatch(metadataReader); &#125; &#125; return false; &#125; /** * Determine whether the given bean definition qualifies as candidate. * &lt;p&gt;The default implementation checks whether the class is not an interface * and not dependent on an enclosing class. * &lt;p&gt;Can be overridden in subclasses. * @param beanDefinition the bean definition to check * @return whether the bean definition qualifies as a candidate component */ protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) &#123; AnnotationMetadata metadata = beanDefinition.getMetadata(); return (metadata.isIndependent() &amp;&amp; (metadata.isConcrete() || (metadata.isAbstract() &amp;&amp; metadata.hasAnnotatedMethods(Lookup.class.getName())))); &#125; /** * Register the default filter for &#123;@link Component @Component&#125;. * &lt;p&gt;This will implicitly register all annotations that have the * &#123;@link Component @Component&#125; meta-annotation including the * &#123;@link Repository @Repository&#125;, &#123;@link Service @Service&#125;, and * &#123;@link Controller @Controller&#125; stereotype annotations. * &lt;p&gt;Also supports Java EE 6's &#123;@link javax.annotation.ManagedBean&#125; and * JSR-330's &#123;@link javax.inject.Named&#125; annotations, if available. * */ @SuppressWarnings("unchecked") protected void registerDefaultFilters() &#123; this.includeFilters.add(new AnnotationTypeFilter(Component.class)); ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader(); try &#123; this.includeFilters.add(new AnnotationTypeFilter( ((Class&lt;? extends Annotation&gt;) ClassUtils.forName("javax.annotation.ManagedBean", cl)), false)); ... &#125; try &#123; this.includeFilters.add(new AnnotationTypeFilter( ((Class&lt;? extends Annotation&gt;) ClassUtils.forName("javax.inject.Named", cl)), false)); ... &#125; &#125;&#125; 默认情况下,ClassPathScanningCandidateComponentProvider构造参数useDefaultFilters为true,并且显示传递给父类构造参数。该方法给属性includeFilters增添了@Component类型AnnotationTypeFilter的TypeFilter。 ClassPathBeanDefinitionScanner默认过滤器引入标注@Component,@Repository,@Service或者@Controller等类。同理,它也能够标注所有@Component的&quot;派生&quot;注解。 @Component注解只包含一个value属性定义，所以其“派生”的注解也只能包含一个vlaue属性定义。 Dubbo实现@Service注解扫描实例: ClassPathBeanDefinitionScanner允许自定义类型过滤规则。因此,Dubbo的@Service没有标注@Component情况下，通过scanner.addIncludeFilter(new AnnotationTypeFilter(Service.class))方式达到识别@Service标注类情况。但是没有使用@Component注解的派生性。 Mybatis实现@Mapper注解扫描实例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class ClassPathMapperScanner extends ClassPathBeanDefinitionScanner&#123; ... public ClassPathMapperScanner(BeanDefinitionRegistry registry) &#123; super(registry, false); &#125; /** * Configures parent scanner to search for the right interfaces. It can search * for all interfaces or just for those that extends a markerInterface or/and * those annotated with the annotationClass */ public void registerFilters() &#123; boolean acceptAllInterfaces = true; // if specified, use the given annotation and / or marker interface if (this.annotationClass != null) &#123; addIncludeFilter(new AnnotationTypeFilter(this.annotationClass)); acceptAllInterfaces = false; &#125; // override AssignableTypeFilter to ignore matches on the actual marker interface if (this.markerInterface != null) &#123; addIncludeFilter(new AssignableTypeFilter(this.markerInterface) &#123; @Override protected boolean matchClassName(String className) &#123; return false; &#125; &#125;); acceptAllInterfaces = false; &#125; if (acceptAllInterfaces) &#123; // default include filter that accepts all classes addIncludeFilter(new TypeFilter() &#123; @Override public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123; return true; &#125; &#125;); &#125; // exclude package-info.java addExcludeFilter(new TypeFilter() &#123; @Override public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123; String className = metadataReader.getClassMetadata().getClassName(); return className.endsWith("package-info"); &#125; &#125;); &#125; /** * &#123;@inheritDoc&#125; */ @Override protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) &#123; return beanDefinition.getMetadata().isInterface() &amp;&amp; beanDefinition.getMetadata().isIndependent(); &#125; private void processBeanDefinitions(Set&lt;BeanDefinitionHolder&gt; beanDefinitions) &#123; GenericBeanDefinition definition; for (BeanDefinitionHolder holder : beanDefinitions) &#123; definition = (GenericBeanDefinition) holder.getBeanDefinition(); ... //复杂对象构建考虑使用FactoryBean接口 // the mapper interface is the original class of the bean // but, the actual class of the bean is MapperFactoryBean //添加泛型参数 definition.getConstructorArgumentValues().addGenericArgumentValue(definition.getBeanClassName()); // issue #59 definition.setBeanClass(this.mapperFactoryBean.getClass()); definition.getPropertyValues().add("addToConfig", this.addToConfig); ... &#125; &#125; ...&#125; 4:思考扩展思考1:利用ClassPathBeanDefinitionScanner类配合includeFilters和excludeFilters定制化批量注册Bean到Spring容器中。常常可以通过注解方式来包含或者排除候选类。 TypeFilter常用实现 AnnotationTypeFilter:注解类型过滤器 AssignableTypeFilter:确定此对象表示的类或者接口是否为给定类或者接口相同。 RegexPatternTypeFilter:判断给定的类名是否符合指定正则表达式。 思考2:复杂对象构建考虑使用FactoryBean实现类。 思考3:如果是读取类和注解信息可以考虑基于ASM或者反射,使用方式往下可以获取。当获取已加载的类信息可以考虑反射(反射大前提是被反射的Class被ClassLoader加载),ASM用于不需要将类路径package下的Class全部加载,Spring应用指定Java package扫描Spring模式注解时,利用的就是基于ASM方式获取类或者注解信息。基于ASM获取会获得更大性能。 思考4:资源读取考虑使用ResourcePatternResolver,这个对象的获取可以通过Spring提供的工具类 ResourcePatternUtils.getResourcePatternResolver(resourceLoader)。在使用的时候,考虑处理 占位符${...}的情况,注意资源是否可读。 5:多层次@Component派生性(1):具体发展过程不再细说,详解请看SpringBoot编程思想这本书。其多层次@Component注解派生性构建在Spring4.x。其核心处理类为AnnotationMetadataReadingVisitor,其采用递归的方式查找元注解。 (2):Spring中,MetadataReader接口唯一实现非公开类SimpleMetadataReader。可以通过SimpleMetadataReaderFactory(ASM字节码操作)和CachingMetadataReaderFactory获取。 其中在SimpleMetadataReader实现上看,ClassMetadataReadingVisitor和AnnotationMetadataReadingVisitor分别是ClassMetadatta和AnnotationMetadata实现类。 由于ClassPathBeanDefinitionScanner在寻找候选的BeanDefinition过程中,将指定basePackage参数下 的*.class资源进行元信息解析,也就是ClassMetadata和AnnotationMetadata对象。 AnnotationMetadataReadingVisitor实现上使用了AnnotationAttributesReadingVisitor，该类主要实现方法是visitEnd()。Spring2.5实现未采用层次递归获取Annotation[],所以仅支持单层次的@Component派生。Spring3.x实现仅两层@Component派生。Spring4.x开始采用递归方式查找元注解。 (3):思考扩展 考虑使用ASM的方式读取类或者注解相关信息。(不需要全部将指定路径下的类加载) MetadataReaderFactory:获取MetadataReader工厂 SimpleMetadataReaderFactory:简单获取MetadataReader工厂实现 ClassReader:基于ASM读取类相关信息,公开类,不建议单独使用。 AnnotationMetadataReadingVisitor:基于ASM读取注解元数据相关信息,不建议单独使用。 MethodMetadataReadingVisitor:基于ASM读取方法相关信息,不建议单独使用。 CachingMetadataReaderFactory:继承SimpleMetadataReaderFactory,增加缓存MetadataReader资源功能。 MetadataReader:获取访问类和注解相关信息。通过MetadataReaderFactory获取。 Resource getResource():获取类文件资源引用 ClassMetadata getClassMetadata():读取基础类的基本元数据 AnnotationMetadata getAnnotationMetadata():读取底层类完整注解元数据,包含注解方法的注解元数据。 考虑使用反射的方式读取类或者注解相关信息(比较费时而且该类必须被ClassLoader加载) StandardClassMetadata:基于反射读取类元数据,可建议单独使用。 StandardAnnotationMetadata:基于反射读取注解元数据,可建议单独使用 StandardMethodMetadata:基于反射读取方法元数据,可建议单独使用 考虑使用Spring内部支持的有用工具类,都是来自于spring-core包中。多使用spring内建API,学习他们的长处。 ClassUtils:类工具类 CollectionUtils:集合工具类 NumberUtils:Number工具类 MimeTypeUtils:媒体类型工具类 IdGenerator:Id生成器 StringUtils:字符串工具类 ResourceUtils:资源工具类 ReflectionUtils:反射工具类 MethodIntrospector:方法自省工具类(EventListenerMethodProcessor#processBean中有使用) PatternMatchUtils:正则资源匹配工具类 ObjectUtils:对象工具类 3:组合注解组合注解指某个注解”元标注”一个或多个其他注解，其目的在于将这些关联的注解行为组合成单个自定义注解。 Spring Framework的类加载通过ASM实现，如ClassReader。相对于ClassLoader体系，Spring ASM更为底层，读取的是类资源，直接操作其中的字节码，获取相关元信息。如MetadataReader接口。 1234567891011121314151617181920212223242526/** * Simple facade for accessing class metadata, * as read by an ASM &#123;@link org.springframework.asm.ClassReader&#125;. * * @author Juergen Hoeller * @since 2.5 */public interface MetadataReader &#123; /** * Return the resource reference for the class file. */ Resource getResource(); /** * Read basic class metadata for the underlying class. */ ClassMetadata getClassMetadata(); /** * Read full annotation metadata for the underlying class, * including metadata for annotated methods. */ AnnotationMetadata getAnnotationMetadata();&#125; AnnotationMetadataReadingVisitor同时实现了ClassMetadata及AnnotationMetadata。因此，元注解的实现集中到AnnotationMetadataReadingVisitor和AnnotationAttributesReadingVisitor之中。 MetadataReader对象通过MetadataReaderFactory对象获取。 12345678910111213141516171819202122232425262728/** * Factory interface for &#123;@link MetadataReader&#125; instances. * Allows for caching a MetadataReader per original resource. * * @author Juergen Hoeller * @since 2.5 * @see SimpleMetadataReaderFactory * @see CachingMetadataReaderFactory */public interface MetadataReaderFactory &#123; /** * Obtain a MetadataReader for the given class name. * @param className the class name (to be resolved to a ".class" file) * @return a holder for the ClassReader instance (never &#123;@code null&#125;) * @throws IOException in case of I/O failure */ MetadataReader getMetadataReader(String className) throws IOException; /** * Obtain a MetadataReader for the given resource. * @param resource the resource (pointing to a ".class" file) * @return a holder for the ClassReader instance (never &#123;@code null&#125;) * @throws IOException in case of I/O failure */ MetadataReader getMetadataReader(Resource resource) throws IOException;&#125; 具体某个注解的元注解信息则通过getMetaAnnotationTypes(String)方法查询。 AnnotationMetadata实现AnnotationMetadataReadingVisitor(ASM实现)，StandardAnnotationMetadata(反射)。 注解元信息抽象:AnnotationMetadata AnnotationMetadataReadingVisitor AnnotationAttributesReadingVisitor(递归查找元注解) 类元信息抽象:ClassMetadata 方法元信息抽象:MethodMetadata 注解属性抽象:AnnotationAttributes 属性环境抽象:Environment 属性文件抽象:PropertySource 元信息读取抽象:MetadataReader 通过MetadataReaderFactory获取 方法内省:MethodIntrospector 1234Map&lt;Method, EventListener&gt; annotatedMethods = null; annotatedMethods = MethodIntrospector.selectMethods(targetType, (MethodIntrospector.MetadataLookup&lt;EventListener&gt;) method -&gt; AnnotatedElementUtils.findMergedAnnotation(method, EventListener.class)); 注解工具类:AnnotationUtils]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring注解属性抽象AnnotationAttributes</tag>
        <tag>模式注解</tag>
        <tag>Component注解派生性原理</tag>
      </tags>
  </entry>
</search>

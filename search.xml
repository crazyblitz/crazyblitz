<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git标签管理]]></title>
    <url>%2F2019%2F08%2F11%2FGit%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[创建标签(tag)在Git中打标签非常简单，首先，切换到需要打标签的分支上： 12345$ git branch* dev master$ git checkout masterSwitched to branch 'master' 然后，敲命令git tag &lt;name&gt;就可以打一个新标签： 1$ git tag v1.0 可以用命令git tag查看所有标签： 12$ git tagv1.0 默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？ 方法是找到历史提交的commit id，然后打上就可以了： 12345678910111213141516$ git log --pretty=oneline --abbrev-commit12a631b (HEAD -&gt; master, tag: v1.0, origin/master) merged bug fix 1014c805e2 fix bug 101e1e9c68 merge with no-fff52c633 add mergecf810e4 conflict fixed5dc6824 &amp; simple14096d0 AND simpleb17d20e branch testd46f35e remove test.txtb84166e add test.txt519219b git tracks changese43a48b understand how stage works1094adb append GPLe475afc add distributedeaadf4e wrote a readme file 比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令： 1$ git tag v0.9 f52c633 再用命令git tag查看标签： 123$ git tagv0.9v1.0 注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show &lt;tagname&gt;查看标签信息： 123456789$ git show v0.9commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:56:54 2018 +0800 add mergediff --git a/readme.txt b/readme.txt... 可以看到，v0.9确实打在add merge这次提交上。 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字： 1$ git tag -a v0.1 -m "version 0.1 released" 1094adb 用命令git show &lt;tagname&gt;可以看到说明文字： 123456789101112131415$ git show v0.1tag v0.1Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 22:48:43 2018 +0800version 0.1 releasedcommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:06:15 2018 +0800 append GPLdiff --git a/readme.txt b/readme.txt... 注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签 小结 命令git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id； 命令git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息； 命令git tag可以查看所有标签。 操作标签如果标签打错了，也可以删除： 12$ git tag -d v0.1Deleted tag 'v0.1' (was f15b0dd) 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。 如果要推送某个标签到远程，使用命令git push origin &lt;tagname&gt;： 1234$ git push origin v1.0Total 0 (delta 0), reused 0 (delta 0)To github.com:michaelliao/learngit.git * [new tag] v1.0 -&gt; v1.0 或者，一次性推送全部尚未推送到远程的本地标签： 1234$ git push origin --tagsTotal 0 (delta 0), reused 0 (delta 0)To github.com:michaelliao/learngit.git * [new tag] v0.9 -&gt; v0.9 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除： 12$ git tag -d v0.9Deleted tag 'v0.9' (was f52c633) 然后，从远程删除。删除命令也是push，但是格式如下： 123$ git push origin :refs/tags/v0.9To github.com:michaelliao/learngit.git - [deleted] v0.9 要看看是否真的从远程库删除了标签，可以登陆GitHub查看。 小结 命令git push origin &lt;tagname&gt;可以推送一个本地标签； 命令git push origin --tags可以推送全部未推送过的本地标签； 命令git tag -d &lt;tagname&gt;可以删除一个本地标签； 命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git多人协作]]></title>
    <url>%2F2019%2F08%2F11%2FGit%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。 要查看远程库的信息，用git remote： 12$ git remoteorigin 或者，用git remote -v显示更详细的信息： 123$ git remote -vorigin git@github.com:michaelliao/learngit.git (fetch)origin git@github.com:michaelliao/learngit.git (push) 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。 推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： 1$ git push origin master 如果要推送其他分支，比如dev，就改成： 1$ git push origin dev 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！ 抓取分支多人协作时，大家都会往master和dev分支上推送各自的修改。 现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆： 1234567$ git clone git@github.com:michaelliao/learngit.gitCloning into &apos;learngit&apos;...remote: Counting objects: 40, done.remote: Compressing objects: 100% (21/21), done.remote: Total 40 (delta 14), reused 40 (delta 14), pack-reused 0Receiving objects: 100% (40/40), done.Resolving deltas: 100% (14/14), done. 当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看： 12$ git branch* master 现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支： 在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支： 1$ git checkout -b dev origin/dev 现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程： 123456789101112131415$ git add env.txt$ git commit -m "add env"[dev 7a5e5dd] add env 1 file changed, 1 insertion(+) create mode 100644 env.txt$ git push origin devCounting objects: 3, done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 308 bytes | 308.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)To github.com:michaelliao/learngit.git f52c633..7a5e5dd dev -&gt; dev 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送： 123456789101112131415161718$ cat env.txtenv$ git add env.txt$ git commit -m "add new env"[dev 7bd91f1] add new env 1 file changed, 1 insertion(+) create mode 100644 env.txt$ git push origin devTo github.com:michaelliao/learngit.git ! [rejected] dev -&gt; dev (non-fast-forward)error: failed to push some refs to 'git@github.com:michaelliao/learngit.git'hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. 推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送： 12345678910$ git pullThere is no tracking information for the current branch.Please specify which branch you want to merge with.See git-pull(1) for details. git pull &lt;remote&gt; &lt;branch&gt;If you wish to set tracking information for this branch you can do so with: git branch --set-upstream-to=origin/&lt;branch&gt; dev git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接： 12$ git branch --set-upstream-to=origin/dev devBranch 'dev' set up to track remote branch 'dev' from 'origin'. 再pull： 1234$ git pullAuto-merging env.txtCONFLICT (add/add): Merge conflict in env.txtAutomatic merge failed; fix conflicts and then commit the result. 这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push： 1234567891011$ git commit -m "fix env conflict"[dev 57c53ab] fix env conflict$ git push origin devCounting objects: 6, done.Delta compression using up to 4 threads.Compressing objects: 100% (4/4), done.Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done.Total 6 (delta 0), reused 0 (delta 0)To github.com:michaelliao/learngit.git 7a5e5dd..57c53ab dev -&gt; dev 因此，多人协作的工作模式通常是这样： 首先，可以试图用git push origin &lt;branch-name&gt;推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 小结 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git中Feature分支]]></title>
    <url>%2F2019%2F08%2F11%2FGit%E4%B8%ADFeature%E5%88%86%E6%94%AF%2F</url>
    <content type="text"><![CDATA[软件开发中，总有无穷无尽的新的功能要不断添加进来。 添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。 现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。 于是准备开发： 12$ git checkout -b feature-vulcanSwitched to a new branch 'feature-vulcan' 5分钟后，开发完毕： 12345678910111213$ git add vulcan.py$ git statusOn branch feature-vulcanChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: vulcan.py$ git commit -m &quot;add feature vulcan&quot;[feature-vulcan 287773e] add feature vulcan 1 file changed, 2 insertions(+) create mode 100644 vulcan.py 切回dev，准备合并： 1$ git checkout dev 一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。 但是！就在此时，接到上级命令，因经费不足，新功能必须取消！虽然白干了，但是这个包含机密资料的分支还是必须就地销毁： 123$ git branch -d feature-vulcanerror: The branch 'feature-vulcan' is not fully merged.If you are sure you want to delete it, run 'git branch -D feature-vulcan'. 销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数。。 现在我们强行删除： 12$ git branch -D feature-vulcanDeleted branch feature-vulcan (was 287773e). 终于删除成功！ 小结开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git中bug分支]]></title>
    <url>%2F2019%2F08%2F11%2FGit%E4%B8%ADbug%E5%88%86%E6%94%AF%2F</url>
    <content type="text"><![CDATA[Bug分支软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。 当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交： 123456789101112$ git statusOn branch devChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) new file: hello.pyChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: readme.txt 并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？ 幸好，Git还提供了一个stash功能(该命令需要文件被加入缓存区，即add过后)，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作： 123456## 先add文件$ git add filename$ git stash## 记录工作目录和索引的当前状态,但是想要返回到干净目录,保存了本地修改,并恢复工作目录## 以匹配HEAD提交Saved working directory and index state WIP on dev: f52c633 add merge 命令介绍 1234567891011121314### 查看储藏修改git stash list [&lt;options&gt;]### 储藏的列表进行检查git stash show [&lt;stash&gt;]### 重新应用储藏git stash ( pop | apply ) [--index] [-q|--quiet] [&lt;stash&gt;]git stash branch &lt;branchname&gt; [&lt;stash&gt;]### git stash相当于git stash save,默认情况下,储藏列表为"分支名称的WIP"### stash@&#123;0&#125;是最近创建的垃圾邮件,stash@&#123;1&#125;依次内推git stash save [-p|--patch] [-k|--[no-]keep-index] [-q|--quiet] [-u|--include-untracked] [-a|--all] [&lt;message&gt;]git stash [push [-p|--patch] [-k|--[no-]keep-index] [-q|--quiet] [-u|--include-untracked] [-a|--all] [-m|--message &lt;message&gt;]] [--] [&lt;pathspec&gt;…​]] 现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。 首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支： 1234567$ git checkout masterSwitched to branch 'master'Your branch is ahead of 'origin/master' by 6 commits. (use "git push" to publish your local commits)$ git checkout -b issue-101Switched to a new branch 'issue-101' 现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交： 1234$ git add readme.txt $ git commit -m "fix bug 101"[issue-101 4c805e2] fix bug 101 1 file changed, 1 insertion(+), 1 deletion(-) 修复完成后，切换到master分支，并完成合并，最后删除issue-101分支： 123456789$ git checkout masterSwitched to branch 'master'Your branch is ahead of 'origin/master' by 6 commits. (use "git push" to publish your local commits)$ git merge --no-ff -m "merged bug fix 101" issue-101Merge made by the 'recursive' strategy. readme.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) 太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！ 123456$ git checkout devSwitched to branch 'dev'$ git statusOn branch devnothing to commit, working tree clean 工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看： 12$ git stash liststash@&#123;0&#125;: WIP on dev: f52c633 add merge 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法： 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了： 1234567891011121314$ git stash popOn branch devChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) new file: hello.pyChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: readme.txtDropped refs/stash@&#123;0&#125; (5d677e2ee266f39ea296182fb2354265b91b3b2a) 再用git stash list查看，就看不到任何stash内容了： 1$ git stash list 你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令： 1$ git stash apply stash@&#123;0&#125; 小结修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多人协作]]></title>
    <url>%2F2019%2F08%2F11%2F%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Git rebase命令实战]]></title>
    <url>%2F2019%2F08%2F10%2FGit-rebase%E5%91%BD%E4%BB%A4%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。 每次合并再push后，分支变成了这样： 12345678910111213141516171819$ git log --graph --pretty=oneline --abbrev-commit* d1be385 (HEAD -&gt; master, origin/master) init hello* e5e69f1 Merge branch 'dev'|\ | * 57c53ab (origin/dev, dev) fix env conflict| |\ | | * 7a5e5dd add env| * | 7bd91f1 add new env| |/ * | 12a631b merged bug fix 101|\ \ | * | 4c805e2 fix bug 101|/ / * | e1e9c68 merge with no-ff|\ \ | |/ | * f52c633 add merge|/ * cf810e4 conflict fixed 总之看上去很乱，有强迫症的童鞋会问：为什么Git的提交历史不能是一条干净的直线？ 其实是可以做到的！ Git有一种称为rebase的操作，有人把它翻译成“变基”。 先不要随意展开想象。我们还是从实际问题出发，看看怎么把分叉的提交变成直线。 在和远程分支同步后，我们对hello.py这个文件做了两次提交。用git log命令看看： 1234567891011$ git log --graph --pretty=oneline --abbrev-commit* 582d922 (HEAD -&gt; master) add author* 8875536 add comment* d1be385 (origin/master) init hello* e5e69f1 Merge branch 'dev'|\ | * 57c53ab (origin/dev, dev) fix env conflict| |\ | | * 7a5e5dd add env| * | 7bd91f1 add new env... 注意到Git用(HEAD -&gt; master)和(origin/master)标识出当前分支的HEAD和远程origin的位置分别是582d922 add author和d1be385 init hello，本地分支比远程分支快两个提交。 现在我们尝试推送本地分支： 123456789$ git push origin masterTo github.com:michaelliao/learngit.git ! [rejected] master -&gt; master (fetch first)error: failed to push some refs to 'git@github.com:michaelliao/learngit.git'hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. 很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下： 123456789101112$ git pullremote: Counting objects: 3, done.remote: Compressing objects: 100% (1/1), done.remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0Unpacking objects: 100% (3/3), done.From github.com:michaelliao/learngit d1be385..f005ed4 master -&gt; origin/master * [new tag] v1.0 -&gt; v1.0Auto-merging hello.pyMerge made by the 'recursive' strategy. hello.py | 1 + 1 file changed, 1 insertion(+) 再用git status看看状态： 123456$ git statusOn branch masterYour branch is ahead of 'origin/master' by 3 commits. (use "git push" to publish your local commits)nothing to commit, working tree clean 加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。 用git log看看： 123456789$ git log --graph --pretty=oneline --abbrev-commit* e0ea545 (HEAD -&gt; master) Merge branch &apos;master&apos; of github.com:michaelliao/learngit|\ | * f005ed4 (origin/master) set exit=1* | 582d922 add author* | 8875536 add comment|/ * d1be385 init hello... 对强迫症童鞋来说，现在事情有点不对头，提交历史分叉了。如果现在把本地分支push到远程，有没有问题？不好看。 这个时候，rebase就派上了用场。我们输入命令git rebase试试： 123456789101112$ git rebaseFirst, rewinding head to replay your work on top of it...Applying: add commentUsing index info to reconstruct a base tree...M hello.pyFalling back to patching base and 3-way merge...Auto-merging hello.pyApplying: add authorUsing index info to reconstruct a base tree...M hello.pyFalling back to patching base and 3-way merge...Auto-merging hello.py 输出了一大堆操作，到底是啥效果？再用git log看看： 123456$ git log --graph --pretty=oneline --abbrev-commit* 7e61ed4 (HEAD -&gt; master) add author* 3611cfe add comment* f005ed4 (origin/master) set exit=1* d1be385 init hello... 原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了f005ed4 (origin/master) set exit=1之后，这样，整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的，但是，我们本地的commit修改内容已经变化了，它们的修改不再基于d1be385 init hello，而是基于f005ed4 (origin/master) set exit=1，但最后的提交7e61ed4内容是一致的。 这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。 最后，通过push操作把本地分支推送到远程： 123456789Mac:~/learngit michael$ git push origin masterCounting objects: 6, done.Delta compression using up to 4 threads.Compressing objects: 100% (5/5), done.Writing objects: 100% (6/6), 576 bytes | 576.00 KiB/s, done.Total 6 (delta 2), reused 0 (delta 0)remote: Resolving deltas: 100% (2/2), completed with 1 local object.To github.com:michaelliao/learngit.git f005ed4..7e61ed4 master -&gt; master 再用git log看看效果： 123456$ git log --graph --pretty=oneline --abbrev-commit* 7e61ed4 (HEAD -&gt; master, origin/master) add author* 3611cfe add comment* f005ed4 set exit=1* d1be385 init hello... 远程分支的提交历史也是一条直线。 小结 rebase操作可以把本地未push的分叉提交历史整理成直线； rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git命令总结]]></title>
    <url>%2F2019%2F08%2F10%2FGit%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Git命令文档]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git差异和冲突解决]]></title>
    <url>%2F2019%2F08%2F10%2FGit%E5%B7%AE%E5%BC%82%E5%92%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[Git差异和冲突解决Git冲突解决人生不如意之事十之八九，合并分支往往也不是一帆风顺的。 准备新的feature1分支，继续我们的新分支开发： 12$ git checkout -b feature1Switched to a new branch 'feature1' 修改readme.txt最后一行，改为： 1Creating a new branch is quick AND simple. 在feature1分支上提交： 12345$ git add readme.txt$ git commit -m "AND simple"[feature1 14096d0] AND simple 1 file changed, 1 insertion(+), 1 deletion(-) 切换到master分支： 1234$ git checkout masterSwitched to branch 'master'Your branch is ahead of 'origin/master' by 1 commit. (use "git push" to publish your local commits) Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。 在master分支上把readme.txt文件的最后一行改为： 1Creating a new branch is quick &amp; simple. 提交： 1234$ git add readme.txt $ git commit -m "&amp; simple"[master 5dc6824] &amp; simple 1 file changed, 1 insertion(+), 1 deletion(-) 现在，master分支和feature1分支各自都分别有新的提交，变成了这样： 这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看： 1234$ git merge feature1Auto-merging readme.txtCONFLICT (content): Merge conflict in readme.txtAutomatic merge failed; fix conflicts and then commit the result. 果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件： 123456789101112131415$ git statusOn branch masterYour branch is ahead of 'origin/master' by 2 commits. (use "git push" to publish your local commits)You have unmerged paths. (fix conflicts and run "git commit") (use "git merge --abort" to abort the merge)Unmerged paths: (use "git add &lt;file&gt;..." to mark resolution) both modified: readme.txtno changes added to commit (use "git add" and/or "git commit -a") 我们可以直接查看readme.txt的内容： 123456789Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存： 1Creating a new branch is quick and simple. 再提交： 123$ git add readme.txt $ git commit -m "conflict fixed"[master cf810e4] conflict fixed 现在，master分支和feature1分支变成了下图所示： 用带参数的git log也可以看到分支的合并情况： 1234567891011121314$ git log --graph --pretty=oneline --abbrev-commit* cf810e4 (HEAD -&gt; master) conflict fixed|\ | * 14096d0 (feature1) AND simple* | 5dc6824 &amp; simple|/ * b17d20e branch test* d46f35e (origin/master) remove test.txt* b84166e add test.txt* 519219b git tracks changes* e43a48b understand how stage works* 1094adb append GPL* e475afc add distributed* eaadf4e wrote a readme file 最后，删除feature1分支： 12$ git branch -d feature1Deleted branch feature1 (was 14096d0) Git差异比较工作目录 vs 暂存区1$ git diff &lt;filename&gt; 意义：查看文件在工作目录与暂存区的差别。如果还没 add 进暂存区，则查看文件自身修改前后的差别。也可查看和另一分支的区别。 1$ git diff &lt;branch&gt; &lt;filename&gt; 暂存区 vs Git仓库(–cached :代表进暂存区,即add过后)1git diff --cached &lt;filename&gt; 意义：表示查看已经 add 进暂存区但是尚未 commit 的内容同最新一次 commit 时的内容的差异。 也可以指定仓库版本： 1git diff --cached &lt;commit&gt; &lt;filename&gt; 工作目录 vs Git仓库1git diff &lt;commit&gt; &lt;filename&gt; 意义：查看工作目录同Git仓库指定 commit 的内容的差异。 &lt;commit&gt;=HEAD 时：查看工作目录同最近一次 commit 的内容的差异。 Git仓库 vs Git仓库1git diff &lt;commit&gt; &lt;commit&gt; 意义：Git仓库任意两次 commit 之间的差别。 扩展以上命令可以不指定 &lt;filename&gt;，则对全部文件操作。 以上命令涉及和 Git仓库 对比的，均可指定 commit 的版本。 HEAD 最近一次 commit HEAD^ 上次提交 HEAD~100 上100次提交 每次提交产生的哈希值]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis Dynamic SQL]]></title>
    <url>%2F2019%2F08%2F07%2FMybatis-Dynamic-SQL%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[钉钉消息推送开发总结]]></title>
    <url>%2F2019%2F08%2F07%2F%E9%92%89%E9%92%89%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot中的JSON技术]]></title>
    <url>%2F2019%2F08%2F07%2FSpring-Boot%E4%B8%AD%E7%9A%84JSON%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[平日里在项目中处理JSON一般用的都是阿里巴巴的Fastjson，后来发现使用Spring Boot内置的Jackson来完成JSON的序列化和反序列化操作也挺方便。Jackson不但可以完成简单的序列化和反序列化操作，也能实现复杂的个性化的序列化和反序列化操作。 自定义ObjectMapper我们都知道，在Spring中使用@ResponseBody注解可以将方法返回的对象序列化成JSON，比如： 12345678@RequestMapping("getuser")@ResponseBodypublic User getUser() &#123; User user = new User(); user.setUserName("mrbird"); user.setBirthday(new Date()); return user;&#125; User类： 123456789public class User implements Serializable &#123; private static final long serialVersionUID = 6222176558369919436L; private String userName; private int age; private String password; private Date birthday; ...&#125; 访问getuser页面输出： 1&#123;"userName":"mrbird","age":0,"password":null,"birthday":1522634892365&#125; 可看到时间默认以时间戳的形式输出，如果想要改变这个默认行为，我们可以自定义一个ObjectMapper来替代： 12345678910111213141516import java.text.SimpleDateFormat;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.fasterxml.jackson.databind.ObjectMapper;@Configurationpublic class JacksonConfig &#123; @Bean public ObjectMapper getObjectMapper()&#123; ObjectMapper mapper = new ObjectMapper(); mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss")); return mapper; &#125;&#125; 上面配置获取了ObjectMapper对象，并且设置了时间格式。再次访问getuser，页面输出： 1&#123;&quot;userName&quot;:&quot;mrbird&quot;,&quot;age&quot;:0,&quot;password&quot;:null,&quot;birthday&quot;:&quot;2018-04-02 10:14:24&quot;&#125; 序列化Jackson通过使用mapper的writeValueAsString方法将Java对象序列化为JSON格式字符串： 1234567891011121314151617@AutowiredObjectMapper mapper;@RequestMapping("serialization")@ResponseBodypublic String serialization() &#123; try &#123; User user = new User(); user.setUserName("mrbird"); user.setBirthday(new Date()); String str = mapper.writeValueAsString(user); return str; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125; 反序列化使用@ResponseBody注解可以使对象序列化为JSON格式字符串，除此之外，Jackson也提供了反序列化方法。 树遍历当采用树遍历的方式时，JSON被读入到JsonNode对象中，可以像操作XML DOM那样读取JSON。比如： 1234567891011121314151617@AutowiredObjectMapper mapper;@RequestMapping("readjsonstring")@ResponseBodypublic String readJsonString() &#123; try &#123; String json = "&#123;\"name\":\"mrbird\",\"age\":26&#125;"; JsonNode node = this.mapper.readTree(json); String name = node.get("name").asText(); int age = node.get("age").asInt(); return name + " " + age; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125; readTree方法可以接受一个字符串或者字节数组、文件、InputStream等， 返回JsonNode作为根节点，你可以像操作XML DOM那样操作遍历JsonNode以获取数据。 解析多级JSON例子： 1234String json = "&#123;\"name\":\"mrbird\",\"hobby\":&#123;\"first\":\"sleep\",\"second\":\"eat\"&#125;&#125;";;JsonNode node = this.mapper.readTree(json);JsonNode hobby = node.get("hobby");String first = hobby.get("first").asText(); 绑定对象我们也可以将Java对象和JSON数据进行绑定，如下所示： 1234567891011121314151617@AutowiredObjectMapper mapper;@RequestMapping("readjsonasobject")@ResponseBodypublic String readJsonAsObject() &#123; try &#123; String json = "&#123;\"name\":\"mrbird\",\"age\":26&#125;"; User user = mapper.readValue(json, User.class); String name = user.getUserName(); int age = user.getAge(); return name + " " + age; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125; Jackson注解Jackson包含了一些实用的注解： @JsonProperty@JsonProperty，作用在属性上，用来为JSON Key指定一个别名。 1@JsonProperty("bth")private Date birthday; 再次访问getuser页面输出： 1&#123;"userName":"mrbird","age":0,"password":null,"bth":"2018-04-02 10:38:37"&#125; key birthday已经被替换为了bth。 @Jsonlgnore@Jsonlgnore，作用在属性上，用来忽略此属性。 1@JsonIgnoreprivate String password; 再次访问getuser页面输出： 1&#123;"userName":"mrbird","age":0,"bth":"2018-04-02 10:40:45"&#125; password属性已被忽略。 @JsonIgnoreProperties@JsonIgnoreProperties，忽略一组属性，作用于类上，比如JsonIgnoreProperties({ &quot;password&quot;, &quot;age&quot; })。 1234@JsonIgnoreProperties(&#123; "password", "age" &#125;)public class User implements Serializable &#123; ...&#125; 再次访问getuser页面输出： 1&#123;"userName":"mrbird","bth":"2018-04-02 10:45:34"&#125; @JsonFormat@JsonFormat，用于日期格式化，如： 12@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")private Date birthday; @JsonNaming@JsonNaming，用于指定一个命名策略，作用于类或者属性上。Jackson自带了多种命名策略，你可以实现自己的命名策略，比如输出的key 由Java命名方式转为下面线命名方法 —— userName转化为user-name。 1234@JsonNaming(PropertyNamingStrategy.LowerCaseWithUnderscoresStrategy.class)public class User implements Serializable &#123; ...&#125; 再次访问getuser页面输出： 1&#123;"user_name":"mrbird","bth":"2018-04-02 10:52:12"&#125; @JsonSerialize@JsonSerialize，指定一个实现类来自定义序列化。类必须实现JsonSerializer接口，代码如下： 123456789101112131415161718import java.io.IOException;import com.example.pojo.User;import com.fasterxml.jackson.core.JsonGenerator;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.JsonSerializer;import com.fasterxml.jackson.databind.SerializerProvider;public class UserSerializer extends JsonSerializer&lt;User&gt; &#123; @Override public void serialize(User user, JsonGenerator generator, SerializerProvider provider) throws IOException, JsonProcessingException &#123; generator.writeStartObject(); generator.writeStringField("user-name", user.getUserName()); generator.writeEndObject(); &#125;&#125; 上面的代码中我们仅仅序列化userName属性，且输出的key是user-name。 使用注解@JsonSerialize来指定User对象的序列化方式： 1234@JsonSerialize(using = UserSerializer.class)public class User implements Serializable &#123; ...&#125; 再次访问getuser页面输出： 1&#123;"user-name":"mrbird"&#125; @JsonDeserialize@JsonDeserialize，用户自定义反序列化，同@JsonSerialize ，类需要实现JsonDeserializer接口。 123456789101112131415161718192021import java.io.IOException;import com.example.pojo.User;import com.fasterxml.jackson.core.JsonParser;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.DeserializationContext;import com.fasterxml.jackson.databind.JsonDeserializer;import com.fasterxml.jackson.databind.JsonNode;public class UserDeserializer extends JsonDeserializer&lt;User&gt; &#123; @Override public User deserialize(JsonParser parser, DeserializationContext context) throws IOException, JsonProcessingException &#123; JsonNode node = parser.getCodec().readTree(parser); String userName = node.get("user-name").asText(); User user = new User(); user.setUserName(userName); return user; &#125;&#125; 使用注解@JsonDeserialize来指定User对象的序列化方式： 1234@JsonDeserialize (using = UserDeserializer.class)public class User implements Serializable &#123; ...&#125; 测试： 12345678910111213141516@AutowiredObjectMapper mapper;@RequestMapping("readjsonasobject")@ResponseBodypublic String readJsonAsObject() &#123; try &#123; String json = "&#123;\"user-name\":\"mrbird\"&#125;"; User user = mapper.readValue(json, User.class); String name = user.getUserName(); return name; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125; 访问readjsonasobject，页面输出： 1mrbird @JsonView@JsonView，作用在类或者属性上，用来定义一个序列化组。 比如对于User对象，某些情况下只返回userName属性就行，而某些情况下需要返回全部属性。 因此User对象可以定义成如下： 12345678910111213141516171819public class User implements Serializable &#123; private static final long serialVersionUID = 6222176558369919436L; public interface UserNameView &#123;&#125;; public interface AllUserFieldView extends UserNameView &#123;&#125;; @JsonView(UserNameView.class) private String userName; @JsonView(AllUserFieldView.class) private int age; @JsonView(AllUserFieldView.class) private String password; @JsonView(AllUserFieldView.class) private Date birthday; ... &#125; User定义了两个接口类，一个为userNameView，另外一个为AllUserFieldView继承了userNameView接口。这两个接口代表了两个序列化组的名称。属性userName使用了@JsonView(UserNameView.class)，而剩下属性使用了@JsonView(AllUserFieldView.class)。 Spring中Controller方法允许使用@JsonView指定一个组名，被序列化的对象只有在这个组的属性才会被序列化，代码如下： 1234567891011@JsonView(User.UserNameView.class)@RequestMapping("getuser")@ResponseBodypublic User getUser() &#123; User user = new User(); user.setUserName("mrbird"); user.setAge(26); user.setPassword("123456"); user.setBirthday(new Date()); return user;&#125; 访问getuser页面输出： 1&#123;"userName":"mrbird"&#125; 如果将@JsonView(User.UserNameView.class)替换为@JsonView(User.AllUserFieldView.class)，输出： 1&#123;"userName":"mrbird","age":26,"password":"123456","birthday":"2018-04-02 11:24:00"&#125; 因为接口AllUserFieldView继承了接口UserNameView所以userName也会被输出。 集合的反序列化在Controller方法中，可以使用＠RequestBody将提交的JSON自动映射到方法参数上，比如： 12345@RequestMapping("updateuser")@ResponseBodypublic int updateUser(@RequestBody List&lt;User&gt; list)&#123; return list.size();&#125; 上面方法可以接受如下一个JSON请求，并自动映射到User对象上： 1[&#123;"userName":"mrbird","age":26&#125;,&#123;"userName":"scott","age":27&#125;] Spring Boot 能自动识别出List对象包含的是User类，因为在方法中定义的泛型的类型会被保留在字节码中，所以Spring Boot能识别List包含的泛型类型从而能正确反序列化。 有些情况下，集合对象并没有包含泛型定义，如下代码所示，反序列化并不能得到期望的结果。 1234567891011121314@AutowiredObjectMapper mapper;@RequestMapping("customize")@ResponseBodypublic String customize() throws JsonParseException, JsonMappingException, IOException &#123; String jsonStr = "[&#123;\"userName\":\"mrbird\",\"age\":26&#125;,&#123;\"userName\":\"scott\",\"age\":27&#125;]"; List&lt;User&gt; list = mapper.readValue(jsonStr, List.class); String msg = ""; for (User user : list) &#123; msg += user.getUserName(); &#125; return msg;&#125; 访问customize，控制台抛出异常： 1java.lang.ClassCastException: java.util.LinkedHashMap cannot be cast to com.example.pojo.User 这是因为在运行时刻，泛型己经被擦除了（不同于方法参数定义的泛型，不会被擦除）。为了提供泛型信息，Jackson提供了JavaType ，用来指明集合类型，将上述方法改为： 123456789101112131415@AutowiredObjectMapper mapper;@RequestMapping("customize")@ResponseBodypublic String customize() throws JsonParseException, JsonMappingException, IOException &#123; String jsonStr = "[&#123;\"userName\":\"mrbird\",\"age\":26&#125;,&#123;\"userName\":\"scott\",\"age\":27&#125;]"; JavaType type = mapper.getTypeFactory().constructParametricType(List.class, User.class); List&lt;User&gt; list = mapper.readValue(jsonStr, type); String msg = ""; for (User user : list) &#123; msg += user.getUserName(); &#125; return msg;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Jackson</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git分支管理]]></title>
    <url>%2F2019%2F08%2F07%2FGit%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Git分支管理git branch 命令不仅仅能创建和删除分支，如果不加任何参数，它会给出当前所有的分支清单。 1234$ git branch develop* master test 带 * 表示当前所在分支。使用命令 git branch -v 可以查看各个分支最后一个提交对象的信息： 1234$ git branch -v develop ef993bc update About.html* master 0986092 [ahead 26] update index.html test 19fffc0 add test file 使用命令 git branch –merged 可以查看哪些分支与当前分支进行了合并操作： 123$ git branch --merged develop* master 与之相反的命令为 git branch –no-merged： 12$ git branch --no-merged test test分支中还包含着尚未合并进来的工作成果，所以简单地用git branch -d删除该分支会提示错误，因为那样做会丢失数据： 123$ git branch -d testerror: The branch 'test' is not fully merged.If you are sure you want to delete it, run 'git branch -D test'. Git提示可以用大写的删除选项 -D 强制执行。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git版本回退]]></title>
    <url>%2F2019%2F08%2F07%2FGit%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80%2F</url>
    <content type="text"><![CDATA[Git版本回退Git中，每次commit提交都会生成一个历史纪录。使用 git log 查看commit历史： 12345678910$ git log --oneline ec88247 modifyed bar.html,foo.txt add new.txt47384c8 modify bar.html in clone again31e1f6f modify foo.txt in original again8747b24 Merge branch 'master' of /home/mrbird/projects/first-project27b76ec modify foo.txt in original796e40d modify bar.html in clone8e1b132 modify foo.txt,add 'hello msg'94418b1 add bar.html,modify foo.txt,delete bar.txtc2e4810 add foo.txt bar.txt 每个记录都有一个与之对应的commit id，所以可以使用命令 git reset –hard commit-id 来回退到相应的版本。除此之卡，在Git中，使用HEAD来代表当前版本，如需回退到前一个版本，可以使用命令git reset --hard HEAD^，前两个版本则用HEAD~2表示，以此类推。 当前版本id为ec88247…比如，现要回退到commit_id为47384c8…的版本，可以使用如下命令： 12$ git reset --hard 47384c8HEAD is now at 47384c8again modify bar.html in clone 或者 12$ git reset --hard HEAD~1HEAD is now at 47384c8 modify bar.html in clone again 再次查看commit历史 123456789$ git log --oneline 47384c8 modify bar.html in clone again31e1f6f modify foo.txt in original again8747b24 Merge branch 'master' of /home/mrbird/projects/first-project27b76ec modify foo.txt in original796e40d modify bar.html in clone8e1b132 modify foo.txt,add 'hello msg'94418b1 add bar.html,modify foo.txt,delete bar.txtc2e4810 add foo.txt bar.txt 可发现，commit_id为ec88247…的记录已经不见了，如果要回退到这个版本，又忘记了与之对应的commit_id该怎么办呢。这时候可以使用 git reflog 命令来查看操作历史： 1234$ git reflog47384c8 HEAD@&#123;0&#125;: reset: moving to 47384c8ec88247 HEAD@&#123;1&#125;: reset: moving to ec88247... 可看到，回退到commit_id为47384c8…的上一个版本的commit_id为ec88247…，所以，使用如下命令即可回到一开始回退前的版本： 12$ git reset --hard ec88247HEAD is now at ec88247 modifyed bar.html,foo.txt add new.txt Git回退的三种类型: git reset git reset –mixed HEAD~1:回退一个版本,且会将暂存区的内容和本地已提交的内容全部恢复到未暂存的状态,不影响原来本地文件(未提交的也不受影响)。 git reset –soft HEAD~1：回退一个版本,不清空暂存区,将已提交的内容恢复到暂存区,不影响原来本地的文件(未提交的也不受影响) git reset –hard HEAD~1：回退一个版本,清空暂存区,将已提交的内容的版本恢复到本地,本地的文件也将被恢复的版本替换。注意,这种方式是改变本地代码仓库源码。 Git版本回退：reset和revert的区别和使用场景(1):未使用git add缓存代码git checkout – filepathname 进行放弃文件修改。 git checkout . 放弃所有的文件修改。 该命令不会删除掉刚新建的文件。 (2):没有push(本地分支版本回退)这种情况发生在你的本地代码仓库,可能你add ,commit 以后发现代码有点问题,准备取消提交,用到下面命令。 12345//找到需要回退的版本commit idgit reflog// 回退版本git reset [--soft | --mixed | --hardgit reset HEAD &lt;file&gt; (3):已经push(公共远程分支版本)对于已经把代码push到线上仓库,你回退本地代码其实也想同时回退线上代码,回滚到某个指定的版本,线上,线下代码保持一致。你要用到下面的命令。 123git revert HEAD //撤销最近一次提交git revert HEAD~1 //撤销上上次的提交,注意: 数字从0开始。git revert commit_id //撤销commit_id这次提交 git revert用于反转提交,执行evert命令时要求工作树必须是干净的. git revert用一个新提交来消除一个历史提交所做的任何修改. revert 之后你的本地代码会回滚到指定的历史版本,这时你再 git push 既可以把线上的代码更新.(这里不会像reset造成冲突的问题)。 revert 使用,需要先找到你想回滚版本唯一的commit标识代码,可以用 git log 或者在adgit搭建的web环境历史提交记录里查看。通常是前几位即可。 特别注意:不要使用下面方式来回滚公共远程分支版本(使用reset+push -f命令)。因为同事的本地分支并没有主动回退。(如果是一个人开发的，可以这样做) 1234//找到回退的版本git refloggit reset --hard HEAD~1(commit_id)git push -f revert是撤销一次提交,所以后面的commit id是你需要回滚到的版本的前一次提交。 使用revert HEAD是撤销最近的一次提交，如果你最近一次提交是用revert命令产生的，那么你再执行一次，就相当于撤销了上次的撤销操作，换句话说，你连续执行两次revert HEAD命令，就跟没执行是一样的。 使用revert HEAD~1 表示撤销最近2次提交，这个数字是从0开始的，如果你之前撤销过产生了commi id，那么也会计算在内的。 如果使用 revert 撤销的不是最近一次提交，那么一定会有代码冲突，需要你合并代码，合并代码只需要把当前的代码全部去掉，保留之前版本的代码就可以了。 (4):区别git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit git reset只是在本地仓库中回退版本，而远程仓库版本不会变化。这样，即使本地reset,但是如果在git pull， 那么远程仓库内容又会和本地之前版本内容进行merge。 上面我们说的如果你已经push到线上代码库, reset 删除指定commit以后,你git push可能导致一大堆冲突。但是revert 并不会。 如果在日后现有分支和历史分支需要合并的时候,reset 恢复部分的代码依然会出现在历史分支里。但是revert 方向提交的commit 并不会出现在历史分支里。 reset 是在正常的commit历史中,删除了指定的commit,这时 HEAD 是向后移动了,而 revert 是在正常的commit历史中再commit一次,只不过是反向提交,他的 HEAD 是一直向前的。 (4):实例下面来看一个revert的使用例子 创建A.txt 内容为AAAA。然后添加到git 123git add .git commit -m "A.txt"12 修改A.txt 添加内容”BBBB”。然后添加到git 123git add .git commit -m "A.txt add BBBB"12 此时A.txt文件内容如下 123AAAABBBB12 此时的提交记录： 1234567891011121314git log ---commit 329515ee5d367bda3effa3e8f0c958e98e93ce31Author: *****Date: Tue Mar 6 19:25:39 2018 +0800 A.txt add BBBBcommit fe0d9b1d7ed0176f542a52835b1923584a4ba060Author: *****Date: Tue Mar 6 19:24:34 2018 +0800 A.txt12345678910111213 现在我要撤回内容BBBB，如下 12git revert 3295151 现在A.txt里的文件内容变为： 12AAAA1 再次查看提交记录： 12345678910111213141516171819202122git log---commit 23880e1f7649b7dca14cfda7553b2ff2e6088d6eAuthor: *****Date: Tue Mar 6 19:29:35 2018 +0800 Revert "A.txt add BBBB" This reverts commit 329515ee5d367bda3effa3e8f0c958e98e93ce31.commit 329515ee5d367bda3effa3e8f0c958e98e93ce31Author: *****Date: Tue Mar 6 19:25:39 2018 +0800 A.txt add BBBBcommit fe0d9b1d7ed0176f542a52835b1923584a4ba060Author: *****Date: Tue Mar 6 19:24:34 2018 +0800 A.txt123456789101112131415161718192021 可以看到我们撤回了提交的内容同时增加了一条commit记录。 如果撤回到之前版本出现冲突怎么办？我们先回到329515版本 12git reset --hard 3295151 恢复后在往里面添加内容“CCCC”并提交。此时A.txt文件内容为： 1234AAAABBBBCCCC123 此时的提交记录： 1234567891011121314151617181920git log ---commit f1258438d3b63e78bb747c510f9af3e56be5b3b0Author: *****Date: Tue Mar 6 19:39:20 2018 +0800 A.txt add CCCCcommit 329515ee5d367bda3effa3e8f0c958e98e93ce31Author: *****Date: Tue Mar 6 19:25:39 2018 +0800 A.txt add BBBBcommit fe0d9b1d7ed0176f542a52835b1923584a4ba060Author: *****Date: Tue Mar 6 19:24:34 2018 +0800 A.txt12345678910111213141516171819 然后我们撤回329515的修改 12git revert 3295151 这个时候git提示你有冲突要解决。我们打开A.txt保留parent … 329515这个版本的内容(git add A.txt)，即”AAAA”。并执行以下命令 12git revert --continue1 这个时候git会继续撤回，如果发现冲突会继续提示。此时的提交日志为 1234567891011121314151617181920212223242526commit 78979e45add34a0f009263e49cc1c6c48a0f93d4Author: *****Date: Tue Mar 6 19:46:40 2018 +0800 Revert "A.txt add BBBB" This reverts commit 329515ee5d367bda3effa3e8f0c958e98e93ce31.commit f1258438d3b63e78bb747c510f9af3e56be5b3b0Author: *****Date: Tue Mar 6 19:39:20 2018 +0800 A.txt add CCCCcommit 329515ee5d367bda3effa3e8f0c958e98e93ce31Author: *****Date: Tue Mar 6 19:25:39 2018 +0800 A.txt add BBBBcommit fe0d9b1d7ed0176f542a52835b1923584a4ba060Author: *****Date: Tue Mar 6 19:24:34 2018 +0800 A.txt12345678910111213141516171819202122232425 如果不想解决冲突的话可以取消撤回：git revert --abort。 (5):revert合并代码,解决冲突使用revert命令，如果不是撤销的最近一次提交，那么一定会有冲突，如下所示： 123456&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD全部清空第一次提交=======全部清空&gt;&gt;&gt;&gt;&gt;&gt;&gt; parent of c24cde7... 全部清空 解决冲突很简单，因为我们只想回到某次提交，因此需要把当前最新的代码去掉即可，也就是HEAD标记的代码： 1234&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD全部清空第一次提交======= 把上面部分代码去掉就可以了，然后再提交一次代码就可以解决冲突了。 (6):继续扩展,简单扩展的回滚方法看到这里也许你已经觉得学会了远程仓库版本回滚方法了，但是实践中总是会遇到很多不按套路来的问题，考虑下面一种情况： 如果你们开发中，忽然发现前面很远的地方有一次错误的合并代码，把本来下一次才能发的功能的代码合并到了这一次来了，这个时候全体成员都觉得直接回滚比较快，因为他们都有备份，覆盖了无所谓，这个时候用reset的话对队友的要求比较高，用revert的话呢要大面积的解决冲突，也很麻烦呀，怎么办呢？ 这个时候，可以使用简单粗暴的办法，直接从那个错误的提交的前一次拉取一份代码放到其他目录，然后将master代码全部删除，把那份新代码方进去，然后提交，果然简单粗暴啊，虽然这种方法不入流，但是，实践中发现很好使啊，所以，实践是检验真理的唯一标准。遇到问题还是要灵活应对。 (7): 撤销文件三种情况场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git状态跟踪]]></title>
    <url>%2F2019%2F08%2F07%2FGit%E7%8A%B6%E6%80%81%E8%B7%9F%E8%B8%AA%2F</url>
    <content type="text"><![CDATA[Git状态跟踪对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。 1.已提交：表示该文件已经被安全地保存在版本库中了。 2.已修改：表示修改了某个文件，但还没有提交到暂存区。 3.已暂存：表示把已修改的文件已经放到暂存区了，下次提交时一并被保存到版本库中。 检查当前文件状态要确定哪些文件当前处于什么状态，可以用 git status 命令。 1234$ git statusOn branch masterYour branch is up-to-date with &apos;origin/master&apos;.nothing to commit, working tree clean 说明现在的工作目录相当干净，并且当前所在分支为master。 在当前目录下创建一个README文件，然后运行 git status 会看到该文件出现在未跟踪文件列表中： 123456789$ git statusOn branch masterYour branch is up-to-date with &apos;origin/master&apos;.Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) READMEnothing added to commit but untracked files present (use &quot;git add&quot; to track) 未跟踪的文件意味着Git在之前的快照（提交）中没有这些文件。 跟踪新文件使用命令 git add 开始跟踪文件README： 1git add README 再运行 git status 命令，会看到 README 文件已被跟踪，并处于暂存状态： 1234567$ git statusOn branch masterYour branch is up-to-date with &apos;origin/master&apos;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: README 只要在 “Changes to be committed” 这行下面的，就说明是已暂存状态。git add 后面可以指明要跟踪的文件或目录路径。如果是目录的话，就说明要递归跟踪该目录下的所有文件。 暂存已修改的文件修改已跟踪过的文件 README，然后再次运行 git status 命令： 12345678910111213$ git statusOn branch masterYour branch is up-to-date with &apos;origin/master&apos;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: READMEChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: README README文件出现了两次，一次是未暂存，一次是一暂存。如果现在提交的话，那么提交的将是已暂存的README，对README的修改并不会被提交。 重新运行 git add 把最新版本README重新暂存起来： 12345678$ git add README$ git statusOn branch masterYour branch is up-to-date with &apos;origin/master&apos;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: README 忽略某些文件如日志文件，编译缓存文件等没必要纳入Git管理的文件，我们可以创建一个.gitignore文件来将这些文件排除在外。比如： 123$ cat .gitignore*.[oa]*~ 第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。 第二行告诉 Git 忽略所有以波浪符（~）结尾的文件。 文件 .gitignore 的格式规范如下： 所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配（glob指shell简化后的正则表达式）。 匹配模式最后跟反斜杠（/）说明要忽略的是目录。 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。 例子如下： 12345678910111213# 此为注释 – 将被 Git 忽略# 忽略所有 .a 结尾的文件*.a# 但 lib.a 除外!lib.a# 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO/TODO# 忽略 build/ 目录下的所有文件build/# 会忽略 doc/notes.txt 但不包括 doc/server/arch.txtdoc/*.txt# ignore all .txt files in the doc/ directorydoc/**/*.txt 查看已暂存和未暂存的更新再次修改README文件，但不添加到暂存区。现在README已经修改了两次，第一次添加内容“hello git”并且使用 git add 添加到了暂存区。第二次添加内容“hello world”，但并未添加到暂存区。 若要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用 git diff –staged 命令： 12345678$ git diff --stageddiff --git a/README b/READMEnew file mode 100644index 0000000..8d0e412--- /dev/null+++ b/README@@ -0,0 +1 @@+hello git 直接使用 git diff 命令查看已暂存和未暂存文件之间的差异： 12345678$ git diffdiff --git a/README b/READMEindex 8d0e412..05fe86c 100644--- a/README+++ b/README@@ -1 +1,2 @@ hello git+hello world 可看到，对于README文件来说，未暂存和已暂存文件相比，添加了一行“hello world”。 提交更新使用 git commit -m 命令来提交更新 1234$ git commit -m &apos;创建README文件，内容为hello git&apos;[master 1f9882d] 创建README文件，内容为hello git 1 file changed, 1 insertion(+) create mode 100644 README 跳过暂存区假如你觉得 git add 过程繁琐，可以使用 git commit -a 命令来跳过添加文件到暂存区的步骤，直接提交。 比如，对于README的第二次修改，我们还未将其添加到暂存区，所以第一次使用 git commit 命令只是提交了对README文件的第一次修改。 1234567891011$ git statusOn branch masterYour branch is ahead of &apos;origin/master&apos; by 1 commit. (use &quot;git push&quot; to publish your local commits)Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: READMEno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 使用 git commit -a 命令直接将README文件的第二次修改提交到版本库： 123$ git commit -a -m &quot;添加hello world&quot;[master db06721] 添加hello world 1 file changed, 1 insertion(+) 移除文件移除文件分为两种情况：从版本库和本地工作目录中移除；仅从版本库移除。 1.从版本库和本地工作目录中移除。使用 git rm 命令来移除README: 123456$ git rm READMErm &apos;README&apos;$ git commit -m &apos;删除README&apos;[master 99a0462] 删除README 1 file changed, 3 deletions(-) delete mode 100644 README 到本地工作目录下查看，会发现README文件已经不存在了。 这里有种情况，假如README文件还在暂存区并未提交，使用 git rm 命令将会出错： 1234$ git rm READMEerror: the following file has changes staged in the index: README(use --cached to keep the file, or -f to force removal) Git提示我们使用 git rm -f 命令来删除。 12$ git rm -f temp.logrm &apos;temp.log&apos; 2.仅从版本库移除。 比如现在不小心将temp.log文件添加并提交到版本库中了： 12345$ git add temp.log$ git commit -m &quot;add temp.log&quot;[master fa31ea5] add temp.log 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 temp.log 现在想将其从版本库中删除，但并不删除本地文件，而是随后将其添加到.gitignore文件中，可以使用命令 git rm –cached： 1234567$ git rm --cached temp.logrm &apos;temp.log&apos;$ git commit -m &quot;delete temp.log&quot;[master e512a82] delete temp.log 1 file changed, 0 insertions(+), 0 deletions(-) delete mode 100644 temp.log 移动文件（重命名）git mv 命令用来重命名文件，比如将REAME文件重命名为README.config： 123456789$ git mv README README.config$ git statusOn branch masterYour branch is ahead of 'origin/master' by 7 commits. (use "git push" to publish your local commits)Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) renamed: README -&gt; README.config 其过程类似于： 123$ mv README README.config$ git rm README$ git add README.config]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git撤销操作]]></title>
    <url>%2F2019%2F08%2F07%2FGit%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Git撤销操作修改最后一次提交如果提交后发现想要修改提交信息，可以直接使用 git commit –amend，使用该命令后，Git会启动文本编辑器，然后可看到上次提交时的说明，编辑它确认没问题后保存退出，就会使用新的提交说明覆盖刚才的提交信息： 1$ git commit --amend 如果刚才提交时忘了暂存某些修改，可以先补上暂存操作，然后再运行 --amend 提交： 12$ git add forgotten_file$ git commit --amend 取消已经暂存的文件123456789$ git statusOn branch masterYour branch is ahead of 'origin/master' by 8 commits. (use "git push" to publish your local commits)Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: README.config modified: README.md 使用命令 git reset HEAD README.config 将README.config移出暂存区： 123456789101112131415161718$ git reset HEAD README.configUnstaged changes after reset:M README.config$ git statusOn branch masterYour branch is ahead of 'origin/master' by 8 commits. (use "git push" to publish your local commits)Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: README.mdChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.config 可看到，README.config已经为Changes not staged for commit状态。 取消对文件的修改将README.config移出暂存区后，可以进一步使用命令，git checkout – README.config 取消对README.config的修改。 123456789101112131415$ cat README.confighello$ git checkout -- README.config$ git statusOn branch masterYour branch is ahead of 'origin/master' by 8 commits. (use "git push" to publish your local commits)Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: README.md$ cat README.config]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ListenableFuture的使用心得]]></title>
    <url>%2F2019%2F08%2F06%2FListenableFuture%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[1.由来​ ListenableFuture是可以监听的Future任务执行情况，是执行成功还是执行失败，并提供响应接口用于对不同结果进行处理。如果异步任务完成自动调用回调函数，减少并发程序复杂度。 ​ Future以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。阻塞的方式显然和我们的异步编程的初衷相违背，轮询的方式又会耗费无谓的CPU资源，而且也不能及时地得到计算结果，为什么不能用观察者设计模式当计算结果完成及时通知监听者呢？ 2.适用场景 如果一个主任务开始执行，然后需要执行各个小任务，并且需要等待返回结果，统一返回给前端，此时Future和ListenableFuture作用几乎差不多，都是通过get()方法阻塞等待每个任务执行完毕返回。 如果一个主任务开始执行，然后执行各个小任务，主任务不需要等待每个小任务执行完，不需要每个小任务的结果，此时用ListenableFuture非常合适，它提供的FutureCallBack接口可以对每个任务的成功或失败单独做出响应。 3.使用示例(1):使用Future示例: 需要阻塞轮训，查看异步任务是否完成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * @author denny.zhang * @ClassName: FutureDemo * @Description: Future多线程并发任务结果归集 * @date 2016年11月4日 下午1:50:32 */public class FutureDemo &#123; public static void main(String[] args) &#123; Long start = System.currentTimeMillis();//开启多线程 ExecutorService exs = Executors.newFixedThreadPool(10); try &#123;//结果集 List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); List&lt;Future&lt;Integer&gt;&gt; futureList = new ArrayList&lt;Future&lt;Integer&gt;&gt;();//1.高速提交10个任务，每个任务返回一个Future入list for (int i = 0; i &lt; 10; i++) &#123; futureList.add(exs.submit(new CallableTask(i + 1))); &#125; Long getResultStart = System.currentTimeMillis(); System.out.println("结果归集开始时间=" + new Date());//2.结果归集，遍历futureList,高速轮询（模拟实现了并发）获取future状态成功完成后获取结果，退出当前循环 for (Future&lt;Integer&gt; future : futureList) &#123; while (true) &#123;//CPU高速轮询：每个future都并发轮循，判断完成状态然后获取结果，这一行，是本实现方案的精髓所在。即有10个future在高速轮询，完成一个future的获取结果，就关闭一个轮询 if (future.isDone() &amp;&amp; !future.isCancelled()) &#123;//获取future成功完成状态，如果想要限制每个任务的超时时间，取消本行的状态判断+future.get(1000*1, TimeUnit.MILLISECONDS)+catch超时异常使用即可。 Integer i = future.get();//获取结果 System.out.println("任务i=" + i + "获取完成!" + new Date()); list.add(i); break;//当前future获取结果完毕，跳出while &#125; else &#123; Thread.sleep(1);//每次轮询休息1毫秒（CPU纳秒级），避免CPU高速轮循耗空CPU---》新手别忘记这个 &#125; &#125; &#125; System.out.println("list=" + list); System.out.println("总耗时=" + (System.currentTimeMillis() - start) + ",取结果归集耗时=" + (System.currentTimeMillis() - getResultStart)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; exs.shutdown(); &#125; &#125; static class CallableTask implements Callable&lt;Integer&gt; &#123; Integer i; public CallableTask(Integer i) &#123; super(); this.i = i; &#125; @Override public Integer call() throws Exception &#123; if (i == 1) &#123; Thread.sleep(3000);//任务1耗时3秒 &#125; else if (i == 5) &#123; Thread.sleep(5000);//任务5耗时5秒 &#125; else &#123; Thread.sleep(1000);//其它任务耗时1秒 &#125; System.out.println("task线程：" + Thread.currentThread().getName() + "任务i=" + i + ",完成！"); return i; &#125; &#125;&#125; (2):使用**CompletionService，**任务先完成优先获取到，结果按照任务的完成先后顺序排序。内部通过阻塞队列+FutureTask。 (3):使用ListenableFuture，异步任务完成之后进行回调，不用在主线程进行等待 123456789101112131415161718192021222324252627282930313233// Guava 和 spring4.0public class TestListenableFuture &#123; // 创建线程池 final static ListeningExecutorService service = MoreExecutors.listeningDecorator(Executors.newCachedThreadPool()); public static void main(String[] args) throws Exception &#123; // 任务1 ListenableFuture&lt;Boolean&gt; booleanTask = service.submit(new Callable&lt;Boolean&gt;() &#123; @Override public Boolean call() throws Exception &#123; return true; &#125; &#125;); // 增加回调函数 Futures.addCallback(booleanTask, new FutureCallback&lt;Boolean&gt;() &#123; // 成功处理 @Override public void onSuccess(Boolean result) &#123; System.err.println("BooleanTask: " + result); &#125; // 失败处理 @Override public void onFailure(Throwable t) &#123; &#125; &#125;); // 任务2 ListenableFuture&lt;String&gt; stringTask = service.submit(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return "Hello World"; &#125; &#125;&#125; 4.原理分析(1):Future增加监听机制相关类 ListenableFuture：增加扩展功能使用，addCallback()方法为了支持增加回调函数 ListenableFutureCallback：Future回调函数接口 ListenableFutureTask：FutureTask子类，主要是为了增加回调函数注册和回调函数调用功能。该类重写了done()方法，执行对回调函数队列的调用。 ListenableFutureCallbackRegistry：回调函数注册类，调用addCallback()注册ListenableFutureTask。 (2):ListenableFutureTask该类继承了FutureTask，重写了done()方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * Extension of &#123;@link FutureTask&#125; that implements &#123;@link ListenableFuture&#125;. * * @author Arjen Poutsma * @since 4.0 */public class ListenableFutureTask&lt;T&gt; extends FutureTask&lt;T&gt; implements ListenableFuture&lt;T&gt; &#123; // 并发编程,尽量使用final关键字,让变量不可变. private final ListenableFutureCallbackRegistry&lt;T&gt; callbacks = new ListenableFutureCallbackRegistry&lt;&gt;(); /** * Create a new &#123;@code ListenableFutureTask&#125; that will, upon running, * execute the given &#123;@link Callable&#125;. * @param callable the callable task */ public ListenableFutureTask(Callable&lt;T&gt; callable) &#123; super(callable); &#125; /** * Create a &#123;@code ListenableFutureTask&#125; that will, upon running, * execute the given &#123;@link Runnable&#125;, and arrange that &#123;@link #get()&#125; * will return the given result on successful completion. * @param runnable the runnable task * @param result the result to return on successful completion */ public ListenableFutureTask(Runnable runnable, @Nullable T result) &#123; super(runnable, result); &#125; ... ... ... @Override protected void done() &#123; Throwable cause; try &#123; // 成功 T result = get(); this.callbacks.success(result); return; &#125; // 第一处捕获异常 catch (InterruptedException ex) &#123; // 异常,则中断线程 Thread.currentThread().interrupt(); return; &#125; // 第二处捕获异常 catch (ExecutionException ex) &#123; // JUC并发异常,需要捕获ExecutionException异常 cause = ex.getCause(); if (cause == null) &#123; cause = ex; &#125; &#125; // 第三处捕获异常 catch (Throwable ex) &#123; cause = ex; &#125; // 失败添加 this.callbacks.failure(cause); &#125;&#125; (3):ListenableFutureCallbackRegistry：回调函数注册类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106public class ListenableFutureCallbackRegistry&lt;T&gt; &#123; private final Queue&lt;SuccessCallback&lt;? super T&gt;&gt; successCallbacks = new LinkedList&lt;&gt;(); private final Queue&lt;FailureCallback&gt; failureCallbacks = new LinkedList&lt;&gt;(); private State state = State.NEW; @Nullable private Object result; /** 互斥锁,控制并发变量,这里需要控制线程执行状态。NEW,SUCCESS,FAILURE **/ private final Object mutex = new Object(); public void addCallback(ListenableFutureCallback&lt;? super T&gt; callback) &#123; Assert.notNull(callback, "'callback' must not be null"); synchronized (this.mutex) &#123; switch (this.state) &#123; case NEW: this.successCallbacks.add(callback); this.failureCallbacks.add(callback); break; case SUCCESS: notifySuccess(callback); break; case FAILURE: notifyFailure(callback); break; &#125; &#125; &#125; private void notifySuccess(SuccessCallback&lt;? super T&gt; callback) &#123; try &#123; callback.onSuccess((T) this.result); &#125; catch (Throwable ex) &#123; // Ignore &#125; &#125; private void notifyFailure(FailureCallback callback) &#123; Assert.state(this.result instanceof Throwable, "No Throwable result for failure state"); try &#123; callback.onFailure((Throwable) this.result); &#125; catch (Throwable ex) &#123; // Ignore &#125; &#125; public void addSuccessCallback(SuccessCallback&lt;? super T&gt; callback) &#123; Assert.notNull(callback, "'callback' must not be null"); synchronized (this.mutex) &#123; switch (this.state) &#123; case NEW: this.successCallbacks.add(callback); break; case SUCCESS: notifySuccess(callback); break; &#125; &#125; &#125; public void addFailureCallback(FailureCallback callback) &#123; Assert.notNull(callback, "'callback' must not be null"); synchronized (this.mutex) &#123; switch (this.state) &#123; case NEW: this.failureCallbacks.add(callback); break; case FAILURE: notifyFailure(callback); break; &#125; &#125; &#125; public void success(@Nullable T result) &#123; synchronized (this.mutex) &#123; this.state = State.SUCCESS; this.result = result; SuccessCallback&lt;? super T&gt; callback; while ((callback = this.successCallbacks.poll()) != null) &#123; notifySuccess(callback); &#125; &#125; &#125; public void failure(Throwable ex) &#123; synchronized (this.mutex) &#123; this.state = State.FAILURE; this.result = ex; FailureCallback callback; while ((callback = this.failureCallbacks.poll()) != null) &#123; notifyFailure(callback); &#125; &#125; &#125; private enum State &#123;NEW, SUCCESS, FAILURE&#125;&#125; 5：设计模式运用(1):适配器模式：FutureAdapter(对象适配器,使用聚合的方式)，ListenableFutureAdapter(类适配器,使用继承的方式)。对象适配器：**FutureAdapter** 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public abstract class FutureAdapter&lt;T, S&gt; implements Future&lt;T&gt; &#123; private final Future&lt;S&gt; adaptee; @Nullable private Object result; private State state = State.NEW; private final Object mutex = new Object(); /** * Constructs a new &#123;@code FutureAdapter&#125; with the given adaptee. * @param adaptee the future to delegate to */ protected FutureAdapter(Future&lt;S&gt; adaptee) &#123; Assert.notNull(adaptee, "Delegate must not be null"); this.adaptee = adaptee; &#125; /** * Returns the adaptee. */ protected Future&lt;S&gt; getAdaptee() &#123; return this.adaptee; &#125; ... ... ... @SuppressWarnings("unchecked") @Nullable final T adaptInternal(S adapteeResult) throws ExecutionException &#123; synchronized (this.mutex) &#123; switch (this.state) &#123; ... ... ... case NEW: try &#123; T adapted = adapt(adapteeResult); this.result = adapted; this.state = State.SUCCESS; return adapted; &#125; ... ... ... &#125; &#125; &#125; /** * Adapts the given adaptee's result into T. * @return the adapted result */ @Nullable protected abstract T adapt(S adapteeResult) throws ExecutionException; ... ...&#125; 类适配器：**ListenableFutureAdapter** 12345678910111213141516171819202122232425262728293031323334353637383940public abstract class ListenableFutureAdapter&lt;T, S&gt; extends FutureAdapter&lt;T, S&gt; implements ListenableFuture&lt;T&gt; &#123; /** * Construct a new &#123;@code ListenableFutureAdapter&#125; with the given adaptee. * @param adaptee the future to adapt to */ protected ListenableFutureAdapter(ListenableFuture&lt;S&gt; adaptee) &#123; super(adaptee); &#125; ... ... ... @Override public void addCallback(final SuccessCallback&lt;? super T&gt; successCallback, final FailureCallback failureCallback) &#123; ListenableFuture&lt;S&gt; listenableAdaptee = (ListenableFuture&lt;S&gt;) getAdaptee(); listenableAdaptee.addCallback(new ListenableFutureCallback&lt;S&gt;() &#123; @Override public void onSuccess(@Nullable S result) &#123; T adapted = null; if (result != null) &#123; try &#123; adapted = adaptInternal(result); &#125; ... ... ... &#125; successCallback.onSuccess(adapted); &#125; @Override public void onFailure(Throwable ex) &#123; failureCallback.onFailure(ex); &#125; &#125;); &#125;&#125;]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Guava</tag>
        <tag>Spring</tag>
        <tag>ListenableFuture</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lamdba表达式学习(Java8)]]></title>
    <url>%2F2019%2F08%2F06%2FLamdba%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0-Java8%2F</url>
    <content type="text"><![CDATA[1：lamdba语法java8新增了一个操作符-&gt;，称为lambda操作符或箭头操作符，它将lambda表达式分为两部分，箭头之前的是参数，箭头之后的是动作。例如： (Integer n1,Integer n2) -&gt; n1 + n2 这个就相当于 1234&gt; Integer method(Integer n1, Integer n2) &#123;&gt; return n1 + n2;&gt; &#125;&gt; 参数类型可以忽略，可以推断出来。 (n1,n2) -&gt; n1 + n2 如果只有一个参数的话，圆括号也可以省略，像这样 n1 -&gt; n1 * n1 如果没有参数，如下所示： 12&gt; () -&gt; 5; //固定返回5&gt; 箭头符号右侧是动作，除了我们看到的这种单行的形式之外，还可以声明一个代码段作为动作，像下面这样 1234&gt; n -&gt; &#123;&gt; return n * n;&gt; &#125;&gt; 这个代码段可以写的很长很长。如果有返回值的话，需要使用return语句返回。 2:函数接口: FunctionInterface在java中，lambda表达式一定要结合functional interface来使用，functional interface是指一个只包含一个抽象方法的接口，可以包含默认实现default。下面来看一个例子。这是一个functional interface： 123456789101112131415161718192021222324252627@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; /** * Performs this operation on the given argument. * * @param t the input argument */ void accept(T t); /** * Returns a composed &#123;@code Consumer&#125; that performs, in sequence, this * operation followed by the &#123;@code after&#125; operation. If performing either * operation throws an exception, it is relayed to the caller of the * composed operation. If performing this operation throws an exception, * the &#123;@code after&#125; operation will not be performed. * * @param after the operation to perform after this operation * @return a composed &#123;@code Consumer&#125; that performs in sequence this * operation followed by the &#123;@code after&#125; operation * @throws NullPointerException if &#123;@code after&#125; is null */ default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) &#123; Objects.requireNonNull(after); return (T t) -&gt; &#123; accept(t); after.accept(t); &#125;; &#125;&#125; 3:变量捕获说到lambda表达式，有一个话题是绕不开的，就是闭包。但这个问题在java中被简化了好多。这个问题可以分为两种情况来讨论： lambda表达式可以访问到所在的类中定义的字段(filed)，也可以修改这个字段。 lambda表达式可以访问到外层代码块(enclosing scope)中定义的局部变量(local varable)，但不能修改他们，并且，如果一个局部变量在lambda表达式中被读取的话，这个变量必须是final或事实上final（变量赋值以后就不能再任何地方再修改了）。如果在匿名类或 Lambda 表达式中访问的局部变量，如果不是 final 类型的话，编译器自动加上 final 修饰符。 为什么 Lambda 表达式(匿名类) 不能访问非 final 的局部变量呢？ 因为实例变量存在堆中，而局部变量是在栈上分配，Lambda 表达(匿名类) 会在另一个线程中执行。如果在线程中要直接访问一个局部变量，可能线程执行时该局部变量已经被销毁了，而 final 类型的局部变量在 Lambda 表达式(匿名类) 中其实是局部变量的一个拷贝。 4.局部变量类型 (1):对象类型，则对象的引用地址不可改变。 (2):基本类型,，则对象的值不能改变。 123456789101112131415public class App &#123; private int filed1 = 10; void method1() &#123; int varable1 = 10; MyInterface myInterface = n -&gt; &#123; filed1 += 2; //可读取，可修改 int m = varable1; //可读取 //varable1 += 2; //不可修改 return 1; &#125;; //varable1 += 2; //已经在lambda表达式中被读取了，就是final了，不能被修改。 &#125;&#125; 4:方法引用lambda表达式的本质是一个匿名方法，但如果有一个方法的签名（参数列表和返回值）和functional interface的签名一样并且逻辑正好是你需要的，那么你可以使用方法引用的方式来将它赋值给你的functional interface，而无需再编写lambda表达式。 方法引用类型： 静态方法: 语法: ClassName::methodName 12myInterface = MyClass::staticMethod;myInterface.doSomething(5); 实例方法: 语法: instance::methodName 123MyClass myClass = new MyClass();myInterface = myClass::instanceMethod;myInterface.doSomething(5); 泛型方法: 语法：instace::methodName 123MyClass myClass = new MyClass();myInterface = myClass::&lt;integer&gt;genericMethod;myInterface.doSomething(5);&lt;/integer&gt; 构造方法: 语法: ClassName::new 123456789101112131415public class Foo &#123; String msg1, msg2; public Foo(String msg1, String msg2) &#123; this.msg1 = msg1; this.msg2 = msg2; &#125;&#125;interface FooInterface &#123; Foo fooMethod(String m1, String m2);&#125;FooInterface fooInterface = Foo::new;Foo fooObj = fooInterface.fooMethod("hello", "world");]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>lamdba</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot配置篇]]></title>
    <url>%2F2019%2F08%2F06%2FSpring-Boot%E9%85%8D%E7%BD%AE%E7%AF%87%2F</url>
    <content type="text"><![CDATA[1:概述SpringBoot支持外部化配置,配置文件格式如下所示: properties files yaml files environment variables command-line arguments 使用外部化配置方式: @Value注解 Environment抽象(Spring环境接口抽象) @ConfigurationProperties PropertySource(文件属性抽象) 2:自定义属性 POM内容如下 123456789101112131415161718&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--生成spring-configuration-metadata.json文件,提示属性--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 当使用Spring Boot开发项目时,Spring Boot会默认读取classpath下application.properties application.yml文件,详情请查看源码ConfigFileApplicationListener。这种自定义少量 属性常常通过@Value注解进行加载,但是@Value所在类必须在Spring IOC容器中。 application.yml自定义属性 123hello: user: name: "刘恩源" 读取该属性常常通过@Value注解进行读取。 12345678@Component@Datapublic class HelloUser &#123; //hello.user.name:default==&gt;&gt;表示当时该属性在 //spring Environment没有找到取默认值default @Value("$&#123;hello.user.name:default&#125;") private String userName;&#125; ​ 123456789101112131415161718192021222324/** * 类描述: spring boot config * * @author liuenyuan * @date 2019/6/16 11:36 * @describe * @see org.springframework.beans.factory.annotation.Value * @see org.springframework.context.annotation.PropertySource * @see org.springframework.boot.context.properties.ConfigurationProperties * @see org.springframework.boot.context.properties.EnableConfigurationProperties * @see org.springframework.core.env.Environment * @see org.springframework.context.annotation.Profile * @see org.springframework.context.support.PropertySourcesPlaceholderConfigurer */@SpringBootApplicationpublic class ConfigApplication &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext context = SpringApplication.run(ConfigApplication.class, args); HelloUser helloUser = context.getBean(HelloUser.class); System.out.println(String.format("通过@Value注解读取自定义的少量属性: %s", helloUser.getUserName())); context.close(); &#125;&#125; @Value注解注入使用情况 转载自:https://www.cnblogs.com/wangbin2188/p/9014837.html 注入普通字符串 注入操作系统属性 注入表达式结果 注入其他Bean属性 注入文件资源 注入URL资源 注入${…}来处理placeholder。 1234567891011121314151617@Value("normal")private String normal; // 注入普通字符串@Value("#&#123;systemProperties['os.name']&#125;")private String systemPropertiesName; // 注入操作系统属性@Value("#&#123; T(java.lang.Math).random() * 100.0 &#125;")private double randomNumber; //注入表达式结果@Value("#&#123;beanInject.another&#125;")private String fromAnotherBean; // 注入其他Bean属性：注入beanInject对象的属性another，类具体定义见下面@Value("classpath:com/hry/spring/configinject/config.txt")private Resource resourceFile; // 注入文件资源@Value("http://www.baidu.com")private Resource testUrl; // 注入URL资源 3:将配置文件属性赋给实体类当有许多配置属性(建议超过5这样),可以将这些属性作为字段来创建一个JavaBean,并将属性赋给他们。例如 在application.yml配置属性如下: person: name: &quot;刘恩源&quot; age: 21 school: &quot;天津师范大学&quot;配置属性类PersonProperties @ConfigurationProperties注解是将properties配置文件转换为bean使用,默认是将application.yml 或者application.properties属性转换成bean使用。@PropertySource只支持properties结尾的文件。 @EnableConfigurationProperties注解的作用是@ConfigurationProperties注解生效,并将属性 配置类注册到Spring IOC容器中。 如果需要加载指定配置文件,可以使用@PropertySource注解。 12345678910111213141516171819202122232425 @ConfigurationProperties(prefix = "person")@Datapublic class PersonProperties &#123; private String name; private Integer age; private String school;&#125;@EnableConfigurationProperties(&#123;PersonProperties.class&#125;)@Configurationpublic class PersonConfiguration &#123; private final PersonProperties personProperties; public PersonConfiguration(PersonProperties personProperties) &#123; this.personProperties = personProperties; System.out.println(String.format("PersonProperties: %s", this.personProperties)); &#125; public PersonProperties getPersonProperties() &#123; return personProperties; &#125;&#125; 4:自定义配置文件上面介绍了读取默认配置文件application.yml|application.properties中的配置属性。当然,我们也可以读取 自定义的配置文件中属性。目前官方使用@PropertySource注解导入自定义的配置文件属性。 建立hello.properties #load config properties person.name=刘恩源 person.age=20 person.school=天津师范大学建立PersonProperties.java 123456789101112//建立声明加载properties配置文件的encoding和name@ConfigurationProperties(prefix = "person")@Data@PropertySource(value = &#123;"classpath:/hello.properties"&#125;, encoding = "UTF-8", name = "hello")public class PersonProperties &#123; private String name; private Integer age; private String school;&#125; 建立PersonConfiguration,使用@EnableConfigurationProperties激活@ConfigurationProperties 注解,将其标注的JavaBean注入到Spring IOC容器中。 1234567891011121314@EnableConfigurationProperties(&#123;PersonProperties.class&#125;)@Configurationpublic class PersonConfiguration &#123; private final PersonProperties personProperties public PersonConfiguration(PersonProperties personProperties) &#123; this.personProperties = personProperties; System.out.println(String.format("PersonProperties: %s", this.personProperties)); &#125; public PersonProperties getPersonProperties() &#123; return personProperties; &#125;&#125; 加载指定yml|yaml文件 配置如下: 1234567891011public class YamlPropertiesConfiguration &#123; @Bean public static PropertySourcesPlaceholderConfigurer properties() &#123; PropertySourcesPlaceholderConfigurer configurer = new PropertySourcesPlaceholderConfigurer(); YamlPropertiesFactoryBean yml = new YamlPropertiesFactoryBean(); yml.setResources(new ClassPathResource("/hello.yml")); configurer.setProperties(yml.getObject()); return configurer; &#125;&#125; 可以参照我实现的自定义注解@YmlPropertySource,加载yml|yaml文件,可以大致实现和@PropertySource 注解同样的功能。 @YmlPropertySource实现加载yml|yaml文件 5:多环境配置在企业开发环境中,需要不同的配置环境.SpringBoot使用spring.profiles.active属性加载不同环境的配置文件,配置文件格式为application-{profile}.properties|yml|yaml。{profile}对应环境标识。 application-test.yml:测试环境 application-dev.yml:开发环境 application.prod:生产环境 可以在springboot默认配置文件application.yml通过配置spring.profiles.active激活环境。也可以在 特定的类使用@Profile注解激活环境。该注解可以使用逻辑运算符。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>外部化配置</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强大JSON解析工具gson]]></title>
    <url>%2F2019%2F08%2F06%2F%E5%BC%BA%E5%A4%A7JSON%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7gson%2F</url>
    <content type="text"><![CDATA[1:GsonUtils工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * google json utils * **/public class GsonUtils &#123; public static final String DATE_FORMAT="yyyy-MM-dd HH:mm:ss"; /** * get google json * @see Gson * **/ public static Gson getGson() &#123; return (new GsonBuilder()).serializeNulls().setDateFormat(GsonUtils.DATE_FORMAT).create(); &#125; /** * object to json * **/ public static String toJson(Object obj) &#123; return getGson().toJson(obj); &#125; /** * json to type * @see Gson#toJson(Object, Type) * **/ public static String toJson(Object obj, Type type) &#123; return getGson().toJson(obj, type); &#125; /** * generic t to json * **/ public static &lt;T&gt; String t2Json(T t) &#123; return getGson().toJson(t); &#125; /** * json to generic t * **/ public static &lt;T&gt; T json2T(String jsonString, Class&lt;T&gt; clazz) &#123; return getGson().fromJson(jsonString, clazz); &#125; /** * json to collection * **/ public static &lt;T&gt; List&lt;T&gt; json2Collection(String jsonStr, Type type) &#123; return (List&lt;T&gt;) getGson().fromJson(jsonStr, type); &#125; /** * json to type * @see Gson#fromJson(String, Type) * **/ public static &lt;T&gt; T fromJson(String jsonStr, Type type) &#123; return getGson().fromJson(jsonStr, type); &#125; /** * json to class type * **/ public static &lt;T&gt; T fromJson(String jsonStr, Class&lt;T&gt; clazz) &#123; return getGson().fromJson(jsonStr, clazz); &#125;&#125; 1:java bean对象转换成json123456789101112//实体类@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private Integer id; private String name; private Integer age;&#125; 1234@Testpublic void testBean2Json() &#123; System.out.println(GsonUtils.toJson(new User(1, "王旭", 22)));&#125; 2:List对象转换成json1234567891011121314151617181920 //方法1 @Test public void testBeanList2Json() &#123; System.out.println(GsonUtils.toJson(Arrays.asList( new User(1, "王旭", 22), new User(2, "王旭1", 23), new User(3, "王旭2", 24) ) )); &#125;//方法2,指定具体的泛型@Test public void testBeanList2Json2() &#123; System.out.println(GsonUtils.toJson(Arrays.asList( new User(1, "王旭", 22), new User(2, "王旭1", 23), new User(3, "王旭2", 24) ), new TypeToken&lt;List&lt;User&gt;&gt;() &#123; &#125;.getType())); &#125; 3:Map对象转换成json1234567891011private static Map&lt;String, User&gt; userMap = new HashMap&lt;&gt;();static &#123; userMap.put("1", new User(1, "王旭", 22)); userMap.put("2", new User(2, "王旭", 23));&#125;@Testpublic void testMap2Json() &#123; System.out.println(GsonUtils.toJson(userMap));&#125; 4:Json转成java bean对象12345@Testpublic void testJson2Bean() &#123; User user = GsonUtils.fromJson("&#123;\"id\":1,\"name\":\"王旭\",\"age\":22&#125;", User.class); System.out.println(user);&#125; 5:Json转成List对象12345678//TypeToken用来获取转换出来的泛型类型,如果转换成泛型请使用该类 @Test public void testJson2List() &#123; String jsonList = "[&#123;\"id\":1,\"name\":\"王旭\",\"age\":22&#125;,&#123;\"id\":2,\"name\":\"王旭1\",\"age\":23&#125;,&#123;\"id\":3,\"name\":\"王旭2\",\"age\":24&#125;]"; List&lt;User&gt; userList = GsonUtils.fromJson(jsonList, new TypeToken&lt;List&lt;User&gt;&gt;() &#123; &#125;.getType()); System.out.println(userList); &#125; 6:Json转成map对象1234567891011121314151617181920212223//其中,使用TypeToken可以将json转换成对应的Java类型 @Test public void testJson2Map() &#123; TypeToken&lt;Map&lt;String, User&gt;&gt; typeToken = new TypeToken&lt;Map&lt;String, User&gt;&gt;() &#123; &#125;; Map&lt;String, User&gt; map = GsonUtils.fromJson("&#123;\"1\":&#123;\"id\":1,\"name\":\"王旭\",\"age\":22&#125;,\"2\":&#123;\"id\":2,\"name\":\"王旭\",\"age\":23&#125;&#125;", typeToken.getType()); System.out.println(map); &#125;//在转换json的时候//第一步:知道json是什么构造的//第二步:转换出相应的Java类型@Test public void testJson2Map() &#123; TypeToken&lt;TreeMap&lt;String, User&gt;&gt; typeToken = new TypeToken&lt;TreeMap&lt;String, User&gt;&gt;() &#123; &#125;; TreeMap&lt;String, User&gt; map = GsonUtils.fromJson("&#123;\"1\":&#123;\"id\":1,\"name\":\"王旭\",\"age\":22&#125;,\"2\":&#123;\"id\":2,\"name\":\"王旭\",\"age\":23&#125;&#125;", typeToken.getType()); for (Map.Entry&lt;String, User&gt; entry : map.entrySet()) &#123; System.out.println(entry.getKey()+":"+entry.getValue()); &#125; &#125;]]></content>
      <categories>
        <category>json</category>
      </categories>
      <tags>
        <tag>gson</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Request header is too large 的问题解决]]></title>
    <url>%2F2019%2F08%2F06%2FRequest-header-is-too-large-%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[1:问题原因: 后台接受前台传入的内容字符串,由于内容字符串太大,导致打印台报错. 1-1:错误描述: 123456789101112java.lang.IllegalArgumentException: Request header is too large at org.apache.coyote.http11.Http11InputBuffer.fill(Http11InputBuffer.java:701) at org.apache.coyote.http11.Http11InputBuffer.parseRequestLine(Http11InputBuffer.java:455) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:667) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:798) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1434) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:745) 1-2:解决方案(服务器容器:tomcat): 1:请求头超过了tomcat的限值。本来post请求是没有参数大小限制，但是服务器有自己的默认大小。2:配置 tomcat的server.xml文件,增加请求字段长度 1234&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; maxHttpHeaderSize=&quot;102400&quot; maxPostSize=&quot;0&quot; URIEncoding=&quot;UTF-8&quot;/&gt; 增加maxHttpHeaderSize参数配置,当maxPostSize=0时,表示不限制. 1-3:SpringBoot项目: 在application.yml文件中,配置server.max-http-header-size=102400参数,即可改变内嵌tomcat容器的最大头大小. 1-4:详细错误原因: 在tomcat的org.apache.coyote.http11.AbstractHttp11Protocol类中定义了其默认值: 12345/** * Maximum size of the HTTP message header. */private int maxHttpHeaderSize = 8 * 1024;//所以当请求头大于8*1024时,就会报错.增对大数据量的请求,需要单独配置maxHttpHeaderSize参数属性.]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>maxHttpHeaderSize</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot中RedisTemplate注意问题]]></title>
    <url>%2F2019%2F08%2F06%2FSpringBoot%E4%B8%ADRedisTemplate%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1:ERR value is not an integer or out of range1-1:背景:使用redisTemplate.opsForValue().increment(key, delat)方法。 1-2:分析:redis对任何不合法的值,都称为ERR。只有使用StringRedisSerializer序列化器才能使用incrment或者decrement方法。 1-3:问题解决: GenericJackson2JsonRedisSerializer、Jackson2JsonRedisSerializer是先将对象转为json，然后再保存到redis，所以，1在redis中是字符串1，所以无法进行加1 JdkSerializationRedisSerializer使用的jdk对象序列化，序列化后的值有类信息、版本号等，所以是一个包含很多字母的字符串，所以根本无法加1,这个序列化器跟memcache的序列化规则很像memcache怎样存储的对象 GenericToStringSerializer、StringRedisSerializer将字符串的值直接转为字节数组，所以保存到redis中是数字，所以可以进行加1 1-4:总结: 使用GenericToStringSerializer、StringRedisSerializer序列化器，都可以使用increment方法. 1-5:建议redis key序列化使用StringRedisSerializer,redis value序列化使用Jackson2JsonRedisSerializer。 1234567891011121314151617/** * key redis serializer: &#123;@link StringRedisSerializer&#125; and * key redis serializer: &#123;@link Jackson2JsonRedisSerializer&#125; **/@Bean(name = &quot;genericRedisTemplate&quot;)public RedisTemplate&lt;String, String&gt; redisTemplate3(RedisConnectionFactory factory) &#123; RedisTemplate&lt;String, String&gt; template = new RedisTemplate&lt;&gt;(); RedisSerializer valueRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); RedisSerializer keyRedisSerializer = new StringRedisSerializer(); template.setKeySerializer(keyRedisSerializer); template.setValueSerializer(valueRedisSerializer); template.setHashKeySerializer(keyRedisSerializer); template.setHashValueSerializer(valueRedisSerializer); template.setConnectionFactory(factory); template.afterPropertiesSet(); return template;&#125; 2:key前面会有一堆\xac\xed\x00\x05t\x00\tb1-1:背景:使用SpringData对redis进行操作 1-2:分析 分析spring-data的org.springframework.data.redis.core.RedisTemplate源代码以后发现.Spring默认采用defaultSerializer = new JdkSerializationRedisSerializer();来对key,value进行序列化操作，在经过查看JdkSerializationRedisSerializer中对序列化的一系列操作,即默认使用。由于spring操作redis是在jedis客户端基础上进行的，而jedis客户端与redis交互的时候协议中定义是用byte类型交互，jedis中提供了string类型转为byte[]类型.原因其实就出现在这里，解决的办法就是手动定义序列化的方法。 1-3:解决方法: 建议redis key序列化使用StringRedisSerializer,redis value序列化使用Jackson2JsonRedisSerializer. // 使用SpringBoot默认配置的redisTemplate 1234567891011121314151617181920212223242526/** * Standard Redis configuration. */@Configurationprotected static class RedisConfiguration &#123; @Bean @ConditionalOnMissingBean(name = "redisTemplate") public RedisTemplate&lt;Object, Object&gt; redisTemplate( RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;Object, Object&gt;(); template.setConnectionFactory(redisConnectionFactory); return template; &#125; @Bean @ConditionalOnMissingBean(StringRedisTemplate.class) public StringRedisTemplate stringRedisTemplate( RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123; StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>RedisTemplate</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中RestTemplate的使用]]></title>
    <url>%2F2019%2F08%2F06%2FSpring%E4%B8%ADRestTemplate%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Spring中RestTemplate的使用Get请求1:带参数的Get请求 请求URL示例:http://localhost:8080/test/sendSms?phone=手机号&amp;msg=短信内容 12345678910111213141516//错误使用:@Autowiredprivate RestOperations restOperations;public void test() throws Exception&#123; String url = &quot;http://localhost:8080/test/sendSms&quot;; Map&lt;String, Object&gt; uriVariables = new HashMap&lt;String, Object&gt;(); uriVariables.put(&quot;phone&quot;, &quot;151xxxxxxxx&quot;); uriVariables.put(&quot;msg&quot;, &quot;测试短信内容&quot;); String result = restOperations.getForObject(url, String.class, uriVariables);&#125;**服务器接收的时候你会发现，接收的该请求时没有参数的** 123456789101112131415//正确使用:public void test() throws Exception&#123; String url = &quot;http://localhost:8080/test/sendSms?phone=&#123;phone&#125;&amp;msg=&#123;phone&#125;&quot;; Map&lt;String, Object&gt; uriVariables = new HashMap&lt;String, Object&gt;(); uriVariables.put(&quot;phone&quot;, &quot;151xxxxxxxx&quot;); uriVariables.put(&quot;msg&quot;, &quot;测试短信内容&quot;); String result = restOperations.getForObject(url, String.class, uriVariables);&#125;public void test() throws Exception&#123; String url = &quot;http://localhost:8080/test/sendSms?phone=&#123;phone&#125;&amp;msg=&#123;phone&#125;&quot;; String result = restOperations.getForObject(url, String.class, &quot;151xxxxxxxx&quot;, &quot;测试短信内容&quot;);&#125; 2:Spring提供的Get请求方法 1234567891011&lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException;&lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException;&lt;T&gt; T getForObject(URI url, Class&lt;T&gt; responseType) throws RestClientException;&lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(String url, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException;&lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException;&lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(URI url, Class&lt;T&gt; responseType) throws RestClientException; Post请求1:带参数的POST请求 带参数的URL示例:http://api.map.baidu.com/geodata/v3/poi/create 123456789101112131415161718192021//正确使用: HttpHeaders headers = new HttpHeaders(); MultiValueMap&lt;String, String&gt; createPostParams = new LinkedMultiValueMap&lt;&gt;(16); headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED); createPostParams.add(&quot;ak&quot;, PositionConstants.AK); createPostParams.add(&quot;geotable_id&quot;, PositionConstants.GEOTABLE_ID); createPostParams.add(&quot;coord_type&quot;, PositionConstants.COORD_TYPE); createPostParams.add(&quot;latitude&quot;, String.valueOf(article.getPositionX())); createPostParams.add(&quot;longitude&quot;, String.valueOf(article.getPositionY())); createPostParams.add(&quot;address&quot;, article.getPositionName()); createPostParams.add(&quot;title&quot;, article.getArticleName()); createPostParams.add(&quot;article_img&quot;, articleImg); createPostParams.add(&quot;article_id&quot;, article.getArticleId()); createPostParams.add(&quot;article_title&quot;, article.getArticleName()); createPostParams.add(&quot;article_time&quot;, String.valueOf(article.getArticleTime())); createPostParams.add(&quot;article_username&quot;, userName); HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; requestEntity = new HttpEntity&lt;&gt;(createPostParams, headers); ResponseEntity&lt;String&gt; responseEntity = restTemplate.postForEntity(PositionConstants.CREATE_URL, requestEntity, String.class); 2:Spring提供的POST方法1234567891011121314&lt;T&gt; T postForObject(String url, Object request, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException;&lt;T&gt; T postForObject(String url, Object request, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException;&lt;T&gt; T postForObject(URI url, Object request, Class&lt;T&gt; responseType) throws RestClientException;&lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(String url, Object request, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException;`&lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(String url, Object request, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException;`&lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(URI url, Object request, Class&lt;T&gt; responseType) throws RestClientException;` PUT请求: PUT请求和POST请求差不多. 1:Spring提供的PUT方法 12345void put(String url, Object request, Object... uriVariables) throws RestClientException;void put(String url, Object request, Map&lt;String, ?&gt; uriVariables) throws RestClientException;void put(URI url, Object request) throws RestClientException; DELETE请求:1:Spring提供的DELETE方法 12345void delete(String url, Object... uriVariables) throws RestClientException;void delete(String url, Map&lt;String, ?&gt; uriVariables) throws RestClientException;void delete(URI url) throws RestClientException;]]></content>
      <categories>
        <category>RestTemplate</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>RestTemplate</tag>
        <tag>Restful请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring的Bean生命周期]]></title>
    <url>%2F2019%2F08%2F06%2FSpring%E7%9A%84Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[一：生命周期执行的过程如下: 对于一个Bean对象来说,它的生命周期有实例化–&gt;初始化–&gt;销毁三大块组成。所以会有如下对三大块前后做定制化Bean。 而对于Bean对象另一份的Spring感知接口来说,会有如下代码和类进行支持。 1234567891011121314151617181920212223242526272829303132333435363738ApplicationContextAwareProcessor对一些感知接口处理。详细看invokeAwareInterfaces方法。class ApplicationContextAwareProcessor implements BeanPostProcessor &#123; private final ConfigurableApplicationContext applicationContext; private final StringValueResolver embeddedValueResolver; /** * Create a new ApplicationContextAwareProcessor for the given context. */ public ApplicationContextAwareProcessor(ConfigurableApplicationContext applicationContext) &#123; this.applicationContext = applicationContext; this.embeddedValueResolver = new EmbeddedValueResolver(applicationContext.getBeanFactory()); &#125;private void invokeAwareInterfaces(Object bean) &#123; if (bean instanceof Aware) &#123; if (bean instanceof EnvironmentAware) &#123; ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment()); &#125; if (bean instanceof EmbeddedValueResolverAware) &#123; ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver); &#125; if (bean instanceof ResourceLoaderAware) &#123; ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext); &#125; if (bean instanceof ApplicationEventPublisherAware) &#123; ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext); &#125; if (bean instanceof MessageSourceAware) &#123; ((MessageSourceAware) bean).setMessageSource(this.applicationContext); &#125; if (bean instanceof ApplicationContextAware) &#123; ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext); &#125; &#125; &#125;&#125; Bean感知接口处理。 AbstractAutowireCapableBeanFactory.java的invokeAwareMethods(final String beanName, final Object bean)方法上处理 12345678910111213141516private void invokeAwareMethods(final String beanName, final Object bean) &#123; if (bean instanceof Aware) &#123; if (bean instanceof BeanNameAware) &#123; ((BeanNameAware) bean).setBeanName(beanName); &#125; if (bean instanceof BeanClassLoaderAware) &#123; ClassLoader bcl = getBeanClassLoader(); if (bcl != null) &#123; ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl); &#125; &#125; if (bean instanceof BeanFactoryAware) &#123; ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this); &#125; &#125;&#125; 1) spring对bean进行实例化,默认bean是单例。2) spring对bean进行依赖注入。3) 如果bean实现了BeanNameAware接口,spring将bean的id传给setBeanName()方法。4) 如果bean实现了BeanFactoryAware接口,spring将调用setBeanFactory方法,将BeanFactory实例传进来。5) 如果bean实现了ApplicationContextAware()接口,spring将调用setApplicationContext()方法将应用上下文的引用传入。6) 如果bean实现了BeanPostProcessor接口,spring将调用它们的postProcessBeforeInitialization接口方法。7) 如果bean实现了InitializingBean接口,spring将调用它们的afterPropertiesSet接口方法,类似的如果bean使用了init-method属性声明了初始化方法,改方法也会被调用。8) 如果bean实现了BeanPostProcessor接口,spring将调用它们的postProcessAfterInitialization接口方法。9) 此时bean已经准备就绪,可以被应用程序使用了,他们将一直驻留在应用上下文中,直到该应用上下文被销毁。10) 若bean实现了DisposableBean接口,spring将调用它的distroy()接口方法。同样的,如果bean使用了destroy-method属性声明了销毁方法,则该方法被调用。 这里一用仓颉的一幅图说明流程： 转载自 https://www.cnblogs.com/xrq730/p/6363055.html 第二幅图解释： 二：代码测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 /** * @see org.springframework.beans.factory.config.BeanFactoryPostProcessor * @see org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter * @see org.springframework.beans.factory.InitializingBean * @see org.springframework.beans.factory.DisposableBean * @see org.springframework.beans.factory.BeanNameAware * @see org.springframework.beans.factory.BeanFactoryAware * @see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean(String, RootBeanDefinition, Object[]) **/@Slf4j@Componentpublic class SpringBean implements BeanNameAware, BeanFactoryAware, InitializingBean, ApplicationContextAware, DisposableBean &#123; public SpringBean() &#123; log.info("new SpringBean......"); &#125; @Override public void setApplicationContext(ApplicationContext context) throws BeansException &#123; log.info("ApplicationContextAware-setApplicationContext......"); &#125; @Override public void afterPropertiesSet() throws Exception &#123; log.info("InitializingBean-afterPropertiesSet......"); &#125; @Override public void setBeanFactory(BeanFactory bf) throws BeansException &#123; log.info("BeanFactoryAware-setBeanFactory......"); &#125; @Override public void setBeanName(String name) &#123; log.info("BeanNameAware-setBeanName......"); &#125; @Override public void destroy() throws Exception &#123; log.info("DisposableBean-destroy....."); &#125;&#125;@Component@Slf4jpublic class SpringBeanPostProcessor implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object o, String s) throws BeansException &#123; if (o instanceof SpringBean) &#123; log.info("BeanPostProcessor-postProcessBeforeInitialization......"); &#125; return o; &#125; @Override public Object postProcessAfterInitialization(Object o, String s) throws BeansException &#123; if (o instanceof SpringBean) &#123; log.info("BeanPostProcessor-postProcessAfterInitialization......"); &#125; return o; &#125;&#125; 结果展示]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Bean生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内省机制]]></title>
    <url>%2F2019%2F08%2F06%2FJava%E5%86%85%E7%9C%81%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一. 内省1:维基百科解释 在计算机科学中，内省是指计算机程序在运行时（Run time）检查对象（Object）类型的一种能力，通常也可以称作运行时类型检查。 不应该将内省和反射混淆。相对于内省，反射更进一步，是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力。 2:Java语言中解释 内省(Introspector) 是Java 语言对 JavaBean 类属性、事件的一种缺省处理方法。JavaBean是一种特殊的类，主要用于传递数据信息，这种类中的方法主要用于访问私有的字段，且方法名符合某种命名规则。如果在两个模块之间传递信息，可以将信息封装进JavaBean中，这种对象称为“值对象”(Value Object)，或“VO”，方法比较少，这些信息储存在类的私有变量中，通过set()、get()获得 二:内省和反射的区别 1: 反射是在运行状态把Java类中的各种成分映射成相应的Java类，可以动态的获取所有的属性以及动态调用任意一个方法，强调的是运行状态。 2: 内省(Introspector)是Java 语言对 Bean 类属性、事件的一种缺省处理方法。 JavaBean是一种特殊的类，主要用于传递数据信息，这种类中的方法主要用于访问私有的字段，且方法名符合某种命名规则。如果在两个模块之间传递信息，可以将信息封装进JavaBean中，这种对象称为“值对象”(Value Object)，或“VO”。方法比较少。这些信息储存在类的私有变量中，通过set()、get()获得。内省机制是通过反射来实现的，BeanInfo用来暴露一个bean的属性、方法和事件，以后我们就可以操纵该JavaBean的属性。 3:比较 三:JDK内省类库 java.beans.Introspector：Introspector 类为通过工具学习有关受目标 Java Bean 支持的属性、事件和方法的知识提供了一个标准方法。 java.beans.BeanInfo接口：希望提供有关其 bean 的显式信息的 bean 实现者可以提供某个 BeanInfo 类，该类实现此 BeanInfo 接口并提供有关其 bean 的方法、属性、事件等显式信息。 java.beans.PropertyDescriptor：PropertyDescriptor 描述 Java Bean 通过一对存储器方法导出的一个属性 四:内省代码测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Java内省机制测试 * * @see java.beans.BeanInfo * @see java.beans.Introspector * @see java.beans.PropertyDescriptor * @see java.beans.MethodDescriptor **/public class IntrospectorTest &#123; private User user; @Before public void init() &#123; user = new User(); user.setAge(20); user.setId(UUID.randomUUID().toString()); user.setName("刘恩源"); &#125; @Test public void testIntrospector() throws Exception &#123; //get BeanInfo BeanInfo beanInfo = Introspector.getBeanInfo(User.class); //PropertyDescriptor PropertyDescriptor[] pds = beanInfo.getPropertyDescriptors(); for (PropertyDescriptor pd : pds) &#123; Method method = pd.getReadMethod(); String methodName = method.getName(); Object result = method.invoke(user); System.out.println(methodName + "--&gt;" + result); &#125; //get name property descriptor PropertyDescriptor namePropertyDescriptor = new PropertyDescriptor("name", User.class); //得到name属性的getter方法 Method readMethod = namePropertyDescriptor.getReadMethod(); //执行getter方法，获取返回值，即name属性的值 String result = (String) readMethod.invoke(user); System.out.println("user.name" + "--&gt;" + result); //得到name属性的setter方法 Method writeMethod = namePropertyDescriptor.getWriteMethod(); //执行setter方法，修改name属性的值 writeMethod.invoke(user, "刘恩源1"); System.out.println("user.name" + "--&gt;" + user.getName()); &#125;&#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java内省机制</tag>
        <tag>Java反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JWT认证详解]]></title>
    <url>%2F2019%2F08%2F06%2FJWT%E8%AE%A4%E8%AF%81%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[JWT(Json web token) 认证详解1:概述JWT声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息,以便从资源服务器获取资源,增加一些额外的其他业务所必须的声明信息。 特别适用于分布式站点的单点登录(SSO)场景 2:起源基于token的认证和传统的session认证区别。 (1):传统的session认证概述 http协议本身是一种无状态的协议,而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证,那么下一次请求时,用户还要再一次进行用户认证才行,因为根据http协议,我们并不能知道是哪个用户发出的请求,所以为了让我们的应用能识别是哪个用户发出的请求,我们只能在服务器存储一份用户登录的信息,这份登录信息会在响应时传递给浏览器,告诉其保存为cookie,以便下次请求时发送给我们的应用,这样我们的应用就能识别请求来自哪个用户了,这就是传统的基于session认证。 基于session认证所显露的问题 session存储问题:由于用户的信息存储在服务端,而且session都是保存在内存中,随之认证用户增多,服务端开销明显增大。 扩展性:用户认证之后,服务端做认证记录,如果认证记录被保存在内存中,意味着用户下次请求还必须要请求这台服务器,才能拿到授权资源。在分布式应用中,相应的限制了负载均衡器的能力。 CSRF:因为基于cookie来进行用户识别,如果cookie被截获,用户就会很容易受到跨站请求伪造攻击。 (2):基于token的鉴权机制概述 基于token的鉴权机制类似于http协议也是无状态的,它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了,这就为应用的扩展提供了便利。 流程 用户使用用户名密码来请求服务器。 服务器进行验证用户的信息。 服务器通过验证发送给用户一个token。 客户端存储token,并在每次请求时附送上这个token值。 服务端验证token值,并返回数据。 这个token必须要在每次请求时传递给服务端,应该保存在请求头里。例外,服务端要支持CORS(跨域请求)。 3:JWT(1):设计jwt(json web token)有三部分构成。 header(头部) 声明类型:jwt 加密算法:HMAC,SHA256 头部进行base64加密。 12345//头部json&#123; "alg": "HS256", "typ": "JWT"&#125; payload:存储有效信息。 标准中注册声明(建议单不强制使用) iss: jwt签发者 sub: jwt所面向的用户 aud: 接收jwt的一方 exp: jwt的过期时间，这个过期时间必须要大于签发时间 nbf: 定义在什么时间之前，该jwt都是不可用的. iat: jwt的签发时间 jti: jwt的唯一身份标识,主要用来作为一次性token,从而回避重放攻击。 公共声明 添加任何信息,一般添加用户的相关信息或者其他业务需要的必要信息。不建议添加敏感信息。(可以在客户端进行解密) 私有声明 提供者和消费者所共同定义的声明,一般不建议存放敏感信息,因为base64是对称解密的，意味着该部分信息可以归类为明文信息。 signature:签证信息 head(base64后的) payload(base64后的) secret:保存在服务端,jwt签发生成也是在服务端。它是用来进行jwt签发和jwt验证,就是服务端的私钥。 这个部分需要base64加密后的header和payload使用。连接组成的字符串,然后通过header中声明的加密方式进行加盐secret组合加密,构成jwt第三部分。 (2):应用一般是在请求头里加入Authorization,并加上Bearer标注: 12345fetch('api/user/1', &#123; headers: &#123; 'Authorization': 'Bearer ' + token &#125;&#125;) (3):总结优点 由于json通用性,所以JWT可以跨语言。 因为有payload,所以jwt可以在自身存储一些其他业务所必要的非敏感信息。 便于传输,字节占用很小 不需要在服务端保存会话信息,易于扩展,特别适用于分布式微服务。 安全相关 不应该在jwt的payload部分存放敏感信息,因为这部分客户端可解密的部分 保护好secret私钥,该私钥非常重要。 如果可以,请使用https协议。]]></content>
      <categories>
        <category>jwt</category>
      </categories>
      <tags>
        <tag>JSON Web Token认证</tag>
        <tag>Session认证</tag>
        <tag>分布式单点登录(SSO)场景</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot自定义注解加载yml或者yaml文件]]></title>
    <url>%2F2019%2F08%2F06%2FSpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%8A%A0%E8%BD%BDyml%E6%88%96%E8%80%85yaml%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[SpringBoot自定义注解加载yml或者yaml文件1:概述SpringBoot的@PropertySource注解只支持加载 properties结尾的文件。当使用@ConfigurationProperties 注解配合@EnableConfigurationProperties注解将配置转换为JavaBean时,可能需要配合@PropertySource 注解加载指定的配置文件。所以为了支持以yml或者yaml文件,我自定义了注解@YmlPropertySource。 2:实现声明注解@YamlPropertySource 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import org.springframework.context.annotation.PropertySource;import org.springframework.core.io.support.PropertySourceFactory;import java.lang.annotation.*;/** * yaml property source and extension &#123;@link PropertySource&#125; * * @author liuenyuan * @see org.springframework.context.annotation.PropertySource **/@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Repeatable(YamlPropertySources.class)public @interface YamlPropertySource &#123; /** * Indicate the name of this property source. If omitted, a name will * be generated based on the description of the underlying resource. * * @see org.springframework.core.env.PropertySource#getName() * @see org.springframework.core.io.Resource#getDescription() */ String name() default ""; /** * Indicate the resource location(s) of the properties file to be loaded. * &lt;p&gt;Both traditional and XML-based properties file formats are supported * &amp;mdash; for example, &#123;@code "classpath:/com/myco/app.properties"&#125; * or &#123;@code "file:/path/to/file.xml"&#125;. * &lt;p&gt;Resource location wildcards (e.g. *&amp;#42;/*.properties) are not permitted; * each location must evaluate to exactly one &#123;@code .properties&#125; resource. * &lt;p&gt;$&#123;...&#125; placeholders will be resolved against any/all property sources already * registered with the &#123;@code Environment&#125;. See &#123;@linkplain PropertySource above&#125; * for examples. * &lt;p&gt;Each location will be added to the enclosing &#123;@code Environment&#125; as its own * property source, and in the order declared. */ String[] value(); /** * Indicate if failure to find the a &#123;@link #value() property resource&#125; should be * ignored. * &lt;p&gt;&#123;@code true&#125; is appropriate if the properties file is completely optional. * Default is &#123;@code false&#125;. * * @since 4.0 */ boolean ignoreResourceNotFound() default false; /** * A specific character encoding for the given resources, e.g. "UTF-8". * * @since 4.3 */ String encoding() default ""; /** * Specify a custom &#123;@link PropertySourceFactory&#125;, if any. * &lt;p&gt;By default, a default factory for standard resource files will be used. * * @see org.springframework.core.io.support.DefaultPropertySourceFactory * @see org.springframework.core.io.support.ResourcePropertySource * @since 4.3 */ Class&lt;? extends PropertySourceFactory&gt; factory() default YamlPropertySourceFactory.class;&#125;/** * @author liuenyuan * @see YamlPropertySource **/@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface YamlPropertySources &#123; YamlPropertySource[] value();&#125; 具体实现如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167import lombok.extern.slf4j.Slf4j;import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter;import org.springframework.beans.factory.config.YamlPropertiesFactoryBean;import org.springframework.context.EnvironmentAware;import org.springframework.context.ResourceLoaderAware;import org.springframework.context.annotation.Configuration;import org.springframework.core.Ordered;import org.springframework.core.annotation.AnnotationUtils;import org.springframework.core.annotation.Order;import org.springframework.core.env.*;import org.springframework.core.io.Resource;import org.springframework.core.io.ResourceLoader;import org.springframework.util.Assert;import java.io.IOException;import java.util.*;/** * 类描述: &#123;@link YamlPropertySource&#125; bean post processor.this class convert the yml or yaml file &#123;@link YamlPropertySource#value()&#125; to &#123;@link PropertiesPropertySource&#125;,and add the property source * named &#123;@link YmlPropertySource#name()&#125; into &#123;@link Environment&#125;.When you use this annotation,you * must for follow example: * &lt;pre&gt;&#123;@code * @link @ConfigurationProperties(prefix = "person") * @link @YmlPropertySource(value = &#123;"classpath:/hello.yml"&#125;, name = "hello") * @link @Data * public class PersonProperties &#123; * * private String name; * * private Integer age; * * private String school; * &#125;&#125;&lt;/pre&gt; * * @author liuenyuan * @date 2019/6/16 20:13 * @describe * @see YamlPropertySource * @see InstantiationAwareBeanPostProcessorAdapter * @see EnvironmentAware * @see ResourceLoaderAware */@Slf4j@Configuration(value = YamlPropertySourceAnnotationPostProcessor.BEAN_NAME)@Order(Ordered.HIGHEST_PRECEDENCE)public class YamlPropertySourceAnnotationPostProcessor extends InstantiationAwareBeanPostProcessorAdapter implements EnvironmentAware, ResourceLoaderAware &#123; public final static String BEAN_NAME = "yamlPropertySourceAnnotationPostProcessor"; private Environment environment; private ResourceLoader resourceLoader; private final List&lt;String&gt; propertySourceNames = new ArrayList&lt;&gt;(); private static final PropertySourceFactory DEFAULT_PROPERTY_SOURCE_FACTORY = new YamlPropertySourceFactory(); @Override public void setEnvironment(Environment environment) &#123; Assert.isInstanceOf(ConfigurableEnvironment.class, environment, "environment must be instance of ConfigurableEnvironment."); this.environment = environment; &#125; @Override public void setResourceLoader(ResourceLoader resourceLoader) &#123; this.resourceLoader = resourceLoader; &#125; @Override public boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException &#123; // Process any @PropertySource annotations Set&lt;YamlPropertySource&gt; yamlPropertySources = AnnotationUtils.getRepeatableAnnotations(bean.getClass(), YamlPropertySource.class, YamlPropertySources.class); if (!yamlPropertySources.isEmpty()) &#123; Set&lt;AnnotationAttributes&gt; attributesSet = new LinkedHashSet&lt;&gt;(yamlPropertySources.size()); for (YamlPropertySource yamlPropertySource : yamlPropertySources) &#123; AnnotationAttributes attributes = AnnotationUtils.getAnnotationAttributes(bean.getClass(), yamlPropertySource); attributesSet.add(attributes); &#125; for (AnnotationAttributes propertySource : attributesSet) &#123; if (this.environment instanceof ConfigurableEnvironment) &#123; try &#123; processPropertySource(propertySource); &#125; catch (IOException e) &#123; log.warn("exception message: &#123;&#125;", e.getMessage()); &#125; &#125; else &#123; log.warn("Ignoring @YamlPropertySource annotation on [" + bean.getClass() + "]. Reason: Environment must implement ConfigurableEnvironment"); &#125; &#125; &#125; return true; &#125; private void processPropertySource(AnnotationAttributes propertySource) throws IOException &#123; String name = propertySource.getString("name"); if (!StringUtils.hasLength(name)) &#123; name = null; &#125; String encoding = propertySource.getString("encoding"); if (!StringUtils.hasLength(encoding)) &#123; encoding = null; &#125; String[] locations = propertySource.getStringArray("value"); Assert.isTrue(locations.length &gt; 0, "At least one @YamlPropertySource(value) location is required"); boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound"); Class&lt;? extends PropertySourceFactory&gt; factoryClass = propertySource.getClass("factory"); PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ? DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass)); for (String location : locations) &#123; try &#123; String resolvedLocation = this.environment.resolveRequiredPlaceholders(location); Resource resource = this.resourceLoader.getResource(resolvedLocation); addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding))); &#125; catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) &#123; // Placeholders not resolvable or resource not found when trying to open it if (ignoreResourceNotFound) &#123; if (log.isInfoEnabled()) &#123; log.info("Properties or Yml or Yaml location [" + location + "] not resolvable: " + ex.getMessage()); &#125; &#125; else &#123; throw ex; &#125; &#125; &#125; &#125; private void addPropertySource(PropertySource&lt;?&gt; propertySource) &#123; String name = propertySource.getName(); MutablePropertySources propertySources = ((ConfigurableEnvironment) this.environment).getPropertySources(); if (this.propertySourceNames.contains(name)) &#123; // We've already added a version, we need to extend it PropertySource&lt;?&gt; existing = propertySources.get(name); if (existing != null) &#123; PropertySource&lt;?&gt; newSource = (propertySource instanceof ResourcePropertySource ? ((ResourcePropertySource) propertySource).withResourceName() : propertySource); if (existing instanceof CompositePropertySource) &#123; ((CompositePropertySource) existing).addFirstPropertySource(newSource); &#125; else &#123; if (existing instanceof ResourcePropertySource) &#123; existing = ((ResourcePropertySource) existing).withResourceName(); &#125; CompositePropertySource composite = new CompositePropertySource(name); composite.addPropertySource(newSource); composite.addPropertySource(existing); propertySources.replace(name, composite); &#125; return; &#125; &#125; if (this.propertySourceNames.isEmpty()) &#123; propertySources.addLast(propertySource); &#125; else &#123; String firstProcessed = this.propertySourceNames.get(this.propertySourceNames.size() - 1); propertySources.addBefore(firstProcessed, propertySource); &#125; this.propertySourceNames.add(name); &#125;&#125; 想法 使用InstantiationAwareBeanPostProcessorAdapter的postProcessAfterInstantiation(Object bean, String beanName)方法,然后通过YamlPropertiesFactoryBean将yml|yaml文件转换为properties文件,然后通过 实现EnvironmentAware接口,将配置文件属性写入到spring的Environment环境中。但是该实现有点 缺陷,就是如果使用@ConfigurationProperties和@EnableConfigurationProperties将配置属性 转换为JavaBean时,需要将@YmlProperySource注解标注到该JavaBean上。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>外部化配置</tag>
        <tag>yml|yaml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring类型转换]]></title>
    <url>%2F2019%2F08%2F06%2FSpring%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[Spring Type Conversion(Spring类型转换)1:概述:Spring3引入了core.convert包,提供了通用类型转换系统,定义了实现类型转换和运行时执行类型的SPI。 在Spring3.0之前,提供的PropertyEditor来将外部化bean属性值字符串转换成必需的实现类型。 2:Converter SPI12345678910111213141516171819202122232425/** * A converter converts a source object of type &#123;@code S&#125; to a target of type &#123;@code T&#125;. * * &lt;p&gt;Implementations of this interface are thread-safe and can be shared. * * &lt;p&gt;Implementations may additionally implement &#123;@link ConditionalConverter&#125;. * * @author Keith Donald * @since 3.0 * @param &lt;S&gt; the source type * @param &lt;T&gt; the target type */@FunctionalInterfacepublic interface Converter&lt;S, T&gt; &#123; /** * Convert the source object of type &#123;@code S&#125; to target type &#123;@code T&#125;. * @param source the source object to convert, which must be an instance of &#123;@code S&#125; (never &#123;@code null&#125;) * @return the converted object, which must be an instance of &#123;@code T&#125; (potentially &#123;@code null&#125;) * @throws IllegalArgumentException if the source cannot be converted to the desired target type */ @Nullable T convert(S source);&#125; 实现自定义的类型转换可以实现Converter接口。但是如果S是集合或者数组转换为T的集合或者数组, 建议参考诸如ArrayToCollectionConverter实现。前提是已经注册了委托数组或集合转换器。例如, DefaultConversionService实现。 Converter.convert(S source)中source确保不能为null,否则转换器可能抛出异常如果转换失败。具体 说,应该会抛出IllegalArgumentException报告不合理的转换源。确保Converter实现是线程安全。 在core.convert.support包下,注册了常见了类型转换器。例如: 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Converts from a String any JDK-standard Number implementation. * * &lt;p&gt;Support Number classes including Byte, Short, Integer, Float, Double, Long, BigInteger, BigDecimal. This class * delegates to &#123;@link NumberUtils#parseNumber(String, Class)&#125; to perform the conversion. * * @author Keith Donald * @since 3.0 * @see java.lang.Byte * @see java.lang.Short * @see java.lang.Integer * @see java.lang.Long * @see java.math.BigInteger * @see java.lang.Float * @see java.lang.Double * @see java.math.BigDecimal * @see NumberUtils */final class StringToNumberConverterFactory implements ConverterFactory&lt;String, Number&gt; &#123; @Override public &lt;T extends Number&gt; Converter&lt;String, T&gt; getConverter(Class&lt;T&gt; targetType) &#123; return new StringToNumber&lt;&gt;(targetType); &#125; private static final class StringToNumber&lt;T extends Number&gt; implements Converter&lt;String, T&gt; &#123; private final Class&lt;T&gt; targetType; public StringToNumber(Class&lt;T&gt; targetType) &#123; this.targetType = targetType; &#125; @Override public T convert(String source) &#123; if (source.isEmpty()) &#123; return null; &#125; return NumberUtils.parseNumber(source, this.targetType); &#125; &#125;&#125; 3:ConverterFactory当你需要集中整理类层次结构的类型转换器,可以使用ConverterFactory。例如StringToNumberConverterFactory, 该接口定义如下,当你需要范围转换器,可以转换这些对象从S类型转换成R的子类型。使用该接口。 1234567891011121314151617181920212223/** * A factory for "ranged" converters that can convert objects from S to subtypes of R. * * &lt;p&gt;Implementations may additionally implement &#123;@link ConditionalConverter&#125;. * * @author Keith Donald * @since 3.0 * @see ConditionalConverter * @param &lt;S&gt; the source type converters created by this factory can convert from * @param &lt;R&gt; the target range (or base) type converters created by this factory can convert to; * for example &#123;@link Number&#125; for a set of number subtypes. */public interface ConverterFactory&lt;S, R&gt; &#123; /** * Get the converter to convert from S to target type T, where T is also an instance of R. * @param &lt;T&gt; the target type * @param targetType the target type to convert to * @return a converter from S to T */ &lt;T extends R&gt; Converter&lt;S, T&gt; getConverter(Class&lt;T&gt; targetType);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Converts from a String any JDK-standard Number implementation. * * &lt;p&gt;Support Number classes including Byte, Short, Integer, Float, Double, Long, BigInteger, BigDecimal. This class * delegates to &#123;@link NumberUtils#parseNumber(String, Class)&#125; to perform the conversion. * * @author Keith Donald * @since 3.0 * @see java.lang.Byte * @see java.lang.Short * @see java.lang.Integer * @see java.lang.Long * @see java.math.BigInteger * @see java.lang.Float * @see java.lang.Double * @see java.math.BigDecimal * @see NumberUtils */final class StringToNumberConverterFactory implements ConverterFactory&lt;String, Number&gt; &#123; @Override public &lt;T extends Number&gt; Converter&lt;String, T&gt; getConverter(Class&lt;T&gt; targetType) &#123; return new StringToNumber&lt;&gt;(targetType); &#125; private static final class StringToNumber&lt;T extends Number&gt; implements Converter&lt;String, T&gt; &#123; private final Class&lt;T&gt; targetType; public StringToNumber(Class&lt;T&gt; targetType) &#123; this.targetType = targetType; &#125; @Override public T convert(String source) &#123; if (source.isEmpty()) &#123; return null; &#125; return NumberUtils.parseNumber(source, this.targetType); &#125; &#125;&#125; 4:GenericConverter GenericConverter提供多种源和目标类型之间转换,比Converter更灵活但是对类型要求不高。它提供了实现 转换逻辑的源和目标上下文。 这样的上下文允许类型转换由字段注释或在字段签名上声明的通用信息驱动。接口 如下: 12345678package org.springframework.core.convert.converter;public interface GenericConverter &#123; public Set&lt;ConvertiblePair&gt; getConvertibleTypes(); Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);&#125; ConvertiblePair持有转换源和目标类型对。convert(Object, TypeDescriptor, TypeDescriptor)。 源TypeDescriptor提供对保存正在转换的值的源字段的访问。 目标TypeDescriptor提供对要设置转换值的目标字段的访问。TypeDescriptor类是关于要转换类型的上下文。 一个好的实例是GenericConverter在Java数组和集合之间转换。例如ArrayToCollectionConverter。 注意 1因为GenericConverter是一个更复杂的SPI接口,所以只有在需要时才应该使用它.喜欢Converter或ConverterFactory以满足基本的类型转换需求。 5:ConditionalGenericConverter该接口是一个带有判断条件的类型转换器。该接口是GenericConverter和ConditionalConverter的组合。 123456789101112131415/** * A &#123;@link GenericConverter&#125; that may conditionally execute based on attributes * of the &#123;@code source&#125; and &#123;@code target&#125; &#123;@link TypeDescriptor&#125;. * * &lt;p&gt;See &#123;@link ConditionalConverter&#125; for details. * * @author Keith Donald * @author Phillip Webb * @since 3.0 * @see GenericConverter * @see ConditionalConverter */public interface ConditionalGenericConverter extends GenericConverter, ConditionalConverter &#123;&#125; ConditionalGenericConverter 的一个好示例是StringToCollectionConverter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Converts a comma-delimited String to a Collection. * If the target collection element type is declared, only matches if * &#123;@code String.class&#125; can be converted to it. * * @author Keith Donald * @author Juergen Hoeller * @since 3.0 */final class StringToCollectionConverter implements ConditionalGenericConverter &#123; private final ConversionService conversionService; public StringToCollectionConverter(ConversionService conversionService) &#123; this.conversionService = conversionService; &#125; @Override public Set&lt;ConvertiblePair&gt; getConvertibleTypes() &#123; return Collections.singleton(new ConvertiblePair(String.class, Collection.class)); &#125; @Override public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) &#123; return (targetType.getElementTypeDescriptor() == null || this.conversionService.canConvert(sourceType, targetType.getElementTypeDescriptor())); &#125; @Override @Nullable public Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) &#123; if (source == null) &#123; return null; &#125; String string = (String) source; String[] fields = StringUtils.commaDelimitedListToStringArray(string); TypeDescriptor elementDesc = targetType.getElementTypeDescriptor(); Collection&lt;Object&gt; target = CollectionFactory.createCollection(targetType.getType(), (elementDesc != null ? elementDesc.getType() : null), fields.length); if (elementDesc == null) &#123; for (String field : fields) &#123; target.add(field.trim()); &#125; &#125; else &#123; for (String field : fields) &#123; Object targetElement = this.conversionService.convert(field.trim(), sourceType, elementDesc); target.add(targetElement); &#125; &#125; return target; &#125;&#125; 6:ConversionService APIConversionService定义了一个统一的API,用于在运行时执行类型转换逻辑. 转换器通常在以下Facade接口后面执行。 12345678910111213package org.springframework.core.convert;public interface ConversionService &#123; boolean canConvert(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType); &lt;T&gt; T convert(Object source, Class&lt;T&gt; targetType); boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType); Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);&#125; 大多数ConversionService实现,同样也实现了ConverterRegistry,该接口提供了SPI来注册Converters. 在内部,ConversionService的实现,容器委托它来注册转换器来执行转换逻辑。 core.convert.support提供一个强大的ConversionService实现,该实现是GenericConversionSer ,它适用于大多数转换器环境实现。ConversionServiceFactory 来创建普通的ConversionService 配置。 7:配置ConversionService ConversionService被设计成无状态对象,在容器启动时被实例化,在多线程间进行共享(线程安全)。 在Spring应用中,可以自定义类型转换器。当需要框架进行类型转换时,Spring会选择合适的类型转换器 使用。你也可以注入ConversionService到beans或者直接调用。 注意 如果没有ConversionService注册到Spring容器,基于的PropertyEditor实现的类型转换会被使用。 ​ 使用如下的方式,注册默认ConversionService进Spring容器中: 12345678public class ConvertersConfiguration &#123; @Bean(name = "conversionService") public ConversionServiceFactoryBean conversionServiceFactory() &#123; ConversionServiceFactoryBean conversionServiceFactoryBean = new ConversionServiceFactoryBean(); return conversionServiceFactoryBean; &#125;&#125; 默认的ConversionService可以在字符串，数字，枚举，集合，映射和其他常见类型之间进行转换。要使用您自己的自定义转换器补充或覆盖默认转换器,请设置converter属性.属性值可以实现任何Converter,ConverterFactory或GenericConverter接口。默认ConversionService实现是DefaultConversionService。 12345678910public class ConvertersConfiguration &#123; @Bean(name = "conversionService") public ConversionServiceFactoryBean conversionServiceFactory() &#123; ConversionServiceFactoryBean conversionServiceFactoryBean = new ConversionServiceFactoryBean(); //实现自定义的类型转换器 conversionServiceFactoryBean.setConverters(Collections.singleton(new StringToDateConverter())); return conversionServiceFactoryBean; &#125;&#125; 也可以使用ConversionService在Spring MVC应用中,参考WebMvcConfigurationSupport类,该类方法 addFormatters(FormatterRegistry registry)可以注册自定义的converters。 在某些情况,希望在类型转换期间需要格式化,参考FormatterRegistry。 在程序中使用ConversionService 123456789101112@Servicepublic class MyService &#123; @Autowired public MyService(ConversionService conversionService) &#123; this.conversionService = conversionService; &#125; public void doIt() &#123; this.conversionService.convert(...) &#125;&#125; 8:Spring域属性格式化 core.convert是一个通用的类型转换系统.它提供了统一的ConversionService API以及强类型转换器SPI,用于实现从一种类型到另一种类型的转换逻辑.Spring容器使用这个系统来绑定bean属性值。额外的,还要SpEL和 DataBinder。Spring3引入了Formatter SPI来实现格式化属性值。ConversionService为两个SPI提供统一的类型转换API。 (1):Formatter SPI12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Formats objects of type T. * A Formatter is both a Printer &lt;i&gt;and&lt;/i&gt; a Parser for an object type. * * @author Keith Donald * @since 3.0 * @param &lt;T&gt; the type of object this Formatter formats */public interface Formatter&lt;T&gt; extends Printer&lt;T&gt;, Parser&lt;T&gt; &#123;&#125;/** * Parses text strings to produce instances of T. * * @author Keith Donald * @since 3.0 * @param &lt;T&gt; the type of object this Parser produces */@FunctionalInterfacepublic interface Parser&lt;T&gt; &#123; /** * Parse a text String to produce a T. * @param text the text string * @param locale the current user locale * @return an instance of T * @throws ParseException when a parse exception occurs in a java.text parsing library * @throws IllegalArgumentException when a parse exception occurs */ T parse(String text, Locale locale) throws ParseException;&#125;/** * Prints objects of type T for display. * * @author Keith Donald * @since 3.0 * @param &lt;T&gt; the type of object this Printer prints */@FunctionalInterfacepublic interface Printer&lt;T&gt; &#123; /** * Print the object of type T for display. * @param object the instance to print * @param locale the current user locale * @return the printed text string */ String print(T object, Locale locale);&#125; (2):Annotation-Driven Formatting域格式化可以通过域类型或者注解配置.为了绑定注解在一个Formatter,实现AnnotationFormatterFactory. 123456789101112131415161718192021package org.springframework.format;/** * A factory that creates formatters to format values of fields annotated with a particular * &#123;@link Annotation&#125;. * * &lt;p&gt;For example, a &#123;@code DateTimeFormatAnnotationFormatterFactory&#125; might create a formatter * that formats &#123;@code Date&#125; values set on fields annotated with &#123;@code @DateTimeFormat&#125;. * * @author Keith Donald * @since 3.0 * @param &lt;A&gt; the annotation type that should trigger formatting */public interface AnnotationFormatterFactory&lt;A extends Annotation&gt; &#123; Set&lt;Class&lt;?&gt;&gt; getFieldTypes(); Printer&lt;?&gt; getPrinter(A annotation, Class&lt;?&gt; fieldType); Parser&lt;?&gt; getParser(A annotation, Class&lt;?&gt; fieldType);&#125; 例如实现NumberFormatAnnotationFormatterFactory,绑定@NumberFormat注解到Formatter。 1234567891011121314151617181920212223242526272829303132333435363738public class NumberFormatAnnotationFormatterFactory extends EmbeddedValueResolutionSupport implements AnnotationFormatterFactory&lt;NumberFormat&gt; &#123; @Override public Set&lt;Class&lt;?&gt;&gt; getFieldTypes() &#123; return NumberUtils.STANDARD_NUMBER_TYPES; &#125; @Override public Printer&lt;Number&gt; getPrinter(NumberFormat annotation, Class&lt;?&gt; fieldType) &#123; return configureFormatterFrom(annotation); &#125; @Override public Parser&lt;Number&gt; getParser(NumberFormat annotation, Class&lt;?&gt; fieldType) &#123; return configureFormatterFrom(annotation); &#125; private Formatter&lt;Number&gt; configureFormatterFrom(NumberFormat annotation) &#123; String pattern = resolveEmbeddedValue(annotation.pattern()); if (StringUtils.hasLength(pattern)) &#123; return new NumberStyleFormatter(pattern); &#125; else &#123; Style style = annotation.style(); if (style == Style.CURRENCY) &#123; return new CurrencyStyleFormatter(); &#125; else if (style == Style.PERCENT) &#123; return new PercentStyleFormatter(); &#125; else &#123; return new NumberStyleFormatter(); &#125; &#125; &#125;&#125; (3):格式化注解APIDateTimeFormat和NumberFormat。 (4):FormatterRegistry SPIFormatterRegistry是用来注册formatters 和 converters的SPI。FormattingConversionService 是FormatterRegistry 一个实现,可以支持大多数环境。可以通过FormattingConversionServiceFactoryBean 来配置。也可以通过Spring’s DataBinder和SpEL。 123456789101112package org.springframework.format;public interface FormatterRegistry extends ConverterRegistry &#123; void addFormatterForFieldType(Class&lt;?&gt; fieldType, Printer&lt;?&gt; printer, Parser&lt;?&gt; parser); void addFormatterForFieldType(Class&lt;?&gt; fieldType, Formatter&lt;?&gt; formatter); void addFormatterForFieldType(Formatter&lt;?&gt; formatter); void addFormatterForAnnotation(AnnotationFormatterFactory&lt;?, ?&gt; factory);&#125; (5):FormatterRegistrar SPIFormatterRegistrar是通过FormatterRegistry注册formatters和converters的SPI。 123456package org.springframework.format;public interface FormatterRegistrar &#123; void registerFormatters(FormatterRegistry registry);&#125; 9:在Spring MVC配置Formatting12345678910Configuration@Slf4jpublic class WebConfiguration extends WebMvcConfigurationSupport &#123; @Override protected void addFormatters(FormatterRegistry registry) &#123; registry.addConverter(new StringToDateConverter()); &#125;&#125; 10:配置全局的Date和时间FormatJodaTimeFormatterRegistrar和DateFormatterRegistrar,使用Joda需要引入joda库 配置如下: 1234567891011121314151617181920@Configurationpublic class AppConfig &#123; @Bean public FormattingConversionService conversionService() &#123; // Use the DefaultFormattingConversionService but do not register defaults DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService(false); // Ensure @NumberFormat is still supported conversionService.addFormatterForFieldAnnotation(new NumberFormatAnnotationFormatterFactory()); // Register date conversion with a specific global format DateFormatterRegistrar registrar = new DateFormatterRegistrar(); registrar.setFormatter(new DateFormatter("yyyyMMdd")); registrar.registerFormatters(conversionService); return conversionService; &#125;&#125; 注意 Joda-Time提供不同类型表示日期date,time,datetime,需要通过JodaTimeFormatterRegistrar进行 注册。或者使用DateTimeFormatterFactoryBean来进行创建formatters。 如果您使用Spring MVC,请记住明确配置使用的转换服务.对于基于Java的@Configuration,这意味着扩展WebMvcConfigurationSupport类并覆盖mvcConversionService()方法.对于XML,您应该使用mvc:annotation-driven元素的conversion-service属性。 有关详细信息，请参阅转换和格式。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Spring Type Converter</tag>
        <tag>单例设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring注解属性覆盖]]></title>
    <url>%2F2019%2F08%2F06%2FSpring%E6%B3%A8%E8%A7%A3%E5%B1%9E%E6%80%A7%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[Spring注解属性覆盖1:隐性覆盖较低层次的注解覆盖其元注解的同名属性 AnnotationAttributes采用注解就近覆盖的设计原则。 @Component ​ | -@Service ​ | -@TransactionalService @Service较@Component,距离@TransactionalService注解更近，属于较低层次的注解。 2:显性覆盖@AliasFor提供的属性覆盖能力。 (1):理解Spring注解属性别名(Aliases) @AliasFor可用于同一注解属性方法之间相互别名。同一注解两个属性方法需要相互 “@AliasFor”，默认值必须相等。 多层次注解属性之间的@AliasFor关系只能由较低层次向较高层次建立。即就近原则。 AnnotatedElementUtils.getMergedAnnotationAttributes方法也符合属性别名完整语义。 Spring为Spring元注解和@AliasFor提供了属性覆盖和别名特性，最终由AnnotationAttributes 对象表达语义。 (2):代码实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 类描述:组合注解 * * @author liuenyuan * @date 2019/4/25 20:11 * @describe */@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Transactional//表明注解属性覆盖符合就近原则,由低层次向高层次建立。@Service(value = "transactionalService")public @interface TransactionalService &#123; /** * @return 服务Bean名称 **/ @AliasFor("value") String name() default "txManager"; /** * 覆盖&#123;@link Transactional#transactionManager()&#125;默认值 * * @return &#123;@link org.springframework.transaction.PlatformTransactionManager&#125;Bean名称,默认关联 * &lt;br/&gt; * "txManager"Bean **/ /** * String transactionManager() default "txManager"; **/ @AliasFor("name") String value() default "txManager"; /** * 建立&#123;@link Transactional#transactionManager()&#125;别名 * * @return &#123;@link org.springframework.transaction.PlatformTransactionManager&#125;Bean名称,默认关联 * "txManager"Bean. **/ @AliasFor(annotation = Transactional.class, attribute = "transactionManager") String manager() default "txManager";&#125; 3:重要的类1：ClassPathBeanDefinitionScanner 读取类路径下的候选Bean，默认选取@Component，@Service，@Repository，@Controller注解的类。继承了ClassPathScanningCandidateComponentProvider。在该类BeanDefinition集合的候选条件由includeFilters和excludeFilters字段决定，在方法isCandidateComponent里实现。 该类允许自定义类型过滤规则。常见的TypeFilter类。 AnnotationTypeFilter：匹配类是否还有指定注解 AssignableTypeFilter：判定此 Class 对象所表示的类或接口与指定的 Class 参数所表示的类或接口是否相同，或是否是其超类或超接口。 RegexPatternTypeFilter：匹配全类限定名是否符合指定正则表达式。 AspectJTypeFilter：使用AspectJ类型模式进行匹配 2：类元信息读取 (1)：MetadataReaderFactory：生成MetadataReader工厂 SimpleMetadataReaderFactory：使用ASM字节码操作技术 CachingMetadataReaderFactory：使用ASM字节码操作技术和带缓存。 (2)：使用Java反射获取类元信息 StandardClassMetadata：读取Class元信息 StandardAnnotationMetadata：读取注解元信息 StandardMethodMetadata：读取方法 (3)：使用ASM操作 AnnotationMetadataReadingVisitor：查找类上元注解信息 MethodMetadataReadingVisitor：查找方法上元注解信息 AnnotationAttributesReadingVisitor：元注解属性读取 (4)：类注解元信息读取接口 AnnotationMetadata：读取注解。通过getAnnotationTypes(String)获取”元注解” 信息，提供getAnnotationAttributes(String)方法获取指定注解的属性方法。 ClassMetadata：类注解 AnnotatedTypeMetadata：注解的元注解 3：Spring注解属性抽象 AnnotationAttributes AnnotatedElementUtils：对查找注解，元注解等注解的工具类 AnnotationUtils：用于处理注解的工具类。 ReflectionUtils：反射工具类。 代码示例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 类描述: 组合注解启动类 * * @author liuenyuan * @date 2019/4/25 20:14 * @describe */@TransactionalServicepublic class ComposeAnnotationApplication &#123; public static void main(String[] args) throws IOException &#123; String className = ComposeAnnotationApplication.class.getName(); //构建MetadataReaderFactory MetadataReaderFactory metadataReaderFactory = new CachingMetadataReaderFactory(); //读取@TransactionalService MetadataReader信息 MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className); //读取@TransactionalService AnnotationMetadata信息 AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); annotationMetadata.getAnnotationTypes().forEach(annotationType -&gt; &#123; Set&lt;String&gt; metaAnnotationTypes = annotationMetadata.getMetaAnnotationTypes(annotationType); metaAnnotationTypes.forEach(metaAnnotationType -&gt; System.out.println(String.format( "注解 %s 元标注; %s\n", annotationType, metaAnnotationType))); &#125;); &#125;&#125; @Test public void springStandardAnnotationMetadata() &#123; //读取@TransactionalService AnnotationMetadata信息 AnnotationMetadata annotationMetadata = new StandardAnnotationMetadata(ComposeAnnotationReflectionApplication.class); //获取所有的元注解(全类名)集合 Set&lt;String&gt; metaAnnotationTypes = annotationMetadata.getAnnotationTypes() .stream() //读取单注解元注解类型集合 .map(annotationMetadata::getMetaAnnotationTypes) //合并元注解类型集合 .collect(LinkedHashSet::new, Set::addAll, Set::addAll); //读取所有元注解类型 metaAnnotationTypes.forEach(metaAnnotation -&gt; &#123; //读取元注解属性 Map&lt;String, Object&gt; annotationAttributes = annotationMetadata.getAnnotationAttributes(metaAnnotation); if (!CollectionUtils.isEmpty(annotationAttributes)) &#123; annotationAttributes.forEach((name, value) -&gt; System.out.printf("注解 %s 属性 %s = %s\n", ClassUtils.getShortName(metaAnnotation), name, value)); &#125; &#125;); &#125; Spring从4.0.0.RELEASE版本开始支持多层次@Component派生性。 1:Spring中@Component,@Repository,@Service,@Controller就属于@Component派生注解。 称之为Spring模式注解。 4:注解驱动过渡时代：Spring Framework 2.x新引入了一些骨架式的Annotation 依赖注入Annotation：@Autowired(可注入单个Bean，也可注入集合)—&gt;限定类型Class方式。 依赖查找Annotation：@Qualifier 组件声明Annotation：@Component,@Service Spring MVC Annotation：@Controller,@RequestMapping,@ModelAttributes等。 支持可扩展的XML编写。即Spring的Schema和Handlers机制。 支持JSR-250规范@Resource注入，@PostConstruct，@PreDestroy等。 总结Spring2.5允许自定义Spring模式注解，不过该版本仅支持单层次的模式注解“派生”。但是编程手段不多，**主要 的原因在于框架层次仍未注解提供驱动注解的Spring应用上下文，并且仍需要XML配置驱动，即XML元素&lt;context:annotation-config&gt;和&lt;context-component-scan&gt;。 5:注解驱动黄金时代：Spring Framework 3.x全面拥抱Java5(泛型,变量参数等)，以及Spring Annotation引入。例如引入了配置类注解@Configuration,AnnotationConfigApplicationContext。但是没有引入替换&lt;context:component-scan/&gt;注解。 选择过渡方案@Import,@ImportResource(需要标注@Configuration注解)。Spring3.1引入注解@ComponentScan。引入了REST开发。 SpringWeb整合了Servlet3.0+按规范，利用javax.servlet.ServletContainerInitialier API实现传统Servlet容器 自动装配的能力，替换了传统的web.xml。 1:Spring3.1抽象了一套全新并统一配置属性API,包括配置属性存储接口Environment,以及配置属性源抽象PropertySource，这两个核心API奠定了SpringBoot外部化配置的基础，也是SpringCloud分布式配置基石。 2:然后是缓存抽象，主要API包括缓存Cache和缓存管理器CacheManager。配套注解Caching和Cacheable等 极大简化了数据缓存开发。 3:异步支持，引入了异步操作注解@Async,周期异步操作@Scheduled及异步Web请求处理操作DefferedResult。 4:校验方面，新增了注解@Validated，整合JSR-303和适配了Spring早期的Validator抽象。 5:Enabled模块驱动特性。将相同职责功能组件以模块化的方式装配。例如EnabledWebMvc。 6:注解驱动完善时代:Spring Framework 4.x引入了条件化注解@Conditional，通过与自定义Condition实现配合，弥补之前版本条件化配置装配的 短板。SpringBoot的所有@ConditionalOn注解均基于@Conditional派生注解，其抽象类*SpringBootCondition**也是Condition的实现。 Spring4.x兼容了Java Time API(JSR-310),@Repeatable及参数名称发现。Java8的@Repeatable出现，解决了 以往Annotation无法重复标注同一个类的限制。Spring4.2引入了事件监听器注解@EventListener。 Spring的派生特性需要确保注解之间属性方法签名一致。限制在Spring4.2新注解@AliasFor解除，实现了 同一注解类属性方法之间的别名。Spring4.3引入REST请求注解。 Spring4.x在Web注解驱动编程也有提示，例如@RestController,@RestControllerAdvice(对RestController AOP拦截通知)。 7:注解驱动当下时代:Spring Framework5.x在SpringBoot应用场景中，大量使用注解@ComponentScan扫描指定package,当扫描package所包含的类越多时, Spring模式注解耗费时间越长。针对这个问题,Spring5.x新引入了注解@Indexed,为Spring模式注解添加索引，提升启动性能。需要引入spring-context-indexer依赖。 7-1:Spring核心注解场景分类Spring模式注解: Spring注解 场景说明 起始版本 @Repository 数据仓库模式注解 2.0 @Component 通用组件模式注解 2.5 @Service 服务模式 2.5 @Controller Web控制器模式注解 2.5 @Configuration 配置类模式注解 3.0 装配注解 Spring注解 场景说明 起始版本 @ImportResource 替换XML元素&lt;import&gt; 2.5 @Import 限定@Autowired依赖注解范围 2.5 @ComponentScan 扫描指定package下标注Spring模式注解 3.1 依赖注入注解 Spring注解 场景说明 起始版本 @Autowired Bean依赖注解,支持多种依赖查找方式 2.5 @Qualifier 细粒度的@Autowired依赖查找 2.5 Java注解 场景说明 起始版本 @Resource Bean依赖注入,仅支持名称依赖查找 2.5 Bean定义注解 Spring注解 场景说明 起始版本 @Bean 替换XML元素&lt;bean&gt; 3.0 @DependsOn 替换XML属性&lt;bean depends-on=”…”/&gt; 3.0 @Lazy 替换XML属性&lt;bean lazy-init=”trus|false”/&gt; 3.0 @Primary 替换XML元素&lt;bean primary=”true|false”/&gt; 3.0 @Role 替换XML元素&lt;bean role=”…”/&gt; 3.1 @Lookup 替换XML属性&lt;bean lookup-method=”…”&gt; 4.1 Spring条件装配注解 Spring注解 场景说明 起始版本 @Profile 配置化条件装配 3.1 @Conditional 编程条件装配 3.1 配置属性注解 Spring注解 场景说明 起始版本 @PropertySource 配置属性抽象PropertySource注解 3.1 @PropertySources @PropertySource集合注解 4.0 生命周期回调注解 Java注解 场景说明 起始版本 @PostContruct 替换XML元素&lt;bean init-method=”…”/&gt; 2.5 @PreDestroy 替换XML元素&lt;bean destroy-method=”…”/&gt; 2.5 注解属性注解 Spring注解 场景说明 起始版本 @AliasFor 别名注解属性,实现复用目的 4.2 性能注解 Spring注解 场景说明 起始版本 @Indexed 提升Spring模式注解扫描效率 5.0 8:AnnotationMetadata注解的实现 在AnnotationMetadata语义上,基于Java反射StandardAnnotationMetadata和AnnotationMetadataReadingVisitor保持一致。基于Java反射API实现必然需要反射的Class被ClassLoader加载，当指定Java Package扫描Spring模式注解时,StandardAnnotationMetadata显然不适应。 因为应用不需要将指定Package下的Class全部加载。基于ASM实现的AnnotationMetadataReadingVisitor更适合这种场景，解释了为什么该类出现ClassPathScanningCandidateComponentProvider实现中。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Annotation</tag>
        <tag>Spring注解属性覆盖</tag>
        <tag>Spring核心注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Guava简介]]></title>
    <url>%2F2019%2F08%2F06%2FGuava%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[1.引言Guava工程包含了若干被Google的 Java项目广泛依赖 的核心库，例如：集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [common annotations] 、字符串处理 [string processing] 、I/O 等等。 所有这些工具每天都在被Google的工程师应用在产品服务中。 2.基本工具 使用和避免null: Optional 前置条件: Preconditions 常见Object方法: Objects 排序: Guava强大的”流畅风格比较器”: Ordering Throwables: 简化了异常和错误的传播与检查 : Throwables 编码类型: Charsets 3.集合 不可变集合: 用不变的集合进行防御性编程和性能提升: Immutable开头。 新集合类型: multisets, multimaps, tables, bidirectional maps等 强大的集合工具类: 提供java.util.Collections中没有的集合工具 扩展工具类：让实现和扩展集合类变得更容易，比如创建Collection的装饰器，或实现迭代器 4.缓存[Caches]Guava Cache: 本地缓存实现,支持多种缓存过期策略。 5.函数式风格[Functional idioms]Guava函数式支持可以显著简化代码,但请谨慎使用。 6.并发[Concurrency] ListenableFuture：完成后触发回调的Future Service框架：抽象可开启和关闭的服务，帮助你维护服务的状态逻辑 7.字符串处理[Strings]非常有用的字符串工具，包括分割、连接、填充等操作 8.原生类型[Primitives]扩展 JDK 未提供的原生类型（如int、char）操作， 包括某些类型的无符号形式 9.区间[Ranges]可比较类型的区间API，包括连续和离散类型 10.I/O简化I/O尤其是I/O流和文件的操作，针对Java5和6版本 11.散列[Hash]提供比Object.hashCode()更复杂的散列实现，并提供布鲁姆过滤器的实现 12. 事件总线[EventBus]发布-订阅模式的组件通信，但组件不需要显式地注册到其他组件中 13.数学运算[Math]优化的、充分测试的数学工具类 14.反射[Reflection]Guava 的 Java 反射机制工具类]]></content>
      <categories>
        <category>Guava</category>
      </categories>
      <tags>
        <tag>Guava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot自动配置原理]]></title>
    <url>%2F2019%2F08%2F05%2FSpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[SpringBoot自动配置原理1:产生背景 在Spring Framework时代,当Spring应用的@Component或者@Configuration Class需要被装配 时,应用需要借助@Import或者@ComponentScan的能力。由于应用依赖的Jar存在变化的可能, 因此其中的@Component或者@Configuration Class所在的包路径也会发生变化。 不鼓励开发人员通过@ComponentScan或者@SpringApplication注解方式扫描默认包。因为 它读取所有JAR中类,并且可能会造成默认Spring Boot错误 当Spring应用自动装配某些组件时,它需要一种综合性技术手段,重新深度结合Spring注解编程 模型,@Enable模块驱动和条件装配等Spring Framework原生特性,这种技术就是Spring Boot 自动装配。 2:理解Spring Boot自动装配(1):理解@EnableAutoConfiguration 用于激活Spring Boot自动装配特性。 (2):优雅的替换自动装配 开发人员可在任意一处定义配置类,从而覆盖那些被自动装配的组件。SpringBoot优先解析 自定义配置类。内建的配置类,一旦应用存在自定义实现，就不会再装配。 (3):失效自动装配 SpringBoot提供两种失效手段 代码配置方式 配置类型安全属性方法:@EnableAutoConfiguration.exclude() 配置排除类名方式:@EnableAutoConfiguration.excludeName() 外部化配置方式 配置属性:spring.autoconfigure.exclude 3:自动装配原理 依照@Enable模块驱动设计模式，@EnableAutoConguration必然是@Import 类ImportSelector 或者ImportBeanDefinitionRegistrar的实现类。 AutoConfigurationImportSelector主要执行逻辑: 1234567891011121314151617181920212223242526public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; //读取自动装配元信息配置文件 //"META-INF/"+ "spring-autoconfigure-metadata.properties" AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader .loadMetadata(this.beanClassLoader); //获取@EnableAutoConfiguration注解属性 AnnotationAttributes attributes = getAttributes(annotationMetadata); //获取自动装配Class候选列表 List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); //移除重复的自动装配类名 configurations = removeDuplicates(configurations); //排除自动装配组件 Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); //检查排除类名集合是否合法 checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); //过滤候选自动装配组件集合中Class不存在成员 configurations = filter(configurations, autoConfigurationMetadata); //触发自动装配导入事件 fireAutoConfigurationImportEvents(configurations, exclusions); return StringUtils.toStringArray(configurations);&#125; (1):读取候选装配组件 使用了Spring工厂加载类SpringFactoriesLoader。原理如下 搜索指定ClassLoader下所有的META-INF/spring.factories资源内容。 将一个或者多个META-INF/spring.factories资源内容作为Properties文件读取,并合并为 一个Key为接口的全类限定名,Value是实现类的全类名列表的Map,作为返回值。 再从上一步返回Map中查找并返回方法指定类名所映射的实现类全类名列表。 SpringBoot自动装配列表存在地方 spring-boot-autoconfigure模块 spring-boot-actuator-autoconfigure模块 spring-boot-devtools模块(可选) 由于@EnableAutoConfiguration配置可能存在配置组件类名重复定义情况,当获取所有候选类, 立即执行removeDuplicates(List)方法,利用Set不可重复性达到去重的目的。 (2):排除自动装配组件 当getExclusions(AnnotationMetadata metadata,AnnotationAttributes attributes) 执行后,程序将获取到一个自动装配Class排除列表。随后检查排除类名集合是否合法。当排除类 存在于当前的ClassLoader但是不在自动装配名单中,将触发排除类非法异常。 1234567891011121314private void checkExcludedClasses(List&lt;String&gt; configurations, Set&lt;String&gt; exclusions) &#123; List&lt;String&gt; invalidExcludes = new ArrayList&lt;&gt;(exclusions.size()); for (String exclusion : exclusions) &#123; //存在当前ClassLoader但是不在自动装配列表名单 if (ClassUtils.isPresent(exclusion, getClass().getClassLoader()) &amp;&amp; !configurations.contains(exclusion)) &#123; invalidExcludes.add(exclusion); &#125; &#125; if (!invalidExcludes.isEmpty()) &#123; handleInvalidExcludes(invalidExcludes); &#125;&#125; (3):过滤自动装配组件 移除排除类名单后Configurations配合AutoConfigurationMetadata对象执行过滤操作。 (4):@EnableAutoConfiguration自动装配事件 SpringBoot1.5开始引入AutoConfigurationImportListener接口,自定义Java EventListener ,仅监听AutoConfigurationImportEvent,然后实例同样被SpringFactoriesLoader加载。其中, ConditionEvaluationReportAutoConfigurationImportListener就是内建实现,用于 记录自动装配组件的条件评估详情。 (5):EnableAutoConfiguration自动装配生命周期 DeferredImportSelector作为ImportSelector变种,它在@Configuration Bean处理完毕 后才运作。在@Conditional场景尤为有用，同时该实现类可通过Ordered接口或者@Order 方式调整其优先顺序。 该接口提供两类方法: process()和selectImports()。前者二次处理selectImports()方法返回 的结果，后者负责决定本组应该导入的Configuration Class作为实际导入的结果。 (6):EnableAutoConfiguration排序自动装配组件 SpringBoot提供两种自动装配组件排序手段: 绝对自动装配顺序:@AutoConfigurationOrder 相对自动装配顺序:@AutoConfigurationBefore和@AutoConfigurationAfter。(常用) (7):EnableAutoConfiguration自动装配BasePackages SpringBoot1.3开始引用注解@AutoConfigurationPackage。 该注解的实现类常常用于默认包获取。例如JPA实现获取默认包。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>自动配置原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[@Enable模块驱动原理]]></title>
    <url>%2F2019%2F08%2F05%2FEnable%E6%A8%A1%E5%9D%97%E9%A9%B1%E5%8A%A8%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[@Enable模块驱动原理1:概述@Enable模块驱动在Spring3.1后开始支持。这里的模块指具备相同领域的功能组件集合,组合所形成的一个独立的单元。例如Web MVC模块,AspectJ代理模块,Caching模块,JMX模块,Async模块等。通过@Enable模块驱动,可以开启响应的模块功能。 @Enable模块驱动可以分为”注解驱动”和”接口编程”两种实现方式。都需要配合@Import注解。 注解驱动:通过@Configuration类和@Bean方法声明类。例如Web MVC模块实现,即@EnableWebMvc注解通过导入DelegatingWebMvcConfiguration来实现。 接口编程:ImportSelector和ImportBeanDefinitionRegistrar的实现类。例如Caching模块实现,即 @EnableCaching注解通过导入CachingConfigurationSelector实现。 2:实现示例(1):注解驱动基于ImportSelector接口 @EnableWebMvc模块实现: 123456@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Documented@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc &#123;&#125; 该注解通过@Import导入一个配置类DelegatingWebMvcConfiguration: 1234@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; ......&#125; 该配置类又继承自WebMvcConfigurationSupport,里面定义一些Web Mvc必须Bean声明。 所以，基于注解驱动的@Enable模块驱动其实就是通过@Import来导入一个配置类，以此实现相应模块的组件注册，当这些组件注册到IOC容器中，这个模块对应的功能也就可以使用了。 (2):接口编程@EnableCaching模块实现。 123456789101112131415@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(CachingConfigurationSelector.class)public @interface EnableCaching &#123; boolean proxyTargetClass() default false; AdviceMode mode() default AdviceMode.PROXY; int order() default Ordered.LOWEST_PRECEDENCE;&#125; @EnableCaching*注解通过@Import导入CachingConfigurationSelector类,该类间接实现了ImportSelector*。 ImportSelector使用Spring注解元信息抽象AnnotationMetadata作为方法参数,该参数内容为导入ImportSelector实现的@Configuration类元信息,进而动态的选择一个或者多个其他@Configuration类进行导入。 1234567891011121314151617181920212223242526272829303132333435363738&gt; /**&gt; * Interface to be implemented by types that determine which @&#123;@link Configuration&#125;&gt; * class(es) should be imported based on a given selection criteria, usually one or more&gt; * annotation attributes.&gt; *&gt; * &lt;p&gt;An &#123;@link ImportSelector&#125; may implement any of the following&gt; * &#123;@link org.springframework.beans.factory.Aware Aware&#125; interfaces, and their respective&gt; * methods will be called prior to &#123;@link #selectImports&#125;:&gt; * &lt;ul&gt;&gt; * &lt;li&gt;&#123;@link org.springframework.context.EnvironmentAware EnvironmentAware&#125;&lt;/li&gt;&gt; * &lt;li&gt;&#123;@link org.springframework.beans.factory.BeanFactoryAware BeanFactoryAware&#125;&lt;/li&gt;&gt; * &lt;li&gt;&#123;@link org.springframework.beans.factory.BeanClassLoaderAware BeanClassLoaderAware&#125;&lt;/li&gt;&gt; * &lt;li&gt;&#123;@link org.springframework.context.ResourceLoaderAware ResourceLoaderAware&#125;&lt;/li&gt;&gt; * &lt;/ul&gt;&gt; *&gt; * &lt;p&gt;ImportSelectors are usually processed in the same way as regular &#123;@code @Import&#125;&gt; * annotations, however, it is also possible to defer selection of imports until all&gt; * &#123;@code @Configuration&#125; classes have been processed (see &#123;@link DeferredImportSelector&#125;&gt; * for details).&gt; *&gt; * @author Chris Beams&gt; * @since 3.1&gt; * @see DeferredImportSelector&gt; * @see Import&gt; * @see ImportBeanDefinitionRegistrar&gt; * @see Configuration&gt; */&gt; public interface ImportSelector &#123;&gt; &gt; /**&gt; * Select and return the names of which class(es) should be imported based on&gt; * the &#123;@link AnnotationMetadata&#125; of the importing @&#123;@link Configuration&#125; class.&gt; */&gt; String[] selectImports(AnnotationMetadata importingClassMetadata);&gt; &gt; &#125;&gt; &gt; 基于ImportBeanDefinitionRegistrar接口 @MapperScan模块实现 12345678910111213141516171819202122232425public class MapperScannerRegistrar implements ImportBeanDefinitionRegistrar, ResourceLoaderAware &#123; private ResourceLoader resourceLoader; /** * &#123;@inheritDoc&#125; */ @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; AnnotationAttributes annoAttrs = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName())); ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry); ... Class&lt;? extends Annotation&gt; annotationClass = annoAttrs.getClass("annotationClass"); if (!Annotation.class.equals(annotationClass)) &#123; scanner.setAnnotationClass(annotationClass); &#125; ... scanner.registerFilters(); scanner.doScan(StringUtils.toStringArray(basePackages)); &#125; ....&#125; 该接口的编程复杂度相比较于ImportSelector更高,接口将Bean定义的注册交给开发人员。常常配合ClassPathBeanDefinitionScanner类进行批量注册BeanDefinition。 ImportBeanDefinitionRegistrar:除注解元信息AnnotationMetadata作为入参外,接口将 Bean定义注册交给开发人员。 12345678910111213141516171819202122232425262728293031323334353637383940414243&gt; /**&gt; * Interface to be implemented by types that register additional bean definitions when&gt; * processing @&#123;@link Configuration&#125; classes. Useful when operating at the bean definition&gt; * level (as opposed to &#123;@code @Bean&#125; method/instance level) is desired or necessary.&gt; *&gt; * &lt;p&gt;Along with &#123;@code @Configuration&#125; and &#123;@link ImportSelector&#125;, classes of this type&gt; * may be provided to the @&#123;@link Import&#125; annotation (or may also be returned from an&gt; * &#123;@code ImportSelector&#125;).&gt; *&gt; * &lt;p&gt;An &#123;@link ImportBeanDefinitionRegistrar&#125; may implement any of the following&gt; * &#123;@link org.springframework.beans.factory.Aware Aware&#125; interfaces, and their respective&gt; * methods will be called prior to &#123;@link #registerBeanDefinitions&#125;:&gt; * &lt;ul&gt;&gt; * &lt;li&gt;&#123;@link org.springframework.context.EnvironmentAware EnvironmentAware&#125;&lt;/li&gt;&gt; * &lt;li&gt;&#123;@link org.springframework.beans.factory.BeanFactoryAware BeanFactoryAware&#125;&gt; * &lt;li&gt;&#123;@link org.springframework.beans.factory.BeanClassLoaderAware BeanClassLoaderAware&#125;&gt; * &lt;li&gt;&#123;@link org.springframework.context.ResourceLoaderAware ResourceLoaderAware&#125;&gt; * &lt;/ul&gt;&gt; *&gt; * &lt;p&gt;See implementations and associated unit tests for usage examples.&gt; *&gt; * @author Chris Beams&gt; * @since 3.1&gt; * @see Import&gt; * @see ImportSelector&gt; * @see Configuration&gt; */&gt; public interface ImportBeanDefinitionRegistrar &#123;&gt; &gt; /**&gt; * Register bean definitions as necessary based on the given annotation metadata of&gt; * the importing &#123;@code @Configuration&#125; class.&gt; * &lt;p&gt;Note that &#123;@link BeanDefinitionRegistryPostProcessor&#125; types may &lt;em&gt;not&lt;/em&gt; be&gt; * registered here, due to lifecycle constraints related to &#123;@code @Configuration&#125;&gt; * class processing.&gt; * @param importingClassMetadata annotation metadata of the importing class&gt; * @param registry current bean definition registry&gt; */&gt; public void registerBeanDefinitions(&gt; AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry);&gt; &gt; &#125;&gt; 3:@Enable模块驱动原理1:概述 @Enable模块驱动,模块无论来自于Spring内建,还是自定义,均使用@Import实现,并且该注解的职责在于装载导入类,将其定义为Spring Bean。导入主要为@Configuration Class,ImportSelector实现及ImportBeanDefinitionRegistrar实现。 2:源码实现 (1):装载@Configuration Class。 @Configuration从Spring3.0开始引入,该版本还未引入@ComponentScan。因此,开发人员经常看到XML元素&lt;context:component-scan/&gt;与&lt;context:annotation-config&gt;同时存在。根据Spring的”可扩展XML编写”特性,可以知道&lt;context:annotation-config&gt;所对应的BeanDefinitionParser实现为AnnotationConfigBeanDefinitionParser。 AnnotationConfigBeanDefinitionParser 1234567891011121314151617181920212223/** * Parser for the &amp;lt;context:annotation-config/&amp;gt; element. * * @author Mark Fisher * @author Juergen Hoeller * @author Christian Dupuis * @since 2.5 * @see AnnotationConfigUtils */public class AnnotationConfigBeanDefinitionParser implements BeanDefinitionParser &#123; @Override public BeanDefinition parse(Element element, ParserContext parserContext) &#123; Object source = parserContext.extractSource(element); // Obtain bean definitions for all relevant BeanPostProcessors. Set&lt;BeanDefinitionHolder&gt; processorDefinitions = AnnotationConfigUtils.registerAnnotationConfigProcessors(parserContext.getRegistry(), source); ... return null; &#125;&#125; AnnotationConfigUtils在Spring3.0增加了@Configuration Class的处理实现ConfigurationClassPostProcessor: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class AnnotationConfigUtils &#123; /** * The bean name of the internally managed Configuration annotation processor. */ public static final String CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME = &quot;org.springframework.context.annotation.internalConfigurationAnnotationProcessor&quot;; /** * The bean name of the internally managed BeanNameGenerator for use when processing * &#123;@link Configuration&#125; classes. Set by &#123;@link AnnotationConfigApplicationContext&#125; * and &#123;@code AnnotationConfigWebApplicationContext&#125; during bootstrap in order to make * any custom name generation strategy available to the underlying * &#123;@link ConfigurationClassPostProcessor&#125;. * @since 3.1.1 */ public static final String CONFIGURATION_BEAN_NAME_GENERATOR = &quot;org.springframework.context.annotation.internalConfigurationBeanNameGenerator&quot;; ... /** * Register all relevant annotation post processors in the given registry. * @param registry the registry to operate on */ public static void registerAnnotationConfigProcessors(BeanDefinitionRegistry registry) &#123; registerAnnotationConfigProcessors(registry, null); &#125; public static Set&lt;BeanDefinitionHolder&gt; registerAnnotationConfigProcessors( BeanDefinitionRegistry registry, Object source) &#123; ... Set&lt;BeanDefinitionHolder&gt; beanDefs = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(4); if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; ... return beanDefs; &#125; ...&#125; 简单的说,ConfigurationClassPostProcessor无论实在XML配置驱动还是在注解驱动使用场景下,均通过AnnotationConfigUtils.registerAnnotationConfigProcessors(registry,source)方法执行得到装载,且为最高优先级。不但处理了@Configuration Class,也负责@Bean方法的Bean定义。 (2):ConfigurationClassPostProcessor处理 //主要处理方法落在processConfigBeanDefinitions(registry) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173public class ConfigurationClassPostProcessor implements BeanDefinitionRegistryPostProcessor, PriorityOrdered, ResourceLoaderAware, BeanClassLoaderAware, EnvironmentAware &#123; ... /** * Prepare the Configuration classes for servicing bean requests at runtime * by replacing them with CGLIB-enhanced subclasses. */ @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123; int factoryId = System.identityHashCode(beanFactory); if (this.factoriesPostProcessed.contains(factoryId)) &#123; throw new IllegalStateException( "postProcessBeanFactory already called on this post-processor against " + beanFactory); &#125; this.factoriesPostProcessed.add(factoryId); if (!this.registriesPostProcessed.contains(factoryId)) &#123; // BeanDefinitionRegistryPostProcessor hook apparently not supported... // Simply call processConfigurationClasses lazily at this point then. processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory); &#125; enhanceConfigurationClasses(beanFactory); beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory)); &#125; /** * Build and validate a configuration model based on the registry of * &#123;@link Configuration&#125; classes. */ public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) &#123; List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;BeanDefinitionHolder&gt;(); String[] candidateNames = registry.getBeanDefinitionNames(); for (String beanName : candidateNames) &#123; BeanDefinition beanDef = registry.getBeanDefinition(beanName); if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) &#123; ... &#125; else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) &#123; configCandidates.add(new BeanDefinitionHolder(beanDef, beanName)); &#125; &#125; // Return immediately if no @Configuration classes were found if (configCandidates.isEmpty()) &#123; return; &#125; // Sort by previously determined @Order value, if applicable Collections.sort(configCandidates, new Comparator&lt;BeanDefinitionHolder&gt;() &#123; @Override public int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) &#123; int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition()); int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition()); return (i1 &lt; i2) ? -1 : (i1 &gt; i2) ? 1 : 0; &#125; &#125;); // Detect any custom bean name generation strategy supplied through the enclosing application context SingletonBeanRegistry sbr = null; if (registry instanceof SingletonBeanRegistry) &#123; sbr = (SingletonBeanRegistry) registry; if (!this.localBeanNameGeneratorSet &amp;&amp; sbr.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) &#123; BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR); this.componentScanBeanNameGenerator = generator; this.importBeanNameGenerator = generator; &#125; &#125; // Parse each @Configuration class ConfigurationClassParser parser = new ConfigurationClassParser( this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry); Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(configCandidates); Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;ConfigurationClass&gt;(configCandidates.size()); do &#123; parser.parse(candidates); parser.validate(); Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;ConfigurationClass&gt;(parser.getConfigurationClasses()); configClasses.removeAll(alreadyParsed); // Read the model and create bean definitions based on its content if (this.reader == null) &#123; this.reader = new ConfigurationClassBeanDefinitionReader( registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry()); &#125; this.reader.loadBeanDefinitions(configClasses); alreadyParsed.addAll(configClasses); candidates.clear(); if (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123; String[] newCandidateNames = registry.getBeanDefinitionNames(); Set&lt;String&gt; oldCandidateNames = new HashSet&lt;String&gt;(Arrays.asList(candidateNames)); Set&lt;String&gt; alreadyParsedClasses = new HashSet&lt;String&gt;(); for (ConfigurationClass configurationClass : alreadyParsed) &#123; alreadyParsedClasses.add(configurationClass.getMetadata().getClassName()); &#125; for (String candidateName : newCandidateNames) &#123; if (!oldCandidateNames.contains(candidateName)) &#123; BeanDefinition bd = registry.getBeanDefinition(candidateName); if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;&amp; !alreadyParsedClasses.contains(bd.getBeanClassName())) &#123; candidates.add(new BeanDefinitionHolder(bd, candidateName)); &#125; &#125; &#125; candidateNames = newCandidateNames; &#125; &#125; while (!candidates.isEmpty()); // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes if (sbr != null) &#123; if (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123; sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry()); &#125; &#125; if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) &#123; ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache(); &#125; &#125; /** * Post-processes a BeanFactory in search of Configuration class BeanDefinitions; * any candidates are then enhanced by a &#123;@link ConfigurationClassEnhancer&#125;. * Candidate status is determined by BeanDefinition attribute metadata. * @see ConfigurationClassEnhancer */ public void enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) &#123; Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = new LinkedHashMap&lt;String, AbstractBeanDefinition&gt;(); for (String beanName : beanFactory.getBeanDefinitionNames()) &#123; BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName); if (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) &#123; if (!(beanDef instanceof AbstractBeanDefinition)) &#123; throw new BeanDefinitionStoreException("Cannot enhance @Configuration bean definition '" + beanName + "' since it is not stored in an AbstractBeanDefinition subclass"); &#125; ... configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef); &#125; &#125; if (configBeanDefs.isEmpty()) &#123; // nothing to enhance -&gt; return immediately return; &#125; ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer(); for (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) &#123; AbstractBeanDefinition beanDef = entry.getValue(); // If a @Configuration class gets proxied, always proxy the target class beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE); try &#123; // Set enhanced subclass of the user-specified bean class Class&lt;?&gt; configClass = beanDef.resolveBeanClass(this.beanClassLoader); Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, this.beanClassLoader); if (configClass != enhancedClass) &#123; ... beanDef.setBeanClass(enhancedClass); &#125; &#125; ... &#125; &#125; &#125; ...&#125; 执行期间,最重要的组件莫过于ConfigurationClassParser,它将已注册的Spring BeanDefinition进行注解元信息解析,其中两个parse重载方法分别采用CGLIB实现的AnnotationMetadataReadingVisitor和Java反射实现的 StandardAnnotationMetadata。 ConfigurationClassParser 1234567891011121314151617181920212223242526272829303132333435363738class ConfigurationClassParser&#123; protected void processConfigurationClass(ConfigurationClass configClass) throws IOException &#123; if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123; return; &#125; ConfigurationClass existingClass = this.configurationClasses.get(configClass); if (existingClass != null) &#123; if (configClass.isImported()) &#123; if (existingClass.isImported()) &#123; existingClass.mergeImportedBy(configClass); &#125; // Otherwise ignore new imported config class; existing non-imported class overrides it. return; &#125; else &#123; // Explicit bean definition found, probably replacing an import. // Let's remove the old one and go with the new one. this.configurationClasses.remove(configClass); for (Iterator&lt;ConfigurationClass&gt; it = this.knownSuperclasses.values().iterator(); it.hasNext();) &#123; if (configClass.equals(it.next())) &#123; it.remove(); &#125; &#125; &#125; &#125; // Recursively process the configuration class and its superclass hierarchy. SourceClass sourceClass = asSourceClass(configClass); do &#123; sourceClass = doProcessConfigurationClass(configClass, sourceClass); &#125; while (sourceClass != null); ... &#125;&#125; doProcessConfigurationClass处理以下问题: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException &#123; // Recursively process any member (nested) classes first processMemberClasses(configClass, sourceClass); // Process any @PropertySource annotations for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable( sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) &#123; if (this.environment instanceof ConfigurableEnvironment) &#123; processPropertySource(propertySource); &#125; else &#123; logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() + "]. Reason: Environment must implement ConfigurableEnvironment"); &#125; &#125; // Process any @ComponentScan annotations Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable( sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class); if (!componentScans.isEmpty() &amp;&amp; !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123; for (AnnotationAttributes componentScan : componentScans) &#123; // The config class is annotated with @ComponentScan -&gt; perform the scan immediately Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName()); // Check the set of scanned definitions for any further config classes and parse recursively if needed for (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123; if (ConfigurationClassUtils.checkConfigurationClassCandidate( holder.getBeanDefinition(), this.metadataReaderFactory)) &#123; parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName()); &#125; &#125; &#125; &#125; // Process any @Import annotations processImports(configClass, sourceClass, getImports(sourceClass), true); // Process any @ImportResource annotations if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) &#123; AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class); String[] resources = importResource.getStringArray("locations"); Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass("reader"); for (String resource : resources) &#123; String resolvedResource = this.environment.resolveRequiredPlaceholders(resource); configClass.addImportedResource(resolvedResource, readerClass); &#125; &#125; // Process individual @Bean methods Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass); for (MethodMetadata methodMetadata : beanMethods) &#123; configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass)); &#125; // Process default methods on interfaces processInterfaces(configClass, sourceClass); // Process superclass, if any if (sourceClass.getMetadata().hasSuperClass()) &#123; String superclass = sourceClass.getMetadata().getSuperClassName(); if (!superclass.startsWith("java") &amp;&amp; !this.knownSuperclasses.containsKey(superclass)) &#123; this.knownSuperclasses.put(superclass, configClass); // Superclass found, return its annotation metadata and recurse return sourceClass.getSuperClass(); &#125; &#125; // No superclass -&gt; processing is complete return null; &#125; 处理@PropertySource注解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081private void processPropertySource(AnnotationAttributes propertySource) throws IOException &#123; String name = propertySource.getString("name"); if (!StringUtils.hasLength(name)) &#123; name = null; &#125; String encoding = propertySource.getString("encoding"); if (!StringUtils.hasLength(encoding)) &#123; encoding = null; &#125; String[] locations = propertySource.getStringArray("value"); Assert.isTrue(locations.length &gt; 0, "At least one @PropertySource(value) location is required"); boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound"); Class&lt;? extends PropertySourceFactory&gt; factoryClass = propertySource.getClass("factory"); PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ? DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass)); for (String location : locations) &#123; try &#123; String resolvedLocation = this.environment.resolveRequiredPlaceholders(location); Resource resource = this.resourceLoader.getResource(resolvedLocation); addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding))); &#125; catch (IllegalArgumentException ex) &#123; // Placeholders not resolvable if (ignoreResourceNotFound) &#123; if (logger.isInfoEnabled()) &#123; logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage()); &#125; &#125; else &#123; throw ex; &#125; &#125; catch (IOException ex) &#123; // Resource not found when trying to open it if (ignoreResourceNotFound &amp;&amp; (ex instanceof FileNotFoundException || ex instanceof UnknownHostException)) &#123; if (logger.isInfoEnabled()) &#123; logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage()); &#125; &#125; else &#123; throw ex; &#125; &#125; &#125; &#125; private void addPropertySource(PropertySource&lt;?&gt; propertySource) &#123; String name = propertySource.getName(); MutablePropertySources propertySources = ((ConfigurableEnvironment) this.environment).getPropertySources(); if (propertySources.contains(name) &amp;&amp; this.propertySourceNames.contains(name)) &#123; // We've already added a version, we need to extend it PropertySource&lt;?&gt; existing = propertySources.get(name); PropertySource&lt;?&gt; newSource = (propertySource instanceof ResourcePropertySource ? ((ResourcePropertySource) propertySource).withResourceName() : propertySource); if (existing instanceof CompositePropertySource) &#123; ((CompositePropertySource) existing).addFirstPropertySource(newSource); &#125; else &#123; if (existing instanceof ResourcePropertySource) &#123; existing = ((ResourcePropertySource) existing).withResourceName(); &#125; CompositePropertySource composite = new CompositePropertySource(name); composite.addPropertySource(newSource); composite.addPropertySource(existing); propertySources.replace(name, composite); &#125; &#125; else &#123; if (this.propertySourceNames.isEmpty()) &#123; propertySources.addLast(propertySource); &#125; else &#123; String firstProcessed = this.propertySourceNames.get(this.propertySourceNames.size() - 1); propertySources.addBefore(firstProcessed, propertySource); &#125; &#125; this.propertySourceNames.add(name); &#125; 处理@ComponentScan注解 123456789101112131415161718// Process any @ComponentScan annotationsSet&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable( sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);if (!componentScans.isEmpty() &amp;&amp; !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123; for (AnnotationAttributes componentScan : componentScans) &#123; // The config class is annotated with @ComponentScan -&gt; perform the scan immediately Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName()); // Check the set of scanned definitions for any further config classes and parse recursively if needed for (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123; if (ConfigurationClassUtils.checkConfigurationClassCandidate( holder.getBeanDefinition(), this.metadataReaderFactory)) &#123; parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName()); &#125; &#125; &#125;&#125; 处理@Import注解,@ImportResource,@Bean注解。其中@Import处理方法processImports与processConfigurationClass(ConfigurationClass configClass)形成递归调用。实现多层次@Import元标注的ConfigurationClass解析。解析后的ConfigurationClass将会被ConfigurationClassBeanDefinitionReader再次注册为SpringBean。ConfigurationClassBeanDefinitionReader将@Import,@ImportResource,@Bean所关联的Bean定义一并注册了。 (3):ConfigurationClassBeanDefinitionReader:将解析的Configuration Classs注册为Spring Bean。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class ConfigurationClassBeanDefinitionReader&#123; ... public void loadBeanDefinitions(Set&lt;ConfigurationClass&gt; configurationModel) &#123; TrackedConditionEvaluator trackedConditionEvaluator = new TrackedConditionEvaluator(); for (ConfigurationClass configClass : configurationModel) &#123; loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator); &#125; &#125; /** * Read a particular &#123;@link ConfigurationClass&#125;, registering bean definitions * for the class itself and all of its &#123;@link Bean&#125; methods. */ private void loadBeanDefinitionsForConfigurationClass(ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) &#123; ... if (configClass.isImported()) &#123; registerBeanDefinitionForImportedConfigurationClass(configClass); &#125; for (BeanMethod beanMethod : configClass.getBeanMethods()) &#123; loadBeanDefinitionsForBeanMethod(beanMethod); &#125; loadBeanDefinitionsFromImportedResources(configClass.getImportedResources()); loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars()); &#125; /** * Register the &#123;@link Configuration&#125; class itself as a bean definition. */ private void registerBeanDefinitionForImportedConfigurationClass(ConfigurationClass configClass) &#123; ... &#125; /** * Read the given &#123;@link BeanMethod&#125;, registering bean definitions * with the BeanDefinitionRegistry based on its contents. */ private void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) &#123; ... &#125; private void loadBeanDefinitionsFromImportedResources( Map&lt;String, Class&lt;? extends BeanDefinitionReader&gt;&gt; importedResources) &#123; ... &#125; private void loadBeanDefinitionsFromRegistrars(Map&lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&gt; registrars) &#123; for (Map.Entry&lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&gt; entry : registrars.entrySet()) &#123; entry.getKey().registerBeanDefinitions(entry.getValue(), this.registry); &#125; &#125;&#125; (4):ConfigurationClassUtils:判定Configuration Class的级别 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596abstract class ConfigurationClassUtils &#123; private static final String CONFIGURATION_CLASS_FULL = "full"; private static final String CONFIGURATION_CLASS_LITE = "lite"; private static final String CONFIGURATION_CLASS_ATTRIBUTE = Conventions.getQualifiedAttributeName(ConfigurationClassPostProcessor.class, "configurationClass"); private static final String ORDER_ATTRIBUTE = Conventions.getQualifiedAttributeName(ConfigurationClassPostProcessor.class, "order"); private static final Log logger = LogFactory.getLog(ConfigurationClassUtils.class); private static final Set&lt;String&gt; candidateIndicators = new HashSet&lt;String&gt;(4); static &#123; candidateIndicators.add(Component.class.getName()); candidateIndicators.add(ComponentScan.class.getName()); candidateIndicators.add(Import.class.getName()); candidateIndicators.add(ImportResource.class.getName()); &#125; ... /** * Check the given metadata for a configuration class candidate * (or nested component class declared within a configuration/component class). * @param metadata the metadata of the annotated class * @return &#123;@code true&#125; if the given class is to be registered as a * reflection-detected bean definition; &#123;@code false&#125; otherwise */ public static boolean isConfigurationCandidate(AnnotationMetadata metadata) &#123; return (isFullConfigurationCandidate(metadata) || isLiteConfigurationCandidate(metadata)); &#125; /** * Check the given metadata for a full configuration class candidate * (i.e. a class annotated with &#123;@code @Configuration&#125;). * @param metadata the metadata of the annotated class * @return &#123;@code true&#125; if the given class is to be processed as a full * configuration class, including cross-method call interception */ public static boolean isFullConfigurationCandidate(AnnotationMetadata metadata) &#123; return metadata.isAnnotated(Configuration.class.getName()); &#125; /** * Check the given metadata for a lite configuration class candidate * (e.g. a class annotated with &#123;@code @Component&#125; or just having * &#123;@code @Import&#125; declarations or &#123;@code @Bean methods&#125;). * @param metadata the metadata of the annotated class * @return &#123;@code true&#125; if the given class is to be processed as a lite * configuration class, just registering it and scanning it for &#123;@code @Bean&#125; methods */ public static boolean isLiteConfigurationCandidate(AnnotationMetadata metadata) &#123; // Do not consider an interface or an annotation... if (metadata.isInterface()) &#123; return false; &#125; // Any of the typical annotations found? for (String indicator : candidateIndicators) &#123; if (metadata.isAnnotated(indicator)) &#123; return true; &#125; &#125; // Finally, let's look for @Bean methods... try &#123; return metadata.hasAnnotatedMethods(Bean.class.getName()); &#125; ... &#125; /** * Determine whether the given bean definition indicates a full &#123;@code @Configuration&#125; * class, through checking &#123;@link #checkConfigurationClassCandidate&#125;'s metadata marker. */ public static boolean isFullConfigurationClass(BeanDefinition beanDef) &#123; return CONFIGURATION_CLASS_FULL.equals(beanDef.getAttribute(CONFIGURATION_CLASS_ATTRIBUTE)); &#125; /** * Determine whether the given bean definition indicates a lite &#123;@code @Configuration&#125; * class, through checking &#123;@link #checkConfigurationClassCandidate&#125;'s metadata marker. */ public static boolean isLiteConfigurationClass(BeanDefinition beanDef) &#123; return CONFIGURATION_CLASS_LITE.equals(beanDef.getAttribute(CONFIGURATION_CLASS_ATTRIBUTE)); &#125; ...&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Enable模块驱动</tag>
        <tag>ImportSelector</tag>
        <tag>ImportBeanDefinitionRegistrar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring事件监听机制]]></title>
    <url>%2F2019%2F08%2F05%2FSpring%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Spring事件监听机制1:Spring事件监听基础 Spring事件/监听机制属于事件/监听器模式,即观察者模式扩展。在Java中,事件源必须是java.util. EventObject对象。事件监听器必须是java.util.EventListener。通常API接口需要提供 监听接口的适配器实现,提供监听空实现的适配方法。当Java8 interface的default方法特性 能够解决以上问题。 ​ Spring事件监听器,仅抽象出单一方法onApplicationEvent(ApplicationEvent),用于监听Spring事件 ApplicationEvent。 ​ 在Spring3.0之前的ApplicationListener基本无解,必须监听所有的ApplicationEvent,如果要过滤 不同类型的事件,需要借助instanceof方式进行筛选。从Spring3.0开始,支持泛型监听。 12345678910@FunctionalInterfacepublic interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener &#123; /** * Handle an application event. * @param event the event to respond to */ void onApplicationEvent(E event);&#125; 由于泛型参数的限制,泛型化的ApplicationListener无法监听不同类型的ApplicationEvent。为此,Spring3.0 引入了SmartApplicationListener接口: 123456789101112131415public interface SmartApplicationListener extends ApplicationListener&lt;ApplicationEvent&gt;, Ordered &#123; /** * Determine whether this listener actually supports the given event type. * @param eventType the event type (never &#123;@code null&#125;) */ boolean supportsEventType(Class&lt;? extends ApplicationEvent&gt; eventType); /** * Determine whether this listener actually supports the given source type. * @param sourceType the source type, or &#123;@code null&#125; if no source */ boolean supportsSourceType(@Nullable Class&lt;?&gt; sourceType);&#125; 例如SpringBoot外部化应用配置文件application.properties的事件监听器ConfigFileApplicationListener 实现,监听了ApplicationEnvironmentPreparedEvent和ApplicationPreparedEvent两个事件. 12345@Overridepublic boolean supportsEventType(Class&lt;? extends ApplicationEvent&gt; eventType) &#123; return ApplicationEnvironmentPreparedEvent.class.isAssignableFrom(eventType) || ApplicationPreparedEvent.class.isAssignableFrom(eventType);&#125; 2:Spring事件发布 ApplicationEventMulticaster主要承担两种职责,一是关联ApplicationListener,二是广播 ApplicationEvent。 1):ApplicationEventMulticaster注册ApplicationListener AbstractApplicationEventMulticaster将ApplicationListener做了分类,再结合retrieverCache的定义, 它是一个ListenerCacheKey为key,ListenerRetriever为value的Map缓存。同时ListenerCacheKey 关联了事件类型和数据源类型。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Cache key for ListenerRetrievers, based on event type and source type. */private static final class ListenerCacheKey implements Comparable&lt;ListenerCacheKey&gt; &#123; private final ResolvableType eventType; @Nullable private final Class&lt;?&gt; sourceType; public ListenerCacheKey(ResolvableType eventType, @Nullable Class&lt;?&gt; sourceType) &#123; Assert.notNull(eventType, "Event type must not be null"); this.eventType = eventType; this.sourceType = sourceType; &#125; @Override public boolean equals(Object other) &#123; if (this == other) &#123; return true; &#125; ListenerCacheKey otherKey = (ListenerCacheKey) other; return (this.eventType.equals(otherKey.eventType) &amp;&amp; ObjectUtils.nullSafeEquals(this.sourceType, otherKey.sourceType)); &#125; @Override public int hashCode() &#123; return this.eventType.hashCode() * 29 + ObjectUtils.nullSafeHashCode(this.sourceType); &#125; @Override public String toString() &#123; return "ListenerCacheKey [eventType = " + this.eventType + ", sourceType = " + this.sourceType + "]"; &#125; @Override public int compareTo(ListenerCacheKey other) &#123; int result = this.eventType.toString().compareTo(other.eventType.toString()); if (result == 0) &#123; if (this.sourceType == null) &#123; return (other.sourceType == null ? 0 : -1); &#125; if (other.sourceType == null) &#123; return 1; &#125; result = this.sourceType.getName().compareTo(other.sourceType.getName()); &#125; return result; &#125;&#125; 实际上,AbstractApplicationEventMulticaster将ApplicationEvent和ApplicationListener集合进行关联。因此 AbstractApplicationEventMulticaster#getApplicationListeners()返回ApplicationEvent关联ApplicationListener集合。 2)ApplicationEventMulticaster广播事件 ​ 广播事件在SimpleApplicationEventMulticaster中实现,也是Spring内建唯一实现。 12345678910111213@Overridepublic void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) &#123; ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event)); for (final ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123; Executor executor = getTaskExecutor(); if (executor != null) &#123; executor.execute(() -&gt; invokeListener(listener, event)); &#125; else &#123; invokeListener(listener, event); &#125; &#125;&#125; //该方法从Spring4.2开始引入。尽管ResolvableType是从Spring4.0开始出现,它是Spring简化Java反射 API而提供的组件,能够轻松的获取泛型类型等。 3)ApplicationEventMulticaster和ApplicationContext之间关系 开发人员可使用ApplicationEventPublisher发布ApplicationEvent。 ApplicationEventPublisher接口被Spring上下文接口ApplicationContext扩展,因此,无论哪种Spring应用 上下文实例,均具备发布ApplicationEvent的能力。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring事件监听机制</tag>
        <tag>观察者模式</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义SpringBoot自动装配]]></title>
    <url>%2F2019%2F08%2F05%2F%E8%87%AA%E5%AE%9A%E4%B9%89SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%2F</url>
    <content type="text"><![CDATA[自定义SpringBoot自动装配1：自动装配Class命名规则AutoConfiguration，其中\代表功能或者模块名。 2：自动装配package命名规则123456$&#123;root-package&#125; |- autoconfigure |- $&#123;module-package&#125; |- *AutoConfiguration |- $&#123;sub-module-package&#125; |- ... 其中${root_package}是根模块，如com.ley。 ${module_package}是功能模块，如web.servlet。 而${sub_module_package}是子模块，如error。 3：自定义SpringBootStarter官方建议将自动装配模块代码存放到autoconfigure模块中，starter模块依赖该模块，并且附加其他需要依赖。当然也可以将autoconfigure和stater合并到单模块。 (1)：Spring Boot Starter命名规则 开发人员将Starter发布为${module}-spring-boot-autoconfigure和${module}-spring-boot-starter两个jar文件。 开发人员不要使用server,management,spring等作为配置Key命名空间。尽量采用独立的命名空间。 (2)：实现Spring Boot Starter (a)：新建Spring Boot Starter工程—–formatter-spring-boot-autoconfigure。 构建一个Maven功能，pom.xml如下。 123456789101112131415161718192021&lt;dependencies&gt; &lt;!-- Compile dependencies --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- @ConfigurationProperties annotation processing (metadata for IDEs) --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; (b)：实现DefaultFormatter自动装配—-FormatterAutoConfiguration (c)：META-INF/spring.factories资源声明FormatterAutoConfiguration 123# FormatterAutoConfiguration 自动装配声明org.springframework.boot.autoconfigure.EnableAutoConfiguration=\ com.ley.formatter.autoconfigure.FormatterAutoConfiguration (d)：构建Spring Boot Starter—-formatter-spring-boot-starter 1234567891011121314151617181920&lt;dependencies&gt; &lt;!--formatter spring boot autoconfigure--&gt; &lt;dependency&gt; &lt;groupId&gt;com.gitee.ley1996&lt;/groupId&gt; &lt;artifactId&gt;formatter-spring-boot-autoconfigure&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring boot 基础依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;!-- 说明formatter-spring-boot-starter不应该 传递spring-boot-starter依赖。 --&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在开发Spring Boot Starter的过程中，请保持spring-boot-starter等相关依赖声明为 、&lt;optional&gt;true&lt;/optional&gt;。 4：Spring Boot 提交化自动装配条件注解总结： Class Conditions Bean Conditions Property Conditions Resource Conditions Web Application Conditions SpEL Expression Conditions 4.1：Class条件注解 ConditionalOnClass：当指定类存在时，在Sprign Boot 1.0~2.0稳定。 ConditionalOnMissingClass：当指定类不存在时，从Spring Boot 1.4开始才保持稳定。推荐使用value()替代。当指定类不存在时，并不需要该类显示地依赖到当前工程或者Starter。 4.2：Bean条件注解 ConditionalOnBean：匹配BeanFactory中Bean的类型和名称。 其中Bean查找策略为SearchStrategy，包含当前，父类及所有。 ConditionalOnMissingBean：当指定Bean不存在时。从Spring Boot 1.2.5开始，增加ignored()和ignoredType()两个方法，用于忽略或者排除指定Bean。 4.3：属性条件注解 ConditionalOnProperty为属性条件注解，其属性来源于Spring Environment。其中Java系统属性(systemProperties)和环境变量(systemEnvironment)是典型的Spring Environment属性来源。在SpringBoot环境中，application.properties或者application.yml也是其中来源之一。 当自动装配组件需要默认装配时，可以使用matchIfMissing()属性值调整为true。 4.4：Resource条件注解 ConditionOnResource为Resource条件注解。其中resources()指定只有资源必须存在方可成立。 4.5：Web应用条件注解。 ConditionalOnWebApplication：判断当前应用是Web类型。 ConditionalOnNotWebApplication：当前应用不是Web类型。 4.6：Spring表达式条件注解 ConditionalOnExpression，其中value()用于评估表达式的真伪。当表达多组配置属性时，可以使用@ConditionalOnExpression。例如${formatter.enabled:true} 总结使用Spring Boot提供的条件注解,以及自动装配顺序注解,实现自己的配置类,然后在META-INF/ spring.factories中声明该类即可。如下所示： 123# FormatterAutoConfiguration 自动装配声明org.springframework.boot.autoconfigure.EnableAutoConfiguration=\ com.ley.formatter.autoconfigure.FormatterAutoConfiguration]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>SpringBoot自动装配</tag>
        <tag>条件化注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring整合Mybatis原理探索]]></title>
    <url>%2F2019%2F08%2F05%2FSpring%E6%95%B4%E5%90%88Mybatis%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[Spring整合Mybatis原理探索@MapperScan注解实现 1:MapperScannerRegistrar类 实现ImportBeanDefinitionRegistrar接口,注册默认@Mapper注解标注的接口。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; //获取@MapperScan注解上属性 AnnotationAttributes mapperScanAttrs = AnnotationAttributes .fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName())); if (mapperScanAttrs != null) &#123; registerBeanDefinitions(mapperScanAttrs, registry); &#125; &#125; void registerBeanDefinitions(AnnotationAttributes annoAttrs, BeanDefinitionRegistry registry) &#123;//扫描指定包下包含默认Mybatis注解@Mapper的接口,并注册到Spring Bean工厂中 ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry); // this check is needed in Spring 3.1 Optional.ofNullable(resourceLoader).ifPresent(scanner::setResourceLoader); Class&lt;? extends Annotation&gt; annotationClass = annoAttrs.getClass("annotationClass"); if (!Annotation.class.equals(annotationClass)) &#123; scanner.setAnnotationClass(annotationClass); &#125; Class&lt;?&gt; markerInterface = annoAttrs.getClass("markerInterface"); if (!Class.class.equals(markerInterface)) &#123; scanner.setMarkerInterface(markerInterface); &#125; Class&lt;? extends BeanNameGenerator&gt; generatorClass = annoAttrs.getClass("nameGenerator"); if (!BeanNameGenerator.class.equals(generatorClass)) &#123; scanner.setBeanNameGenerator(BeanUtils.instantiateClass(generatorClass)); &#125; Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass = annoAttrs.getClass("factoryBean"); if (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) &#123; scanner.setMapperFactoryBean(BeanUtils.instantiateClass(mapperFactoryBeanClass)); &#125; scanner.setSqlSessionTemplateBeanName(annoAttrs.getString("sqlSessionTemplateRef")); scanner.setSqlSessionFactoryBeanName(annoAttrs.getString("sqlSessionFactoryRef")); List&lt;String&gt; basePackages = new ArrayList&lt;&gt;(); basePackages.addAll( Arrays.stream(annoAttrs.getStringArray("value")) .filter(StringUtils::hasText) .collect(Collectors.toList())); basePackages.addAll( Arrays.stream(annoAttrs.getStringArray("basePackages")) .filter(StringUtils::hasText) .collect(Collectors.toList())); basePackages.addAll( Arrays.stream(annoAttrs.getClassArray("basePackageClasses")) .map(ClassUtils::getPackageName) .collect(Collectors.toList())); scanner.registerFilters(); scanner.doScan(StringUtils.toStringArray(basePackages)); &#125; 2:ClassPathMapperScanner 继承了ClassPathBeanDefinitionScanner类,该类扫描指定包下的模式注解,并注册到Spring Bean工厂中。 实现主要方法研究 注册BeanDefinition过滤接口 12345678910111213141516171819202122232425262728293031323334353637/** * Configures parent scanner to search for the right interfaces. It can search * for all interfaces or just for those that extends a markerInterface or/and * those annotated with the annotationClass */public void registerFilters() &#123; boolean acceptAllInterfaces = true; // if specified, use the given annotation and / or marker interface if (this.annotationClass != null) &#123; addIncludeFilter(new AnnotationTypeFilter(this.annotationClass)); acceptAllInterfaces = false; &#125; // override AssignableTypeFilter to ignore matches on the actual marker interface if (this.markerInterface != null) &#123; //由于生成的BeanDefinition为MapperFactoryBean,所以BeanClass不是原来的类名 addIncludeFilter(new AssignableTypeFilter(this.markerInterface) &#123; @Override protected boolean matchClassName(String className) &#123; return false; &#125; &#125;); acceptAllInterfaces = false; &#125; if (acceptAllInterfaces) &#123; // default include filter that accepts all classes addIncludeFilter((metadataReader, metadataReaderFactory) -&gt; true); &#125; // exclude package-info.java addExcludeFilter((metadataReader, metadataReaderFactory) -&gt; &#123; String className = metadataReader.getClassMetadata().getClassName(); return className.endsWith("package-info"); &#125;);&#125; 注册MapperFactoryBean 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private void processBeanDefinitions(Set&lt;BeanDefinitionHolder&gt; beanDefinitions) &#123; GenericBeanDefinition definition; for (BeanDefinitionHolder holder : beanDefinitions) &#123; definition = (GenericBeanDefinition) holder.getBeanDefinition(); String beanClassName = definition.getBeanClassName(); LOGGER.debug(() -&gt; "Creating MapperFactoryBean with name '" + holder.getBeanName() + "' and '" + beanClassName + "' mapperInterface"); // the mapper interface is the original class of the bean // but, the actual class of the bean is MapperFactoryBean //添加要与类型匹配的通用参数值注意：单个通用参数值将只使用一次*，而不是多次匹配。 //MapperFactoryBean是个泛型类,泛型参数是Mybatis的DAO全类限定名 definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); / definition.setBeanClass(this.mapperFactoryBean.getClass()); definition.getPropertyValues().add("addToConfig", this.addToConfig); boolean explicitFactoryUsed = false; if (StringUtils.hasText(this.sqlSessionFactoryBeanName)) &#123; //如果配置了SqlSesiionFactoryBean,获取运行期间的SqlSessionFactory Bean引用 definition.getPropertyValues().add("sqlSessionFactory", new RuntimeBeanReference(this.sqlSessionFactoryBeanName)); explicitFactoryUsed = true; &#125; else if (this.sqlSessionFactory != null) &#123; definition.getPropertyValues().add("sqlSessionFactory", this.sqlSessionFactory); explicitFactoryUsed = true; &#125; if (StringUtils.hasText(this.sqlSessionTemplateBeanName)) &#123; if (explicitFactoryUsed) &#123; LOGGER.warn(() -&gt; "Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored."); &#125; definition.getPropertyValues().add("sqlSessionTemplate", new RuntimeBeanReference(this.sqlSessionTemplateBeanName)); explicitFactoryUsed = true; &#125; else if (this.sqlSessionTemplate != null) &#123; if (explicitFactoryUsed) &#123; LOGGER.warn(() -&gt; "Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored."); &#125; definition.getPropertyValues().add("sqlSessionTemplate", this.sqlSessionTemplate); explicitFactoryUsed = true; &#125; if (!explicitFactoryUsed) &#123; LOGGER.debug(() -&gt; "Enabling autowire by type for MapperFactoryBean with name '" + holder.getBeanName() + "'."); definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE); &#125; &#125; &#125; 设置候选BeanDefinition条件 12345//判断候选的BeanDefinition是否是接口和独立类@Overrideprotected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) &#123; return beanDefinition.getMetadata().isInterface() &amp;&amp; beanDefinition.getMetadata().isIndependent();&#125; 相关类 ClassPathMapperScanner:扫描Bean并注册Bean工厂中 MapperFactoryBean:Mapper Bean工程 MapperScannerRegistrar:提供解析MapperScan注解和批量注册Bean SqlSessionDaoSupport:提供SqlSession 总结实现批量注册Bean时,提供扫描包注解+标注候选注解+实现ImportBeanDefinitionRegistrar接口+ 继承ClassPathBeanDefinitionScanner+实现FactoryBean接口。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Mybatis</tag>
        <tag>MapperScan注解实现原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Environment抽象]]></title>
    <url>%2F2019%2F08%2F05%2FSpring%20Environment%E6%8A%BD%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Spring Environment抽象1:概述Spring中Environment是Spring3.1版本引入的,是Spring核心框架定义的一个接口,用来表示整个应用运行时环境。该环境模型只接受两种应用环境profiles(配置文件)和properties(属性)。与属性访问相关的方法通过PropertyResolver超接口访问。 建模关键 profile(配置文件) 一个profile是一组Bean定义的逻辑分组,只有当配置文件被激活的时候,才会将对应逻辑上组织的Bean定义注册到容器中。 Bean添加到profile可以通过XML或者Annotation方式。 Environment对象对于profile机制所扮演的角色是用来指定哪些profile是当前活跃或者缺省活跃。可以通过getActiveProfiles或者getDefaultProfiles获取。 proprety(属性) 一个应用属性有很多来源:属性文件(properties files),JVM系统属性(getSystemProperties),系统变量属性(getSystemEnvironment),JNDI,servlet上下文参数,临时属性对象,Maps等。 Environment对于property所扮演的角色提供给使用一个方便服务接口用于 配置属性源 从属性源解析和获取属性 容器上下文(ApplicationContext)所获取的bean,如果想直接使用Environment对象访问profile状态或者获取属性。有以下方式。 EnvironmentAware接口 @Inject 或者 @Autowired注入一个 Environment对象 绝大多数情况,bean都不需要直接访问Environment对象,而是通过类似@Value注解方式把属性值注入进来。 这个接口定义在包 org.springframework.core.env 中。下面是Spring围绕环境抽象Environment各个接口/类之间的继承关系: 2:Environment接口相关类介绍 接口|类 介绍 PropertyResolver 接口,抽象对属性源的访问比如是否包含某个属性，读取属性，解析占位符，将读取到的属性转换成指定类型 (提供读操作)默认实现PropertySourcesPropertyResolver Environment 接口,继承自PropertyResolver,对环境属性访问和default/active profile访问的抽象 。 ConfigurablePropertyResolver 接口，为PropertyResolver接口抽象的属性源访问做了配置方面的增强。(提供写操作。) ConfigurableEnvironment 接口，在所继承的接口之上增加了设置defaut/active profile的能力，增加/删除环境对象中属性源的能力 ConfigurableWebEnvironment 接口，向接口ConfigurableEnvironment增强了根据Servlet上下文/配置初始化属性源的能力 AbstractEnvironment Environment抽象基类，实现了ConfigurableEnvironment StandardEnvironment 实现类,针对标准Spring应用(非Web应用)环境, 在AbstractEnvironment基础上提供了属性源systemEnvironment(来自System.getenv())和systemProperties(来自System.getProperties()) StandardServletEnvironment 实现类,针对标准Spring Servlet Web应用的环境， 增加了servletContextInitParams/servletConfigInitParams/jndiProperties 3:外部化配置抽象相关类 接口|类 介绍 PropertySource 用来抽象属性键值对(外部化配置,即属性源)配置基类。例如Map,Properties,ServletConfig,ServletContext PropertySources 对PropertySource抽象属性键值对外部化配置提供集合操作。 MutablePropertySources PropertySources默认实现。 MapPropertySource Map对象中读取属性键值对 PropertiesPropertySource Properties对象中读取属性键值对 ResourcePropertySource Resource对象读取中读取属性键值对。只支持.xml和.properties文件。底层实现使用了工具类PropertiesLoaderUtils。 CompositePropertySource 聚合一组PropertySource。 Web环境实现类和JNDI实现类和随机数实现类 ServletConfigPropertySource,ServletContextPropertySource, JndiPropertySource,RandomValuePropertySource 命令行参数实现类 CommandLinePropertySource 4:混淆定义 上下文:用来处理分层传递抽象,代表着应用。 环境:当前上下文运行环境,存储各种全局变量。比如JDK信息,内存信息等等。 5:核心API PropertySource:属性源。key-value属性对抽象 PropertyResolver:属性解析器。用于解析相应key的value Profile:配置。只有激活的配置profile的组件/配置才会注册到Spring容器,类似于maven中profile。 Environment:环境，本身也是个属性解析器PropertyResolver。 6:属性解析器相关类详细介绍PropertySourcesPropertyResolver该类是Spring内建提供的PropertyResolver唯一实现类。环境抽象Environment属性解析委托给该类。包括对属性类型之间必要转换。Converter和ConverterService。实际的占位符解析委托给PropertyPlaceholderHelper。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class PropertySourcesPropertyResolver extends AbstractPropertyResolver &#123; ... @Nullable private final PropertySources propertySources; //内部持有一组PropertySource // 由此可以看出propertySources的顺序很重要~~~ // 并且还能处理占位符~~~~~ resolveNestedPlaceholders支持内嵌、嵌套占位符 @Nullable protected &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetValueType, boolean resolveNestedPlaceholders) &#123; if (this.propertySources != null) &#123; for (PropertySource&lt;?&gt; propertySource : this.propertySources) &#123; Object value = propertySource.getProperty(key); if (value != null) &#123; if (resolveNestedPlaceholders &amp;&amp; value instanceof String) &#123; value = resolveNestedPlaceholders((String) value); &#125; logKeyFound(key, propertySource, value); return convertValueIfNecessary(value, targetValueType); &#125; &#125; &#125; return null; &#125; ...&#125;public abstract class AbstractPropertyResolver implements ConfigurablePropertyResolver &#123; ... @Nullable private volatile ConfigurableConversionService conversionService; @Nullable private PropertyPlaceholderHelper nonStrictHelper; @Nullable private PropertyPlaceholderHelper strictHelper; private boolean ignoreUnresolvableNestedPlaceholders = false; private String placeholderPrefix = SystemPropertyUtils.PLACEHOLDER_PREFIX; private String placeholderSuffix = SystemPropertyUtils.PLACEHOLDER_SUFFIX; @Nullable private String valueSeparator = SystemPropertyUtils.VALUE_SEPARATOR; private final Set&lt;String&gt; requiredProperties = new LinkedHashSet&lt;&gt;(); ...&#125; 7:应用环境抽象EnvironmentEnvironment接口:环境的读操作 1234567891011121314151617181920212223242526272829303132333435363738394041public interface Environment extends PropertyResolver &#123; /** * Return the set of profiles explicitly made active for this environment. Profiles * are used for creating logical groupings of bean definitions to be registered * conditionally, for example based on deployment environment. Profiles can be * activated by setting &#123;@linkplain AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME * "spring.profiles.active"&#125; as a system property or by calling * &#123;@link ConfigurableEnvironment#setActiveProfiles(String...)&#125;. * &lt;p&gt;If no profiles have explicitly been specified as active, then any * &#123;@linkplain #getDefaultProfiles() default profiles&#125; will automatically be activated. * @see #getDefaultProfiles * @see ConfigurableEnvironment#setActiveProfiles * @see AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME */ String[] getActiveProfiles(); /** * Return the set of profiles to be active by default when no active profiles have * been set explicitly. * @see #getActiveProfiles * @see ConfigurableEnvironment#setDefaultProfiles * @see AbstractEnvironment#DEFAULT_PROFILES_PROPERTY_NAME */ String[] getDefaultProfiles(); /** * Return whether one or more of the given profiles is active or, in the case of no * explicit active profiles, whether one or more of the given profiles is included in * the set of default profiles. If a profile begins with '!' the logic is inverted, * i.e. the method will return true if the given profile is &lt;em&gt;not&lt;/em&gt; active. * For example, &lt;pre class="code"&gt;env.acceptsProfiles("p1", "!p2")&lt;/pre&gt; will * return &#123;@code true&#125; if profile 'p1' is active or 'p2' is not active. * @throws IllegalArgumentException if called with zero arguments * or if any profile is &#123;@code null&#125;, empty or whitespace-only * @see #getActiveProfiles * @see #getDefaultProfiles */ boolean acceptsProfiles(String... profiles);&#125; ConfigurableEnvironment:增加环境的写操作 1234567891011121314151617181920public interface ConfigurableEnvironment extends Environment, ConfigurablePropertyResolver &#123; // 指定该环境下的 profile 集 void setActiveProfiles(String... profiles); // 增加此环境的 profile void addActiveProfile(String profile); // 设置默认的 profile void setDefaultProfiles(String... profiles); // 返回此环境的 PropertySources MutablePropertySources getPropertySources(); // 尝试返回 System.getenv() 的值，若失败则返回通过 System.getenv(string) 的来访问各个键的映射 Map&lt;String, Object&gt; getSystemEnvironment(); // 尝试返回 System.getProperties() 的值，若失败则返回通过 System.getProperties(string) 的来访问各个键的映射 Map&lt;String, Object&gt; getSystemProperties(); void merge(ConfigurableEnvironment parent);&#125; AbstractEnvironment:作为环境接口抽象实现,主要实现了profile相关功能 12345678910111213141516171819202122232425262728293031public abstract class AbstractEnvironment implements ConfigurableEnvironment &#123; public static final String IGNORE_GETENV_PROPERTY_NAME = "spring.getenv.ignore"; // 请参考：ConfigurableEnvironment#setActiveProfiles public static final String ACTIVE_PROFILES_PROPERTY_NAME = "spring.profiles.active"; // 请参考：ConfigurableEnvironment#setDefaultProfiles public static final String DEFAULT_PROFILES_PROPERTY_NAME = "spring.profiles.default"; private final Set&lt;String&gt; defaultProfiles = new LinkedHashSet&lt;&gt;(getReservedDefaultProfiles()); // 默认的profile名称 protected static final String RESERVED_DEFAULT_PROFILE_NAME = "default"; ... protected Set&lt;String&gt; doGetActiveProfiles() &#123; synchronized (this.activeProfiles) &#123; if (this.activeProfiles.isEmpty()) &#123; String profiles = getProperty(ACTIVE_PROFILES_PROPERTY_NAME); if (StringUtils.hasText(profiles)) &#123; setActiveProfiles(StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(profiles))); &#125; &#125; return this.activeProfiles; &#125; &#125; ...&#125; 如果 activeProfiles 为空,则从 Properties 中获取 spring.profiles.active 配置;如果不为空，则调用 setActiveProfiles() 设置 profile,最后返回。 从这里可以知道，API设置的activeProfiles优先级第一，其次才是属性配置。 8:应用环境配置激活(@Profile和ProfileCondition)123456789@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Conditional(ProfileCondition.class)public @interface Profile &#123; String[] value();&#125; 从Spring4.0开始提供Conditional接口,该注解实现原理基于Condition条件接口,Condition条件接口计算结果实现类为ConditionEvaluator,该类是个内部类。 ProfileCondition 1234567891011121314151617181920class ProfileCondition implements Condition &#123; @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; // 因为value值是个数组，所以此处有多个值 用的MultiValueMap MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName()); if (attrs != null) &#123; for (Object value : attrs.get("value")) &#123; // 多个值中，但凡只要有一个acceptsProfiles了，那就返回true~ if (context.getEnvironment().acceptsProfiles(Profiles.of((String[]) value))) &#123; return true; &#125; &#125; return false; &#125; return true; &#125;&#125; @Profile的value可以指定多个值,并且只需要有一个值符合了条件,@Profile标注的方法、类就会生效，就会被加入到容器内。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Environment抽象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git分支的创建与合并]]></title>
    <url>%2F2019%2F08%2F05%2FGit%E5%88%86%E6%94%AF%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[Git分支的创建与合并Git管理项目代码，常见流程。1.开发公司网站。 2.为了开发某个新功能新建一个分支（假如叫develop），并在该分支上进行开发。 3.接到测试组的Bug反馈，返回主分支，新建一个新的分支（bugFix），在该分支上修复Bug，然后与主分支master合并。 4.将分支切换回develop，继续开发新功能，结束后和主分支master合并。 分支的新建与切换假如公司网站项目已经开发了一段时间，并且使用Git提交了几次更新，提交历史如下图所示： 为了开发新的功能，新建分支develop并切换到该分支： 1234$ git branch develop$ git checkout developSwitched to branch 'develop' 也可以使用命令 git checkout -b 直接新建并切换： 12$ git checkout -b developSwitched to a new branch 'develop' 执行完上述命令后，仓库历史大致如下所示： Git新建了一个分支指针develop，然后将HEAD指向develop。 接下来在该分支上开心的开发新功能，比如新建了公司网站About页面，添加了内容然后提交了此次修改： 12345678$ vim About.html$ git add About.html$ git commit -a -m "add About.html page"[develop b462691] add About.html page 1 file changed, 12 insertions(+) create mode 100644 About.html 此时，仓库历史如下图所示： 这时候接到测试组公司网站主页index.html的Bug反馈，于是将分支切换回主分支master，然后新建分支bugFix，修复Bug，并提交该修复： 1234567891011$ git checkout masterSwitched to branch 'master'$ git checkout -b "bugFix"Switched to a new branch 'bugFix'$ vim index.html$ git commit -a -m "update index.html page"[bugFix 11a3074] update index.html page 1 file changed, 2 insertions(+), 2 deletions(-) 此时，仓库历史如下图所示： ` 假如确定Bug修复后，可以切换回master分支，然后将bugFix和master分支合并： 12345$ git merge bugFixUpdating e7ad858..11a3074Fast-forward index.html | 4 ++-- 1 file changed, 2 insertions(+), 2 deletions(-) 合并时出现了“Fast forward”的提示。如果顺着一个分支走下去可以到达另一个分支的话，那么Git在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。 此时bugFix分支已经完成了历史使命，可以使用命令 git branch -d 将其删除： 合并master与bugFix，并删除bugFix分支后，仓库历史如下图所示： Bug修复后，切换回develop分支继续开发新的功能，并且提交： 分支合并和合并master分支与bugFix分支那样，合并master与develop分支过程也差不多： 1234567$ git checkout masterSwitched to branch 'master'$ git merge developMerge made by the 'recursive' strategy. About.html | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) 由于master指向的C4并不是develop指向C5的直接祖先C2，所以合并方式不是“Fast forward”，Git 会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算。 合并master和develop后，仓库历史如下图所示： 解决合并冲突假如在不同分支中都对同一个文件进行了修改，那么合并的时候就会发生冲突。比如在master分支和develop分支上都修改了About.html页面，然后进行分支合并： 1234$ git merge developAuto-merging About.htmlCONFLICT (content): Merge conflict in About.htmlAutomatic merge failed; fix conflicts and then commit the result. Git作了合并，但没有提交，它会停下来等你解决冲突。 可是使用命令 git status 查看哪些文件存在冲突： 123456789101112$ git statusOn branch masterYou have unmerged paths. (fix conflicts and run "git commit") (use "git merge --abort" to abort the merge)Unmerged paths: (use "git add &lt;file&gt;..." to mark resolution) both modified: About.htmlno changes added to commit (use "git add" and/or "git commit -a") 任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出。编辑About.html页面，可看到文件包含类似下面部分的内容： 123456&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD &lt;footer&gt;2016~2017 All Rights Reserved&lt;/footer&gt;======= &lt;footer&gt;&amp;copy;2016~2017&lt;/footer&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; develop 可以看到 ======= 隔开的上半部分，是HEAD（即 master 分支，在运行merge命令时所切换到的分支）中的内容，下半部分是在develop分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。 1&lt;footer&gt;&amp;copy; 2016~2017 All Rights Reserved&lt;/footer&gt; 转载:http://mrbird.cc/Git分支的创建与合并.html]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[@Component注解派生性原理]]></title>
    <url>%2F2019%2F08%2F04%2FComponent%E6%B3%A8%E8%A7%A3%E6%B4%BE%E7%94%9F%E6%80%A7%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[@Component注解的派生性原理1:模式注解Stereotype Annotation俗称为模式注解。Spring核心部分提供了几种内建的模式注解,如@Component,@Repository,@Service,@Controller,@Configuration等。这些注解均派生于@Component。 由于Java语言规定,Annotation不允许继承,没有类派生子类的特性,因此Spring采用元标注的方式实现注解之间的派生。 2:@Component派生性@Component注解作为Spring容器托管的通用模式组件,任何被@Component标注的组件均为组件扫描的候选对象。 任何论证过程离不开所处的环境,需要开发人员具备一定工程意识,包括软件版本,特性范围,兼容情况等。因此,论证过程从最低版本开始推导,逐步证明不同版本得提升和差异。 3:@Component注解派生性原理当ClassPathBeanDefinitionScanner#doScan(String... basePackages)调用时,它利用basePackages参数迭代执行的findCandidateComponents(String basePackage),每次执行结果都生成候选的BeanDefinition集合,即candidates变量。 123456789101112131415 public class ClassPathBeanDefinitionScanner extends ClassPathScanningCandidateComponentProvider&#123; ... protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123; Assert.notEmpty(basePackages, "At least one base package must be specified"); //获取候选的BeanDefinition集合 Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(); for (String basePackage : basePackages) &#123; Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage); ... &#125; return beanDefinitions; &#125; ...&#125; 而findCandidateComponents(String basePackage)从父类ClassPathScanningCandidateComponentProvider 中继承。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100public class ClassPathScanningCandidateComponentProvider implements EnvironmentCapable, ResourceLoaderAware &#123; ... public Set&lt;BeanDefinition&gt; findCandidateComponents(String basePackage) &#123; Set&lt;BeanDefinition&gt; candidates = new LinkedHashSet&lt;BeanDefinition&gt;(); try &#123; //获取查询的package,并处理占位符情况$&#123;...&#125;,转换为ClassLoader资源(.class)搜索路径 String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + '/' + this.resourcePattern; Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath); ... //resource迭代执行,当资源可读取时,获取该资源的MetadataReader对象 for (Resource resource : resources) &#123; ... if (resource.isReadable()) &#123; try &#123; //包含了类和注解元信息读取方法 MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource); //判断资源是否为候选的组件,通过excludeFilters和includeFilters进行判断 if (isCandidateComponent(metadataReader)) &#123; //基于ASM,支持AnnotatedBeanDefinition接口 ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setResource(resource); sbd.setSource(resource); //判断BeanDefinition是否候选组件 if (isCandidateComponent(sbd)) &#123; ... candidates.add(sbd); &#125; ... &#125; &#125; ... return candidates; &#125; ... /** * Determine whether the given class does not match any exclude filter * and does match at least one include filter. * @param metadataReader the ASM ClassReader for the class * @return whether the class qualifies as a candidate component */ protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException&#123; for (TypeFilter tf : this.excludeFilters) &#123; if (tf.match(metadataReader, this.metadataReaderFactory)) &#123; return false; &#125; &#125; for (TypeFilter tf : this.includeFilters) &#123; if (tf.match(metadataReader, this.metadataReaderFactory)) &#123; return isConditionMatch(metadataReader); &#125; &#125; return false; &#125; /** * Determine whether the given bean definition qualifies as candidate. * &lt;p&gt;The default implementation checks whether the class is not an interface * and not dependent on an enclosing class. * &lt;p&gt;Can be overridden in subclasses. * @param beanDefinition the bean definition to check * @return whether the bean definition qualifies as a candidate component */ protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) &#123; AnnotationMetadata metadata = beanDefinition.getMetadata(); return (metadata.isIndependent() &amp;&amp; (metadata.isConcrete() || (metadata.isAbstract() &amp;&amp; metadata.hasAnnotatedMethods(Lookup.class.getName())))); &#125; /** * Register the default filter for &#123;@link Component @Component&#125;. * &lt;p&gt;This will implicitly register all annotations that have the * &#123;@link Component @Component&#125; meta-annotation including the * &#123;@link Repository @Repository&#125;, &#123;@link Service @Service&#125;, and * &#123;@link Controller @Controller&#125; stereotype annotations. * &lt;p&gt;Also supports Java EE 6's &#123;@link javax.annotation.ManagedBean&#125; and * JSR-330's &#123;@link javax.inject.Named&#125; annotations, if available. * */ @SuppressWarnings("unchecked") protected void registerDefaultFilters() &#123; this.includeFilters.add(new AnnotationTypeFilter(Component.class)); ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader(); try &#123; this.includeFilters.add(new AnnotationTypeFilter( ((Class&lt;? extends Annotation&gt;) ClassUtils.forName("javax.annotation.ManagedBean", cl)), false)); ... &#125; try &#123; this.includeFilters.add(new AnnotationTypeFilter( ((Class&lt;? extends Annotation&gt;) ClassUtils.forName("javax.inject.Named", cl)), false)); ... &#125; &#125;&#125; 默认情况下,ClassPathScanningCandidateComponentProvider构造参数useDefaultFilters为true,并且显示传递给父类构造参数。该方法给属性includeFilters增添了@Component类型AnnotationTypeFilter的TypeFilter。 ClassPathBeanDefinitionScanner默认过滤器引入标注@Component,@Repository,@Service或者@Controller等类。同理,它也能够标注所有@Component的&quot;派生&quot;注解。 @Component注解只包含一个value属性定义，所以其“派生”的注解也只能包含一个vlaue属性定义。 Dubbo实现@Service注解扫描实例: ClassPathBeanDefinitionScanner允许自定义类型过滤规则。因此,Dubbo的@Service没有标注@Component情况下，通过scanner.addIncludeFilter(new AnnotationTypeFilter(Service.class))方式达到识别@Service标注类情况。但是没有使用@Component注解的派生性。 Mybatis实现@Mapper注解扫描实例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class ClassPathMapperScanner extends ClassPathBeanDefinitionScanner&#123; ... public ClassPathMapperScanner(BeanDefinitionRegistry registry) &#123; super(registry, false); &#125; /** * Configures parent scanner to search for the right interfaces. It can search * for all interfaces or just for those that extends a markerInterface or/and * those annotated with the annotationClass */ public void registerFilters() &#123; boolean acceptAllInterfaces = true; // if specified, use the given annotation and / or marker interface if (this.annotationClass != null) &#123; addIncludeFilter(new AnnotationTypeFilter(this.annotationClass)); acceptAllInterfaces = false; &#125; // override AssignableTypeFilter to ignore matches on the actual marker interface if (this.markerInterface != null) &#123; addIncludeFilter(new AssignableTypeFilter(this.markerInterface) &#123; @Override protected boolean matchClassName(String className) &#123; return false; &#125; &#125;); acceptAllInterfaces = false; &#125; if (acceptAllInterfaces) &#123; // default include filter that accepts all classes addIncludeFilter(new TypeFilter() &#123; @Override public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123; return true; &#125; &#125;); &#125; // exclude package-info.java addExcludeFilter(new TypeFilter() &#123; @Override public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123; String className = metadataReader.getClassMetadata().getClassName(); return className.endsWith("package-info"); &#125; &#125;); &#125; /** * &#123;@inheritDoc&#125; */ @Override protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) &#123; return beanDefinition.getMetadata().isInterface() &amp;&amp; beanDefinition.getMetadata().isIndependent(); &#125; private void processBeanDefinitions(Set&lt;BeanDefinitionHolder&gt; beanDefinitions) &#123; GenericBeanDefinition definition; for (BeanDefinitionHolder holder : beanDefinitions) &#123; definition = (GenericBeanDefinition) holder.getBeanDefinition(); ... //复杂对象构建考虑使用FactoryBean接口 // the mapper interface is the original class of the bean // but, the actual class of the bean is MapperFactoryBean //添加泛型参数 definition.getConstructorArgumentValues().addGenericArgumentValue(definition.getBeanClassName()); // issue #59 definition.setBeanClass(this.mapperFactoryBean.getClass()); definition.getPropertyValues().add("addToConfig", this.addToConfig); ... &#125; &#125; ...&#125; 4:思考扩展思考1:利用ClassPathBeanDefinitionScanner类配合includeFilters和excludeFilters定制化批量注册Bean到Spring容器中。常常可以通过注解方式来包含或者排除候选类。 TypeFilter常用实现 AnnotationTypeFilter:注解类型过滤器 AssignableTypeFilter:确定此对象表示的类或者接口是否为给定类或者接口相同。 RegexPatternTypeFilter:判断给定的类名是否符合指定正则表达式。 思考2:复杂对象构建考虑使用FactoryBean实现类。 思考3:如果是读取类和注解信息可以考虑基于ASM或者反射,使用方式往下可以获取。当获取已加载的类信息可以考虑反射(反射大前提是被反射的Class被ClassLoader加载),ASM用于不需要将类路径package下的Class全部加载,Spring应用指定Java package扫描Spring模式注解时,利用的就是基于ASM方式获取类或者注解信息。基于ASM获取会获得更大性能。 思考4:资源读取考虑使用ResourcePatternResolver,这个对象的获取可以通过Spring提供的工具类 ResourcePatternUtils.getResourcePatternResolver(resourceLoader)。在使用的时候,考虑处理 占位符${...}的情况,注意资源是否可读。 5:多层次@Component派生性(1):具体发展过程不再细说,详解请看SpringBoot编程思想这本书。其多层次@Component注解派生性构建在Spring4.x。其核心处理类为AnnotationMetadataReadingVisitor,其采用递归的方式查找元注解。 (2):Spring中,MetadataReader接口唯一实现非公开类SimpleMetadataReader。可以通过SimpleMetadataReaderFactory(ASM字节码操作)和CachingMetadataReaderFactory获取。 其中在SimpleMetadataReader实现上看,ClassMetadataReadingVisitor和AnnotationMetadataReadingVisitor分别是ClassMetadatta和AnnotationMetadata实现类。 由于ClassPathBeanDefinitionScanner在寻找候选的BeanDefinition过程中,将指定basePackage参数下 的*.class资源进行元信息解析,也就是ClassMetadata和AnnotationMetadata对象。 AnnotationMetadataReadingVisitor实现上使用了AnnotationAttributesReadingVisitor，该类主要实现方法是visitEnd()。Spring2.5实现未采用层次递归获取Annotation[],所以仅支持单层次的@Component派生。Spring3.x实现仅两层@Component派生。Spring4.x开始采用递归方式查找元注解。 (3):思考扩展 考虑使用ASM的方式读取类或者注解相关信息。(不需要全部将指定路径下的类加载) MetadataReaderFactory:获取MetadataReader工厂 SimpleMetadataReaderFactory:简单获取MetadataReader工厂实现 ClassReader:基于ASM读取类相关信息,公开类,不建议单独使用。 AnnotationMetadataReadingVisitor:基于ASM读取注解元数据相关信息,不建议单独使用。 MethodMetadataReadingVisitor:基于ASM读取方法相关信息,不建议单独使用。 CachingMetadataReaderFactory:继承SimpleMetadataReaderFactory,增加缓存MetadataReader资源功能。 MetadataReader:获取访问类和注解相关信息。通过MetadataReaderFactory获取。 Resource getResource():获取类文件资源引用 ClassMetadata getClassMetadata():读取基础类的基本元数据 AnnotationMetadata getAnnotationMetadata():读取底层类完整注解元数据,包含注解方法的注解元数据。 考虑使用反射的方式读取类或者注解相关信息(比较费时而且该类必须被ClassLoader加载) StandardClassMetadata:基于反射读取类元数据,可建议单独使用。 StandardAnnotationMetadata:基于反射读取注解元数据,可建议单独使用 StandardMethodMetadata:基于反射读取方法元数据,可建议单独使用 考虑使用Spring内部支持的有用工具类,都是来自于spring-core包中。多使用spring内建API,学习他们的长处。 ClassUtils:类工具类 CollectionUtils:集合工具类 NumberUtils:Number工具类 MimeTypeUtils:媒体类型工具类 IdGenerator:Id生成器 StringUtils:字符串工具类 ResourceUtils:资源工具类 ReflectionUtils:反射工具类 MethodIntrospector:方法自省工具类(EventListenerMethodProcessor#processBean中有使用) PatternMatchUtils:正则资源匹配工具类 ObjectUtils:对象工具类 3:组合注解组合注解指某个注解”元标注”一个或多个其他注解，其目的在于将这些关联的注解行为组合成单个自定义注解。 Spring Framework的类加载通过ASM实现，如ClassReader。相对于ClassLoader体系，Spring ASM更为底层，读取的是类资源，直接操作其中的字节码，获取相关元信息。如MetadataReader接口。 1234567891011121314151617181920212223242526/** * Simple facade for accessing class metadata, * as read by an ASM &#123;@link org.springframework.asm.ClassReader&#125;. * * @author Juergen Hoeller * @since 2.5 */public interface MetadataReader &#123; /** * Return the resource reference for the class file. */ Resource getResource(); /** * Read basic class metadata for the underlying class. */ ClassMetadata getClassMetadata(); /** * Read full annotation metadata for the underlying class, * including metadata for annotated methods. */ AnnotationMetadata getAnnotationMetadata();&#125; AnnotationMetadataReadingVisitor同时实现了ClassMetadata及AnnotationMetadata。因此，元注解的实现集中到AnnotationMetadataReadingVisitor和AnnotationAttributesReadingVisitor之中。 MetadataReader对象通过MetadataReaderFactory对象获取。 12345678910111213141516171819202122232425262728/** * Factory interface for &#123;@link MetadataReader&#125; instances. * Allows for caching a MetadataReader per original resource. * * @author Juergen Hoeller * @since 2.5 * @see SimpleMetadataReaderFactory * @see CachingMetadataReaderFactory */public interface MetadataReaderFactory &#123; /** * Obtain a MetadataReader for the given class name. * @param className the class name (to be resolved to a ".class" file) * @return a holder for the ClassReader instance (never &#123;@code null&#125;) * @throws IOException in case of I/O failure */ MetadataReader getMetadataReader(String className) throws IOException; /** * Obtain a MetadataReader for the given resource. * @param resource the resource (pointing to a ".class" file) * @return a holder for the ClassReader instance (never &#123;@code null&#125;) * @throws IOException in case of I/O failure */ MetadataReader getMetadataReader(Resource resource) throws IOException;&#125; 具体某个注解的元注解信息则通过getMetaAnnotationTypes(String)方法查询。 AnnotationMetadata实现AnnotationMetadataReadingVisitor(ASM实现)，StandardAnnotationMetadata(反射)。 注解元信息抽象:AnnotationMetadata AnnotationMetadataReadingVisitor AnnotationAttributesReadingVisitor(递归查找元注解) 类元信息抽象:ClassMetadata 方法元信息抽象:MethodMetadata 注解属性抽象:AnnotationAttributes 属性环境抽象:Environment 属性文件抽象:PropertySource 元信息读取抽象:MetadataReader 通过MetadataReaderFactory获取 方法内省:MethodIntrospector 1234Map&lt;Method, EventListener&gt; annotatedMethods = null; annotatedMethods = MethodIntrospector.selectMethods(targetType, (MethodIntrospector.MetadataLookup&lt;EventListener&gt;) method -&gt; AnnotatedElementUtils.findMergedAnnotation(method, EventListener.class)); 注解工具类:AnnotationUtils]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring注解属性抽象AnnotationAttributes</tag>
        <tag>模式注解</tag>
        <tag>Component注解派生性原理</tag>
      </tags>
  </entry>
</search>

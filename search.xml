<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JWT认证详解</title>
      <link href="/2019/08/06/JWT%E8%AE%A4%E8%AF%81%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/08/06/JWT%E8%AE%A4%E8%AF%81%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="JWT-Json-web-token-认证详解"><a href="#JWT-Json-web-token-认证详解" class="headerlink" title="JWT(Json web token) 认证详解"></a>JWT(Json web token) 认证详解</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1:概述"></a>1:概述</h3><p><code>JWT声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息,以便从资源服务器获取资源,增加一些额外的其他业务所必须的声明信息</code>。</p><p><strong><code>特别适用于分布式站点的单点登录(SSO)场景</code></strong></p><h3 id="2-起源"><a href="#2-起源" class="headerlink" title="2:起源"></a>2:起源</h3><p>基于token的认证和传统的session认证区别。</p><h5 id="1-传统的session认证"><a href="#1-传统的session认证" class="headerlink" title="(1):传统的session认证"></a>(1):传统的session认证</h5><p><strong><code>概述</code></strong></p><p><code>http协议本身是一种无状态的协议</code>,而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证,那么下一次请求时,用户还要再一次进行用户认证才行,<code>因为根据http协议,我们并不能知道是哪个用户发出的请求,所以为了让我们的应用能识别是哪个用户发出的请求,我们只能在服务器存储一份用户登录的信息</code>,这份登录信息会在响应时传递给浏览器,告诉其保存为cookie,以便下次请求时发送给我们的应用,这样我们的应用就能识别请求来自哪个用户了,这就是传统的基于session认证。</p><p><strong><code>基于session认证所显露的问题</code></strong></p><ul><li><code>session存储问题</code>:由于用户的信息存储在服务端,而且session都是保存在内存中,随之认证用户增多,服务端开销明显增大。</li><li><code>扩展性</code>:用户认证之后,服务端做认证记录,如果认证记录被保存在内存中,<code>意味着用户下次请求还必须要请求这台服务器,才能拿到授权资源</code>。在分布式应用中,相应的限制了负载均衡器的能力。</li><li><code>CSRF</code>:因为<code>基于cookie来进行用户识别</code>,如果cookie被截获,用户就会很容易受到<code>跨站请求伪造攻击</code>。</li></ul><h5 id="2-基于token的鉴权机制"><a href="#2-基于token的鉴权机制" class="headerlink" title="(2):基于token的鉴权机制"></a>(2):基于token的鉴权机制</h5><p><strong><code>概述</code></strong></p><p>基于token的鉴权机制类似于http协议也是无状态的,它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了,这就为应用的扩展提供了便利。</p><p><strong><code>流程</code></strong></p><ul><li>用户使用用户名密码来请求服务器。</li><li>服务器进行验证用户的信息。</li><li>服务器通过验证发送给用户一个token。</li><li>客户端存储token,并在每次请求时附送上这个token值。</li><li>服务端验证token值,并返回数据。</li></ul><p>这个<code>token</code>必须要在<code>每次请求时传递给服务端</code>,应该保存在<code>请求头里</code>。例外,服务端要支持<code>CORS(跨域请求)</code>。</p><h3 id="3-JWT"><a href="#3-JWT" class="headerlink" title="3:JWT"></a>3:JWT</h3><h5 id="1-设计"><a href="#1-设计" class="headerlink" title="(1):设计"></a>(1):设计</h5><p>jwt(json web token)有三部分构成。</p><ul><li><p><strong><code>header(头部)</code></strong></p><ul><li><p>声明类型:<code>jwt</code></p></li><li><p>加密算法:<code>HMAC</code>,<code>SHA256</code></p></li><li><p><strong><code>头部进行base64加密</code></strong>。</p></li><li><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//头部json</span><br><span class="line">&#123; </span><br><span class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">   <span class="attr">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>payload</code></strong>:存储有效信息。</p><ul><li>标准中注册声明(建议单不强制使用)<ul><li><strong>iss</strong>: jwt签发者</li><li><strong><code>sub</code></strong>: <code>jwt所面向的用户</code></li><li><strong>aud</strong>: 接收jwt的一方</li><li><strong>exp</strong>: jwt的过期时间，这个过期时间必须要大于签发时间</li><li><strong>nbf</strong>: 定义在什么时间之前，该jwt都是不可用的.</li><li><strong>iat</strong>: jwt的签发时间</li><li><strong>jti</strong>: jwt的唯一身份标识,主要用来作为一次性token,从而回避重放攻击。</li></ul></li><li>公共声明<ul><li>添加任何信息,一般添加用户的相关信息或者其他业务需要的必要信息。<code>不建议添加敏感信息。(可以在客户端进行解密)</code></li></ul></li><li>私有声明<ul><li><code>提供者和消费者所共同定义的声明,一般不建议存放敏感信息</code>,因为base64是对称解密的，意味着该部分信息可以归类为明文信息。</li></ul></li></ul></li><li><p><strong><code>signature</code></strong>:签证信息</p><ul><li><p>head(base64后的)</p></li><li><p>payload(base64后的)</p></li><li><p>secret:<code>保存在服务端,jwt签发生成也是在服务端。它是用来进行jwt签发和jwt验证,就是服务端的私钥。</code></p><blockquote><p>这个部分需要base64加密后的header和payload使用。连接组成的字符串,然后通过header中声明的加密方式进行加盐secret组合加密,构成jwt第三部分。</p></blockquote></li></ul></li></ul><h5 id="2-应用"><a href="#2-应用" class="headerlink" title="(2):应用"></a>(2):应用</h5><p>一般是在请求头里加入<code>Authorization</code>,并加上<code>Bearer</code>标注:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'api/user/1'</span>, &#123;</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Authorization'</span>: <span class="string">'Bearer '</span> + token</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://images2017.cnblogs.com/blog/1277635/201711/1277635-20171116141211968-1715750540.png" alt="img"></p><h5 id="3-总结"><a href="#3-总结" class="headerlink" title="(3):总结"></a>(3):总结</h5><p><strong><code>优点</code></strong></p><ul><li>由于json通用性,所以JWT可以跨语言。</li><li>因为有payload,所以jwt可以在自身存储一些其他业务所必要的非敏感信息。</li><li>便于传输,字节占用很小</li><li>不需要在服务端保存会话信息,易于扩展,特别适用于分布式微服务。</li></ul><p><strong><code>安全相关</code></strong></p><ul><li><code>不应该在jwt的payload部分存放敏感信息</code>,因为这部分客户端可解密的部分</li><li><code>保护好secret私钥</code>,该私钥非常重要。</li><li><code>如果可以,请使用https协议</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JWT </category>
          
          <category> SSO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON Web Token认证 </tag>
            
            <tag> Session认证 </tag>
            
            <tag> 分布式单点登录(SSO)场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot自定义注解加载yml或者yaml文件</title>
      <link href="/2019/08/06/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%8A%A0%E8%BD%BDyml%E6%88%96%E8%80%85yaml%E6%96%87%E4%BB%B6/"/>
      <url>/2019/08/06/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%8A%A0%E8%BD%BDyml%E6%88%96%E8%80%85yaml%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot自定义注解加载yml或者yaml文件"><a href="#SpringBoot自定义注解加载yml或者yaml文件" class="headerlink" title="SpringBoot自定义注解加载yml或者yaml文件"></a>SpringBoot自定义注解加载yml或者yaml文件</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1:概述"></a>1:概述</h3><p>SpringBoot的<code>@PropertySource</code>注解只支持加载    properties结尾的文件。当使用@ConfigurationProperties</p><p>注解配合<code>@EnableConfigurationProperties</code>注解将配置转换为JavaBean时,可能需要配合@PropertySource</p><p>注解加载指定的配置文件。所以为了支持以<code>yml或者yaml</code>文件,我自定义了注解<code>@YmlPropertySource</code>。</p><h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2:实现"></a>2:实现</h3><p><strong>声明注解@YamlPropertySource</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PropertySourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * yaml property source and extension &#123;<span class="doctag">@link</span> PropertySource&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.annotation.PropertySource</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Repeatable</span>(YamlPropertySources.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> YamlPropertySource &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicate the name of this property source. If omitted, a name will</span></span><br><span class="line"><span class="comment">     * be generated based on the description of the underlying resource.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.core.env.PropertySource#getName()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.core.io.Resource#getDescription()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicate the resource location(s) of the properties file to be loaded.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Both traditional and XML-based properties file formats are supported</span></span><br><span class="line"><span class="comment">     * &amp;mdash; for example, &#123;<span class="doctag">@code</span> "classpath:/com/myco/app.properties"&#125;</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@code</span> "file:/path/to/file.xml"&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Resource location wildcards (e.g. *&amp;#42;/*.properties) are not permitted;</span></span><br><span class="line"><span class="comment">     * each location must evaluate to exactly one &#123;<span class="doctag">@code</span> .properties&#125; resource.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;$&#123;...&#125; placeholders will be resolved against any/all property sources already</span></span><br><span class="line"><span class="comment">     * registered with the &#123;<span class="doctag">@code</span> Environment&#125;. See &#123;<span class="doctag">@linkplain</span> PropertySource above&#125;</span></span><br><span class="line"><span class="comment">     * for examples.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Each location will be added to the enclosing &#123;<span class="doctag">@code</span> Environment&#125; as its own</span></span><br><span class="line"><span class="comment">     * property source, and in the order declared.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicate if failure to find the a &#123;<span class="doctag">@link</span> #value() property resource&#125; should be</span></span><br><span class="line"><span class="comment">     * ignored.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&#123;<span class="doctag">@code</span> true&#125; is appropriate if the properties file is completely optional.</span></span><br><span class="line"><span class="comment">     * Default is &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 4.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">ignoreResourceNotFound</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A specific character encoding for the given resources, e.g. "UTF-8".</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 4.3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">encoding</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Specify a custom &#123;<span class="doctag">@link</span> PropertySourceFactory&#125;, if any.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;By default, a default factory for standard resource files will be used.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.core.io.support.DefaultPropertySourceFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.core.io.support.ResourcePropertySource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 4.3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? extends PropertySourceFactory&gt; factory() <span class="keyword">default</span> YamlPropertySourceFactory.class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> YamlPropertySource</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> YamlPropertySources &#123;</span><br><span class="line"></span><br><span class="line">    YamlPropertySource[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体实现如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.YamlPropertiesFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.EnvironmentAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ResourceLoaderAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.AnnotationUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ResourceLoader;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.Assert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类描述: &#123;<span class="doctag">@link</span> YamlPropertySource&#125; bean post processor.this class convert the yml or yaml file &#123;<span class="doctag">@link</span> YamlPropertySource#value()&#125; to &#123;<span class="doctag">@link</span> PropertiesPropertySource&#125;,and add the property source</span></span><br><span class="line"><span class="comment"> * named &#123;<span class="doctag">@link</span> YmlPropertySource#name()&#125; into &#123;<span class="doctag">@link</span> Environment&#125;.When you use this annotation,you</span></span><br><span class="line"><span class="comment"> * must for follow example:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@link</span> <span class="doctag">@ConfigurationProperties</span>(prefix = "person")</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@link</span> <span class="doctag">@YmlPropertySource</span>(value = &#123;"classpath:/hello.yml"&#125;, name = "hello")</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@link</span> <span class="doctag">@Data</span></span></span><br><span class="line"><span class="comment"> * public class PersonProperties &#123;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * private String name;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * private Integer age;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * private String school;</span></span><br><span class="line"><span class="comment"> * &#125;&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/6/16 20:13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> YamlPropertySource</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> InstantiationAwareBeanPostProcessorAdapter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnvironmentAware</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ResourceLoaderAware</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Configuration</span>(value = YamlPropertySourceAnnotationPostProcessor.BEAN_NAME)</span><br><span class="line"><span class="meta">@Order</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YamlPropertySourceAnnotationPostProcessor</span> <span class="keyword">extends</span> <span class="title">InstantiationAwareBeanPostProcessorAdapter</span> <span class="keyword">implements</span> <span class="title">EnvironmentAware</span>, <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String BEAN_NAME = <span class="string">"yamlPropertySourceAnnotationPostProcessor"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; propertySourceNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> PropertySourceFactory DEFAULT_PROPERTY_SOURCE_FACTORY = <span class="keyword">new</span> YamlPropertySourceFactory();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        Assert.isInstanceOf(ConfigurableEnvironment.class, environment, <span class="string">"environment must be instance of ConfigurableEnvironment."</span>);</span><br><span class="line">        <span class="keyword">this</span>.environment = environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// Process any @PropertySource annotations</span></span><br><span class="line">        Set&lt;YamlPropertySource&gt; yamlPropertySources = AnnotationUtils.getRepeatableAnnotations(bean.getClass(),</span><br><span class="line">                YamlPropertySource.class, YamlPropertySources.class);</span><br><span class="line">        <span class="keyword">if</span> (!yamlPropertySources.isEmpty()) &#123;</span><br><span class="line">            Set&lt;AnnotationAttributes&gt; attributesSet = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(yamlPropertySources.size());</span><br><span class="line">            <span class="keyword">for</span> (YamlPropertySource yamlPropertySource : yamlPropertySources) &#123;</span><br><span class="line">                AnnotationAttributes attributes = AnnotationUtils.getAnnotationAttributes(bean.getClass(),</span><br><span class="line">                        yamlPropertySource);</span><br><span class="line">                attributesSet.add(attributes);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (AnnotationAttributes propertySource : attributesSet) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        processPropertySource(propertySource);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        log.warn(<span class="string">"exception message: &#123;&#125;"</span>, e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.warn(<span class="string">"Ignoring @YamlPropertySource annotation on ["</span> + bean.getClass() +</span><br><span class="line">                            <span class="string">"]. Reason: Environment must implement ConfigurableEnvironment"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processPropertySource</span><span class="params">(AnnotationAttributes propertySource)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String name = propertySource.getString(<span class="string">"name"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasLength(name)) &#123;</span><br><span class="line">            name = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String encoding = propertySource.getString(<span class="string">"encoding"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasLength(encoding)) &#123;</span><br><span class="line">            encoding = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] locations = propertySource.getStringArray(<span class="string">"value"</span>);</span><br><span class="line">        Assert.isTrue(locations.length &gt; <span class="number">0</span>, <span class="string">"At least one @YamlPropertySource(value) location is required"</span>);</span><br><span class="line">        <span class="keyword">boolean</span> ignoreResourceNotFound = propertySource.getBoolean(<span class="string">"ignoreResourceNotFound"</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;? extends PropertySourceFactory&gt; factoryClass = propertySource.getClass(<span class="string">"factory"</span>);</span><br><span class="line">        PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?</span><br><span class="line">                DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String location : locations) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String resolvedLocation = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(location);</span><br><span class="line">                Resource resource = <span class="keyword">this</span>.resourceLoader.getResource(resolvedLocation);</span><br><span class="line">                addPropertySource(factory.createPropertySource(name, <span class="keyword">new</span> EncodedResource(resource, encoding)));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) &#123;</span><br><span class="line">                <span class="comment">// Placeholders not resolvable or resource not found when trying to open it</span></span><br><span class="line">                <span class="keyword">if</span> (ignoreResourceNotFound) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">                        log.info(<span class="string">"Properties or Yml or Yaml location ["</span> + location + <span class="string">"] not resolvable: "</span> + ex.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addPropertySource</span><span class="params">(PropertySource&lt;?&gt; propertySource)</span> </span>&#123;</span><br><span class="line">        String name = propertySource.getName();</span><br><span class="line">        MutablePropertySources propertySources = ((ConfigurableEnvironment) <span class="keyword">this</span>.environment).getPropertySources();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.propertySourceNames.contains(name)) &#123;</span><br><span class="line">            <span class="comment">// We've already added a version, we need to extend it</span></span><br><span class="line">            PropertySource&lt;?&gt; existing = propertySources.get(name);</span><br><span class="line">            <span class="keyword">if</span> (existing != <span class="keyword">null</span>) &#123;</span><br><span class="line">                PropertySource&lt;?&gt; newSource = (propertySource <span class="keyword">instanceof</span> ResourcePropertySource ?</span><br><span class="line">                        ((ResourcePropertySource) propertySource).withResourceName() : propertySource);</span><br><span class="line">                <span class="keyword">if</span> (existing <span class="keyword">instanceof</span> CompositePropertySource) &#123;</span><br><span class="line">                    ((CompositePropertySource) existing).addFirstPropertySource(newSource);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (existing <span class="keyword">instanceof</span> ResourcePropertySource) &#123;</span><br><span class="line">                        existing = ((ResourcePropertySource) existing).withResourceName();</span><br><span class="line">                    &#125;</span><br><span class="line">                    CompositePropertySource composite = <span class="keyword">new</span> CompositePropertySource(name);</span><br><span class="line">                    composite.addPropertySource(newSource);</span><br><span class="line">                    composite.addPropertySource(existing);</span><br><span class="line">                    propertySources.replace(name, composite);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.propertySourceNames.isEmpty()) &#123;</span><br><span class="line">            propertySources.addLast(propertySource);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String firstProcessed = <span class="keyword">this</span>.propertySourceNames.get(<span class="keyword">this</span>.propertySourceNames.size() - <span class="number">1</span>);</span><br><span class="line">            propertySources.addBefore(firstProcessed, propertySource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.propertySourceNames.add(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>想法</strong></p><p>使用<code>InstantiationAwareBeanPostProcessorAdapter</code>的postProcessAfterInstantiation(Object bean, String beanName)方法,然后通过<code>YamlPropertiesFactoryBean</code>将yml|yaml文件转换为properties文件,然后通过</p><p>实现<code>EnvironmentAware</code>接口,将配置文件属性写入到spring的<code>Environment</code>环境中。但是该实现有点</p><p>缺陷,就是如果使用<code>@ConfigurationProperties</code>和<code>@EnableConfigurationProperties</code>将配置属性</p><p>转换为<code>JavaBean</code>时,需要将<code>@YmlProperySource</code>注解标注到该<code>JavaBean</code>上。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> 外部化配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 外部化配置 </tag>
            
            <tag> yml|yaml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring类型转换</title>
      <link href="/2019/08/06/Spring%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2019/08/06/Spring%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Type-Conversion-Spring类型转换"><a href="#Spring-Type-Conversion-Spring类型转换" class="headerlink" title="Spring Type Conversion(Spring类型转换)"></a>Spring Type Conversion(Spring类型转换)</h2><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1:概述:"></a>1:概述:</h4><p><code>Spring3</code>引入了<code>core.convert</code>包,提供了<code>通用类型转换系统</code>,定义了实现<code>类型转换和运行时执行类型的SPI</code>。</p><p>在<code>Spring3.0</code>之前,提供的<code>PropertyEditor</code>来将外部化bean属性值字符串转换成必需的实现类型。</p><h4 id="2-Converter-SPI"><a href="#2-Converter-SPI" class="headerlink" title="2:Converter SPI"></a>2:<code>Converter SPI</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A converter converts a source object of type &#123;<span class="doctag">@code</span> S&#125; to a target of type &#123;<span class="doctag">@code</span> T&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Implementations of this interface are thread-safe and can be shared.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Implementations may additionally implement &#123;<span class="doctag">@link</span> ConditionalConverter&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;S&gt; the source type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the target type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert the source object of type &#123;<span class="doctag">@code</span> S&#125; to target type &#123;<span class="doctag">@code</span> T&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> source the source object to convert, which must be an instance of &#123;<span class="doctag">@code</span> S&#125; (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the converted object, which must be an instance of &#123;<span class="doctag">@code</span> T&#125; (potentially &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the source cannot be converted to the desired target type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">T <span class="title">convert</span><span class="params">(S source)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   实现自定义的类型转换可以实现<code>Converter</code>接口。但是如果S是<code>集合或者数组</code>转换为<code>T的集合或者数组</code>,</p><p>建议参考诸如<code>ArrayToCollectionConverter</code>实现。前提是已经注册了委托<code>数组或集合转换器</code>。例如,</p><p><code>DefaultConversionService</code>实现。</p><p>  <code>Converter.convert(S source)中source确保不能为null,否则转换器可能抛出异常如果转换失败。</code>具体</p><p>说,应该会抛出<code>IllegalArgumentException</code>报告不合理的转换源。确保<code>Converter</code>实现是<code>线程安全</code>。</p><p>   在<code>core.convert.support</code>包下,注册了常见了类型转换器。例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Converts from a String any JDK-standard Number implementation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Support Number classes including Byte, Short, Integer, Float, Double, Long, BigInteger, BigDecimal. This class</span></span><br><span class="line"><span class="comment"> * delegates to &#123;<span class="doctag">@link</span> NumberUtils#parseNumber(String, Class)&#125; to perform the conversion.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Byte</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Short</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Integer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.math.BigInteger</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Float</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Double</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.math.BigDecimal</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> NumberUtils</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToNumberConverterFactory</span> <span class="keyword">implements</span> <span class="title">ConverterFactory</span>&lt;<span class="title">String</span>, <span class="title">Number</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Number&gt; <span class="function">Converter&lt;String, T&gt; <span class="title">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> StringToNumber&lt;&gt;(targetType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToNumber</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; targetType;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringToNumber</span><span class="params">(Class&lt;T&gt; targetType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.targetType = targetType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (source.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NumberUtils.parseNumber(source, <span class="keyword">this</span>.targetType);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-ConverterFactory"><a href="#3-ConverterFactory" class="headerlink" title="3:ConverterFactory"></a>3:<code>ConverterFactory</code></h4><p><code>当你需要集中整理类层次结构的类型转换器,可以使用ConverterFactory</code>。例如StringToNumberConverterFactory,</p><p>该接口定义如下,<code>当你需要范围转换器,可以转换这些对象从S类型转换成R的子类型。使用该接口</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A factory for "ranged" converters that can convert objects from S to subtypes of R.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Implementations may additionally implement &#123;<span class="doctag">@link</span> ConditionalConverter&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConditionalConverter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;S&gt; the source type converters created by this factory can convert from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;R&gt; the target range (or base) type converters created by this factory can convert to;</span></span><br><span class="line"><span class="comment"> * for example &#123;<span class="doctag">@link</span> Number&#125; for a set of number subtypes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConverterFactory</span>&lt;<span class="title">S</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the converter to convert from S to target type T, where T is also an instance of R.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the target type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetType the target type to convert to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a converter from S to T</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;T extends R&gt; <span class="function">Converter&lt;S, T&gt; <span class="title">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Converts from a String any JDK-standard Number implementation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Support Number classes including Byte, Short, Integer, Float, Double, Long, BigInteger, BigDecimal. This class</span></span><br><span class="line"><span class="comment"> * delegates to &#123;<span class="doctag">@link</span> NumberUtils#parseNumber(String, Class)&#125; to perform the conversion.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Byte</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Short</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Integer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.math.BigInteger</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Float</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Double</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.math.BigDecimal</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> NumberUtils</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToNumberConverterFactory</span> <span class="keyword">implements</span> <span class="title">ConverterFactory</span>&lt;<span class="title">String</span>, <span class="title">Number</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Number&gt; <span class="function">Converter&lt;String, T&gt; <span class="title">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> StringToNumber&lt;&gt;(targetType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToNumber</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; targetType;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringToNumber</span><span class="params">(Class&lt;T&gt; targetType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.targetType = targetType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (source.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NumberUtils.parseNumber(source, <span class="keyword">this</span>.targetType);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-GenericConverter"><a href="#4-GenericConverter" class="headerlink" title="4:GenericConverter"></a>4:<code>GenericConverter</code></h4><p>  <code>GenericConverter</code>提供<code>多种源和目标类型之间转换</code>,比<code>Converter更灵活但是对类型要求不高</code>。它提供了实现</p><p>转换逻辑的<code>源和目标上下文</code>。 这样的上下文允许类型转换由字段注释或在字段签名上声明的通用信息驱动。接口</p><p>如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="title">getConvertibleTypes</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConvertiblePair</code>持有<code>转换源和目标类型对</code>。<code>convert(Object, TypeDescriptor, TypeDescriptor)</code>。</p><p><code>源TypeDescriptor</code>提供对保存正在转换的值的源字段的访问。 <code>目标TypeDescriptor</code>提供对要设置转换值的目标字段的访问。<code>TypeDescriptor</code>类是<code>关于要转换类型的上下文</code>。</p><p>  一个好的实例是<code>GenericConverter</code>在Java数组和集合之间转换。例如<code>ArrayToCollectionConverter</code>。</p><p><strong><code>注意</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为GenericConverter是一个更复杂的SPI接口,所以只有在需要时才应该使用它.喜欢Converter或ConverterFactory以满足基本的类型转换需求。</span><br></pre></td></tr></table></figure><h4 id="5-ConditionalGenericConverter"><a href="#5-ConditionalGenericConverter" class="headerlink" title="5:ConditionalGenericConverter"></a>5:<code>ConditionalGenericConverter</code></h4><p>该接口是一个带有判断条件的类型转换器。该接口是<code>GenericConverter</code>和<code>ConditionalConverter</code>的组合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@link</span> GenericConverter&#125; that may conditionally execute based on attributes</span></span><br><span class="line"><span class="comment"> * of the &#123;<span class="doctag">@code</span> source&#125; and &#123;<span class="doctag">@code</span> target&#125; &#123;<span class="doctag">@link</span> TypeDescriptor&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;See &#123;<span class="doctag">@link</span> ConditionalConverter&#125; for details.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Phillip Webb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> GenericConverter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConditionalConverter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConditionalGenericConverter</span> <span class="keyword">extends</span> <span class="title">GenericConverter</span>, <span class="title">ConditionalConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConditionalGenericConverter</code> 的一个好示例是<code>StringToCollectionConverter</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Converts a comma-delimited String to a Collection.</span></span><br><span class="line"><span class="comment"> * If the target collection element type is declared, only matches if</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> String.class&#125; can be converted to it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToCollectionConverter</span> <span class="keyword">implements</span> <span class="title">ConditionalGenericConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConversionService conversionService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringToCollectionConverter</span><span class="params">(ConversionService conversionService)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.conversionService = conversionService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="title">getConvertibleTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> ConvertiblePair(String.class, Collection.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (targetType.getElementTypeDescriptor() == <span class="keyword">null</span> ||</span><br><span class="line"><span class="keyword">this</span>.conversionService.canConvert(sourceType, targetType.getElementTypeDescriptor()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">convert</span><span class="params">(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (source == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">String string = (String) source;</span><br><span class="line"></span><br><span class="line">String[] fields = StringUtils.commaDelimitedListToStringArray(string);</span><br><span class="line">TypeDescriptor elementDesc = targetType.getElementTypeDescriptor();</span><br><span class="line">Collection&lt;Object&gt; target = CollectionFactory.createCollection(targetType.getType(),</span><br><span class="line">(elementDesc != <span class="keyword">null</span> ? elementDesc.getType() : <span class="keyword">null</span>), fields.length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (elementDesc == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String field : fields) &#123;</span><br><span class="line">target.add(field.trim());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (String field : fields) &#123;</span><br><span class="line">Object targetElement = <span class="keyword">this</span>.conversionService.convert(field.trim(), sourceType, elementDesc);</span><br><span class="line">target.add(targetElement);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-ConversionService-API"><a href="#6-ConversionService-API" class="headerlink" title="6:ConversionService API"></a>6:<code>ConversionService API</code></h4><p><code>ConversionService定义了一个统一的API,用于在运行时执行类型转换逻辑</code>. 转换器通常在以下Facade接口后面执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConversionService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">convert</span><span class="params">(Object source, Class&lt;T&gt; targetType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  大多数ConversionService实现,同样也实现了<code>ConverterRegistry</code>,该接口提供了<code>SPI</code>来注册<code>Converters</code>.</p><p>在内部,<code>ConversionService</code>的实现,容器委托它来注册转换器来执行转换逻辑。</p><p>  <code>core.convert.support</code>提供一个强大的<code>ConversionService</code>实现,该实现是<code>GenericConversionSer</code></p><p>,它适用于大多数转换器环境实现。<code>ConversionServiceFactory</code> 来创建普通的<code>ConversionService</code></p><p>配置。</p><h4 id="7-配置ConversionService"><a href="#7-配置ConversionService" class="headerlink" title="7:配置ConversionService"></a>7:配置<code>ConversionService</code></h4><p>  <code>ConversionService</code>被设计成<code>无状态对象</code>,在<code>容器</code>启动时被实例化,在多线程间进行共享(线程安全)。</p><p>在Spring应用中,可以自定义<code>类型转换器</code>。当需要框架进行类型转换时,Spring会选择<code>合适的类型转换器</code></p><p>使用。你也可以注入<code>ConversionService</code>到beans或者直接调用。</p><p>   <strong><code>注意</code></strong></p><blockquote><p>如果没有<code>ConversionService</code>注册到Spring容器,基于的<code>PropertyEditor</code>实现的类型转换会被使用。</p></blockquote><p>​    使用如下的方式,注册默认<code>ConversionService进</code>Spring容器中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertersConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"conversionService"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConversionServiceFactoryBean <span class="title">conversionServiceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ConversionServiceFactoryBean conversionServiceFactoryBean = <span class="keyword">new</span> ConversionServiceFactoryBean();</span><br><span class="line">        <span class="keyword">return</span> conversionServiceFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   默认的<code>ConversionService</code>可以在<code>字符串，数字，枚举，集合，映射和其他常见类型之间进行转换</code>。要使用您自己的自定义转换器补充或覆盖默认转换器,请设置converter属性.属性值可以实现任何Converter,ConverterFactory或GenericConverter接口。默认<code>ConversionService</code>实现是<code>DefaultConversionService</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertersConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"conversionService"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConversionServiceFactoryBean <span class="title">conversionServiceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ConversionServiceFactoryBean conversionServiceFactoryBean = <span class="keyword">new</span> ConversionServiceFactoryBean();</span><br><span class="line">        <span class="comment">//实现自定义的类型转换器</span></span><br><span class="line">        conversionServiceFactoryBean.setConverters(Collections.singleton(<span class="keyword">new</span> StringToDateConverter()));</span><br><span class="line">        <span class="keyword">return</span> conversionServiceFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   也可以使用<code>ConversionService</code>在Spring MVC应用中,参考<code>WebMvcConfigurationSupport</code>类,该类方法</p><p><code>addFormatters(FormatterRegistry registry)</code>可以注册自定义的<code>converters</code>。</p><p>   在某些情况,希望在类型转换期间需要格式化,参考<code>FormatterRegistry</code>。</p><p>   <strong>在程序中使用<code>ConversionService</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(ConversionService conversionService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.conversionService = conversionService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doIt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.conversionService.convert(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-Spring域属性格式化"><a href="#8-Spring域属性格式化" class="headerlink" title="8:Spring域属性格式化"></a>8:Spring域属性格式化</h4><p>   <code>core.convert</code>是一个<code>通用的类型转换系统</code>.它提供了统一的ConversionService API以及强类型转换器SPI,用于实现从一种类型到另一种类型的转换逻辑.Spring容器使用这个系统来<code>绑定bean属性值</code>。额外的,还要<code>SpEL</code>和</p><p><code>DataBinder</code>。<code>Spring3</code>引入了<code>Formatter SPI</code>来实现格式化属性值。<code>ConversionService</code>为两个SPI提供统一的类型转换API。</p><h5 id="1-Formatter-SPI"><a href="#1-Formatter-SPI" class="headerlink" title="(1):Formatter SPI"></a>(1):<code>Formatter SPI</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Formats objects of type T.</span></span><br><span class="line"><span class="comment"> * A Formatter is both a Printer &lt;i&gt;and&lt;/i&gt; a Parser for an object type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of object this Formatter formats</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Formatter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Printer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Parser</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parses text strings to produce instances of T.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of object this Parser produces</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Parser</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse a text String to produce a T.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text the text string</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> locale the current user locale</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an instance of T</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ParseException when a parse exception occurs in a java.text parsing library</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException when a parse exception occurs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">T <span class="title">parse</span><span class="params">(String text, Locale locale)</span> <span class="keyword">throws</span> ParseException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prints objects of type T for display.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of object this Printer prints</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Printer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Print the object of type T for display.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> object the instance to print</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> locale the current user locale</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the printed text string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">print</span><span class="params">(T object, Locale locale)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-Annotation-Driven-Formatting"><a href="#2-Annotation-Driven-Formatting" class="headerlink" title="(2):Annotation-Driven Formatting"></a>(2):<code>Annotation-Driven Formatting</code></h5><p>域格式化可以通过<code>域类型或者注解配置.</code>为了绑定注解在一个<code>Formatter</code>,实现<code>AnnotationFormatterFactory</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.format;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A factory that creates formatters to format values of fields annotated with a particular</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Annotation&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;For example, a &#123;<span class="doctag">@code</span> DateTimeFormatAnnotationFormatterFactory&#125; might create a formatter</span></span><br><span class="line"><span class="comment"> * that formats &#123;<span class="doctag">@code</span> Date&#125; values set on fields annotated with &#123;<span class="doctag">@code</span> <span class="doctag">@DateTimeFormat</span>&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;A&gt; the annotation type that should trigger formatting</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnnotationFormatterFactory</span>&lt;<span class="title">A</span> <span class="keyword">extends</span> <span class="title">Annotation</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; getFieldTypes();</span><br><span class="line"></span><br><span class="line">    Printer&lt;?&gt; getPrinter(A annotation, Class&lt;?&gt; fieldType);</span><br><span class="line"></span><br><span class="line">    Parser&lt;?&gt; getParser(A annotation, Class&lt;?&gt; fieldType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如实现<code>NumberFormatAnnotationFormatterFactory</code>,绑定<code>@NumberFormat</code>注解到<code>Formatter</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberFormatAnnotationFormatterFactory</span> <span class="keyword">extends</span> <span class="title">EmbeddedValueResolutionSupport</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">AnnotationFormatterFactory</span>&lt;<span class="title">NumberFormat</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getFieldTypes() &#123;</span><br><span class="line"><span class="keyword">return</span> NumberUtils.STANDARD_NUMBER_TYPES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Printer&lt;Number&gt; <span class="title">getPrinter</span><span class="params">(NumberFormat annotation, Class&lt;?&gt; fieldType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> configureFormatterFrom(annotation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Parser&lt;Number&gt; <span class="title">getParser</span><span class="params">(NumberFormat annotation, Class&lt;?&gt; fieldType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> configureFormatterFrom(annotation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Formatter&lt;Number&gt; <span class="title">configureFormatterFrom</span><span class="params">(NumberFormat annotation)</span> </span>&#123;</span><br><span class="line">String pattern = resolveEmbeddedValue(annotation.pattern());</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(pattern)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> NumberStyleFormatter(pattern);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Style style = annotation.style();</span><br><span class="line"><span class="keyword">if</span> (style == Style.CURRENCY) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> CurrencyStyleFormatter();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (style == Style.PERCENT) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> PercentStyleFormatter();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> NumberStyleFormatter();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-格式化注解API"><a href="#3-格式化注解API" class="headerlink" title="(3):格式化注解API"></a>(3):格式化注解API</h5><p><code>DateTimeFormat</code>和<code>NumberFormat</code>。</p><h5 id="4-FormatterRegistry-SPI"><a href="#4-FormatterRegistry-SPI" class="headerlink" title="(4):FormatterRegistry SPI"></a>(4):<code>FormatterRegistry SPI</code></h5><p><code>FormatterRegistry</code>是用来注册<code>formatters 和 converters</code>的<code>SPI</code>。<code>FormattingConversionService</code></p><p>是<code>FormatterRegistry</code> 一个实现,可以支持大多数环境。可以通过FormattingConversionServiceFactoryBean</p><p>来配置。也可以通过Spring’s <code>DataBinder</code>和<code>SpEL</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.format;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FormatterRegistry</span> <span class="keyword">extends</span> <span class="title">ConverterRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFormatterForFieldType</span><span class="params">(Class&lt;?&gt; fieldType, Printer&lt;?&gt; printer, Parser&lt;?&gt; parser)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFormatterForFieldType</span><span class="params">(Class&lt;?&gt; fieldType, Formatter&lt;?&gt; formatter)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFormatterForFieldType</span><span class="params">(Formatter&lt;?&gt; formatter)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFormatterForAnnotation</span><span class="params">(AnnotationFormatterFactory&lt;?, ?&gt; factory)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-FormatterRegistrar-SPI"><a href="#5-FormatterRegistrar-SPI" class="headerlink" title="(5):FormatterRegistrar SPI"></a>(5):<code>FormatterRegistrar SPI</code></h5><p><code>FormatterRegistrar</code>是通过<code>FormatterRegistry</code>注册formatters和converters的<code>SPI</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.format;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FormatterRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerFormatters</span><span class="params">(FormatterRegistry registry)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-在Spring-MVC配置Formatting"><a href="#9-在Spring-MVC配置Formatting" class="headerlink" title="9:在Spring MVC配置Formatting"></a>9:在Spring MVC配置Formatting</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Configuration</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addFormatters</span><span class="params">(FormatterRegistry registry)</span> </span>&#123;</span><br><span class="line">       registry.addConverter(<span class="keyword">new</span> StringToDateConverter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-配置全局的Date和时间Format"><a href="#10-配置全局的Date和时间Format" class="headerlink" title="10:配置全局的Date和时间Format"></a>10:配置全局的Date和时间Format</h4><p><code>JodaTimeFormatterRegistrar</code>和<code>DateFormatterRegistrar</code>,使用Joda需要引入joda库</p><p>配置如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FormattingConversionService <span class="title">conversionService</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use the DefaultFormattingConversionService but do not register defaults</span></span><br><span class="line">        DefaultFormattingConversionService conversionService = <span class="keyword">new</span> DefaultFormattingConversionService(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ensure @NumberFormat is still supported</span></span><br><span class="line">        conversionService.addFormatterForFieldAnnotation(<span class="keyword">new</span> NumberFormatAnnotationFormatterFactory());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Register date conversion with a specific global format</span></span><br><span class="line">        DateFormatterRegistrar registrar = <span class="keyword">new</span> DateFormatterRegistrar();</span><br><span class="line">        registrar.setFormatter(<span class="keyword">new</span> DateFormatter(<span class="string">"yyyyMMdd"</span>));</span><br><span class="line">        registrar.registerFormatters(conversionService);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> conversionService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><blockquote><p>Joda-Time提供不同类型表示日期<code>date,time,datetime</code>,需要通过<code>JodaTimeFormatterRegistrar</code>进行</p><p>注册。或者使用<code>DateTimeFormatterFactoryBean</code>来进行创建formatters。</p></blockquote><blockquote><p>如果您使用Spring MVC,请记住明确配置使用的转换服务.对于基于Java的@Configuration,这意味着扩展WebMvcConfigurationSupport类并覆盖mvcConversionService()方法.对于XML,您应该使用mvc:annotation-driven元素的conversion-service属性。 有关详细信息，请参阅转换和格式。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Type Converter </tag>
            
            <tag> 单例设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring注解属性覆盖</title>
      <link href="/2019/08/06/Spring%E6%B3%A8%E8%A7%A3%E5%B1%9E%E6%80%A7%E8%A6%86%E7%9B%96/"/>
      <url>/2019/08/06/Spring%E6%B3%A8%E8%A7%A3%E5%B1%9E%E6%80%A7%E8%A6%86%E7%9B%96/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring注解属性覆盖"><a href="#Spring注解属性覆盖" class="headerlink" title="Spring注解属性覆盖"></a>Spring注解属性覆盖</h2><h3 id="1-隐性覆盖"><a href="#1-隐性覆盖" class="headerlink" title="1:隐性覆盖"></a>1:隐性覆盖</h3><p>较低层次的注解覆盖其元注解的同名属性</p><p>AnnotationAttributes采用注解就近覆盖的设计原则。</p><blockquote><p>@Component</p><p>​    | -@Service</p><p>​           | -@TransactionalService</p><p>@Service较@Component,距离@TransactionalService注解更近，属于较低层次的注解。</p></blockquote><h3 id="2-显性覆盖"><a href="#2-显性覆盖" class="headerlink" title="2:显性覆盖"></a>2:显性覆盖</h3><p>@AliasFor提供的属性覆盖能力。</p><h5 id="1-理解Spring注解属性别名-Aliases"><a href="#1-理解Spring注解属性别名-Aliases" class="headerlink" title="(1):理解Spring注解属性别名(Aliases)"></a>(1):理解Spring注解属性别名(Aliases)</h5><ul><li>@AliasFor可用于同一注解属性方法之间相互别名。<strong>同一注解两个属性方法需要相互</strong></li></ul><p><strong>“@AliasFor”，默认值必须相等</strong>。</p><ul><li>多层次注解属性之间的@AliasFor关系只能由较低层次向较高层次建立。即<strong>就近原则</strong>。</li><li>AnnotatedElementUtils.getMergedAnnotationAttributes方法也符合属性别名完整语义。</li><li>Spring为Spring元注解和@AliasFor提供了属性覆盖和别名特性，最终由AnnotationAttributes</li></ul><p>对象表达语义。</p><h5 id="2-代码实例"><a href="#2-代码实例" class="headerlink" title="(2):代码实例"></a>(2):代码实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类描述:组合注解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/4/25 20:11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="comment">//表明注解属性覆盖符合就近原则,由低层次向高层次建立。</span></span><br><span class="line"><span class="meta">@Service</span>(value = <span class="string">"transactionalService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TransactionalService &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 服务Bean名称</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> "txManager"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆盖&#123;<span class="doctag">@link</span> Transactional#transactionManager()&#125;默认值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> org.springframework.transaction.PlatformTransactionManager&#125;Bean名称,默认关联</span></span><br><span class="line"><span class="comment">     * &lt;br/&gt;</span></span><br><span class="line"><span class="comment">     * "txManager"Bean</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * String transactionManager() default "txManager";</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"name"</span>)</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "txManager"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立&#123;<span class="doctag">@link</span> Transactional#transactionManager()&#125;别名</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> org.springframework.transaction.PlatformTransactionManager&#125;Bean名称,默认关联</span></span><br><span class="line"><span class="comment">     * "txManager"Bean.</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(annotation = Transactional.class, attribute = <span class="string">"transactionManager"</span>)</span><br><span class="line">    <span class="function">String <span class="title">manager</span><span class="params">()</span> <span class="keyword">default</span> "txManager"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-重要的类"><a href="#3-重要的类" class="headerlink" title="3:重要的类"></a>3:重要的类</h3><p>1：ClassPathBeanDefinitionScanner</p><p>   读取类路径下的候选Bean，默认选取@Component，@Service，@Repository，@Controller注解的类。继承了ClassPathScanningCandidateComponentProvider。在该类BeanDefinition集合的候选条件由includeFilters和excludeFilters字段决定，在方法isCandidateComponent里实现。</p><p>  该类允许自定义类型过滤规则。常见的TypeFilter类。</p><ul><li>AnnotationTypeFilter：匹配类是否还有指定注解</li><li>AssignableTypeFilter：判定此 <code>Class</code> 对象所表示的类或接口与指定的 <code>Class</code> 参数所表示的类或接口是否相同，或是否是其超类或超接口。</li><li>RegexPatternTypeFilter：匹配全类限定名是否符合指定正则表达式。</li><li>AspectJTypeFilter：使用AspectJ类型模式进行匹配</li></ul><p>2：类元信息读取</p><p>(1)：MetadataReaderFactory：生成MetadataReader工厂</p><ul><li>SimpleMetadataReaderFactory：使用ASM字节码操作技术</li><li>CachingMetadataReaderFactory：使用ASM字节码操作技术和带缓存。</li></ul><p>(2)：使用Java反射获取类元信息</p><ul><li>StandardClassMetadata：读取Class元信息</li><li>StandardAnnotationMetadata：读取注解元信息</li><li>StandardMethodMetadata：读取方法</li></ul><p>(3)：使用ASM操作</p><ul><li>AnnotationMetadataReadingVisitor：查找类上元注解信息</li><li>MethodMetadataReadingVisitor：查找方法上元注解信息</li><li>AnnotationAttributesReadingVisitor：元注解属性读取</li></ul><p>(4)：类注解元信息读取接口</p><ul><li>AnnotationMetadata：读取注解。通过getAnnotationTypes(String)获取”元注解”</li></ul><p>信息，提供getAnnotationAttributes(String)方法获取指定注解的属性方法。</p><ul><li>ClassMetadata：类注解</li><li>AnnotatedTypeMetadata：注解的元注解</li></ul><p>3：Spring注解属性抽象</p><ul><li>AnnotationAttributes</li><li>AnnotatedElementUtils：对查找注解，元注解等注解的工具类</li><li>AnnotationUtils：用于处理注解的工具类。</li><li>ReflectionUtils：反射工具类。</li></ul><p>代码示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类描述: 组合注解启动类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/4/25 20:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@TransactionalService</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComposeAnnotationApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String className = ComposeAnnotationApplication.class.getName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建MetadataReaderFactory</span></span><br><span class="line">        MetadataReaderFactory metadataReaderFactory = <span class="keyword">new</span> CachingMetadataReaderFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取@TransactionalService MetadataReader信息</span></span><br><span class="line">        MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取@TransactionalService AnnotationMetadata信息</span></span><br><span class="line">        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();</span><br><span class="line"></span><br><span class="line">        annotationMetadata.getAnnotationTypes().forEach(annotationType -&gt; &#123;</span><br><span class="line">            Set&lt;String&gt; metaAnnotationTypes = annotationMetadata.getMetaAnnotationTypes(annotationType);</span><br><span class="line"></span><br><span class="line">            metaAnnotationTypes.forEach(metaAnnotationType -&gt; System.out.println(String.format(</span><br><span class="line">                    <span class="string">"注解 %s 元标注; %s\n"</span>, annotationType, metaAnnotationType)));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">springStandardAnnotationMetadata</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//读取@TransactionalService AnnotationMetadata信息</span></span><br><span class="line">        AnnotationMetadata annotationMetadata = <span class="keyword">new</span> StandardAnnotationMetadata(ComposeAnnotationReflectionApplication.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有的元注解(全类名)集合</span></span><br><span class="line">        Set&lt;String&gt; metaAnnotationTypes = annotationMetadata.getAnnotationTypes()</span><br><span class="line">                .stream()</span><br><span class="line">                <span class="comment">//读取单注解元注解类型集合</span></span><br><span class="line">                .map(annotationMetadata::getMetaAnnotationTypes)</span><br><span class="line">                <span class="comment">//合并元注解类型集合</span></span><br><span class="line">                .collect(LinkedHashSet::<span class="keyword">new</span>, Set::addAll, Set::addAll);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取所有元注解类型</span></span><br><span class="line">        metaAnnotationTypes.forEach(metaAnnotation -&gt; &#123;</span><br><span class="line">            <span class="comment">//读取元注解属性</span></span><br><span class="line">            Map&lt;String, Object&gt; annotationAttributes = annotationMetadata.getAnnotationAttributes(metaAnnotation);</span><br><span class="line">            <span class="keyword">if</span> (!CollectionUtils.isEmpty(annotationAttributes)) &#123;</span><br><span class="line">                annotationAttributes.forEach((name, value) -&gt; System.out.printf(<span class="string">"注解 %s 属性 %s = %s\n"</span>,</span><br><span class="line">                        ClassUtils.getShortName(metaAnnotation), name, value));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>Spring从4.0.0.RELEASE版本开始支持多层次@Component派生性。</strong></p><p>1:Spring中@Component,@Repository,@Service,@Controller就属于<strong>@Component派生注解</strong>。</p><p>称之为<strong>Spring模式注解</strong>。</p><h3 id="4-注解驱动过渡时代：Spring-Framework-2-x"><a href="#4-注解驱动过渡时代：Spring-Framework-2-x" class="headerlink" title="4:注解驱动过渡时代：Spring Framework 2.x"></a>4:注解驱动过渡时代：Spring Framework 2.x</h3><p>新引入了一些骨架式的Annotation</p><ul><li>依赖注入Annotation：@Autowired(可注入单个Bean，也可注入集合)—&gt;限定类型Class方式。</li><li>依赖查找Annotation：@Qualifier</li><li>组件声明Annotation：@Component,@Service</li><li>Spring MVC Annotation：@Controller,@RequestMapping,@ModelAttributes等。</li></ul><p>支持<strong>可扩展的XML编写</strong>。即Spring的Schema和Handlers机制。</p><p>支持<strong>JSR-250</strong>规范@Resource注入，@PostConstruct，@PreDestroy等。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>Spring2.5允许自定义Spring模式注解，不过该版本仅支持单层次的模式注解<strong>“派生”</strong>。但是编程手段不多，**主要</p><p>的原因在于框架层次仍未<strong>注解</strong>提供驱动注解的Spring应用上下文，并且仍需要XML配置驱动，即XML元素&lt;context:annotation-config&gt;和&lt;context-component-scan&gt;。</p><h3 id="5-注解驱动黄金时代：Spring-Framework-3-x"><a href="#5-注解驱动黄金时代：Spring-Framework-3-x" class="headerlink" title="5:注解驱动黄金时代：Spring Framework 3.x"></a>5:注解驱动黄金时代：Spring Framework 3.x</h3><p>全面拥抱Java5(泛型,变量参数等)，以及Spring Annotation引入。例如引入了配置类注解@Configuration,AnnotationConfigApplicationContext。但是没有引入替换&lt;context:component-scan/&gt;注解。</p><p>选择过渡方案@Import,@ImportResource(需要标注@Configuration注解)。Spring3.1引入注解@ComponentScan。<strong>引入了REST开发</strong>。</p><p>SpringWeb整合了<strong>Servlet3.0+</strong>按规范，利用<strong>javax.servlet.ServletContainerInitialier</strong> API实现传统Servlet容器</p><p><strong>自动装配</strong>的能力，替换了传统的web.xml。</p><p>1:Spring3.1抽象了一套全新并统一配置属性API,包括<strong>配置属性存储接口Environment,以及配置属性源抽象PropertySource</strong>，这两个核心API奠定了<strong>SpringBoot外部化配置的基础，也是SpringCloud分布式配置基石</strong>。</p><p>2:然后是<strong>缓存抽象</strong>，主要API包括<strong>缓存Cache和缓存管理器CacheManager</strong>。配套注解<strong>Caching和Cacheable等</strong></p><p>极大简化了数据缓存开发。</p><p>3:异步支持，引入了异步操作注解<strong>@Async,周期异步操作@Scheduled及异步Web请求处理操作DefferedResult</strong>。</p><p>4:校验方面，新增了注解<strong>@Validated</strong>，整合JSR-303和适配了Spring早期的Validator抽象。</p><p>5:<strong>Enabled模块驱动</strong>特性。将<strong>相同职责功能组件以模块化的方式装配</strong>。例如<strong>EnabledWebMvc</strong>。</p><h3 id="6-注解驱动完善时代-Spring-Framework-4-x"><a href="#6-注解驱动完善时代-Spring-Framework-4-x" class="headerlink" title="6:注解驱动完善时代:Spring Framework 4.x"></a>6:注解驱动完善时代:Spring Framework 4.x</h3><p>引入了<strong>条件化注解@Conditional</strong>，通过与自定义Condition实现配合，弥补之前版本条件化配置装配的</p><p>短板。SpringBoot的所有@ConditionalOn<em>注解均基于@Conditional派生注解，其抽象类*</em>SpringBootCondition**也是Condition的实现。</p><p>Spring4.x兼容了Java Time API(JSR-310),@Repeatable及参数名称发现。Java8的@Repeatable出现，解决了</p><p>以往Annotation无法重复标注同一个类的限制。<strong>Spring4.2引入了事件监听器注解@EventListener</strong>。</p><p>Spring的<strong>派生</strong>特性需要确保<strong>注解之间属性方法签名一致</strong>。限制在Spring4.2新注解<strong>@AliasFor</strong>解除，实现了</p><p>同一注解类属性方法之间的别名。Spring4.3引入<strong>REST请求注解</strong>。</p><p>Spring4.x在Web注解驱动编程也有提示，例如<strong>@RestController,@RestControllerAdvice(对RestController AOP拦截通知)</strong>。</p><h3 id="7-注解驱动当下时代-Spring-Framework5-x"><a href="#7-注解驱动当下时代-Spring-Framework5-x" class="headerlink" title="7:注解驱动当下时代:Spring Framework5.x"></a>7:注解驱动当下时代:Spring Framework5.x</h3><p>在SpringBoot应用场景中，大量使用注解@ComponentScan扫描指定package,当扫描package所包含的类越多时,</p><p>Spring模式注解耗费时间越长。针对这个问题,Spring5.x新引入了注解<strong>@Indexed</strong>,为Spring模式注解添加索引，提升启动性能。需要引入<strong>spring-context-indexer</strong>依赖。</p><h5 id="7-1-Spring核心注解场景分类"><a href="#7-1-Spring核心注解场景分类" class="headerlink" title="7-1:Spring核心注解场景分类"></a>7-1:Spring核心注解场景分类</h5><p><strong>Spring模式注解:</strong></p><table><thead><tr><th align="center">Spring注解</th><th align="center">场景说明</th><th align="center">起始版本</th></tr></thead><tbody><tr><td align="center">@Repository</td><td align="center">数据仓库模式注解</td><td align="center">2.0</td></tr><tr><td align="center">@Component</td><td align="center">通用组件模式注解</td><td align="center">2.5</td></tr><tr><td align="center">@Service</td><td align="center">服务模式</td><td align="center">2.5</td></tr><tr><td align="center">@Controller</td><td align="center">Web控制器模式注解</td><td align="center">2.5</td></tr><tr><td align="center">@Configuration</td><td align="center">配置类模式注解</td><td align="center">3.0</td></tr></tbody></table><p><strong>装配注解</strong></p><table><thead><tr><th align="center">Spring注解</th><th align="center">场景说明</th><th align="center">起始版本</th></tr></thead><tbody><tr><td align="center">@ImportResource</td><td align="center">替换XML元素&lt;import&gt;</td><td align="center">2.5</td></tr><tr><td align="center">@Import</td><td align="center">限定@Autowired依赖注解范围</td><td align="center">2.5</td></tr><tr><td align="center">@ComponentScan</td><td align="center">扫描指定package下标注Spring模式注解</td><td align="center">3.1</td></tr></tbody></table><p><strong>依赖注入注解</strong></p><table><thead><tr><th align="center">Spring注解</th><th align="center">场景说明</th><th align="center">起始版本</th></tr></thead><tbody><tr><td align="center">@Autowired</td><td align="center">Bean依赖注解,支持多种依赖查找方式</td><td align="center">2.5</td></tr><tr><td align="center">@Qualifier</td><td align="center">细粒度的@Autowired依赖查找</td><td align="center">2.5</td></tr><tr><td align="center">Java注解</td><td align="center">场景说明</td><td align="center">起始版本</td></tr><tr><td align="center">@Resource</td><td align="center">Bean依赖注入,仅支持名称依赖查找</td><td align="center">2.5</td></tr></tbody></table><p><strong>Bean定义注解</strong></p><table><thead><tr><th align="center">Spring注解</th><th align="center">场景说明</th><th align="center">起始版本</th></tr></thead><tbody><tr><td align="center">@Bean</td><td align="center">替换XML元素&lt;bean&gt;</td><td align="center">3.0</td></tr><tr><td align="center">@DependsOn</td><td align="center">替换XML属性&lt;bean depends-on=”…”/&gt;</td><td align="center">3.0</td></tr><tr><td align="center">@Lazy</td><td align="center">替换XML属性&lt;bean lazy-init=”trus|false”/&gt;</td><td align="center">3.0</td></tr><tr><td align="center">@Primary</td><td align="center">替换XML元素&lt;bean primary=”true|false”/&gt;</td><td align="center">3.0</td></tr><tr><td align="center">@Role</td><td align="center">替换XML元素&lt;bean role=”…”/&gt;</td><td align="center">3.1</td></tr><tr><td align="center">@Lookup</td><td align="center">替换XML属性&lt;bean lookup-method=”…”&gt;</td><td align="center">4.1</td></tr></tbody></table><p><strong>Spring条件装配注解</strong></p><table><thead><tr><th align="center">Spring注解</th><th align="center">场景说明</th><th align="center">起始版本</th></tr></thead><tbody><tr><td align="center">@Profile</td><td align="center">配置化条件装配</td><td align="center">3.1</td></tr><tr><td align="center">@Conditional</td><td align="center">编程条件装配</td><td align="center">3.1</td></tr></tbody></table><p><strong>配置属性注解</strong></p><table><thead><tr><th align="center">Spring注解</th><th align="center">场景说明</th><th align="center">起始版本</th></tr></thead><tbody><tr><td align="center">@PropertySource</td><td align="center">配置属性抽象PropertySource注解</td><td align="center">3.1</td></tr><tr><td align="center">@PropertySources</td><td align="center">@PropertySource集合注解</td><td align="center">4.0</td></tr></tbody></table><p><strong>生命周期回调注解</strong></p><table><thead><tr><th align="center">Java注解</th><th align="center">场景说明</th><th align="center">起始版本</th></tr></thead><tbody><tr><td align="center">@PostContruct</td><td align="center">替换XML元素&lt;bean init-method=”…”/&gt;</td><td align="center">2.5</td></tr><tr><td align="center">@PreDestroy</td><td align="center">替换XML元素&lt;bean destroy-method=”…”/&gt;</td><td align="center">2.5</td></tr></tbody></table><p><strong>注解属性注解</strong></p><table><thead><tr><th align="center">Spring注解</th><th align="center">场景说明</th><th align="center">起始版本</th></tr></thead><tbody><tr><td align="center">@AliasFor</td><td align="center">别名注解属性,实现复用目的</td><td align="center">4.2</td></tr></tbody></table><p><strong>性能注解</strong></p><table><thead><tr><th align="center">Spring注解</th><th align="center">场景说明</th><th align="center">起始版本</th></tr></thead><tbody><tr><td align="center">@Indexed</td><td align="center">提升Spring模式注解扫描效率</td><td align="center">5.0</td></tr></tbody></table><h5 id="8-AnnotationMetadata注解的实现"><a href="#8-AnnotationMetadata注解的实现" class="headerlink" title="8:AnnotationMetadata注解的实现"></a>8:AnnotationMetadata注解的实现</h5><blockquote><p>在AnnotationMetadata语义上,基于<code>Java反射StandardAnnotationMetadata</code>和<code>AnnotationMetadataReadingVisitor</code>保持一致。基于Java反射API实现必然需要<code>反射的Class被ClassLoader加载</code>，当指定Java Package扫描Spring模式注解时,StandardAnnotationMetadata显然不适应。</p><p>因为<code>应用不需要将指定Package下的Class全部加载</code>。基于ASM实现的<code>AnnotationMetadataReadingVisitor</code>更适合这种场景，解释了为什么该类出现ClassPathScanningCandidateComponentProvider实现中。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Annotation </tag>
            
            <tag> Spring注解属性覆盖 </tag>
            
            <tag> Spring核心注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Guava简介</title>
      <link href="/2019/08/06/Guava%E7%AE%80%E4%BB%8B/"/>
      <url>/2019/08/06/Guava%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h2><p>Guava工程包含了若干被Google的 Java项目广泛依赖 的核心库，例如：<strong>集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [common annotations] 、字符串处理 [string processing] 、I/O 等等</strong>。 所有这些工具每天都在被Google的工程师应用在产品服务中。</p><h2 id="2-基本工具"><a href="#2-基本工具" class="headerlink" title="2.基本工具"></a>2.基本工具</h2><ol><li><strong>使用和避免null: Optional</strong></li><li><strong>前置条件: Preconditions</strong></li><li><strong>常见Object方法: Objects</strong></li><li><strong>排序: Guava强大的”流畅风格比较器”:</strong> <strong>Ordering</strong></li><li><a href="http://ifeve.com/google-guava-throwables/" target="_blank" rel="noopener"><strong>Throwables</strong></a>: 简化了异常和错误的传播与检查 :  <strong>Throwables</strong></li><li><strong>编码类型:</strong> Charsets</li></ol><h2 id="3-集合"><a href="#3-集合" class="headerlink" title="3.集合"></a>3.集合</h2><ol><li><a href="http://ifeve.com/google-guava-immutablecollections/" target="_blank" rel="noopener"><strong>不可变集合</strong></a>: 用不变的集合进行防御性编程和性能提升:  Immutable开头。</li><li><a href="http://ifeve.com/google-guava-newcollectiontypes/" target="_blank" rel="noopener"><strong>新集合类型</strong></a>: multisets, multimaps, tables, bidirectional maps等</li><li><a href="http://ifeve.com/google-guava-collectionutilities/" target="_blank" rel="noopener"><strong>强大的集合工具类</strong></a>: 提供java.util.Collections中没有的集合工具</li><li><a href="http://ifeve.com/google-guava-collectionhelpersexplained/" target="_blank" rel="noopener"><strong>扩展工具类</strong></a>：让实现和扩展集合类变得更容易，比如创建Collection的装饰器，或实现迭代器</li></ol><h2 id="4-缓存-Caches"><a href="#4-缓存-Caches" class="headerlink" title="4.缓存[Caches]"></a>4.<a href="http://ifeve.com/google-guava-cachesexplained" target="_blank" rel="noopener">缓存</a>[Caches]</h2><p>Guava Cache: 本地缓存实现,支持多种缓存过期策略。</p><h2 id="5-函数式风格-Functional-idioms"><a href="#5-函数式风格-Functional-idioms" class="headerlink" title="5.函数式风格[Functional idioms]"></a>5.<a href="http://ifeve.com/google-guava-functional/" target="_blank" rel="noopener">函数式风格</a>[Functional idioms]</h2><p><strong>Guava函数式支持可以显著简化代码,但请谨慎使用。</strong></p><h2 id="6-并发-Concurrency"><a href="#6-并发-Concurrency" class="headerlink" title="6.并发[Concurrency]"></a>6.并发[Concurrency]</h2><ol><li><a href="http://ifeve.com/google-guava-listenablefuture/" target="_blank" rel="noopener"><strong>ListenableFuture</strong></a>：完成后触发回调的Future</li><li><a href="http://ifeve.com/google-guava-serviceexplained/" target="_blank" rel="noopener"><strong>Service框架</strong></a>：抽象可开启和关闭的服务，帮助你维护服务的状态逻辑</li></ol><h2 id="7-字符串处理-Strings"><a href="#7-字符串处理-Strings" class="headerlink" title="7.字符串处理[Strings]"></a>7.<a href="http://ifeve.com/google-guava-strings/" target="_blank" rel="noopener">字符串处理</a>[Strings]</h2><p>非常有用的字符串工具，包括分割、连接、填充等操作</p><h2 id="8-原生类型-Primitives"><a href="#8-原生类型-Primitives" class="headerlink" title="8.原生类型[Primitives]"></a>8.<a href="http://ifeve.com/google-guava-primitives/" target="_blank" rel="noopener">原生类型</a>[Primitives]</h2><p>扩展 JDK 未提供的原生类型（如int、char）操作， 包括某些类型的无符号形式</p><h2 id="9-区间-Ranges"><a href="#9-区间-Ranges" class="headerlink" title="9.区间[Ranges]"></a>9.<a href="http://ifeve.com/google-guava-ranges/" target="_blank" rel="noopener">区间</a>[Ranges]</h2><p>可比较类型的区间API，包括连续和离散类型</p><h2 id="10-I-O"><a href="#10-I-O" class="headerlink" title="10.I/O"></a>10.<a href="http://ifeve.com/google-guava-io/" target="_blank" rel="noopener">I/O</a></h2><p>简化I/O尤其是I/O流和文件的操作，<strong>针对Java5和6版本</strong></p><h2 id="11-散列-Hash"><a href="#11-散列-Hash" class="headerlink" title="11.散列[Hash]"></a>11.<a href="http://ifeve.com/google-guava-hashing/" target="_blank" rel="noopener">散列</a>[Hash]</h2><p>提供比Object.hashCode()更复杂的散列实现，<strong>并提供布鲁姆过滤器的实现</strong></p><h2 id="12-事件总线-EventBus"><a href="#12-事件总线-EventBus" class="headerlink" title="12. 事件总线[EventBus]"></a>12. <a href="http://ifeve.com/google-guava-eventbus/" target="_blank" rel="noopener">事件总线</a>[EventBus]</h2><p>发布-订阅模式的组件通信，但组件不需要显式地注册到其他组件中</p><h2 id="13-数学运算-Math"><a href="#13-数学运算-Math" class="headerlink" title="13.数学运算[Math]"></a>13.<a href="http://ifeve.com/google-guava-math/" target="_blank" rel="noopener">数学运算</a>[Math]</h2><p>优化的、充分测试的数学工具类</p><h2 id="14-反射-Reflection"><a href="#14-反射-Reflection" class="headerlink" title="14.反射[Reflection]"></a>14.<a href="http://ifeve.com/guava-reflection/" target="_blank" rel="noopener">反射</a>[Reflection]</h2><p>Guava 的 Java 反射机制工具类</p>]]></content>
      
      
      <categories>
          
          <category> Guava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Guava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot自动配置原理</title>
      <link href="/2019/08/05/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/"/>
      <url>/2019/08/05/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot自动配置原理"><a href="#SpringBoot自动配置原理" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h2><h4 id="1-产生背景"><a href="#1-产生背景" class="headerlink" title="1:产生背景"></a>1:产生背景</h4><p>  在Spring Framework时代,当Spring应用的@Component或者@Configuration Class需要被装配</p><p>时,应用需要借助@Import或者@ComponentScan的能力。由于应用依赖的Jar存在变化的可能,</p><p>因此其中的@Component或者@Configuration Class所在的包路径也会发生变化。</p><p>  <code>不鼓励开发人员通过@ComponentScan或者@SpringApplication</code>注解方式扫描默认包。<strong>因为</strong></p><p><strong>它读取所有JAR中类,并且可能会造成默认Spring Boot错误</strong></p><p>   当Spring应用自动装配某些组件时,它需要一种综合性技术手段,<strong>重新深度结合Spring注解编程</strong></p><p><strong>模型,@Enable模块驱动和条件装配等Spring Framework原生特性,这种技术就是Spring Boot</strong></p><p><strong>自动装配。</strong></p><h4 id="2-理解Spring-Boot自动装配"><a href="#2-理解Spring-Boot自动装配" class="headerlink" title="2:理解Spring Boot自动装配"></a>2:理解Spring Boot自动装配</h4><p>(1):理解@EnableAutoConfiguration</p><p>用于激活Spring Boot自动装配特性。</p><p>(2):优雅的替换自动装配</p><p>开发人员可在任意一处定义配置类,从而覆盖那些被自动装配的组件。<code>SpringBoot优先解析</code></p><p><code>自定义配置类。内建的配置类,一旦应用存在自定义实现，就不会再装配</code>。</p><p>(3):失效自动装配</p><p>SpringBoot提供两种失效手段</p><ul><li>代码配置方式<ul><li>配置类型安全属性方法:@EnableAutoConfiguration.exclude()</li><li>配置排除类名方式:@EnableAutoConfiguration.excludeName()</li></ul></li><li>外部化配置方式<ul><li>配置属性:spring.autoconfigure.exclude</li></ul></li></ul><h4 id="3-自动装配原理"><a href="#3-自动装配原理" class="headerlink" title="3:自动装配原理"></a>3:自动装配原理</h4><p>  依照@Enable模块驱动设计模式，@EnableAutoConguration必然是@Import 类ImportSelector</p><p>或者ImportBeanDefinitionRegistrar的实现类。</p><p><strong>AutoConfigurationImportSelector主要执行逻辑:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line"><span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line"><span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//读取自动装配元信息配置文件</span></span><br><span class="line">       <span class="comment">//"META-INF/"+ "spring-autoconfigure-metadata.properties"</span></span><br><span class="line">AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">.loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">       <span class="comment">//获取@EnableAutoConfiguration注解属性</span></span><br><span class="line">AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">       <span class="comment">//获取自动装配Class候选列表</span></span><br><span class="line">List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">attributes);</span><br><span class="line">       <span class="comment">//移除重复的自动装配类名</span></span><br><span class="line">configurations = removeDuplicates(configurations);</span><br><span class="line">       <span class="comment">//排除自动装配组件</span></span><br><span class="line">Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">       <span class="comment">//检查排除类名集合是否合法</span></span><br><span class="line">checkExcludedClasses(configurations, exclusions);</span><br><span class="line">configurations.removeAll(exclusions);</span><br><span class="line">       <span class="comment">//过滤候选自动装配组件集合中Class不存在成员</span></span><br><span class="line">configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">       <span class="comment">//触发自动装配导入事件</span></span><br><span class="line">fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line"><span class="keyword">return</span> StringUtils.toStringArray(configurations);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(1):读取候选装配组件</p><p>使用了Spring工厂加载类<code>SpringFactoriesLoader</code>。原理如下</p><ul><li><p>搜索指定ClassLoader下所有的META-INF/spring.factories资源内容。</p></li><li><p>将一个或者多个META-INF/spring.factories资源内容作为Properties文件读取,并合并为</p><p>一个Key为接口的全类限定名,Value是实现类的全类名列表的Map,作为返回值。</p></li><li><p>再从上一步返回Map中查找并返回方法指定类名所映射的实现类全类名列表。</p></li></ul><p>SpringBoot自动装配列表存在地方</p><ul><li>spring-boot-autoconfigure模块</li><li>spring-boot-actuator-autoconfigure模块</li><li>spring-boot-devtools模块(可选)</li></ul><p>由于@EnableAutoConfiguration配置可能存在配置组件类名重复定义情况,当获取所有候选类,</p><p>立即执行removeDuplicates(List)方法,利用Set不可重复性达到去重的目的。</p><p>(2):排除自动装配组件</p><p>当<code>getExclusions(AnnotationMetadata metadata,AnnotationAttributes attributes)</code></p><p>执行后,程序将获取到一个自动装配Class排除列表。随后检查排除类名集合是否合法。当排除类</p><p>存在于当前的ClassLoader但是不在自动装配名单中,将触发排除类非法异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkExcludedClasses</span><span class="params">(List&lt;String&gt; configurations,</span></span></span><br><span class="line"><span class="function"><span class="params">Set&lt;String&gt; exclusions)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; invalidExcludes = <span class="keyword">new</span> ArrayList&lt;&gt;(exclusions.size());</span><br><span class="line"><span class="keyword">for</span> (String exclusion : exclusions) &#123;</span><br><span class="line">           <span class="comment">//存在当前ClassLoader但是不在自动装配列表名单</span></span><br><span class="line"><span class="keyword">if</span> (ClassUtils.isPresent(exclusion, getClass().getClassLoader())</span><br><span class="line">&amp;&amp; !configurations.contains(exclusion)) &#123;</span><br><span class="line">invalidExcludes.add(exclusion);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!invalidExcludes.isEmpty()) &#123;</span><br><span class="line">handleInvalidExcludes(invalidExcludes);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3):过滤自动装配组件</p><p>移除排除类名单后Configurations配合AutoConfigurationMetadata对象执行过滤操作。</p><p>(4):@EnableAutoConfiguration自动装配事件</p><p> SpringBoot1.5开始引入<code>AutoConfigurationImportListener</code>接口,自定义Java EventListener</p><p>,仅监听AutoConfigurationImportEvent,然后实例同样被SpringFactoriesLoader加载。其中,</p><p><code>ConditionEvaluationReportAutoConfigurationImportListener</code>就是内建实现,用于</p><p>记录自动装配组件的条件评估详情。</p><p>(5):EnableAutoConfiguration自动装配生命周期</p><p><code>DeferredImportSelector</code>作为<code>ImportSelector</code>变种,它在@Configuration Bean处理完毕</p><p>后才运作。在<code>@Conditional</code>场景尤为有用，同时该实现类可通过Ordered接口或者@Order</p><p>方式调整其优先顺序。</p><p> 该接口提供两类方法: process()和selectImports()。前者二次处理selectImports()方法返回</p><p>的结果，后者负责决定本组应该导入的Configuration Class作为实际导入的结果。</p><p>(6):EnableAutoConfiguration排序自动装配组件</p><p> SpringBoot提供两种自动装配组件排序手段:</p><ul><li>绝对自动装配顺序:@AutoConfigurationOrder</li><li>相对自动装配顺序:@AutoConfigurationBefore和@AutoConfigurationAfter。(常用)</li></ul><p>(7):EnableAutoConfiguration自动装配BasePackages</p><p> SpringBoot1.3开始引用注解@AutoConfigurationPackage。</p><p> 该注解的实现类常常用于默认包获取。例如JPA实现获取默认包。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 自动配置原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>@Enable模块驱动原理</title>
      <link href="/2019/08/05/Enable%E6%A8%A1%E5%9D%97%E9%A9%B1%E5%8A%A8%E5%8E%9F%E7%90%86/"/>
      <url>/2019/08/05/Enable%E6%A8%A1%E5%9D%97%E9%A9%B1%E5%8A%A8%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Enable模块驱动原理"><a href="#Enable模块驱动原理" class="headerlink" title="@Enable模块驱动原理"></a>@Enable模块驱动原理</h2><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1:概述"></a>1:概述</h4><p><strong>@Enable模块驱动</strong>在<em>Spring3.1</em>后开始支持。这里的<em>模块指具备相同领域的功能组件集合,组合所形成的一个独立的单元</em>。例如Web MVC模块,AspectJ代理模块,Caching模块,JMX模块,Async模块等。通过@Enable模块驱动,可以开启响应的模块功能。</p><p>@Enable模块驱动可以分为”注解驱动”和”接口编程”两种实现方式。<strong>都需要配合@Import注解。</strong></p><blockquote><ul><li>注解驱动:通过@Configuration类和@Bean方法声明类。例如Web MVC模块实现,即@EnableWebMvc注解通过导入DelegatingWebMvcConfiguration来实现。</li><li>接口编程:ImportSelector和ImportBeanDefinitionRegistrar的实现类。例如Caching模块实现,即</li></ul><p>@EnableCaching注解通过导入CachingConfigurationSelector实现。</p></blockquote><h4 id="2-实现示例"><a href="#2-实现示例" class="headerlink" title="2:实现示例"></a>2:实现示例</h4><h5 id="1-注解驱动"><a href="#1-注解驱动" class="headerlink" title="(1):注解驱动"></a>(1):注解驱动</h5><p><strong>基于ImportSelector接口</strong></p><p>@EnableWebMvc模块实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(DelegatingWebMvcConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableWebMvc &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注解通过<em>@Import<em>导入一个配置类</em>DelegatingWebMvcConfiguration</em>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line">      ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该配置类又继承自<em>WebMvcConfigurationSupport</em>,里面定义一些Web Mvc必须Bean声明。</p><blockquote><p>所以，基于注解驱动的<code>@Enable</code>模块驱动其实就是通过<code>@Import</code>来导入一个配置类，以此实现相应模块的组件注册，当这些组件注册到IOC容器中，这个模块对应的功能也就可以使用了。</p></blockquote><h5 id="2-接口编程"><a href="#2-接口编程" class="headerlink" title="(2):接口编程"></a>(2):接口编程</h5><p>@EnableCaching模块实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(CachingConfigurationSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableCaching &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">AdviceMode <span class="title">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>@EnableCaching*注解通过</em>@Import<em>导入</em>CachingConfigurationSelector<em>类,该类间接实现了</em>ImportSelector*。</p><blockquote><p><strong>ImportSelector</strong>使用Spring<code>注解元信息抽象AnnotationMetadata</code>作为方法参数,该参数内容为导入ImportSelector实现的@Configuration类元信息,进而动态的选择一个或者多个其他@Configuration类进行导入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt; * Interface to be implemented by types that determine which @&#123;<span class="doctag">@link</span> Configuration&#125;</span></span><br><span class="line"><span class="comment">&gt; * class(es) should be imported based on a given selection criteria, usually one or more</span></span><br><span class="line"><span class="comment">&gt; * annotation attributes.</span></span><br><span class="line"><span class="comment">&gt; *</span></span><br><span class="line"><span class="comment">&gt; * &lt;p&gt;An &#123;<span class="doctag">@link</span> ImportSelector&#125; may implement any of the following</span></span><br><span class="line"><span class="comment">&gt; * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.Aware Aware&#125; interfaces, and their respective</span></span><br><span class="line"><span class="comment">&gt; * methods will be called prior to &#123;<span class="doctag">@link</span> #selectImports&#125;:</span></span><br><span class="line"><span class="comment">&gt; * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">&gt; * &lt;li&gt;&#123;<span class="doctag">@link</span> org.springframework.context.EnvironmentAware EnvironmentAware&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">&gt; * &lt;li&gt;&#123;<span class="doctag">@link</span> org.springframework.beans.factory.BeanFactoryAware BeanFactoryAware&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">&gt; * &lt;li&gt;&#123;<span class="doctag">@link</span> org.springframework.beans.factory.BeanClassLoaderAware BeanClassLoaderAware&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">&gt; * &lt;li&gt;&#123;<span class="doctag">@link</span> org.springframework.context.ResourceLoaderAware ResourceLoaderAware&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">&gt; * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">&gt; *</span></span><br><span class="line"><span class="comment">&gt; * &lt;p&gt;ImportSelectors are usually processed in the same way as regular &#123;<span class="doctag">@code</span> <span class="doctag">@Import</span>&#125;</span></span><br><span class="line"><span class="comment">&gt; * annotations, however, it is also possible to defer selection of imports until all</span></span><br><span class="line"><span class="comment">&gt; * &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; classes have been processed (see &#123;<span class="doctag">@link</span> DeferredImportSelector&#125;</span></span><br><span class="line"><span class="comment">&gt; * for details).</span></span><br><span class="line"><span class="comment">&gt; *</span></span><br><span class="line"><span class="comment">&gt; * <span class="doctag">@author</span> Chris Beams</span></span><br><span class="line"><span class="comment">&gt; * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment">&gt; * <span class="doctag">@see</span> DeferredImportSelector</span></span><br><span class="line"><span class="comment">&gt; * <span class="doctag">@see</span> Import</span></span><br><span class="line"><span class="comment">&gt; * <span class="doctag">@see</span> ImportBeanDefinitionRegistrar</span></span><br><span class="line"><span class="comment">&gt; * <span class="doctag">@see</span> Configuration</span></span><br><span class="line"><span class="comment">&gt; */</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;  * Select and return the names of which class(es) should be imported based on</span></span><br><span class="line"><span class="comment">&gt;  * the &#123;<span class="doctag">@link</span> AnnotationMetadata&#125; of the importing @&#123;<span class="doctag">@link</span> Configuration&#125; class.</span></span><br><span class="line"><span class="comment">&gt;  */</span></span><br><span class="line">&gt; String[] selectImports(AnnotationMetadata importingClassMetadata);</span><br><span class="line">&gt; </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>基于ImportBeanDefinitionRegistrar接口</strong></p><p>@MapperScan模块实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperScannerRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AnnotationAttributes annoAttrs = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));</span><br><span class="line">    ClassPathMapperScanner scanner = <span class="keyword">new</span> ClassPathMapperScanner(registry);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationClass = annoAttrs.getClass(<span class="string">"annotationClass"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!Annotation.class.equals(annotationClass)) &#123;</span><br><span class="line">      scanner.setAnnotationClass(annotationClass);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    scanner.registerFilters();</span><br><span class="line">    scanner.doScan(StringUtils.toStringArray(basePackages));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口的编程复杂度相比较于ImportSelector更高,接口将Bean定义的注册交给开发人员。常常配合<code>ClassPathBeanDefinitionScanner</code>类进行批量注册BeanDefinition。</p><blockquote><p><strong>ImportBeanDefinitionRegistrar</strong>:除注解元信息AnnotationMetadata作为入参外,接口将</p><p>Bean定义注册交给开发人员。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt; * Interface to be implemented by types that register additional bean definitions when</span></span><br><span class="line"><span class="comment">&gt; * processing @&#123;<span class="doctag">@link</span> Configuration&#125; classes. Useful when operating at the bean definition</span></span><br><span class="line"><span class="comment">&gt; * level (as opposed to &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; method/instance level) is desired or necessary.</span></span><br><span class="line"><span class="comment">&gt; *</span></span><br><span class="line"><span class="comment">&gt; * &lt;p&gt;Along with &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; and &#123;<span class="doctag">@link</span> ImportSelector&#125;, classes of this type</span></span><br><span class="line"><span class="comment">&gt; * may be provided to the @&#123;<span class="doctag">@link</span> Import&#125; annotation (or may also be returned from an</span></span><br><span class="line"><span class="comment">&gt; * &#123;<span class="doctag">@code</span> ImportSelector&#125;).</span></span><br><span class="line"><span class="comment">&gt; *</span></span><br><span class="line"><span class="comment">&gt; * &lt;p&gt;An &#123;<span class="doctag">@link</span> ImportBeanDefinitionRegistrar&#125; may implement any of the following</span></span><br><span class="line"><span class="comment">&gt; * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.Aware Aware&#125; interfaces, and their respective</span></span><br><span class="line"><span class="comment">&gt; * methods will be called prior to &#123;<span class="doctag">@link</span> #registerBeanDefinitions&#125;:</span></span><br><span class="line"><span class="comment">&gt; * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">&gt; * &lt;li&gt;&#123;<span class="doctag">@link</span> org.springframework.context.EnvironmentAware EnvironmentAware&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">&gt; * &lt;li&gt;&#123;<span class="doctag">@link</span> org.springframework.beans.factory.BeanFactoryAware BeanFactoryAware&#125;</span></span><br><span class="line"><span class="comment">&gt; * &lt;li&gt;&#123;<span class="doctag">@link</span> org.springframework.beans.factory.BeanClassLoaderAware BeanClassLoaderAware&#125;</span></span><br><span class="line"><span class="comment">&gt; * &lt;li&gt;&#123;<span class="doctag">@link</span> org.springframework.context.ResourceLoaderAware ResourceLoaderAware&#125;</span></span><br><span class="line"><span class="comment">&gt; * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">&gt; *</span></span><br><span class="line"><span class="comment">&gt; * &lt;p&gt;See implementations and associated unit tests for usage examples.</span></span><br><span class="line"><span class="comment">&gt; *</span></span><br><span class="line"><span class="comment">&gt; * <span class="doctag">@author</span> Chris Beams</span></span><br><span class="line"><span class="comment">&gt; * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment">&gt; * <span class="doctag">@see</span> Import</span></span><br><span class="line"><span class="comment">&gt; * <span class="doctag">@see</span> ImportSelector</span></span><br><span class="line"><span class="comment">&gt; * <span class="doctag">@see</span> Configuration</span></span><br><span class="line"><span class="comment">&gt; */</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;  * Register bean definitions as necessary based on the given annotation metadata of</span></span><br><span class="line"><span class="comment">&gt;  * the importing &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment">&gt;  * &lt;p&gt;Note that &#123;<span class="doctag">@link</span> BeanDefinitionRegistryPostProcessor&#125; types may &lt;em&gt;not&lt;/em&gt; be</span></span><br><span class="line"><span class="comment">&gt;  * registered here, due to lifecycle constraints related to &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125;</span></span><br><span class="line"><span class="comment">&gt;  * class processing.</span></span><br><span class="line"><span class="comment">&gt;  * <span class="doctag">@param</span> importingClassMetadata annotation metadata of the importing class</span></span><br><span class="line"><span class="comment">&gt;  * <span class="doctag">@param</span> registry current bean definition registry</span></span><br><span class="line"><span class="comment">&gt;  */</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">&gt; AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span></span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="3-Enable模块驱动原理"><a href="#3-Enable模块驱动原理" class="headerlink" title="3:@Enable模块驱动原理"></a>3:@Enable模块驱动原理</h4><p>1:概述</p><p>@Enable模块驱动,模块无论来自于Spring内建,还是自定义,均使用<code>@Import</code>实现,<strong>并且该注解的职责在于装载导入类,将其定义为Spring Bean。导入主要为@Configuration Class,ImportSelector实现及ImportBeanDefinitionRegistrar实现。</strong></p><p>2:源码实现</p><p>(1):装载@Configuration Class。</p><p>@Configuration从Spring3.0开始引入,<em>该版本还未引入@ComponentScan</em>。因此,开发人员经常看到XML元素&lt;context:component-scan/&gt;与&lt;context:annotation-config&gt;同时存在。根据Spring的”可扩展XML编写”特性,可以知道&lt;context:annotation-config&gt;所对应的BeanDefinitionParser实现为AnnotationConfigBeanDefinitionParser。</p><p>AnnotationConfigBeanDefinitionParser</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parser for the &amp;lt;context:annotation-config/&amp;gt; element.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mark Fisher</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Christian Dupuis</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> AnnotationConfigUtils</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationConfigBeanDefinitionParser</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">Object source = parserContext.extractSource(element);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Obtain bean definitions for all relevant BeanPostProcessors.</span></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; processorDefinitions =</span><br><span class="line">AnnotationConfigUtils.registerAnnotationConfigProcessors(parserContext.getRegistry(), source);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AnnotationConfigUtils在Spring3.0增加了@Configuration Class的处理实现ConfigurationClassPostProcessor:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class AnnotationConfigUtils &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The bean name of the internally managed Configuration annotation processor.</span><br><span class="line"> */</span><br><span class="line">public static final String CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME =</span><br><span class="line">&quot;org.springframework.context.annotation.internalConfigurationAnnotationProcessor&quot;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The bean name of the internally managed BeanNameGenerator for use when processing</span><br><span class="line"> * &#123;@link Configuration&#125; classes. Set by &#123;@link AnnotationConfigApplicationContext&#125;</span><br><span class="line"> * and &#123;@code AnnotationConfigWebApplicationContext&#125; during bootstrap in order to make</span><br><span class="line"> * any custom name generation strategy available to the underlying</span><br><span class="line"> * &#123;@link ConfigurationClassPostProcessor&#125;.</span><br><span class="line"> * @since 3.1.1</span><br><span class="line"> */</span><br><span class="line">public static final String CONFIGURATION_BEAN_NAME_GENERATOR =</span><br><span class="line">&quot;org.springframework.context.annotation.internalConfigurationBeanNameGenerator&quot;;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Register all relevant annotation post processors in the given registry.</span><br><span class="line"> * @param registry the registry to operate on</span><br><span class="line"> */</span><br><span class="line">public static void registerAnnotationConfigProcessors(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">registerAnnotationConfigProcessors(registry, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static Set&lt;BeanDefinitionHolder&gt; registerAnnotationConfigProcessors(</span><br><span class="line">BeanDefinitionRegistry registry, Object source) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; beanDefs = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(4);</span><br><span class="line"></span><br><span class="line">if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);</span><br><span class="line">def.setSource(source);</span><br><span class="line">beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">return beanDefs;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的说,ConfigurationClassPostProcessor无论实在XML配置驱动还是在注解驱动使用场景下,均通过AnnotationConfigUtils.registerAnnotationConfigProcessors(registry,source)方法执行得到装载,且为最高优先级。不但处理了@Configuration Class,也负责@Bean方法的Bean定义。</p><p>(2):ConfigurationClassPostProcessor处理</p><p>//主要处理方法落在processConfigBeanDefinitions(registry)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationClassPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>,</span></span><br><span class="line"><span class="class"><span class="title">PriorityOrdered</span>, <span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prepare the Configuration classes for servicing bean requests at runtime</span></span><br><span class="line"><span class="comment"> * by replacing them with CGLIB-enhanced subclasses.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> factoryId = System.identityHashCode(beanFactory);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.factoriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="string">"postProcessBeanFactory already called on this post-processor against "</span> + beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.factoriesPostProcessed.add(factoryId);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.registriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line"><span class="comment">// BeanDefinitionRegistryPostProcessor hook apparently not supported...</span></span><br><span class="line"><span class="comment">// Simply call processConfigurationClasses lazily at this point then.</span></span><br><span class="line">processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enhanceConfigurationClasses(beanFactory);</span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ImportAwareBeanPostProcessor(beanFactory));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Build and validate a configuration model based on the registry of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Configuration&#125; classes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> ArrayList&lt;BeanDefinitionHolder&gt;();</span><br><span class="line">String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">BeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class="line"><span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||</span><br><span class="line">ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) &#123;</span><br><span class="line">                ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">configCandidates.add(<span class="keyword">new</span> BeanDefinitionHolder(beanDef, beanName));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return immediately if no @Configuration classes were found</span></span><br><span class="line"><span class="keyword">if</span> (configCandidates.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort by previously determined @Order value, if applicable</span></span><br><span class="line">Collections.sort(configCandidates, <span class="keyword">new</span> Comparator&lt;BeanDefinitionHolder&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line"><span class="keyword">int</span> i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line"><span class="keyword">return</span> (i1 &lt; i2) ? -<span class="number">1</span> : (i1 &gt; i2) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detect any custom bean name generation strategy supplied through the enclosing application context</span></span><br><span class="line">SingletonBeanRegistry sbr = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) &#123;</span><br><span class="line">sbr = (SingletonBeanRegistry) registry;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.localBeanNameGeneratorSet &amp;&amp; sbr.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) &#123;</span><br><span class="line">BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line"><span class="keyword">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line"><span class="keyword">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parse each @Configuration class</span></span><br><span class="line">ConfigurationClassParser parser = <span class="keyword">new</span> ConfigurationClassParser(</span><br><span class="line"><span class="keyword">this</span>.metadataReaderFactory, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.environment,</span><br><span class="line"><span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinitionHolder&gt;(configCandidates);</span><br><span class="line">Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> HashSet&lt;ConfigurationClass&gt;(configCandidates.size());</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">parser.parse(candidates);</span><br><span class="line">parser.validate();</span><br><span class="line"></span><br><span class="line">Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> LinkedHashSet&lt;ConfigurationClass&gt;(parser.getConfigurationClasses());</span><br><span class="line">configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read the model and create bean definitions based on its content</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.reader == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.reader = <span class="keyword">new</span> ConfigurationClassBeanDefinitionReader(</span><br><span class="line">registry, <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.environment,</span><br><span class="line"><span class="keyword">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">alreadyParsed.addAll(configClasses);</span><br><span class="line"></span><br><span class="line">candidates.clear();</span><br><span class="line"><span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">Set&lt;String&gt; oldCandidateNames = <span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(candidateNames));</span><br><span class="line">Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"><span class="keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class="line">alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String candidateName : newCandidateNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line">BeanDefinition bd = registry.getBeanDefinition(candidateName);</span><br><span class="line"><span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="keyword">this</span>.metadataReaderFactory) &amp;&amp;</span><br><span class="line">!alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line">candidates.add(<span class="keyword">new</span> BeanDefinitionHolder(bd, candidateName));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">candidateNames = newCandidateNames;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span></span><br><span class="line"><span class="keyword">if</span> (sbr != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class="line">sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.metadataReaderFactory <span class="keyword">instanceof</span> CachingMetadataReaderFactory) &#123;</span><br><span class="line">((CachingMetadataReaderFactory) <span class="keyword">this</span>.metadataReaderFactory).clearCache();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Post-processes a BeanFactory in search of Configuration class BeanDefinitions;</span></span><br><span class="line"><span class="comment"> * any candidates are then enhanced by a &#123;<span class="doctag">@link</span> ConfigurationClassEnhancer&#125;.</span></span><br><span class="line"><span class="comment"> * Candidate status is determined by BeanDefinition attribute metadata.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurationClassEnhancer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enhanceConfigurationClasses</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = <span class="keyword">new</span> LinkedHashMap&lt;String, AbstractBeanDefinition&gt;();</span><br><span class="line"><span class="keyword">for</span> (String beanName : beanFactory.getBeanDefinitionNames()) &#123;</span><br><span class="line">BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);</span><br><span class="line"><span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(beanDef <span class="keyword">instanceof</span> AbstractBeanDefinition)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Cannot enhance @Configuration bean definition '"</span> +</span><br><span class="line">beanName + <span class="string">"' since it is not stored in an AbstractBeanDefinition subclass"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (configBeanDefs.isEmpty()) &#123;</span><br><span class="line"><span class="comment">// nothing to enhance -&gt; return immediately</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ConfigurationClassEnhancer enhancer = <span class="keyword">new</span> ConfigurationClassEnhancer();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) &#123;</span><br><span class="line">AbstractBeanDefinition beanDef = entry.getValue();</span><br><span class="line"><span class="comment">// If a @Configuration class gets proxied, always proxy the target class</span></span><br><span class="line">beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Set enhanced subclass of the user-specified bean class</span></span><br><span class="line">Class&lt;?&gt; configClass = beanDef.resolveBeanClass(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, <span class="keyword">this</span>.beanClassLoader);</span><br><span class="line"><span class="keyword">if</span> (configClass != enhancedClass) &#123;</span><br><span class="line">    ...</span><br><span class="line">beanDef.setBeanClass(enhancedClass);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行期间,最重要的组件莫过于ConfigurationClassParser</strong>,它将已注册的Spring BeanDefinition进行注解元信息解析,其中两个parse重载方法分别采用CGLIB实现的AnnotationMetadataReadingVisitor和Java反射实现的</p><p>StandardAnnotationMetadata。</p><p>ConfigurationClassParser</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigurationClassParser</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processConfigurationClass</span><span class="params">(ConfigurationClass configClass)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConfigurationClass existingClass = <span class="keyword">this</span>.configurationClasses.get(configClass);</span><br><span class="line"><span class="keyword">if</span> (existingClass != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line"><span class="keyword">if</span> (existingClass.isImported()) &#123;</span><br><span class="line">existingClass.mergeImportedBy(configClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Otherwise ignore new imported config class; existing non-imported class overrides it.</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Explicit bean definition found, probably replacing an import.</span></span><br><span class="line"><span class="comment">// Let's remove the old one and go with the new one.</span></span><br><span class="line"><span class="keyword">this</span>.configurationClasses.remove(configClass);</span><br><span class="line"><span class="keyword">for</span> (Iterator&lt;ConfigurationClass&gt; it = <span class="keyword">this</span>.knownSuperclasses.values().iterator(); it.hasNext();) &#123;</span><br><span class="line"><span class="keyword">if</span> (configClass.equals(it.next())) &#123;</span><br><span class="line">it.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Recursively process the configuration class and its superclass hierarchy.</span></span><br><span class="line">SourceClass sourceClass = asSourceClass(configClass);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">sourceClass = doProcessConfigurationClass(configClass, sourceClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (sourceClass != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doProcessConfigurationClass处理以下问题:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Recursively process any member (nested) classes first</span></span><br><span class="line">processMemberClasses(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process any @PropertySource annotations</span></span><br><span class="line"><span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">sourceClass.getMetadata(), PropertySources.class,</span><br><span class="line">org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">processPropertySource(propertySource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.warn(<span class="string">"Ignoring @PropertySource annotation on ["</span> + sourceClass.getMetadata().getClassName() +</span><br><span class="line"><span class="string">"]. Reason: Environment must implement ConfigurableEnvironment"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process any @ComponentScan annotations</span></span><br><span class="line">Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line"><span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">!<span class="keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line"><span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line"><span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line"><span class="keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line"><span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line"><span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line"><span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(</span><br><span class="line">holder.getBeanDefinition(), <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process any @Import annotations</span></span><br><span class="line">processImports(configClass, sourceClass, getImports(sourceClass), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process any @ImportResource annotations</span></span><br><span class="line"><span class="keyword">if</span> (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) &#123;</span><br><span class="line">AnnotationAttributes importResource =</span><br><span class="line">AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line">String[] resources = importResource.getStringArray(<span class="string">"locations"</span>);</span><br><span class="line">Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(<span class="string">"reader"</span>);</span><br><span class="line"><span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">String resolvedResource = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process individual @Bean methods</span></span><br><span class="line">Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line"><span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">configClass.addBeanMethod(<span class="keyword">new</span> BeanMethod(methodMetadata, configClass));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process default methods on interfaces</span></span><br><span class="line">processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process superclass, if any</span></span><br><span class="line"><span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">String superclass = sourceClass.getMetadata().getSuperClassName();</span><br><span class="line"><span class="keyword">if</span> (!superclass.startsWith(<span class="string">"java"</span>) &amp;&amp; !<span class="keyword">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line"><span class="keyword">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line"><span class="comment">// Superclass found, return its annotation metadata and recurse</span></span><br><span class="line"><span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No superclass -&gt; processing is complete</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理<strong>@PropertySource</strong>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processPropertySource</span><span class="params">(AnnotationAttributes propertySource)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">String name = propertySource.getString(<span class="string">"name"</span>);</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(name)) &#123;</span><br><span class="line">name = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">String encoding = propertySource.getString(<span class="string">"encoding"</span>);</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(encoding)) &#123;</span><br><span class="line">encoding = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">String[] locations = propertySource.getStringArray(<span class="string">"value"</span>);</span><br><span class="line">Assert.isTrue(locations.length &gt; <span class="number">0</span>, <span class="string">"At least one @PropertySource(value) location is required"</span>);</span><br><span class="line"><span class="keyword">boolean</span> ignoreResourceNotFound = propertySource.getBoolean(<span class="string">"ignoreResourceNotFound"</span>);</span><br><span class="line"></span><br><span class="line">Class&lt;? extends PropertySourceFactory&gt; factoryClass = propertySource.getClass(<span class="string">"factory"</span>);</span><br><span class="line">PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?</span><br><span class="line">DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String location : locations) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String resolvedLocation = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(location);</span><br><span class="line">Resource resource = <span class="keyword">this</span>.resourceLoader.getResource(resolvedLocation);</span><br><span class="line">addPropertySource(factory.createPropertySource(name, <span class="keyword">new</span> EncodedResource(resource, encoding)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line"><span class="comment">// Placeholders not resolvable</span></span><br><span class="line"><span class="keyword">if</span> (ignoreResourceNotFound) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Properties location ["</span> + location + <span class="string">"] not resolvable: "</span> + ex.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="comment">// Resource not found when trying to open it</span></span><br><span class="line"><span class="keyword">if</span> (ignoreResourceNotFound &amp;&amp;</span><br><span class="line">(ex <span class="keyword">instanceof</span> FileNotFoundException || ex <span class="keyword">instanceof</span> UnknownHostException)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Properties location ["</span> + location + <span class="string">"] not resolvable: "</span> + ex.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addPropertySource</span><span class="params">(PropertySource&lt;?&gt; propertySource)</span> </span>&#123;</span><br><span class="line">String name = propertySource.getName();</span><br><span class="line">MutablePropertySources propertySources = ((ConfigurableEnvironment) <span class="keyword">this</span>.environment).getPropertySources();</span><br><span class="line"><span class="keyword">if</span> (propertySources.contains(name) &amp;&amp; <span class="keyword">this</span>.propertySourceNames.contains(name)) &#123;</span><br><span class="line"><span class="comment">// We've already added a version, we need to extend it</span></span><br><span class="line">PropertySource&lt;?&gt; existing = propertySources.get(name);</span><br><span class="line">PropertySource&lt;?&gt; newSource = (propertySource <span class="keyword">instanceof</span> ResourcePropertySource ?</span><br><span class="line">((ResourcePropertySource) propertySource).withResourceName() : propertySource);</span><br><span class="line"><span class="keyword">if</span> (existing <span class="keyword">instanceof</span> CompositePropertySource) &#123;</span><br><span class="line">((CompositePropertySource) existing).addFirstPropertySource(newSource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (existing <span class="keyword">instanceof</span> ResourcePropertySource) &#123;</span><br><span class="line">existing = ((ResourcePropertySource) existing).withResourceName();</span><br><span class="line">&#125;</span><br><span class="line">CompositePropertySource composite = <span class="keyword">new</span> CompositePropertySource(name);</span><br><span class="line">composite.addPropertySource(newSource);</span><br><span class="line">composite.addPropertySource(existing);</span><br><span class="line">propertySources.replace(name, composite);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.propertySourceNames.isEmpty()) &#123;</span><br><span class="line">propertySources.addLast(propertySource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">String firstProcessed = <span class="keyword">this</span>.propertySourceNames.get(<span class="keyword">this</span>.propertySourceNames.size() - <span class="number">1</span>);</span><br><span class="line">propertySources.addBefore(firstProcessed, propertySource);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.propertySourceNames.add(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理<strong>@ComponentScan</strong>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Process any @ComponentScan annotations</span></span><br><span class="line">Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line"><span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">!<span class="keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line"><span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line"><span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line"><span class="keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line"><span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line"><span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line"><span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(</span><br><span class="line">holder.getBeanDefinition(), <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理@Import注解,@ImportResource,@Bean注解。其中@Import处理方法processImports与processConfigurationClass(ConfigurationClass configClass)形成递归调用。实现多层次@Import元标注的ConfigurationClass解析。解析后的ConfigurationClass将会被ConfigurationClassBeanDefinitionReader再次注册为SpringBean。ConfigurationClassBeanDefinitionReader将@Import,@ImportResource,@Bean所关联的Bean定义一并注册了。</p><p>(3):ConfigurationClassBeanDefinitionReader:将解析的Configuration Classs注册为Spring Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigurationClassBeanDefinitionReader</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(Set&lt;ConfigurationClass&gt; configurationModel)</span> </span>&#123;</span><br><span class="line">TrackedConditionEvaluator trackedConditionEvaluator = <span class="keyword">new</span> TrackedConditionEvaluator();</span><br><span class="line"><span class="keyword">for</span> (ConfigurationClass configClass : configurationModel) &#123;</span><br><span class="line">loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Read a particular &#123;<span class="doctag">@link</span> ConfigurationClass&#125;, registering bean definitions</span></span><br><span class="line"><span class="comment"> * for the class itself and all of its &#123;<span class="doctag">@link</span> Bean&#125; methods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitionsForConfigurationClass</span><span class="params">(ConfigurationClass configClass,</span></span></span><br><span class="line"><span class="function"><span class="params">TrackedConditionEvaluator trackedConditionEvaluator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">registerBeanDefinitionForImportedConfigurationClass(configClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (BeanMethod beanMethod : configClass.getBeanMethods()) &#123;</span><br><span class="line">loadBeanDefinitionsForBeanMethod(beanMethod);</span><br><span class="line">&#125;</span><br><span class="line">loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());</span><br><span class="line">loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register the &#123;<span class="doctag">@link</span> Configuration&#125; class itself as a bean definition.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitionForImportedConfigurationClass</span><span class="params">(ConfigurationClass configClass)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Read the given &#123;<span class="doctag">@link</span> BeanMethod&#125;, registering bean definitions</span></span><br><span class="line"><span class="comment"> * with the BeanDefinitionRegistry based on its contents.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitionsForBeanMethod</span><span class="params">(BeanMethod beanMethod)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitionsFromImportedResources</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Map&lt;String, Class&lt;? extends BeanDefinitionReader&gt;&gt; importedResources)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitionsFromRegistrars</span><span class="params">(Map&lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&gt; registrars)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&gt; entry : registrars.entrySet()) &#123;</span><br><span class="line">entry.getKey().registerBeanDefinitions(entry.getValue(), <span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4):ConfigurationClassUtils:判定Configuration Class的级别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationClassUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIGURATION_CLASS_FULL = <span class="string">"full"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIGURATION_CLASS_LITE = <span class="string">"lite"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIGURATION_CLASS_ATTRIBUTE =</span><br><span class="line">Conventions.getQualifiedAttributeName(ConfigurationClassPostProcessor.class, <span class="string">"configurationClass"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ORDER_ATTRIBUTE =</span><br><span class="line">Conventions.getQualifiedAttributeName(ConfigurationClassPostProcessor.class, <span class="string">"order"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(ConfigurationClassUtils.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; candidateIndicators = <span class="keyword">new</span> HashSet&lt;String&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">candidateIndicators.add(Component.class.getName());</span><br><span class="line">candidateIndicators.add(ComponentScan.class.getName());</span><br><span class="line">candidateIndicators.add(Import.class.getName());</span><br><span class="line">candidateIndicators.add(ImportResource.class.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check the given metadata for a configuration class candidate</span></span><br><span class="line"><span class="comment"> * (or nested component class declared within a configuration/component class).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> metadata the metadata of the annotated class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the given class is to be registered as a</span></span><br><span class="line"><span class="comment"> * reflection-detected bean definition; &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isConfigurationCandidate</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (isFullConfigurationCandidate(metadata) || isLiteConfigurationCandidate(metadata));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check the given metadata for a full configuration class candidate</span></span><br><span class="line"><span class="comment"> * (i.e. a class annotated with &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125;).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> metadata the metadata of the annotated class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the given class is to be processed as a full</span></span><br><span class="line"><span class="comment"> * configuration class, including cross-method call interception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFullConfigurationCandidate</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> metadata.isAnnotated(Configuration.class.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check the given metadata for a lite configuration class candidate</span></span><br><span class="line"><span class="comment"> * (e.g. a class annotated with &#123;<span class="doctag">@code</span> <span class="doctag">@Component</span>&#125; or just having</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Import</span>&#125; declarations or &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span> methods&#125;).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> metadata the metadata of the annotated class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the given class is to be processed as a lite</span></span><br><span class="line"><span class="comment"> * configuration class, just registering it and scanning it for &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; methods</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLiteConfigurationCandidate</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Do not consider an interface or an annotation...</span></span><br><span class="line"><span class="keyword">if</span> (metadata.isInterface()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Any of the typical annotations found?</span></span><br><span class="line"><span class="keyword">for</span> (String indicator : candidateIndicators) &#123;</span><br><span class="line"><span class="keyword">if</span> (metadata.isAnnotated(indicator)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally, let's look for @Bean methods...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> metadata.hasAnnotatedMethods(Bean.class.getName());</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine whether the given bean definition indicates a full &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125;</span></span><br><span class="line"><span class="comment"> * class, through checking &#123;<span class="doctag">@link</span> #checkConfigurationClassCandidate&#125;'s metadata marker.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFullConfigurationClass</span><span class="params">(BeanDefinition beanDef)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> CONFIGURATION_CLASS_FULL.equals(beanDef.getAttribute(CONFIGURATION_CLASS_ATTRIBUTE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine whether the given bean definition indicates a lite &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125;</span></span><br><span class="line"><span class="comment"> * class, through checking &#123;<span class="doctag">@link</span> #checkConfigurationClassCandidate&#125;'s metadata marker.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLiteConfigurationClass</span><span class="params">(BeanDefinition beanDef)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> CONFIGURATION_CLASS_LITE.equals(beanDef.getAttribute(CONFIGURATION_CLASS_ATTRIBUTE));</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Enable模块驱动 </tag>
            
            <tag> ImportSelector </tag>
            
            <tag> ImportBeanDefinitionRegistrar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事件监听机制</title>
      <link href="/2019/08/05/Spring%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/08/05/Spring%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring事件监听机制"><a href="#Spring事件监听机制" class="headerlink" title="Spring事件监听机制"></a>Spring事件监听机制</h2><h4 id="1-Spring事件监听基础"><a href="#1-Spring事件监听基础" class="headerlink" title="1:Spring事件监听基础"></a>1:Spring事件监听基础</h4><p>   Spring事件/监听机制属于<code>事件/监听器模式</code>,即<code>观察者模式扩展</code>。在Java中,事件源必须是java.util.</p><p><code>EventObject</code>对象。事件监听器必须是<code>java.util.EventListener</code>。通常<code>API</code>接口需要提供</p><p>监听接口的<code>适配器</code>实现,提供监听空实现的适配方法。当<code>Java8 interface的default方法</code>特性</p><p>能够解决以上问题。</p><p>​    Spring事件监听器,仅抽象出单一方法onApplicationEvent(ApplicationEvent),用于监听Spring事件</p><p>ApplicationEvent。</p><p>​    在Spring3.0之前的ApplicationListener基本无解,必须监听所有的ApplicationEvent,如果要过滤</p><p>不同类型的事件,需要借助instanceof方式进行筛选。从Spring3.0开始,支持泛型监听。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationListener</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handle an application event.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> event the event to respond to</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(E event)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  由于泛型参数的限制,泛型化的ApplicationListener无法监听不同类型的ApplicationEvent。为此,Spring3.0</p><p>引入了SmartApplicationListener接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmartApplicationListener</span> <span class="keyword">extends</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationEvent</span>&gt;, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine whether this listener actually supports the given event type.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> eventType the event type (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supportsEventType</span><span class="params">(Class&lt;? extends ApplicationEvent&gt; eventType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine whether this listener actually supports the given source type.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceType the source type, or &#123;<span class="doctag">@code</span> null&#125; if no source</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supportsSourceType</span><span class="params">(@Nullable Class&lt;?&gt; sourceType)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  例如SpringBoot外部化应用配置文件application.properties的事件监听器ConfigFileApplicationListener</p><p>实现,监听了ApplicationEnvironmentPreparedEvent和ApplicationPreparedEvent两个事件.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsEventType</span><span class="params">(Class&lt;? extends ApplicationEvent&gt; eventType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ApplicationEnvironmentPreparedEvent.class.isAssignableFrom(eventType)</span><br><span class="line">|| ApplicationPreparedEvent.class.isAssignableFrom(eventType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Spring事件发布"><a href="#2-Spring事件发布" class="headerlink" title="2:Spring事件发布"></a>2:Spring事件发布</h4><p>   <code>ApplicationEventMulticaster</code>主要承担两种职责,一是关联ApplicationListener,二是广播</p><p>ApplicationEvent。</p><p>   1):ApplicationEventMulticaster注册ApplicationListener</p><p>  AbstractApplicationEventMulticaster将ApplicationListener做了分类,再结合retrieverCache的定义,</p><p>它是一个ListenerCacheKey为key,ListenerRetriever为value的Map缓存。同时ListenerCacheKey</p><p><code>关联了事件类型和数据源类型</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cache key for ListenerRetrievers, based on event type and source type.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerCacheKey</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ListenerCacheKey</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ResolvableType eventType;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; sourceType;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ListenerCacheKey</span><span class="params">(ResolvableType eventType, @Nullable Class&lt;?&gt; sourceType)</span> </span>&#123;</span><br><span class="line">Assert.notNull(eventType, <span class="string">"Event type must not be null"</span>);</span><br><span class="line"><span class="keyword">this</span>.eventType = eventType;</span><br><span class="line"><span class="keyword">this</span>.sourceType = sourceType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == other) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">ListenerCacheKey otherKey = (ListenerCacheKey) other;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span>.eventType.equals(otherKey.eventType) &amp;&amp;</span><br><span class="line">ObjectUtils.nullSafeEquals(<span class="keyword">this</span>.sourceType, otherKey.sourceType));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.eventType.hashCode() * <span class="number">29</span> + ObjectUtils.nullSafeHashCode(<span class="keyword">this</span>.sourceType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"ListenerCacheKey [eventType = "</span> + <span class="keyword">this</span>.eventType + <span class="string">", sourceType = "</span> + <span class="keyword">this</span>.sourceType + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ListenerCacheKey other)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = <span class="keyword">this</span>.eventType.toString().compareTo(other.eventType.toString());</span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.sourceType == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (other.sourceType == <span class="keyword">null</span> ? <span class="number">0</span> : -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (other.sourceType == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">result = <span class="keyword">this</span>.sourceType.getName().compareTo(other.sourceType.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   实际上,AbstractApplicationEventMulticaster将ApplicationEvent和ApplicationListener集合进行关联。因此</p><p>AbstractApplicationEventMulticaster#getApplicationListeners()返回ApplicationEvent关联ApplicationListener集合。</p><p>   2)ApplicationEventMulticaster广播事件</p><p>​    广播事件在SimpleApplicationEventMulticaster中实现,也是Spring内建唯一实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, @Nullable ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">final</span> ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">Executor executor = getTaskExecutor();</span><br><span class="line"><span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">invokeListener(listener, event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//该方法从Spring4.2开始引入。尽管<code>ResolvableType</code>是从Spring4.0开始出现,它是Spring简化<code>Java反射</code></p><p><code>API而提供的组件,能够轻松的获取泛型类型等。</code></p><p>  3)ApplicationEventMulticaster和ApplicationContext之间关系</p><p>   开发人员可使用<code>ApplicationEventPublisher</code>发布ApplicationEvent。</p><p>   ApplicationEventPublisher接口被Spring上下文接口ApplicationContext扩展,因此,无论哪种Spring应用</p><p>上下文实例,均具备发布ApplicationEvent的能力。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring事件监听机制 </tag>
            
            <tag> 观察者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义SpringBoot自动装配</title>
      <link href="/2019/08/05/%E8%87%AA%E5%AE%9A%E4%B9%89SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"/>
      <url>/2019/08/05/%E8%87%AA%E5%AE%9A%E4%B9%89SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="自定义SpringBoot自动装配"><a href="#自定义SpringBoot自动装配" class="headerlink" title="自定义SpringBoot自动装配"></a>自定义SpringBoot自动装配</h2><h3 id="1：自动装配Class命名规则"><a href="#1：自动装配Class命名规则" class="headerlink" title="1：自动装配Class命名规则"></a>1：自动装配Class命名规则</h3><p><em>AutoConfiguration，其中\</em>代表功能或者模块名。</p><h3 id="2：自动装配package命名规则"><a href="#2：自动装配package命名规则" class="headerlink" title="2：自动装配package命名规则"></a>2：自动装配package命名规则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$&#123;root-package&#125;</span><br><span class="line"> |- autoconfigure</span><br><span class="line">  |- $&#123;module-package&#125;</span><br><span class="line">   |- *AutoConfiguration</span><br><span class="line">    |- $&#123;sub-module-package&#125;</span><br><span class="line">     |- ...</span><br></pre></td></tr></table></figure><p>其中${root_package}是根模块，如com.ley。</p><p>${module_package}是功能模块，如web.servlet。</p><p>而${sub_module_package}是子模块，如error。</p><h3 id="3：自定义SpringBootStarter"><a href="#3：自定义SpringBootStarter" class="headerlink" title="3：自定义SpringBootStarter"></a>3：自定义SpringBootStarter</h3><p>官方建议将自动装配模块代码存放到autoconfigure模块中，starter模块依赖该模块，并且附加其他需要依赖。当然也可以将autoconfigure和stater合并到单模块。</p><p>(1)：Spring Boot Starter命名规则</p><p>开发人员将Starter发布为${module}-spring-boot-autoconfigure和${module}-spring-boot-starter两个jar文件。</p><p><strong>开发人员不要使用server,management,spring等作为配置Key命名空间。尽量采用独立的命名空间。</strong></p><p>(2)：实现Spring Boot Starter</p><p>(a)：新建Spring Boot Starter工程—–formatter-spring-boot-autoconfigure。</p><p>构建一个Maven功能，pom.xml如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Compile dependencies --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- @ConfigurationProperties annotation processing (metadata for IDEs) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(b)：实现DefaultFormatter自动装配—-FormatterAutoConfiguration</p><p>(c)：META-INF/spring.factories资源声明FormatterAutoConfiguration</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># FormatterAutoConfiguration 自动装配声明</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">  com.ley.formatter.autoconfigure.FormatterAutoConfiguration</span><br></pre></td></tr></table></figure><p>(d)：构建Spring Boot Starter—-formatter-spring-boot-starter</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--formatter spring boot autoconfigure--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.gitee.ley1996<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>formatter-spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--spring boot 基础依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            说明formatter-spring-boot-starter不应该</span></span><br><span class="line"><span class="comment">            传递spring-boot-starter依赖。</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在开发Spring Boot Starter的过程中，请保持spring-boot-starter等相关依赖声明为 、&lt;optional&gt;true&lt;/optional&gt;。</p><h3 id="4：Spring-Boot-提交化自动装配"><a href="#4：Spring-Boot-提交化自动装配" class="headerlink" title="4：Spring Boot 提交化自动装配"></a>4：Spring Boot 提交化自动装配</h3><p>条件注解总结：</p><ul><li>Class Conditions</li><li>Bean Conditions</li><li>Property Conditions</li><li>Resource Conditions</li><li>Web Application Conditions</li><li>SpEL Expression Conditions</li></ul><p>4.1：Class条件注解</p><ul><li>ConditionalOnClass：当指定类存在时，在Sprign Boot 1.0~2.0稳定。</li><li>ConditionalOnMissingClass：当指定类不存在时，从Spring Boot 1.4开始才保持稳定。推荐使用value()替代。当指定类不存在时，并不需要该类显示地依赖到当前工程或者Starter。</li></ul><p>4.2：Bean条件注解</p><ul><li>ConditionalOnBean：匹配BeanFactory中Bean的类型和名称。 其中Bean查找策略为SearchStrategy，包含当前，父类及所有。</li><li>ConditionalOnMissingBean：当指定Bean不存在时。从Spring Boot 1.2.5开始，增加ignored()和ignoredType()两个方法，用于忽略或者排除指定Bean。</li></ul><p>4.3：属性条件注解</p><p>  ConditionalOnProperty为属性条件注解，其属性来源于Spring Environment。其中Java系统属性(systemProperties)和环境变量(systemEnvironment)是典型的Spring Environment属性来源。在SpringBoot环境中，application.properties或者application.yml也是其中来源之一。</p><p> 当自动装配组件需要默认装配时，可以使用matchIfMissing()属性值调整为true。</p><p>4.4：Resource条件注解</p><p> ConditionOnResource为Resource条件注解。其中resources()指定只有资源必须存在方可成立。</p><p>4.5：Web应用条件注解。</p><ul><li>ConditionalOnWebApplication：判断当前应用是Web类型。</li><li>ConditionalOnNotWebApplication：当前应用不是Web类型。</li></ul><p>4.6：Spring表达式条件注解</p><p> ConditionalOnExpression，其中value()用于评估表达式的真伪。当表达多组配置属性时，可以使用@ConditionalOnExpression。例如${formatter.enabled:true}</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用Spring Boot提供的条件注解,以及自动装配顺序注解,实现自己的配置类,然后在META-INF/</p><p>spring.factories中声明该类即可。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># FormatterAutoConfiguration 自动装配声明</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">  com.ley.formatter.autoconfigure.FormatterAutoConfiguration</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> SpringBoot自动装配 </tag>
            
            <tag> 条件化注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring整合Mybatis原理探索</title>
      <link href="/2019/08/05/Spring%E6%95%B4%E5%90%88Mybatis%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/"/>
      <url>/2019/08/05/Spring%E6%95%B4%E5%90%88Mybatis%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring整合Mybatis原理探索"><a href="#Spring整合Mybatis原理探索" class="headerlink" title="Spring整合Mybatis原理探索"></a>Spring整合Mybatis原理探索</h2><p><code>@MapperScan</code>注解实现</p><p>1:<code>MapperScannerRegistrar</code>类</p><p>实现<code>ImportBeanDefinitionRegistrar</code>接口,注册默认<code>@Mapper</code>注解标注的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//获取@MapperScan注解上属性</span></span><br><span class="line">   AnnotationAttributes mapperScanAttrs = AnnotationAttributes</span><br><span class="line">       .fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));</span><br><span class="line">   <span class="keyword">if</span> (mapperScanAttrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">     registerBeanDefinitions(mapperScanAttrs, registry);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationAttributes annoAttrs, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">//扫描指定包下包含默认Mybatis注解@Mapper的接口,并注册到Spring Bean工厂中</span></span><br><span class="line">   ClassPathMapperScanner scanner = <span class="keyword">new</span> ClassPathMapperScanner(registry);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// this check is needed in Spring 3.1</span></span><br><span class="line">   Optional.ofNullable(resourceLoader).ifPresent(scanner::setResourceLoader);</span><br><span class="line"></span><br><span class="line">   Class&lt;? extends Annotation&gt; annotationClass = annoAttrs.getClass(<span class="string">"annotationClass"</span>);</span><br><span class="line">   <span class="keyword">if</span> (!Annotation.class.equals(annotationClass)) &#123;</span><br><span class="line">     scanner.setAnnotationClass(annotationClass);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Class&lt;?&gt; markerInterface = annoAttrs.getClass(<span class="string">"markerInterface"</span>);</span><br><span class="line">   <span class="keyword">if</span> (!Class.class.equals(markerInterface)) &#123;</span><br><span class="line">     scanner.setMarkerInterface(markerInterface);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Class&lt;? extends BeanNameGenerator&gt; generatorClass = annoAttrs.getClass(<span class="string">"nameGenerator"</span>);</span><br><span class="line">   <span class="keyword">if</span> (!BeanNameGenerator.class.equals(generatorClass)) &#123;</span><br><span class="line">     scanner.setBeanNameGenerator(BeanUtils.instantiateClass(generatorClass));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass = annoAttrs.getClass(<span class="string">"factoryBean"</span>);</span><br><span class="line">   <span class="keyword">if</span> (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) &#123;</span><br><span class="line">     scanner.setMapperFactoryBean(BeanUtils.instantiateClass(mapperFactoryBeanClass));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   scanner.setSqlSessionTemplateBeanName(annoAttrs.getString(<span class="string">"sqlSessionTemplateRef"</span>));</span><br><span class="line">   scanner.setSqlSessionFactoryBeanName(annoAttrs.getString(<span class="string">"sqlSessionFactoryRef"</span>));</span><br><span class="line"></span><br><span class="line">   List&lt;String&gt; basePackages = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   basePackages.addAll(</span><br><span class="line">       Arrays.stream(annoAttrs.getStringArray(<span class="string">"value"</span>))</span><br><span class="line">           .filter(StringUtils::hasText)</span><br><span class="line">           .collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">   basePackages.addAll(</span><br><span class="line">       Arrays.stream(annoAttrs.getStringArray(<span class="string">"basePackages"</span>))</span><br><span class="line">           .filter(StringUtils::hasText)</span><br><span class="line">           .collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">   basePackages.addAll(</span><br><span class="line">       Arrays.stream(annoAttrs.getClassArray(<span class="string">"basePackageClasses"</span>))</span><br><span class="line">           .map(ClassUtils::getPackageName)</span><br><span class="line">           .collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">   scanner.registerFilters();</span><br><span class="line">   scanner.doScan(StringUtils.toStringArray(basePackages));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>2:<code>ClassPathMapperScanner</code></p><p>继承了<code>ClassPathBeanDefinitionScanner</code>类,该类扫描指定包下的模式注解,并注册到Spring Bean工厂中。</p><p>实现主要方法研究</p><p><strong>注册BeanDefinition过滤接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Configures parent scanner to search for the right interfaces. It can search</span></span><br><span class="line"><span class="comment"> * for all interfaces or just for those that extends a markerInterface or/and</span></span><br><span class="line"><span class="comment"> * those annotated with the annotationClass</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerFilters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> acceptAllInterfaces = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if specified, use the given annotation and / or marker interface</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.annotationClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">    addIncludeFilter(<span class="keyword">new</span> AnnotationTypeFilter(<span class="keyword">this</span>.annotationClass));</span><br><span class="line">    acceptAllInterfaces = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// override AssignableTypeFilter to ignore matches on the actual marker interface</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.markerInterface != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//由于生成的BeanDefinition为MapperFactoryBean,所以BeanClass不是原来的类名</span></span><br><span class="line">    addIncludeFilter(<span class="keyword">new</span> AssignableTypeFilter(<span class="keyword">this</span>.markerInterface) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">matchClassName</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    acceptAllInterfaces = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (acceptAllInterfaces) &#123;</span><br><span class="line">    <span class="comment">// default include filter that accepts all classes</span></span><br><span class="line">    addIncludeFilter((metadataReader, metadataReaderFactory) -&gt; <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// exclude package-info.java</span></span><br><span class="line">  addExcludeFilter((metadataReader, metadataReaderFactory) -&gt; &#123;</span><br><span class="line">    String className = metadataReader.getClassMetadata().getClassName();</span><br><span class="line">    <span class="keyword">return</span> className.endsWith(<span class="string">"package-info"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注册MapperFactoryBean</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processBeanDefinitions</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; beanDefinitions)</span> </span>&#123;</span><br><span class="line">   GenericBeanDefinition definition;</span><br><span class="line">   <span class="keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">     definition = (GenericBeanDefinition) holder.getBeanDefinition();</span><br><span class="line">     String beanClassName = definition.getBeanClassName();</span><br><span class="line">     LOGGER.debug(() -&gt; <span class="string">"Creating MapperFactoryBean with name '"</span> + holder.getBeanName()</span><br><span class="line">         + <span class="string">"' and '"</span> + beanClassName + <span class="string">"' mapperInterface"</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// the mapper interface is the original class of the bean</span></span><br><span class="line">     <span class="comment">// but, the actual class of the bean is MapperFactoryBean</span></span><br><span class="line">     <span class="comment">//添加要与类型匹配的通用参数值注意：单个通用参数值将只使用一次*，而不是多次匹配。</span></span><br><span class="line">     <span class="comment">//MapperFactoryBean是个泛型类,泛型参数是Mybatis的DAO全类限定名</span></span><br><span class="line">     definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); /</span><br><span class="line">     definition.setBeanClass(<span class="keyword">this</span>.mapperFactoryBean.getClass());</span><br><span class="line"></span><br><span class="line">     definition.getPropertyValues().add(<span class="string">"addToConfig"</span>, <span class="keyword">this</span>.addToConfig);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">boolean</span> explicitFactoryUsed = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.sqlSessionFactoryBeanName)) &#123;</span><br><span class="line">       <span class="comment">//如果配置了SqlSesiionFactoryBean,获取运行期间的SqlSessionFactory Bean引用  </span></span><br><span class="line">       definition.getPropertyValues().add(<span class="string">"sqlSessionFactory"</span>, <span class="keyword">new</span> RuntimeBeanReference(<span class="keyword">this</span>.sqlSessionFactoryBeanName));</span><br><span class="line">       explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sqlSessionFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">       definition.getPropertyValues().add(<span class="string">"sqlSessionFactory"</span>, <span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">       explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.sqlSessionTemplateBeanName)) &#123;</span><br><span class="line">       <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">         LOGGER.warn(() -&gt; <span class="string">"Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored."</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       definition.getPropertyValues().add(<span class="string">"sqlSessionTemplate"</span>, <span class="keyword">new</span> RuntimeBeanReference(<span class="keyword">this</span>.sqlSessionTemplateBeanName));</span><br><span class="line">       explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sqlSessionTemplate != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">         LOGGER.warn(() -&gt; <span class="string">"Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored."</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       definition.getPropertyValues().add(<span class="string">"sqlSessionTemplate"</span>, <span class="keyword">this</span>.sqlSessionTemplate);</span><br><span class="line">       explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!explicitFactoryUsed) &#123;</span><br><span class="line">       LOGGER.debug(() -&gt; <span class="string">"Enabling autowire by type for MapperFactoryBean with name '"</span> + holder.getBeanName() + <span class="string">"'."</span>);</span><br><span class="line">       definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>设置候选BeanDefinition条件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断候选的BeanDefinition是否是接口和独立类</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(AnnotatedBeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> beanDefinition.getMetadata().isInterface() &amp;&amp; beanDefinition.getMetadata().isIndependent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>相关类</strong></p><ul><li><code>ClassPathMapperScanner</code>:扫描Bean并注册Bean工厂中</li><li><code>MapperFactoryBean</code>:Mapper Bean工程</li><li><code>MapperScannerRegistrar</code>:提供解析<code>MapperScan</code>注解和批量注册Bean</li><li><code>SqlSessionDaoSupport</code>:提供SqlSession</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>实现批量注册Bean时,提供<code>扫描包注解+标注候选注解+实现ImportBeanDefinitionRegistrar接口+</code></p><p><code>继承ClassPathBeanDefinitionScanner+实现FactoryBean接口</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Mybatis </tag>
            
            <tag> MapperScan注解实现原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Environment抽象</title>
      <link href="/2019/08/05/Spring%20Environment%E6%8A%BD%E8%B1%A1/"/>
      <url>/2019/08/05/Spring%20Environment%E6%8A%BD%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Environment抽象"><a href="#Spring-Environment抽象" class="headerlink" title="Spring Environment抽象"></a>Spring Environment抽象</h2><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1:概述"></a>1:概述</h4><p>Spring中<code>Environment</code>是<code>Spring3.1</code>版本引入的,是<code>Spring</code>核心框架定义的一个接口,用来<strong><code>表示整个应用运行时环境</code>。</strong>该环境模型只接受两种应用环境<strong><code>profiles(配置文件)</code>和<code>properties(属性)</code></strong>。<strong>与属性访问相关的方法通过<code>PropertyResolver</code>超接口访问。</strong></p><p><strong><code>建模关键</code></strong></p><p><code>profile(配置文件)</code></p><ul><li>一个<code>profile</code>是一组<code>Bean</code>定义的逻辑分组,只有当配置文件被激活的时候,才会将对应逻辑上组织的Bean定义注册到容器中。</li><li><code>Bean</code>添加到<code>profile</code>可以通过<code>XML或者Annotation</code>方式。</li><li><code>Environment</code>对象对于<code>profile</code>机制所扮演的角色是用来指定哪些<code>profile</code>是<code>当前活跃或者缺省活跃</code>。可以通过<code>getActiveProfiles</code>或者<code>getDefaultProfiles</code>获取。</li></ul><p><code>proprety(属性)</code></p><ul><li>一个应用属性有很多来源:属性文件(properties files),JVM系统属性(<code>getSystemProperties</code>),系统变量属性(<code>getSystemEnvironment</code>),<code>JNDI</code>,<code>servlet上下文参数</code>,<code>临时属性对象,Maps</code>等。</li><li><code>Environment</code>对于<code>property</code>所扮演的角色提供给使用一个方便服务接口用于<ul><li>配置属性源</li><li>从属性源解析和获取属性</li></ul></li></ul><p>容器上下文(<code>ApplicationContext</code>)所获取的<code>bean</code>,如果想直接使用<code>Environment</code>对象访问<code>profile</code>状态或者获取属性。有以下方式。</p><ul><li><code>EnvironmentAware</code>接口</li><li><code>@Inject</code> 或者 <code>@Autowired</code>注入一个 <code>Environment</code>对象</li></ul><p>绝大多数情况,bean都不需要直接访问<code>Environment</code>对象,而是通过类似<code>@Value</code>注解方式把属性值注入进来。</p><p>这个接口定义在包 <code>org.springframework.core.env</code> 中。下面是<code>Spring</code>围绕环境抽象<code>Environment</code>各个接口/类之间的继承关系: </p><p><img src="https://img-blog.csdnimg.cn/20181124170340612.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FuZHlfemhhbmcyMDA3,size_16,color_FFFFFF,t_70" alt="Spring Environment"> </p><h4 id="2-Environment接口相关类介绍"><a href="#2-Environment接口相关类介绍" class="headerlink" title="2:Environment接口相关类介绍"></a>2:<code>Environment</code>接口相关类介绍</h4><table><thead><tr><th align="center">接口|类</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center"><code>PropertyResolver</code></td><td align="center">接口,抽象对属性源的访问比如是否包含某个属性，读取属性，解析占位符，将读取到的属性转换成指定类型 (<code>提供读操作)默认实现PropertySourcesPropertyResolver</code></td></tr><tr><td align="center"><code>Environment</code></td><td align="center">接口,继承自<code>PropertyResolver</code>,对环境属性访问和<code>default/active profile</code>访问的抽象 。</td></tr><tr><td align="center"><code>ConfigurablePropertyResolver</code></td><td align="center">接口，为<code>PropertyResolver</code>接口抽象的属性源访问做了配置方面的增强。(<code>提供写操作。</code>)</td></tr><tr><td align="center"><code>ConfigurableEnvironment</code></td><td align="center">接口，在所继承的接口之上增加了设置<code>defaut/active profile</code>的能力，增加/删除环境对象中属性源的能力</td></tr><tr><td align="center"><code>ConfigurableWebEnvironment</code></td><td align="center">接口，向接口<code>ConfigurableEnvironment</code>增强了根据Servlet上下文/配置初始化属性源的能力</td></tr><tr><td align="center"><code>AbstractEnvironment</code></td><td align="center"><code>Environment</code>抽象基类，实现了<code>ConfigurableEnvironment</code></td></tr><tr><td align="center"><code>StandardEnvironment</code></td><td align="center">实现类,针对标准Spring应用(非Web应用)环境, 在<code>AbstractEnvironment</code>基础上提供了属性源<code>systemEnvironment</code>(来自<code>System.getenv()</code>)和<code>systemProperties</code>(来自<code>System.getProperties()</code>)</td></tr><tr><td align="center"><code>StandardServletEnvironment</code></td><td align="center">实现类,针对标准Spring Servlet Web应用的环境， 增加了<code>servletContextInitParams</code>/<code>servletConfigInitParams</code>/<code>jndiProperties</code></td></tr></tbody></table><h4 id="3-外部化配置抽象相关类"><a href="#3-外部化配置抽象相关类" class="headerlink" title="3:外部化配置抽象相关类"></a>3:<code>外部化配置抽象相关类</code></h4><table><thead><tr><th align="center">接口|类</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center"><code>PropertySource</code></td><td align="center"><code>用来抽象属性键值对(外部化配置,即属性源)配置基类</code>。例如<code>Map,Properties,ServletConfig,ServletContext</code></td></tr><tr><td align="center"><code>PropertySources</code></td><td align="center">对<code>PropertySource</code>抽象属性键值对外部化配置提供集合操作。</td></tr><tr><td align="center"><code>MutablePropertySources</code></td><td align="center"><code>PropertySources</code>默认实现。</td></tr><tr><td align="center"><code>MapPropertySource</code></td><td align="center"><code>Map对象中读取属性键值对</code></td></tr><tr><td align="center"><code>PropertiesPropertySource</code></td><td align="center"><code>Properties对象中读取属性键值对</code></td></tr><tr><td align="center"><code>ResourcePropertySource</code></td><td align="center"><code>Resource对象读取中读取属性键值对。只支持.xml和.properties文件。</code>底层实现使用了工具类<code>PropertiesLoaderUtils</code>。</td></tr><tr><td align="center"><code>CompositePropertySource</code></td><td align="center"><code>聚合一组PropertySource</code>。</td></tr><tr><td align="center">Web环境实现类和JNDI实现类和随机数实现类</td><td align="center"><code>ServletConfigPropertySource</code>,<code>ServletContextPropertySource</code>,  <code>JndiPropertySource</code>,<code>RandomValuePropertySource</code></td></tr><tr><td align="center">命令行参数实现类</td><td align="center"><code>CommandLinePropertySource</code></td></tr></tbody></table><h4 id="4-混淆定义"><a href="#4-混淆定义" class="headerlink" title="4:混淆定义"></a>4:混淆定义</h4><ul><li>上下文:用来处理分层传递抽象,代表着<code>应用</code>。</li><li>环境:<code>当前上下文运行环境</code>,存储各种<code>全局变量</code>。比如JDK信息,内存信息等等。</li></ul><h4 id="5-核心API"><a href="#5-核心API" class="headerlink" title="5:核心API"></a>5:核心API</h4><ul><li><strong>PropertySource:</strong>属性源。key-value属性对抽象</li><li><strong>PropertyResolver:</strong>属性解析器。用于解析相应key的value</li><li><strong>Profile:</strong>配置。<strong>只有激活的配置profile</strong>的组件/配置才会注册到Spring容器,类似于maven中profile。</li><li><strong>Environment:</strong>环境，本身也是个属性解析器<code>PropertyResolver</code>。 </li></ul><h4 id="6-属性解析器相关类详细介绍"><a href="#6-属性解析器相关类详细介绍" class="headerlink" title="6:属性解析器相关类详细介绍"></a>6:属性解析器相关类详细介绍</h4><h5 id="PropertySourcesPropertyResolver"><a href="#PropertySourcesPropertyResolver" class="headerlink" title="PropertySourcesPropertyResolver"></a><code>PropertySourcesPropertyResolver</code></h5><p>该类是Spring内建提供的<code>PropertyResolver</code>唯一实现类。环境抽象<code>Environment</code>属性解析委托给该类。包括对属性类型之间必要转换。<code>Converter</code>和<code>ConverterService</code>。实际的占位符解析委托给<code>PropertyPlaceholderHelper</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertySourcesPropertyResolver</span> <span class="keyword">extends</span> <span class="title">AbstractPropertyResolver</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PropertySources propertySources; <span class="comment">//内部持有一组PropertySource</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由此可以看出propertySources的顺序很重要~~~</span></span><br><span class="line"><span class="comment">// 并且还能处理占位符~~~~~ resolveNestedPlaceholders支持内嵌、嵌套占位符</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">getProperty</span><span class="params">(String key, Class&lt;T&gt; targetValueType, <span class="keyword">boolean</span> resolveNestedPlaceholders)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.propertySources != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (PropertySource&lt;?&gt; propertySource : <span class="keyword">this</span>.propertySources) &#123;</span><br><span class="line">Object value = propertySource.getProperty(key);</span><br><span class="line"><span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (resolveNestedPlaceholders &amp;&amp; value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">value = resolveNestedPlaceholders((String) value);</span><br><span class="line">&#125;</span><br><span class="line">logKeyFound(key, propertySource, value);</span><br><span class="line"><span class="keyword">return</span> convertValueIfNecessary(value, targetValueType);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPropertyResolver</span> <span class="keyword">implements</span> <span class="title">ConfigurablePropertyResolver</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ConfigurableConversionService conversionService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> PropertyPlaceholderHelper nonStrictHelper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> PropertyPlaceholderHelper strictHelper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> ignoreUnresolvableNestedPlaceholders = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String placeholderPrefix = SystemPropertyUtils.PLACEHOLDER_PREFIX;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String placeholderSuffix = SystemPropertyUtils.PLACEHOLDER_SUFFIX;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> String valueSeparator = SystemPropertyUtils.VALUE_SEPARATOR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; requiredProperties = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-应用环境抽象Environment"><a href="#7-应用环境抽象Environment" class="headerlink" title="7:应用环境抽象Environment"></a>7:应用环境抽象<code>Environment</code></h4><p><code>Environment</code>接口:环境的读操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Environment</span> <span class="keyword">extends</span> <span class="title">PropertyResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the set of profiles explicitly made active for this environment. Profiles</span></span><br><span class="line"><span class="comment"> * are used for creating logical groupings of bean definitions to be registered</span></span><br><span class="line"><span class="comment"> * conditionally, for example based on deployment environment.  Profiles can be</span></span><br><span class="line"><span class="comment"> * activated by setting &#123;<span class="doctag">@linkplain</span> AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME</span></span><br><span class="line"><span class="comment"> * "spring.profiles.active"&#125; as a system property or by calling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ConfigurableEnvironment#setActiveProfiles(String...)&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If no profiles have explicitly been specified as active, then any</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> #getDefaultProfiles() default profiles&#125; will automatically be activated.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getDefaultProfiles</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurableEnvironment#setActiveProfiles</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] getActiveProfiles();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the set of profiles to be active by default when no active profiles have</span></span><br><span class="line"><span class="comment"> * been set explicitly.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getActiveProfiles</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurableEnvironment#setDefaultProfiles</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> AbstractEnvironment#DEFAULT_PROFILES_PROPERTY_NAME</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] getDefaultProfiles();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return whether one or more of the given profiles is active or, in the case of no</span></span><br><span class="line"><span class="comment"> * explicit active profiles, whether one or more of the given profiles is included in</span></span><br><span class="line"><span class="comment"> * the set of default profiles. If a profile begins with '!' the logic is inverted,</span></span><br><span class="line"><span class="comment"> * i.e. the method will return true if the given profile is &lt;em&gt;not&lt;/em&gt; active.</span></span><br><span class="line"><span class="comment"> * For example, &lt;pre class="code"&gt;env.acceptsProfiles("p1", "!p2")&lt;/pre&gt; will</span></span><br><span class="line"><span class="comment"> * return &#123;<span class="doctag">@code</span> true&#125; if profile 'p1' is active or 'p2' is not active.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if called with zero arguments</span></span><br><span class="line"><span class="comment"> * or if any profile is &#123;<span class="doctag">@code</span> null&#125;, empty or whitespace-only</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getActiveProfiles</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getDefaultProfiles</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">acceptsProfiles</span><span class="params">(String... profiles)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConfigurableEnvironment</code>:增加环境的写操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurableEnvironment</span> <span class="keyword">extends</span> <span class="title">Environment</span>, <span class="title">ConfigurablePropertyResolver</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指定该环境下的 profile 集</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setActiveProfiles</span><span class="params">(String... profiles)</span></span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 增加此环境的 profile</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addActiveProfile</span><span class="params">(String profile)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置默认的 profile</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDefaultProfiles</span><span class="params">(String... profiles)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回此环境的 PropertySources</span></span><br><span class="line">    <span class="function">MutablePropertySources <span class="title">getPropertySources</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 尝试返回 System.getenv() 的值，若失败则返回通过 System.getenv(string) 的来访问各个键的映射</span></span><br><span class="line">    <span class="function">Map&lt;String, Object&gt; <span class="title">getSystemEnvironment</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 尝试返回 System.getProperties() 的值，若失败则返回通过 System.getProperties(string) 的来访问各个键的映射</span></span><br><span class="line">    <span class="function">Map&lt;String, Object&gt; <span class="title">getSystemProperties</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(ConfigurableEnvironment parent)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AbstractEnvironment</code>:作为环境接口抽象实现,主要实现了<code>profile</code>相关功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractEnvironment</span> <span class="keyword">implements</span> <span class="title">ConfigurableEnvironment</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String IGNORE_GETENV_PROPERTY_NAME = <span class="string">"spring.getenv.ignore"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请参考：ConfigurableEnvironment#setActiveProfiles</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACTIVE_PROFILES_PROPERTY_NAME = <span class="string">"spring.profiles.active"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请参考：ConfigurableEnvironment#setDefaultProfiles</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PROFILES_PROPERTY_NAME = <span class="string">"spring.profiles.default"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; defaultProfiles = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(getReservedDefaultProfiles());</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 默认的profile名称</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String RESERVED_DEFAULT_PROFILE_NAME = <span class="string">"default"</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;String&gt; <span class="title">doGetActiveProfiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.activeProfiles) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.activeProfiles.isEmpty()) &#123;</span><br><span class="line">String profiles = getProperty(ACTIVE_PROFILES_PROPERTY_NAME);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(profiles)) &#123;</span><br><span class="line">setActiveProfiles(StringUtils.commaDelimitedListToStringArray(</span><br><span class="line">StringUtils.trimAllWhitespace(profiles)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.activeProfiles;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>activeProfiles</code> 为空,则从 <code>Properties</code> 中获取 <code>spring.profiles.active</code> 配置;如果不为空，则调用 <code>setActiveProfiles()</code> 设置 profile,最后返回。 </p><blockquote><p>从这里可以知道，API设置的activeProfiles优先级第一，其次才是属性配置。</p></blockquote><h4 id="8-应用环境配置激活-Profile和ProfileCondition"><a href="#8-应用环境配置激活-Profile和ProfileCondition" class="headerlink" title="8:应用环境配置激活(@Profile和ProfileCondition)"></a>8:应用环境配置激活(@Profile和ProfileCondition)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Conditional</span>(ProfileCondition.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Profile &#123;</span><br><span class="line"></span><br><span class="line">String[] value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>从Spring4.0</code>开始提供<code>Conditional</code>接口,该注解实现原理基于<code>Condition</code>条件接口,<code>Condition</code>条件接口计算结果实现类为<code>ConditionEvaluator</code>,该类是个内部类。</p><p><code>ProfileCondition</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProfileCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 因为value值是个数组，所以此处有多个值 用的MultiValueMap</span></span><br><span class="line">MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());</span><br><span class="line"><span class="keyword">if</span> (attrs != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (Object value : attrs.get(<span class="string">"value"</span>)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个值中，但凡只要有一个acceptsProfiles了，那就返回true~</span></span><br><span class="line"><span class="keyword">if</span> (context.getEnvironment().acceptsProfiles(Profiles.of((String[]) value))) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Profile</code>的value可以指定多个值,并且只需要有一个值符合了条件,<code>@Profile</code>标注的方法、类就会生效，就会被加入到容器内。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Environment抽象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git分支的创建与合并</title>
      <link href="/2019/08/05/Git%E5%88%86%E6%94%AF%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6/"/>
      <url>/2019/08/05/Git%E5%88%86%E6%94%AF%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Git分支的创建与合并"><a href="#Git分支的创建与合并" class="headerlink" title="Git分支的创建与合并"></a>Git分支的创建与合并</h1><h2 id="Git管理项目代码，常见流程。"><a href="#Git管理项目代码，常见流程。" class="headerlink" title="Git管理项目代码，常见流程。"></a>Git管理项目代码，常见流程。</h2><p>1.开发公司网站。</p><p>2.为了开发某个新功能新建一个分支（假如叫develop），并在该分支上进行开发。</p><p>3.接到测试组的Bug反馈，返回主分支，新建一个新的分支（bugFix），在该分支上修复Bug，然后与主分支master合并。</p><p>4.将分支切换回develop，继续开发新功能，结束后和主分支master合并。</p><h2 id="分支的新建与切换"><a href="#分支的新建与切换" class="headerlink" title="分支的新建与切换"></a>分支的新建与切换</h2><p>假如公司网站项目已经开发了一段时间，并且使用Git提交了几次更新，提交历史如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1564850183032-b09e5025-ebca-4b9d-8c8d-7f15295b3874.png" alt="img"></p><p>为了开发新的功能，新建分支develop并切换到该分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch develop</span><br><span class="line"></span><br><span class="line">$ git checkout develop</span><br><span class="line">Switched to branch <span class="string">'develop'</span></span><br></pre></td></tr></table></figure><p>也可以使用命令 <strong><em>git checkout -b</em></strong> 直接新建并切换：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b develop</span><br><span class="line">Switched to a new branch <span class="string">'develop'</span></span><br></pre></td></tr></table></figure><p>执行完上述命令后，仓库历史大致如下所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1564850266347-b3a8d859-2863-491a-8a44-c312b6be87eb.png" alt="img"></p><p>Git新建了一个分支指针develop，然后将HEAD指向develop。</p><p>接下来在该分支上开心的开发新功能，比如新建了公司网站About页面，添加了内容然后提交了此次修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ vim About.html</span><br><span class="line"></span><br><span class="line">$ git add About.html</span><br><span class="line"></span><br><span class="line">$ git commit -a -m <span class="string">"add About.html page"</span></span><br><span class="line">[develop b462691] add About.html page</span><br><span class="line"> 1 file changed, 12 insertions(+)</span><br><span class="line"> create mode 100644 About.html</span><br></pre></td></tr></table></figure><p>此时，仓库历史如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1564850293014-6b3c4cd9-8af7-4c22-92d8-caa3f00fbe18.png" alt="img"></p><p>这时候接到测试组公司网站主页index.html的Bug反馈，于是将分支切换回主分支master，然后新建分支bugFix，修复Bug，并提交该修复：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line"></span><br><span class="line">$ git checkout -b <span class="string">"bugFix"</span></span><br><span class="line">Switched to a new branch <span class="string">'bugFix'</span></span><br><span class="line"></span><br><span class="line">$ vim index.html</span><br><span class="line"></span><br><span class="line">$ git  commit -a -m <span class="string">"update index.html page"</span></span><br><span class="line">[bugFix 11a3074] update index.html page</span><br><span class="line"> 1 file changed, 2 insertions(+), 2 deletions(-)</span><br></pre></td></tr></table></figure><p>此时，仓库历史如下图所示：</p><p>`<img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1564850338214-4d62fbb7-4fe4-4a46-b4ad-f07a6897274c.png" alt="img"></p><p>假如确定<strong>Bug</strong>修复后，可以切换回<strong>master</strong>分支，然后将<strong>bugFix</strong>和<strong>master</strong>分支合并：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge bugFix</span><br><span class="line">Updating e7ad858..11a3074</span><br><span class="line">Fast-forward</span><br><span class="line"> index.html | 4 ++--</span><br><span class="line"> 1 file changed, 2 insertions(+), 2 deletions(-)</span><br></pre></td></tr></table></figure><p>合并时出现了“<strong>Fast forward</strong>”的提示。如果顺着一个分支走下去可以到达另一个分支的话，那么Git在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（<strong>Fast forward</strong>）。</p><p>此时<strong>bugFix</strong>分支已经完成了历史使命，可以使用命令 <strong><em>git branch -d</em></strong> 将其删除：</p><p>合并<strong>master</strong>与<strong>bugFix</strong>，并删除<strong>bugFix</strong>分支后，仓库历史如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1564850437440-6d477607-a8df-4f3b-b8ac-30c16e876de8.png" alt="img"></p><p><strong>Bug</strong>修复后，切换回<strong>develop</strong>分支继续开发新的功能，并且提交：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1564850459181-df04d3be-ed07-4103-9a67-947f16c8b6b6.png" alt="img"></p><h2 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h2><p>和合并<strong>master</strong>分支与<strong>bugFix</strong>分支那样，合并<strong>master</strong>与<strong>develop</strong>分支过程也差不多：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line"></span><br><span class="line">$ git merge develop</span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> About.html | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>由于master指向的C4并不是develop指向C5的直接祖先C2，所以合并方式不是“Fast forward”，Git 会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算。</p><p>合并master和develop后，仓库历史如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1564850520992-d529f6e1-5437-4575-983d-dd1ade41518c.png" alt="img"></p><h2 id="解决合并冲突"><a href="#解决合并冲突" class="headerlink" title="解决合并冲突"></a>解决合并冲突</h2><p>假如在不同分支中都对同一个文件进行了修改，那么合并的时候就会发生冲突。比如在master分支和develop分支上都修改了About.html页面，然后进行分支合并：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge develop</span><br><span class="line">Auto-merging About.html</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> About.html</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure><p>Git作了合并，但没有提交，它会停下来等你解决冲突。</p><p>可是使用命令 <strong><em>git status</em></strong> 查看哪些文件存在冲突：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">"git commit"</span>)</span><br><span class="line">  (use <span class="string">"git merge --abort"</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to mark resolution)</span><br><span class="line"></span><br><span class="line">        both modified:   About.html</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><p>任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出。编辑About.html页面，可看到文件包含类似下面部分的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">  &lt;footer&gt;2016~2017 All Rights Reserved&lt;/footer&gt;</span><br><span class="line">=======</span><br><span class="line">  &lt;footer&gt;&amp;copy;2016~2017&lt;/footer&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; develop</span><br></pre></td></tr></table></figure><p>可以看到 ======= 隔开的上半部分，是<strong>HEAD</strong>（即 <strong>master</strong> 分支，<strong>在运行merge命令时所切换到的分支</strong>）中的内容，下半部分是在develop分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;footer&gt;&amp;copy; 2016~2017 All Rights Reserved&lt;/footer&gt;</span><br></pre></td></tr></table></figure><p><strong>转载</strong>:<a href="http://mrbird.cc/Git分支的创建与合并.html" target="_blank" rel="noopener">http://mrbird.cc/Git分支的创建与合并.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>@Component注解派生性原理</title>
      <link href="/2019/08/04/Component%E6%B3%A8%E8%A7%A3%E6%B4%BE%E7%94%9F%E6%80%A7%E5%8E%9F%E7%90%86/"/>
      <url>/2019/08/04/Component%E6%B3%A8%E8%A7%A3%E6%B4%BE%E7%94%9F%E6%80%A7%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Component注解的派生性原理"><a href="#Component注解的派生性原理" class="headerlink" title="@Component注解的派生性原理"></a>@Component注解的派生性原理</h2><h4 id="1-模式注解"><a href="#1-模式注解" class="headerlink" title="1:模式注解"></a>1:模式注解</h4><p><code>Stereotype Annotation</code>俗称为模式注解。Spring核心部分提供了几种内建的<code>模式注解</code>,如<em>@Component,@Repository,@Service,@Controller,@Configuration等</em>。这些注解均<code>派生于@Component</code>。</p><p>由于<em>Java语言规定,Annotation不允许继承,没有类派生子类的特性</em>,因此<em><code>Spring采用元标注的方式实现注解之间的派生</code></em>。</p><h4 id="2-Component派生性"><a href="#2-Component派生性" class="headerlink" title="2:@Component派生性"></a>2:@Component派生性</h4><p>@Component注解作为Spring容器托管的通用模式组件,<em>任何被@Component标注的组件均为组件扫描的候选对象。</em></p><blockquote><p>任何论证过程离不开所处的环境,需要开发人员具备一定工程意识,包括<strong>软件版本,特性范围,兼容情况等</strong>。因此,<em>论证过程从最低版本开始推导,逐步证明不同版本得提升和差异。</em></p></blockquote><h4 id="3-Component注解派生性原理"><a href="#3-Component注解派生性原理" class="headerlink" title="3:@Component注解派生性原理"></a>3:@Component注解派生性原理</h4><p>当<code>ClassPathBeanDefinitionScanner#doScan(String... basePackages)</code>调用时,它利用basePackages参数迭代执行的<code>findCandidateComponents(String basePackage)</code>,每次执行结果都生成候选的BeanDefinition集合,即candidates变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathBeanDefinitionScanner</span> <span class="keyword">extends</span> <span class="title">ClassPathScanningCandidateComponentProvider</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"> <span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">        <span class="comment">//获取候选的BeanDefinition集合</span></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinitionHolder&gt;();</span><br><span class="line"><span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;   </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而findCandidateComponents(String basePackage)从父类ClassPathScanningCandidateComponentProvider</p><p>中继承。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathScanningCandidateComponentProvider</span> <span class="keyword">implements</span> <span class="title">EnvironmentCapable</span>, <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"> <span class="function"><span class="keyword">public</span> Set&lt;BeanDefinition&gt; <span class="title">findCandidateComponents</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line">Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinition&gt;();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取查询的package,并处理占位符情况$&#123;...&#125;,转换为ClassLoader资源(.class)搜索路径</span></span><br><span class="line">String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class="line">resolveBasePackage(basePackage) + <span class="string">'/'</span> + <span class="keyword">this</span>.resourcePattern;</span><br><span class="line">Resource[] resources = <span class="keyword">this</span>.resourcePatternResolver.getResources(packageSearchPath);</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//resource迭代执行,当资源可读取时,获取该资源的MetadataReader对象</span></span><br><span class="line"><span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (resource.isReadable()) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//包含了类和注解元信息读取方法</span></span><br><span class="line">MetadataReader metadataReader = <span class="keyword">this</span>.metadataReaderFactory.getMetadataReader(resource);</span><br><span class="line">                        <span class="comment">//判断资源是否为候选的组件,通过excludeFilters和includeFilters进行判断</span></span><br><span class="line"><span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">                            <span class="comment">//基于ASM,支持AnnotatedBeanDefinition接口</span></span><br><span class="line">ScannedGenericBeanDefinition sbd = <span class="keyword">new</span> ScannedGenericBeanDefinition(metadataReader);</span><br><span class="line">sbd.setResource(resource);</span><br><span class="line">sbd.setSource(resource);</span><br><span class="line">                            <span class="comment">//判断BeanDefinition是否候选组件</span></span><br><span class="line"><span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line">...</span><br><span class="line">candidates.add(sbd);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> candidates;</span><br><span class="line">&#125;   </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine whether the given class does not match any exclude filter</span></span><br><span class="line"><span class="comment"> * and does match at least one include filter.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> metadataReader the ASM ClassReader for the class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> whether the class qualifies as a candidate component</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(MetadataReader metadataReader)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.excludeFilters) &#123;</span><br><span class="line"><span class="keyword">if</span> (tf.match(metadataReader, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.includeFilters) &#123;</span><br><span class="line"><span class="keyword">if</span> (tf.match(metadataReader, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line"><span class="keyword">return</span> isConditionMatch(metadataReader);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine whether the given bean definition qualifies as candidate.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The default implementation checks whether the class is not an interface</span></span><br><span class="line"><span class="comment"> * and not dependent on an enclosing class.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Can be overridden in subclasses.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanDefinition the bean definition to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> whether the bean definition qualifies as a candidate component</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(AnnotatedBeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">AnnotationMetadata metadata = beanDefinition.getMetadata();</span><br><span class="line"><span class="keyword">return</span> (metadata.isIndependent() &amp;&amp; (metadata.isConcrete() ||</span><br><span class="line">(metadata.isAbstract() &amp;&amp; metadata.hasAnnotatedMethods(Lookup.class.getName()))));</span><br><span class="line">&#125;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register the default filter for &#123;<span class="doctag">@link</span> Component <span class="doctag">@Component</span>&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This will implicitly register all annotations that have the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Component <span class="doctag">@Component</span>&#125; meta-annotation including the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Repository <span class="doctag">@Repository</span>&#125;, &#123;<span class="doctag">@link</span> Service <span class="doctag">@Service</span>&#125;, and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Controller <span class="doctag">@Controller</span>&#125; stereotype annotations.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Also supports Java EE 6's &#123;<span class="doctag">@link</span> javax.annotation.ManagedBean&#125; and</span></span><br><span class="line"><span class="comment"> * JSR-330's &#123;<span class="doctag">@link</span> javax.inject.Named&#125; annotations, if available.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerDefaultFilters</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(Component.class));</span><br><span class="line">ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">((Class&lt;? extends Annotation&gt;) ClassUtils.forName(<span class="string">"javax.annotation.ManagedBean"</span>, cl)), <span class="keyword">false</span>));</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">((Class&lt;? extends Annotation&gt;) ClassUtils.forName(<span class="string">"javax.inject.Named"</span>, cl)), <span class="keyword">false</span>));</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下,ClassPathScanningCandidateComponentProvider构造参数<code>useDefaultFilters为true</code>,并且显示传递给父类构造参数。该方法给属性<code>includeFilters</code>增添了<code>@Component</code>类型AnnotationTypeFilter的TypeFilter。</p><p>ClassPathBeanDefinitionScanner默认过滤器引入标注@Component,@Repository,@Service或者@Controller等类。<code>同理,它也能够标注所有@Component的&quot;派生&quot;注解。</code></p><blockquote><p><code>@Component</code>注解只包含一个value属性定义，所以其“派生”的注解也只能包含一个vlaue属性定义。 </p></blockquote><p>Dubbo实现<code>@Service</code>注解扫描实例:</p><blockquote><p><strong>ClassPathBeanDefinitionScanner</strong>允许自定义类型过滤规则。因此,Dubbo的@Service没有标注@Component情况下，通过scanner.addIncludeFilter(new AnnotationTypeFilter(Service.class))方式达到识别@Service标注类情况。但是没有使用<code>@Component</code>注解的派生性。</p></blockquote><p>Mybatis实现<code>@Mapper</code>注解扫描实例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathMapperScanner</span> <span class="keyword">extends</span> <span class="title">ClassPathBeanDefinitionScanner</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ClassPathMapperScanner</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(registry, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Configures parent scanner to search for the right interfaces. It can search</span></span><br><span class="line"><span class="comment">   * for all interfaces or just for those that extends a markerInterface or/and</span></span><br><span class="line"><span class="comment">   * those annotated with the annotationClass</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerFilters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> acceptAllInterfaces = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if specified, use the given annotation and / or marker interface</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.annotationClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">      addIncludeFilter(<span class="keyword">new</span> AnnotationTypeFilter(<span class="keyword">this</span>.annotationClass));</span><br><span class="line">      acceptAllInterfaces = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// override AssignableTypeFilter to ignore matches on the actual marker interface</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.markerInterface != <span class="keyword">null</span>) &#123;</span><br><span class="line">      addIncludeFilter(<span class="keyword">new</span> AssignableTypeFilter(<span class="keyword">this</span>.markerInterface) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">matchClassName</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      acceptAllInterfaces = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (acceptAllInterfaces) &#123;</span><br><span class="line">      <span class="comment">// default include filter that accepts all classes</span></span><br><span class="line">      addIncludeFilter(<span class="keyword">new</span> TypeFilter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exclude package-info.java</span></span><br><span class="line">    addExcludeFilter(<span class="keyword">new</span> TypeFilter() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String className = metadataReader.getClassMetadata().getClassName();</span><br><span class="line">        <span class="keyword">return</span> className.endsWith(<span class="string">"package-info"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(AnnotatedBeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> beanDefinition.getMetadata().isInterface() &amp;&amp; beanDefinition.getMetadata().isIndependent();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processBeanDefinitions</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; beanDefinitions)</span> </span>&#123;</span><br><span class="line">    GenericBeanDefinition definition;</span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">      definition = (GenericBeanDefinition) holder.getBeanDefinition();</span><br><span class="line">     </span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">      <span class="comment">//复杂对象构建考虑使用FactoryBean接口           </span></span><br><span class="line">      <span class="comment">// the mapper interface is the original class of the bean</span></span><br><span class="line">      <span class="comment">// but, the actual class of the bean is MapperFactoryBean</span></span><br><span class="line">     <span class="comment">//添加泛型参数         </span></span><br><span class="line">           definition.getConstructorArgumentValues().addGenericArgumentValue(definition.getBeanClassName());</span><br><span class="line">     <span class="comment">// issue #59</span></span><br><span class="line">      definition.setBeanClass(<span class="keyword">this</span>.mapperFactoryBean.getClass());</span><br><span class="line"></span><br><span class="line">      definition.getPropertyValues().add(<span class="string">"addToConfig"</span>, <span class="keyword">this</span>.addToConfig);</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-思考扩展"><a href="#4-思考扩展" class="headerlink" title="4:思考扩展"></a>4:思考扩展</h4><p>思考1:利用<code>ClassPathBeanDefinitionScanner</code>类配合<code>includeFilters</code>和<code>excludeFilters</code>定制化批量注册Bean到Spring容器中。常常可以通过注解方式来包含或者排除候选类。</p><p><em>TypeFilter常用实现</em></p><ul><li>AnnotationTypeFilter:注解类型过滤器</li><li>AssignableTypeFilter:确定此对象表示的类或者接口是否为给定类或者接口相同。</li><li>RegexPatternTypeFilter:判断给定的类名是否符合指定正则表达式。</li></ul><p>思考2:复杂对象构建考虑使用<code>FactoryBean</code>实现类。</p><p>思考3:如果是读取类和注解信息可以考虑基于ASM或者反射,使用方式往下可以获取。当获取已加载的类信息可以考虑反射(<code>反射大前提是被反射的Class被ClassLoader加载</code>),ASM用于不需要将类路径package下的Class全部加载,Spring应用指定Java package扫描Spring模式注解时,利用的就是基于ASM方式获取类或者注解信息。基于ASM获取会获得更大性能。</p><p>思考4:资源读取考虑使用<code>ResourcePatternResolver</code>,这个对象的获取可以通过Spring提供的工具类</p><p><code>ResourcePatternUtils.getResourcePatternResolver(resourceLoader)</code>。在使用的时候,考虑处理</p><p><code>占位符${...}</code>的情况,注意资源是否可读。</p><h4 id="5-多层次-Component派生性"><a href="#5-多层次-Component派生性" class="headerlink" title="5:多层次@Component派生性"></a>5:多层次@Component<code>派生性</code></h4><p>(1):具体发展过程不再细说,详解请看<code>SpringBoot编程思想这本书</code>。其多层次@Component注解派生性构建在<code>Spring4.x</code>。其核心处理类为<code>AnnotationMetadataReadingVisitor</code>,<code>其采用递归的方式查找元注解</code>。</p><p>(2):Spring中,MetadataReader接口唯一实现非公开类<code>SimpleMetadataReader</code>。可以通过<br><code>SimpleMetadataReaderFactory(ASM字节码操作)</code>和<code>CachingMetadataReaderFactory</code>获取。</p><p>其中在SimpleMetadataReader实现上看,<code>ClassMetadataReadingVisitor</code>和<code>AnnotationMetadataReadingVisitor</code>分别是<code>ClassMetadatta</code>和<code>AnnotationMetadata</code>实现类。</p><p>由于<code>ClassPathBeanDefinitionScanner</code>在寻找候选的BeanDefinition过程中,将指定basePackage参数下</p><p>的*.class资源进行元信息解析,也就是<code>ClassMetadata</code>和<code>AnnotationMetadata</code>对象。</p><p><code>AnnotationMetadataReadingVisitor</code>实现上使用了<code>AnnotationAttributesReadingVisitor</code>，该类主要实现方法是<code>visitEnd()</code>。<em>Spring2.5实现未采用层次递归获取Annotation[],所以仅支持单层次的@Component派生。Spring3.x实现仅两层@Component派生。Spring4.x开始采用递归方式查找元注解。</em></p><p>(3):<strong><code>思考扩展</code></strong></p><ul><li><code>考虑使用ASM的方式读取类或者注解相关信息。(不需要全部将指定路径下的类加载)</code><ul><li>MetadataReaderFactory:获取MetadataReader工厂<ul><li>SimpleMetadataReaderFactory:简单获取MetadataReader工厂实现<ul><li>ClassReader:基于ASM读取类相关信息,公开类,不建议单独使用。</li><li>AnnotationMetadataReadingVisitor:基于ASM读取注解元数据相关信息,不建议单独使用。</li><li>MethodMetadataReadingVisitor:基于ASM读取方法相关信息,不建议单独使用。</li></ul></li><li>CachingMetadataReaderFactory:继承SimpleMetadataReaderFactory,增加缓存MetadataReader资源功能。</li></ul></li><li>MetadataReader:获取访问类和注解相关信息。通过MetadataReaderFactory获取。<ul><li>Resource getResource():获取类文件资源引用</li><li>ClassMetadata getClassMetadata():读取基础类的基本元数据</li><li>AnnotationMetadata getAnnotationMetadata():读取底层类完整注解元数据,包含注解方法的注解元数据。</li></ul></li></ul></li><li><code>考虑使用反射的方式读取类或者注解相关信息(比较费时而且该类必须被ClassLoader加载)</code><ul><li>StandardClassMetadata:基于反射读取类元数据,可建议单独使用。</li><li>StandardAnnotationMetadata:基于反射读取注解元数据,可建议单独使用</li><li>StandardMethodMetadata:基于反射读取方法元数据,可建议单独使用</li></ul></li><li><code>考虑使用Spring内部支持的有用工具类</code>,都是来自于spring-core包中。<code>多使用spring内建API,学习他们的长处。</code><ul><li>ClassUtils:类工具类</li><li>CollectionUtils:集合工具类</li><li>NumberUtils:Number工具类</li><li>MimeTypeUtils:媒体类型工具类</li><li>IdGenerator:Id生成器</li><li>StringUtils:字符串工具类</li><li>ResourceUtils:资源工具类</li><li>ReflectionUtils:反射工具类</li><li>MethodIntrospector:方法自省工具类(EventListenerMethodProcessor#processBean中有使用)</li><li>PatternMatchUtils:正则资源匹配工具类</li><li>ObjectUtils:对象工具类</li></ul></li></ul><h5 id="3-组合注解"><a href="#3-组合注解" class="headerlink" title="3:组合注解"></a>3:组合注解</h5><p><code>组合注解</code>指某个注解”元标注”一个或多个其他注解，其目的在于将这些关联的注解行为组合成单个自定义注解。</p><p>Spring Framework的类加载通过ASM实现，如<code>ClassReader</code>。相对于ClassLoader体系，Spring ASM更为底层，读取的是<code>类资源</code>，直接操作其中的字节码，获取相关元信息。如<code>MetadataReader接口</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Simple facade for accessing class metadata,</span></span><br><span class="line"><span class="comment"> * as read by an ASM &#123;<span class="doctag">@link</span> org.springframework.asm.ClassReader&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MetadataReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the resource reference for the class file.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Resource <span class="title">getResource</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Read basic class metadata for the underlying class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ClassMetadata <span class="title">getClassMetadata</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Read full annotation metadata for the underlying class,</span></span><br><span class="line"><span class="comment"> * including metadata for annotated methods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">AnnotationMetadata <span class="title">getAnnotationMetadata</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AnnotationMetadataReadingVisitor</code>同时实现了ClassMetadata及AnnotationMetadata。因此，元注解的实现集中到<code>AnnotationMetadataReadingVisitor</code>和<code>AnnotationAttributesReadingVisitor</code>之中。</p><p><code>MetadataReader</code>对象通过<code>MetadataReaderFactory</code>对象获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Factory interface for &#123;<span class="doctag">@link</span> MetadataReader&#125; instances.</span></span><br><span class="line"><span class="comment"> * Allows for caching a MetadataReader per original resource.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> SimpleMetadataReaderFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> CachingMetadataReaderFactory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MetadataReaderFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Obtain a MetadataReader for the given class name.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> className the class name (to be resolved to a ".class" file)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a holder for the ClassReader instance (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException in case of I/O failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">MetadataReader <span class="title">getMetadataReader</span><span class="params">(String className)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Obtain a MetadataReader for the given resource.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resource the resource (pointing to a ".class" file)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a holder for the ClassReader instance (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException in case of I/O failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">MetadataReader <span class="title">getMetadataReader</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体某个注解的<code>元注解</code>信息则通过<code>getMetaAnnotationTypes(String)</code>方法查询。</p><p><code>AnnotationMetadata</code>实现<code>AnnotationMetadataReadingVisitor(ASM实现)</code>，<code>StandardAnnotationMetadata(反射)</code>。</p><ul><li>注解元信息抽象:<code>AnnotationMetadata</code><ul><li><code>AnnotationMetadataReadingVisitor</code><ul><li><code>AnnotationAttributesReadingVisitor</code>(递归查找元注解)</li></ul></li></ul></li><li>类元信息抽象:<code>ClassMetadata</code></li><li>方法元信息抽象:<code>MethodMetadata</code></li><li>注解属性抽象:<code>AnnotationAttributes</code></li><li>属性环境抽象:<code>Environment</code></li><li>属性文件抽象:<code>PropertySource</code></li><li>元信息读取抽象:<code>MetadataReader</code><ul><li>通过<code>MetadataReaderFactory</code>获取</li></ul></li></ul><p>方法内省:<code>MethodIntrospector</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Method, EventListener&gt; annotatedMethods = <span class="keyword">null</span>;</span><br><span class="line">   annotatedMethods = MethodIntrospector.selectMethods(targetType,</span><br><span class="line">(MethodIntrospector.MetadataLookup&lt;EventListener&gt;) method -&gt;</span><br><span class="line">AnnotatedElementUtils.findMergedAnnotation(method, EventListener.class));</span><br></pre></td></tr></table></figure><p>注解工具类:<code>AnnotationUtils</code></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring注解属性抽象AnnotationAttributes </tag>
            
            <tag> 模式注解 </tag>
            
            <tag> Component注解派生性原理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

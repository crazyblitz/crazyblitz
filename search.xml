<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用Stream收集数据</title>
      <link href="/2019/08/16/%E4%BD%BF%E7%94%A8Stream%E6%94%B6%E9%9B%86%E6%95%B0%E6%8D%AE/"/>
      <url>/2019/08/16/%E4%BD%BF%E7%94%A8Stream%E6%94%B6%E9%9B%86%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="使用流收集数据"><a href="#使用流收集数据" class="headerlink" title="使用流收集数据"></a>使用流收集数据</h2><p>  终端操作<code>collect</code>方法用于收集流中的元素，并放到不同类型的结果中，比如<code>List</code>、<code>Set</code>或者<code>Map</code>。其实<code>collect</code>方法可以接受各种Collectors接口的静态方法作为参数来实现更为强大的规约操作，比如查找最大值最小值，汇总，分区和分组等等。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>为了演示Collectors接口中的静态方法使用，这里创建一个Dish类（菜谱类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dish</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Type &#123;MEAT, FISH, OTHER&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 食物名称 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="comment">/** 是否是素食 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> vegetarian;</span><br><span class="line">    <span class="comment">/** 卡路里 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories;</span><br><span class="line">    <span class="comment">/** 类型：肉，海鲜，其他 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Type type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dish</span><span class="params">(String name, <span class="keyword">boolean</span> vegetarian, <span class="keyword">int</span> calories, Type type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.vegetarian = vegetarian;</span><br><span class="line">        <span class="keyword">this</span>.calories = calories;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get,set略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建一个List，包含各种食材：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Dish&gt; list = Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> Dish(<span class="string">"pork"</span>, <span class="keyword">false</span>, <span class="number">800</span>, Dish.Type.MEAT),</span><br><span class="line">        <span class="keyword">new</span> Dish(<span class="string">"beef"</span>, <span class="keyword">false</span>, <span class="number">700</span>, Dish.Type.MEAT),</span><br><span class="line">        <span class="keyword">new</span> Dish(<span class="string">"chicken"</span>, <span class="keyword">false</span>, <span class="number">400</span>, Dish.Type.MEAT),</span><br><span class="line">        <span class="keyword">new</span> Dish(<span class="string">"french fries"</span>, <span class="keyword">true</span>, <span class="number">530</span>, Dish.Type.OTHER),</span><br><span class="line">        <span class="keyword">new</span> Dish(<span class="string">"rice"</span>, <span class="keyword">true</span>, <span class="number">350</span>, Dish.Type.OTHER),</span><br><span class="line">        <span class="keyword">new</span> Dish(<span class="string">"season fruit"</span>, <span class="keyword">true</span>, <span class="number">120</span>, Dish.Type.OTHER),</span><br><span class="line">        <span class="keyword">new</span> Dish(<span class="string">"pizza"</span>, <span class="keyword">true</span>, <span class="number">550</span>, Dish.Type.OTHER),</span><br><span class="line">        <span class="keyword">new</span> Dish(<span class="string">"prawns"</span>, <span class="keyword">false</span>, <span class="number">300</span>, Dish.Type.FISH),</span><br><span class="line">        <span class="keyword">new</span> Dish(<span class="string">"salmon"</span>, <span class="keyword">false</span>, <span class="number">450</span>, Dish.Type.FISH) );</span><br></pre></td></tr></table></figure><p>在测试类中导入所有Collectors接口的静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.*;</span><br></pre></td></tr></table></figure><h3 id="规约与汇总"><a href="#规约与汇总" class="headerlink" title="规约与汇总"></a>规约与汇总</h3><h4 id="最大最小值"><a href="#最大最小值" class="headerlink" title="最大最小值"></a>最大最小值</h4><p><code>Collectors.maxBy</code>和<code>Collectors.minBy</code>用来计算流中的最大或最小值，比如按卡路里的大小来筛选出卡路里最高的食材：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().collect(maxBy(Comparator.comparingInt(Dish::getCalories)))    .ifPresent(System.out::println);</span><br></pre></td></tr></table></figure><p>输出<code>pork</code>。</p><h4 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h4><p><code>Collectors.summingInt</code>可以用于求和，参数类型为int类型。相应的基本类型对应的方法还有<code>Collectors.summingLong</code>和<code>Collectors.summingDouble</code>。比如求所有食材的卡路里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lambda </tag>
            
            <tag> Java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda表达式篇二</title>
      <link href="/2019/08/16/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AF%87%E4%BA%8C/"/>
      <url>/2019/08/16/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AF%87%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="Lambda表达式篇二"><a href="#Lambda表达式篇二" class="headerlink" title="Lambda表达式篇二"></a>Lambda表达式篇二</h2><p>   Java 8已经给我们提供了一套能够描述常见函数描述符的函数式接口。比如<code>Predicate&lt;T&gt;</code>、<code>Consumer&lt;T&gt;</code>、<code>Function&lt;T,R&gt;</code>、<code>Supplier&lt;T&gt;</code>等，这些函数式接口位于<code>java.util.function</code>包。这一节主要记录这些函数式接口的应用。</p><h3 id="Java8中的函数式接口"><a href="#Java8中的函数式接口" class="headerlink" title="Java8中的函数式接口"></a>Java8中的函数式接口</h3><p>下表列出了Java8中常见的函数式接口：</p><table><thead><tr><th align="left">函数式接口</th><th align="left">函数描述符</th><th align="left">原始类型特化</th></tr></thead><tbody><tr><td align="left">Predicate(过滤)</td><td align="left">T-&gt;boolean</td><td align="left">IntPredicate,LongPredicate, DoublePredicate</td></tr><tr><td align="left">Consumer(消费者)</td><td align="left">T-&gt;void</td><td align="left">IntConsumer,LongConsumer, DoubleConsumer</td></tr><tr><td align="left">Function&lt;T,R&gt;</td><td align="left">T-&gt;R</td><td align="left">IntFunction, IntToDoubleFunction, IntToLongFunction, LongFunction, LongToDoubleFunction, LongToIntFunction, DoubleFunction, ToIntFunction, ToDoubleFunction, ToLongFunction</td></tr><tr><td align="left">Supplier(生产者)</td><td align="left">()-&gt;T</td><td align="left">BooleanSupplier,IntSupplier, LongSupplier, DoubleSupplier</td></tr><tr><td align="left">UnaryOperator</td><td align="left">T-&gt;T</td><td align="left">IntUnaryOperator, LongUnaryOperator, DoubleUnaryOperator</td></tr><tr><td align="left">BinaryOperator</td><td align="left">(T,T)-&gt;T</td><td align="left">IntBinaryOperator, LongBinaryOperator, DoubleBinaryOperator</td></tr><tr><td align="left">BiPredicate&lt;L,R&gt;</td><td align="left">(L,R)-&gt;boolean</td><td align="left"></td></tr><tr><td align="left">BiConsumer&lt;T,U&gt;</td><td align="left">(T,U)-&gt;void</td><td align="left">ObjIntConsumer, ObjLongConsumer, ObjDoubleConsumer</td></tr><tr><td align="left">BiFunction&lt;T,U,R&gt;</td><td align="left">(T,U)-&gt;R</td><td align="left">ToIntBiFunction&lt;T,U&gt;, ToLongBiFunction&lt;T,U&gt;, ToDoubleBiFunction&lt;T,U&gt;</td></tr></tbody></table><h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><p>predicate:断言。从接口的名称就可以推断出这个函数式接口的主要作用就是用于判断作用，Predicate源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">negate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">or</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">isEqual</span><span class="params">(Object targetRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">null</span> == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可看到<code>java.util.function.Predicate&lt;T&gt;</code>接口定义了一个名叫<code>test</code>的抽象方法，它接受泛型<code>T</code>对象，并返回一个<code>boolean</code>，函数描述符为<code>(T) -&gt; boolean</code>举几个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 偶数判断</span></span><br><span class="line">Predicate&lt;Integer&gt; isEven = (in) -&gt; in % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">isEven.test(<span class="number">17</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字符串的长度是否为0</span></span><br><span class="line">Predicate&lt;String&gt; isEmptyString = String::isEmpty;</span><br><span class="line">isEmptyString.test(<span class="string">""</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>除了抽象方法外，<code>java.util.function.Predicate&lt;T&gt;</code>接口还定义了三个默认方法：<code>and</code>，<code>negate</code>和<code>or</code>，对应“与”，“非”和“或”操作，这样我们便可以复合Lambda表达式了，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是偶数，并且大于30</span></span><br><span class="line">Predicate&lt;Integer&gt; isEven = (in) -&gt; in % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">isEven.and((in) -&gt; in &gt; <span class="number">30</span>).test(<span class="number">40</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 奇数判断</span></span><br><span class="line">Predicate&lt;Integer&gt; isEven = (in) -&gt; in % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">Predicate&lt;Integer&gt; isOdd = isEven.negate();</span><br><span class="line">isOdd.test(<span class="number">17</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>消费者。该函数式接口用于消费一个对象，即接收一个对象，对其执行某些操作，然后没有返回值。Consumer源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可看到<code>java.util.function.Consumer&lt;T&gt;</code>定义了一个名叫<code>accept</code>的抽象方法，它接受泛型<code>T</code>的对象，没有返回(<code>void</code>)，函数描述符为<code>(T) -&gt; void</code>。其还提供了一个默认方法<code>andThen</code>。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;Apple&gt; printAppleColor = (a)-&gt; System.out.println(a.getColor());</span><br><span class="line">printAppleColor.accept(<span class="keyword">new</span> Apple(<span class="string">"red"</span>,<span class="number">17</span>)); <span class="comment">// red</span></span><br><span class="line"></span><br><span class="line">printAppleColor.andThen((a) -&gt; System.out.println(a.getWeight())).accept(<span class="keyword">new</span> Apple(<span class="string">"red"</span>, <span class="number">17</span>)); <span class="comment">// red 17.0</span></span><br></pre></td></tr></table></figure><h3 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h3><p>供应商;供应者;供给者。其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可看到<code>java.util.function.Supplier&lt;T&gt;</code>定义了一个名叫<code>get</code>的抽象方法，它不接收参数，返回泛型<code>T</code>的对象，函数描述符为<code>() -&gt; T</code>。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Person&gt; personSupplier = Person::<span class="keyword">new</span>;</span><br><span class="line">personSupplier.get();   <span class="comment">// new Person</span></span><br></pre></td></tr></table></figure><h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><p>Functions源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;V, R&gt; <span class="title">compose</span><span class="params">(Function&lt;? <span class="keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Function&lt;T, T&gt; <span class="title">identity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>java.util.function.Function&lt;T, R&gt;</code>接口定义了一个叫作<code>apply</code>的方法，它接受一个泛型<code>T</code>的对象，并返回一个泛型<code>R</code>的对象，函数描述符为<code>(T) -&gt; R</code>。举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Apple, Double&gt; getAppleWeight = (a) -&gt; &#123;    return a.getWeight();&#125;;getAppleWeight.apply(new Apple(17)); // 17.0</span><br></pre></td></tr></table></figure><p>Functions接口还提供了两个抽象方法<code>compose</code>和<code>andThen</code>，从源码可以看出两者的根本区别。举个<code>compose</code>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Apple, Double&gt; getAppleWeight = (a) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> a.getWeight();</span><br><span class="line">&#125;;</span><br><span class="line">getAppleWeight.apply(<span class="keyword">new</span> Apple(<span class="number">17</span>)); <span class="comment">// 17.0</span></span><br></pre></td></tr></table></figure><p>过程为：<code>f(g(2))</code>，也就是<code>1+(2*2)</code>。</p><p>举个andThen的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; f = (x) -&gt; x + <span class="number">1</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; g = (x) -&gt; x * <span class="number">2</span>;</span><br><span class="line">f.compose(g).apply(<span class="number">2</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>过程为：<code>g(f(2))</code>，也就是<code>(2+1)*2</code>。</p><h3 id="原始类型特化"><a href="#原始类型特化" class="headerlink" title="原始类型特化"></a>原始类型特化</h3><p>在学习Function接口的时候，我们定义了<code>f</code>函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; f = (x) -&gt; x + 1;</span><br></pre></td></tr></table></figure><p>x的类型为Integer类型，1为int类型，返回值为Integer类型，整个过程实际上为<code>Integer.valueOf(x.intValue() + 1)</code>。虽然编译器可以自动帮我们完成拆装箱，但这会造成不必要的性能消耗。考虑到了这一点，Java8为我们提供了int类型的Function接口：IntFunction:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntFunction</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以<code>f</code>最好重构为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntFunction&lt;Integer&gt; f = (x) -&gt; x + 1;</span><br></pre></td></tr></table></figure><p>剩余的原始类型特化函数式接口可参考上面的表格。</p><h3 id="Java8中增强的Comparator"><a href="#Java8中增强的Comparator" class="headerlink" title="Java8中增强的Comparator"></a>Java8中增强的Comparator</h3><p>在Java8之前，Comparator接口用于实现简单的比较排序算法。比如有如下List：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Double&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">12.3</span>);</span><br><span class="line">list.add(<span class="number">100.2</span>);</span><br><span class="line">list.add(<span class="number">3.14</span>);</span><br><span class="line">list.add(<span class="number">27.7</span>);</span><br><span class="line">list.add(-<span class="number">9.8</span>);</span><br></pre></td></tr></table></figure><p>使用Comparator接口对其从小到大排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Double&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Double o1, Double o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Comparator接口也是一个函数式接口，函数描述符为<code>(T,T) -&gt; int</code>，Java8中可以使用Lambda改造上面的排序方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, (o1, o2) -&gt; o1.compareTo(o2));</span><br></pre></td></tr></table></figure><p>Java8对List提供了<code>sort</code>方法，可以替代<code>Collections.sort</code>，所以上面的代码可以简化为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.sort((o1, o2) -&gt; o1.compareTo(o2));</span><br></pre></td></tr></table></figure><p>使用方法的引用来进一步简化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.sort(Double::compareTo);</span><br></pre></td></tr></table></figure><p>Java8对Comparator进行了增强，加入了一些实用的默认方法，比如对排序结果反转：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Double&gt; comparator = Double::compareTo;</span><br><span class="line">list.sort(comparator.reversed());</span><br></pre></td></tr></table></figure><p>更多方法可以参考Comparator接口的JavaDoc。</p><blockquote><p>查看Comparator的时候发现其虽然是函数式接口，但是却包含了<code>compare</code>和<code>equals</code>这两个抽象方法，顿时有点懵逼，函数式接口不是只能有一个抽象方法么？查找资料后发现：函数式接口中可以额外定义多个抽象方法，但这些抽象方法签名必须和Object的public方法一样，接口最终有确定的类实现，而类的最终父类是Object。因此函数式接口可以定义Object的public方法。</p></blockquote><h3 id="转载-https-mrbird-cc-java8lambda2-html"><a href="#转载-https-mrbird-cc-java8lambda2-html" class="headerlink" title="转载:https://mrbird.cc/java8lambda2.html"></a>转载:<a href="https://mrbird.cc/java8lambda2.html" target="_blank" rel="noopener">https://mrbird.cc/java8lambda2.html</a></h3>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lambda </tag>
            
            <tag> Java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sql Or NoSql 选型方案及比较</title>
      <link href="/2019/08/16/Sql-Or-NoSql-%E9%80%89%E5%9E%8B%E6%96%B9%E6%A1%88%E5%8F%8A%E6%AF%94%E8%BE%83/"/>
      <url>/2019/08/16/Sql-Or-NoSql-%E9%80%89%E5%9E%8B%E6%96%B9%E6%A1%88%E5%8F%8A%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<h2 id="Sql-Or-NoSql"><a href="#Sql-Or-NoSql" class="headerlink" title="Sql Or NoSql"></a>Sql Or NoSql</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>你是否在为系统的数据库来一波大流量就几乎打满CPU，日常CPU居高不下烦恼？你是否在各种NoSql间纠结不定，到底该选用那种最好？今天的你就是昨天的我，这也是写这篇文章的初衷。</p><p>这篇文章是我好几个月来一直想写的一篇文章，也是一直想学习的一个内容，作为互联网从业人员，我们要知道关系型数据库（MySql、Oracle）无法满足我们对存储的所有要求，因此对底层存储的选型，对每种存储引擎的理解非常重要。同时也由于过去一段时间的工作经历，对这块有了一些更多的思考，想通过自己的总结把这块写出来分享给大家。</p><h3 id="结构化数据、非结构化数据与半结构化数据"><a href="#结构化数据、非结构化数据与半结构化数据" class="headerlink" title="结构化数据、非结构化数据与半结构化数据"></a>结构化数据、非结构化数据与半结构化数据</h3><p>   文章的开始，聊一下结构化数据、非结构化数据与半结构化数据，因为数据特点的不同，将在技术上直接影响存储引擎的选型。</p><p>   首先是结构化数据，根据定义<strong><code>结构化数据指的是由二维表结构来逻辑表达和实现的数据，严格遵循数据格式与长度规范，也称作为行数据</code></strong>，特点为：数据以行为单位，一行数据表示一个实体的信息，每一行数据的属性是相同的。例如：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1565679679544-1c94c526-bc37-4779-a6d6-4c37c664f275.png" alt="结构化数据.PNG"></p><p>   因此关系型数据库完美契合结构化数据的特点，关系型数据库也是关系型数据最主要的存储与管理引擎。</p><p>   非结构化数据，指的是<strong><code>数据结构不规则或不完整，没有任何预定义的数据模型，不方便用二维逻辑表来表现的数据</code></strong>，例如办公文档（Word）、文本、图片、HTML、各类报表、视频音频等。</p><p>   介于结构化与非结构化数据之间的数据就是半结构化数据了，它是结构化数据的一种形式，虽然<strong><code>不符合二维逻辑这种数据模型结构，但是包含相关标记，用来分割语义元素以及对记录和字段进行分层</code></strong>。常见的半结构化数据有<code>XML和JSON</code>，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">phone</span>&gt;</span>12345<span class="tag">&lt;/<span class="name">phone</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br></pre></td></tr></table></figure><p>   这种结构也被成为自描述的结构。</p><h2 id="以关系型数据库的方式做存储的架构演进"><a href="#以关系型数据库的方式做存储的架构演进" class="headerlink" title="以关系型数据库的方式做存储的架构演进"></a>以关系型数据库的方式做存储的架构演进</h2><p>   首先，我们看一下使用关系型数据库的方式，企业一个系统发展的几个阶段的架构演进（由于本文写的是Sql与NoSql，因此只以<strong>存储方式作为切入点</strong>，不会涉及类似MQ、ZK这些中间件内容）：</p><p>   <img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1565679960823-53ce36f9-79a9-4db3-b0ba-2d4ecba6a26a.png" alt="关系型数据库演进.PNG"></p><p>  阶段一：企业刚发展的阶段，最简单，<code>一个应用服务器配一个关系型数据库，每次读写数据库</code>。</p><p>  阶段二：无论是使用MySQL还是Oracle还是别的关系型数据库，数据库通常不会先成为性能瓶颈，通常随着企业规模的扩大，一台应用服务器扛不住上游过来的流量且一台应用服务器会产生单点故障的问题，因此<strong><code>加应用服务器并且在流量入口使用Nginx做一层负载均衡</code></strong>，保证把流量均匀打到应用服务器上。</p><p>  阶段三：随着企业规模的继续扩大，此时由于读写都在同一个数据库上，数据库性能出现一定的瓶颈，此时简单地做一层<strong><code>读写分离</code></strong>，每次写主库，读备库，主备库之间通过<code>binlog</code>同步数据，就能很大程度上解决这个阶段的数据库性能问题</p><p>  阶段四：企业发展越来越好了，业务越来越大了，做了读写分离数据库压力还是越来越大，这时候怎么办呢，一台数据库扛不住，那我们就分几台吧，做<strong><code>分库分表</code></strong>，<code>对表做垂直拆分，对库做水平拆分</code>。以扩数据库为例，扩出两台数据库，以一定的单号（例如交易单号），以一定的规则（例如取模），交易单号对2取模为0的丢到数据库1去，交易单号对2取模为1的丢到数据库2去，通过这样的方式将写数据库的流量均分到两台数据库上。一般分库分表会使用<strong>Shard</strong>的方式，通过一个中间件，便于连接管理、数据监控且客户端无需感知数据库ip。</p><h3 id="关系型数据库的优点"><a href="#关系型数据库的优点" class="headerlink" title="关系型数据库的优点"></a>关系型数据库的优点</h3><p>  上面的方式，看似可以解决问题（实际上确实也能解决很多问题），<strong><code>正常对关系型数据库做一下读写分离 + 分库分表，支撑个1W+的读写QPS还是问题不大的</code></strong>。但是受限于关系型数据库本身，这套架构方案依然有着明显的不足，下面对利用关系型数据库方式做存储的方案的优点先进行一下分析，后一部分再分析一下缺点，对某个技术的优缺点的充分理解是技术选型的前提。</p><ul><li><p><strong>易理解</strong></p><p>因为行 + 列的二维表逻辑是非常贴近逻辑世界的一个概念，关系模型相对网状、层次等其他模型更加容易被理解　</p></li><li><p><strong>操作方便</strong></p></li></ul><p>　　通用的SQL语言使得操作关系型数据库非常方便，支持join等复杂查询</p><ul><li><strong>数据一致性</strong></li></ul><p>　　支持ACID特性，可以维护数据之间的一致性，这是使用数据库非常重要的一个理由之一，例如同银行转账，张三转给李四100元钱，张三扣100元，李四加100元，而且必须同时成功或者同时失败，否则就会造成用户的资损</p><ul><li><strong>数据稳定</strong></li></ul><p>　　数据持久化到磁盘，没有丢失数据风险，支持海量数据存储</p><ul><li><strong>服务稳定</strong></li></ul><p>　　最常用的关系型数据库产品MySql、Oracle服务器性能卓越，服务稳定，通常很少出现宕机异常</p><h3 id="关系型数据库的缺点"><a href="#关系型数据库的缺点" class="headerlink" title="关系型数据库的缺点"></a>关系型数据库的缺点</h3><p>紧接着的，我们看一下关系型数据库的缺点，也是比较明显的。</p><ul><li><strong>高并发下IO压力大</strong></li></ul><p>　　数据按行存储，即使只针对其中某一列进行运算，也会将整行数据从存储设备中读入内存，导致IO较高</p><ul><li><strong>为维护索引付出的代价大</strong></li></ul><p>　　为了提供丰富的查询能力，通常热点表都会有多个二级索引，一旦有了二级索引，数据的新增必然伴随着所有二级索引的新增，数据的更新也必然伴随着所有二级索引的更新，这不可避免地降低了关系型数据库的读写能力，且索引越多读写能力越差。有机会的话可以看一下自己公司的数据库，除了数据文件不可避免地占空间外，索引占的空间其实也并不少</p><ul><li><strong>为维护数据一致性付出的代价大</strong></li></ul><p>　　数据一致性是关系型数据库的核心，但是同样为了维护数据一致性的代价也是非常大的。我们都知道SQL标准为事务定义了不同的隔离级别，<code>从低到高依次是读未提交、读已提交、可重复度、串行化，事务隔离级别越低，可能出现的并发异常越多，但是通常而言能提供的并发能力越强</code>。那么为了保证事务一致性，数据库就需要<code>提供并发控制与故障恢复</code>两种技术，前者用于减少并发异常，后者可以在系统异常的时候保证事务与数据库状态不会被破坏。对于并发控制，其核心思想就是加锁，无论是乐观锁还是悲观锁，只要提供的隔离级别越高，那么读写性能必然越差</p><ul><li><strong>水平扩展后带来的种种问题难处理</strong></li></ul><p>​    前文提过，随着企业规模扩大，一种方式是对数据库做分库，做了分库之后，数据迁移（1个库的数据按照一定规则打到2个库中）、跨库join（订单数据里有用户数据，两条数据不在同一个库中）、分布式事务处理都是需要考虑的问题，尤其是分布式事务处理，业界当前都没有特别好的解决方案</p><ul><li><strong>表结构扩展不方便</strong></li></ul><p>　　由于数据库存储的是结构化数据，因此表结构schema是固定的，扩展不方便，如果需要修改表结构，需要执行DDL（data definition language）语句修改，修改期间会导致锁表，部分服务不可用</p><ul><li><strong>全文搜索功能弱</strong></li></ul><p>　　例如like “%中国真伟大%”，只能搜索到”2019年中国真伟大，爱祖国”，无法搜索到”中国真是太伟大了”这样的文本，即不具备分词能力，且like查询在”%中国真伟大”这样的搜索条件下，无法命中索引，将会导致查询效率大大降低。</p><p>   写了这么多，我的理解核心还是前三点，它反映出的一个问题是<strong>关系型数据库在高并发下的能力是有瓶颈的</strong>，尤其是写入/更新频繁的情况下，出现瓶颈的结果就是<code>数据库CPU高、Sql执行慢、客户端报数据库连接池不够等错误</code>，因此例如万人秒杀这种场景，我们绝对不可能通过数据库直接去扣减库存。</p><p>  可能有朋友说，数据库在高并发下的能力有瓶颈，我公司有钱，加CPU、换固态硬盘、继续买服务器加数据库做分库不就好了，问题是这是一种性价比非常低的方式，花1000万达到的效果，换其他方式可能100万就达到了，<strong>不考虑人员、服务器投入产出比的Leader就是个不合格的Leader，且关系型数据库的方式，受限于它本身的特点，可能花了钱都未必能达到想要的效果</strong>。至于什么是花100万就能达到花1000万效果的方式呢？可以继续往下看，这就是我们要说的NoSql。</p><h3 id="结合NoSql的方式做存储的架构演进"><a href="#结合NoSql的方式做存储的架构演进" class="headerlink" title="结合NoSql的方式做存储的架构演进"></a>结合NoSql的方式做存储的架构演进</h3><p>   像上文分析的，数据库作为一种关系型数据的存储引擎，存储的是关系型数据，它有优点，同时也有明显的缺点，因此通常在企业规模不断扩大的情况下，不会一味指望通过增强数据库的能力来解决数据存储问题，而是会引入其他存储，也就是我们说的NoSql。</p><p>   NoSql的全称为Not Only SQL，泛指非关系型数据库，是对关系型数据库的一种<strong>补充</strong>，特别注意补充这两个字，<strong>这意味着NoSql与关系型数据库并不是对立关系，二者各有优劣，取长补短，在合适的场景下选择合适的存储引擎才是正确的做法。</strong></p><p>   比较简单的NoSql就是缓存：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1565681417354-91a60881-f34e-44cc-8136-f47735a3458c.png" alt="NoSQL缓存.PNG"></p><p>   针对那些读远多于写的数据，引入一层缓存，每次读从缓存中读取，缓存中读取不到，再去数据库中取，取完之后再写入到缓存，对数据做好失效机制通常就没有大问题了。<strong><code>通常来说，缓存是性能优化的第一选择也是见效最明显的方案。</code></strong></p><p>   但是，<strong><code>缓存通常都是KV型存储且容量有限（基于内存）</code></strong>，无法解决所有问题，于是再进一步的优化，我们继续引入其他NoSql：</p><p>  <img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1565681610068-07501fe4-00a4-4aac-8a38-5fc0136b24a9.png" alt="其他NoSQL.PNG"></p><p>   数据库、缓存与其他NoSql并行工作，充分发挥每种NoSql的特点。当然NoSql在性能方面大大优于关系挺数据库的同时，往往也伴随着一些特性的缺失，比较常见的就是事务功能的缺失。 </p><p>   下面看一下常用的NoSql及他们的代表产品，并对每种NoSql的优缺点和适用场景做一下分析，便于熟悉每种NoSql的特点，方便技术选型。</p><h3 id="KV型NoSql（代表—-Redis）"><a href="#KV型NoSql（代表—-Redis）" class="headerlink" title="KV型NoSql（代表—-Redis）"></a>KV型NoSql（代表—-Redis）</h3><p>   KV型NoSql顾名思义就是以键值对形式存储的非关系型数据库，是最简单、最容易理解也是大家最熟悉的一种NoSql，因此比较快地带过。Redis、MemCache是其中的代表，Redis又是KV型NoSql中应用最广泛的NoSql，KV型数据库以Redis为例，<strong><code>最大的优点我总结下来就两点：</code></strong></p><ul><li><p>数据基于内存，读写效率高</p></li><li><p>K/V型数据，时间复杂度为O(1)，查询速度快</p><p>因此，KV型NoSql最大的优点就是<strong><code>高性能</code></strong>，利用Redis自带的BenchMark做基准测试，TPS可达到10万的级别，性能非常强劲。同样的Redis也有所有KV型NoSql都有的比较明显的缺点：</p></li><li><p>只能根据K查V，无法根据V查K</p></li><li><p>查询方式单一，只有KV的方式，不支持条件查询，多条件查询唯一的做法就是数据冗余，但这会极大的浪费存储空间。</p></li><li><p>内存是有限的，无法支持海量数据存储</p></li><li><p>同样的，由于KV型NoSql的存储是基于内存的，会有丢失数据的风险</p></li></ul><p>综上所述，KV型NoSql最合适的场景就是<strong>缓存</strong>的场景：</p><ul><li><p>读远多于写</p></li><li><p>读取能力强</p></li><li><p>没有持久化的需求，可以容忍数据丢失，反正丢了再查询一把写入就是了</p><p>例如根据用户id查询用户信息，每次根据用户id去缓存中查询一把，查到数据直接返回，查不到去关系型数据库里面根据id查询一把数据写到缓存中去。</p></li></ul><h3 id="搜索型NoSql（代表—-ElasticSearch）"><a href="#搜索型NoSql（代表—-ElasticSearch）" class="headerlink" title="搜索型NoSql（代表—-ElasticSearch）"></a>搜索型NoSql（代表—-ElasticSearch）</h3><p>  传统关系型数据库主要通过索引来达到快速查询的目的，但是在全文搜索的场景下，索引是无能为力的，like查询一来无法满足所有模糊匹配需求，二来使用限制太大且使用不当容易造成慢查询，<strong><code>搜索型NoSql的诞生正是为了解决关系型数据库全文搜索能力较弱的问题</code></strong>，ElasticSearch是搜索型NoSql的代表产品。</p><p>  全文搜索的原理是<strong><code>倒排索引</code></strong>，我们看一下什么是倒排索引。要说倒排索引我们先看下什么是正排索引，传统的正排索引是<strong>文档–&gt;关键字</strong>的映射，例如”Tom is my friend”这句话，会将其切分为”Tom”、”is”、”my”、”friend”四个单词，在搜索的时候对文档进行扫描，符合条件的查出来。这种方式原理非常简单，但是由于其检索效率太低，基本没什么实用价值。</p><p>倒排索引则完全相反，它是<strong>关键字–&gt;文档</strong>的映射，我用张表格展示一下就比较清楚了：</p><p>  <img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1565682157714-30a0d3db-0636-4e19-9f2d-8dc0f12c5fa8.png" alt="倒排索引.PNG"></p><p>  意思是我现在这里有”Tom is Tom”、”Tom is my friend”、”Thank you, Betty”、”Tom is Betty’s husband”四句话，搜索引擎会根据一定的切分规则将这句话切成N个关键字，并以关键字的维度维护关键字在每个文本中的出现次数。这样下次搜索”Tom”的时候，由于Tom这个词语在”Tom is Tom”、”Tom is my friend”、”Tom is Betty’s husband”三句话中都有出现，因此这三条记录都会被检索出来，且由于”Tom is Tom”这句话中”Tom”出现了2次，因此这条记录对”Tom”这个单词的匹配度最高，最先展示。这就是搜索引擎倒排索引的基本原理，假设某个关键字在某个文档中出现，那么倒排索引中有两部分内容：</p><ul><li><p>文档ID</p></li><li><p>在该文档中出现的位置情况</p><p> 可以举一反三，我们搜索”Betty Tom”这两个词语也是一样，搜索引擎将”Betty Tom”切分为”Tom”、”Betty”两个单词，根据开发者指定的满足率，比如满足率=50%，那么只要记录中出现了两个单词之一的记录都会被检索出来，再按照匹配度进行展示。</p><p> <strong>搜索型NoSql以ElasticSearch为例，它的优点为：</strong></p></li><li><p>支持分词场景、全文搜索，这是区别于关系型数据库最大特点</p></li><li><p>支持条件查询，支持聚合操作，类似关系型数据库的Group By，但是功能更加强大，适合做数据分析</p></li><li><p>数据写文件无丢失风险，在集群环境下可以方便横向扩展，可承载PB级别的数据</p></li><li><p>高可用，自动发现新的或者失败的节点，重组和重新平衡数据，确保数据是安全和可访问的。</p></li></ul><p>同样，ElasticSearch也有比较明显的缺点：</p><ul><li><p>性能全靠内存来顶，也是使用的时候最需要注意的点，非常吃硬件资源、吃内存，大数据量下64G + SSD基本是标配，算得上是数据库中的爱马仕了。为什么要专门提一下内存呢，因为内存这个东西是很值钱的，相同的配置多一倍内存，一个月差不多就要多花几百块钱，至于ElasticSearch内存用在什么地方，大概有如下这些：</p></li><li><ul><li>Indexing Buffer—-ElasticSearch基于Luence，Lucene的倒排索引是先在内存里生成，然后定期以Segment File的方式刷磁盘的，每个Segment File实际就是一个完整的倒排索引</li><li>Segment Memory—-倒排索引前面说过是基于关键字的，Lucene在4.0后会将所有关键字以FST这种数据结构的方式将所有关键字在启动的时候全量加载到内存，加快查询速度，官方建议至少留系统一半内存给Lucene</li><li>各类缓存—-Filter Cache、Field Cache、Indexing Cache等，用于提升查询分析性能，例如Filter Cache用于缓存使用过的Filter的结果集</li><li>Cluter State Buffer—-ElasticSearch被设计为每个Node都可以响应用户请求，因此每个Node的内存中都包含有一份集群状态的拷贝，一个规模很大的集群这个状态信息可能会非常大</li></ul></li><li><p>读写之间有延迟，写入的数据差不多1s样子会被读取到，这也正常，写入的时候自动加入这么多索引肯定影响性能</p></li><li><p>数据结构灵活性不高，ElasticSearch这个东西，字段一旦建立就没法修改类型了，假如建立的数据表某个字段没有加全文索引，想加上，那么只能把整个表删了再重建</p><p>因此，搜索型NoSql最适用的场景就是<strong>有条件搜索尤其是全文搜索的场景</strong>，作为关系型数据库的一种替代方案。</p></li></ul><p>另外，搜索型数据库还有一种特别重要的应用场景。我们可以想，一旦对数据库做了分库分表后，原来可以在单表中做的聚合操作、统计操作是否通通失效？例如我把订单表分16个库，1024张表，那么订单数据就散落在1024张表中，我想要统计昨天浙江省单笔成交金额最高的订单是哪笔如何做？我想要把昨天的所有订单按照时间排序分页展示如何做？<strong>这就是文档型NoSql的另一大作用了，我们可以把分表之后的数据统一打在文档型NoSql中，利用文档型NoSql的搜索与聚合能力完成对全量数据的查询</strong>。</p><p>至于为什么把它放在KV型NoSql后面作为第二个写呢，因为通常搜索型NoSql也会作为一层前置缓存，来对关系型数据库进行保护。</p><h3 id="列式NoSql（代表—-HBase）"><a href="#列式NoSql（代表—-HBase）" class="headerlink" title="列式NoSql（代表—-HBase）"></a>列式NoSql（代表—-HBase）</h3><p>  列式NoSql，大数据时代最具代表性的技术之一了，以HBase为代表。</p><p>  列式NoSql是基于列式存储的，那么什么是列式存储呢，列式Sql和关系型数据库一样都有主键的概念，区别在于关系型数据库是按照行组织的数据：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1565685245588-c1b4c438-9c3a-4bf4-9268-1526ccb51408.png" alt="关系型数据库样例.PNG"></p><p>  看到每行有name、phone、address三个字段，这是行式存储的方式，且可以观察id = 2的这条数据，<strong>即使phone字段没有，它也是占空间的。数据库会根据创建表的字段类型预分配空间。</strong></p><p>  列式存储完全是另一种方式，它是按每一列进行组织的数据：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1565690989795-ef912061-e290-4c31-8ca1-ed6608a8ee6a.png" alt="列式存储.PNG"></p><p>这么做有什么好处呢？大致有以下几点：</p><ul><li>查询时只有指定的列会被读取，不会读取所有列</li><li>存储上节约空间，Null值不会被存储，一列中有时候会有很多重复数据（尤其是枚举数据，性别、状态等），这类数据可压缩，<strong>行式数据库压缩率通常在3:1<del>5:1之间，列式数据库的压缩率一般在8:1</del>30:1左右。</strong></li><li>列数据被组织到一起，一次磁盘IO可以将一列数据一次性读取到内存中</li></ul><p>第二点说到了数据压缩，什么意思呢，以比较常见的字典表压缩方式举例：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1565691934205-a4c06727-f06b-4e58-a23c-08210386b554.png" alt="字典表压缩方式.PNG"></p><p>  接着继续讲讲优缺点，列式NoSql，以HBase为代表的，优点为：</p><ul><li>海量数据无限存储，PB级别数据随便存，底层基于HDFS（Hadoop文件系统），数据持久化</li><li>读写性能好，只要没有滥用造成数据热点，读写基本随便玩</li><li>横向扩展在关系型数据库及非关系型数据库中都是最方便的之一，只需要添加新机器就可以实现数据容量的线性增长，且可用在廉价服务器上，节省成本</li><li>本身没有单点故障，可用性高</li><li>可存储结构化或者半结构化的数据</li><li>列数理论上无限，HBase本身只对列族数量有要求，建议1~3个</li></ul><p>说了这么多HBase的优点，又到了说HBase缺点的时候了：</p><ul><li>HBase是Hadoop生态的一部分，因此它本身是一款比较重的产品，依赖很多Hadoop组件，数据规模不大没必要用，运维还是有点复杂的</li><li>KV式，不支持条件查询，或者说条件查询非常非常弱吧，HBase在Scan扫描一批数据的情况下还是提供了前缀匹配这种API的，条件查询除非定义多个RowKey做数据冗余</li><li>不支持分页查询，因为统计不了数据总数</li></ul><p>因此<strong>HBase比较适用于那种KV型的且未来无法预估数据增长量的场景</strong>，另外HBase使用还是需要一定的经验，主要体现在RowKey的设计上。</p><h3 id="文档型NoSql（代表—-MongoDB）"><a href="#文档型NoSql（代表—-MongoDB）" class="headerlink" title="文档型NoSql（代表—-MongoDB）"></a>文档型NoSql（代表—-MongoDB）</h3><p>坦白讲，根据我的工作经历，文档型NoSql我只有比较浅的使用经验，因此这部分只能结合之前的使用与网上的文章大致给大家介绍一下。</p><p>什么是文档型NoSql呢，文档型NoSql指的是将半结构化数据存储为文档的一种NoSql，文档型NoSql通常以JSON或者XML格式存储数据，因此文档型NoSql是没有Schema的，由于没有Schema的特性，我们可以随意地存储与读取数据，因此文档型NoSql的出现是<strong>解决关系型数据库表结构扩展不方便的问题的</strong>。</p><p>MongoDB是文档型NoSql的代表产品，同时也是所有NoSql产品中的明星产品之一，因此这里以MongoDB为例。按我的理解，作为文档型NoSql，MongoDB是一款完全和关系型数据库对标的产品，就我们从存储上来看：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1565752949259-06d9bce3-b485-46a8-b85f-2a276f3675b3.png" alt="文档型数据库.PNG"></p><p>看到，关系型数据库是按部就班地每个字段一列存，在MongDB里面就是一个JSON字符串存储。关系型数据可以为name、phone建立索引，MongoDB使用createIndex命令一样可以为列建立索引，建立索引之后可以大大提升查询效率。其他方面而言，就大的基本概念，二者之间基本也是类似的：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1565753085583-0b65879b-936c-44e3-bf51-9a67f95b135e.png" alt="关系型数据库和文档数据库对比.PNG"></p><p>因此，对于MongDB，我们只要理解成一个Free-Schema的关系型数据库就完事了，它的优缺点比较一目了然，优点：</p><ul><li>没有预定义的字段，扩展字段容易</li><li>相较于关系型数据库，读写性能优越，命中二级索引的查询不会比关系型数据库慢，对于非索引字段的查询则是全面胜出</li></ul><p>缺点在于：</p><ul><li>不支持事务操作，虽然Mongodb4.0之后宣称支持事务，但是效果待观测</li><li>多表之间的关联查询不支持（虽然有嵌入文档的方式），join查询还是需要多次操作</li><li>空间占用较大，这个是MongDB的设计问题，空间预分配机制 + 删除数据后空间不释放，只有用db.repairDatabase()去修复才能释放</li><li>目前没发现MongoDB有关系型数据库例如MySql的Navicat这种成熟的运维工具</li></ul><p><strong>总而言之，MongDB的使用场景很大程度上可以对标关系型数据库，但是**</strong>比较适合处理那些没有join、没有强一致性要求且表Schema会常变化的数据<strong>**。</strong></p><h3 id="总结：数据库与NoSql及各种NoSql间的对比"><a href="#总结：数据库与NoSql及各种NoSql间的对比" class="headerlink" title="总结：数据库与NoSql及各种NoSql间的对比"></a>总结：数据库与NoSql及各种NoSql间的对比</h3><p>最后一部分，做一个总结，本文归根到底是两个话题：</p><ul><li>何时选用关系型数据库，何时选用非关系型数据库</li><li>选用非关系型数据库，使用哪种非关系型数据库</li></ul><p>首先是第一个话题，关系型数据库与非关系型数据库的选择，在我理解里面无非就是两点考虑：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1565753171973-b1365f3c-8479-4c88-a36e-4313fb73c5ce.png" alt="Sql和各种NoSql比较.PNG"></p><p>第一点，不多解释应该都理解，<strong>非关系型数据库都是通过牺牲了ACID特性来获取更高的性能的</strong>，假设两张表之间有比较强的一致性需求，那么这类数据是不适合放在非关系型数据库中的。</p><p>第二点，<strong>核心数据不走非关系型数据库</strong>，例如用户表、订单表，但是这有一个前提，就是这一类核心数据会有多种查询模式，例如用户表有ABCD四个字段，可能根据AB查，可能根据AC查，可能根据D查，假设核心数据，但是就是个KV形式，比如用户的聊天记录，那么HBase一存就完事了。</p><p><strong>这几年的工作经验来看，非核心数据尤其是日志、流水一类中间数据千万不要写在关系型数据库中，这一类数据通常有两个特点：</strong></p><ul><li><strong>写远高于读</strong></li><li><strong>写入量巨大</strong></li></ul><p>一旦使用关系型数据库作为存储引擎，将大大降低关系型数据库的能力，<strong>正常读写QPS(**</strong>每秒查询率<strong>**)</strong>不高的核心服务会受这一类数据读写的拖累。</p><p>接着是第二个问题，如果我们使用非关系型数据库作为存储引擎，那么如何选型？其实上面的文章基本都写了，这里只是做一个总结（所有的缺点都不会体现事务这个点，因为这是所有NoSql相比关系型数据库共有的一个问题）</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1565753499953-18dbfd9d-ac04-45d9-9b84-bfa5a9072c12.png" alt="Sql和NoSql选型对比总结.PNG"></p><p>但是这里特别说明，<strong>选型一定要结合实际情况而不是照本宣科</strong>，比如：</p><ul><li>企业发展之初，明明一个关系型数据库就能搞定且支撑一年的架构，搞一套大而全的技术方案出来</li><li>有一些数据条件查询多，更适合使用ElasticSearch做存储降低关系型数据库压力，但是公司成本有限，这种情况下这类数据可以尝试继续使用关系型数据库做存储</li><li>有一类数据格式简单，就是个KV类型且增长量大，但是公司没有HBase这方面的人才，运维上可能会有一定难度，出于实际情况考虑，可先用关系型数据库顶一阵子</li></ul><p>所以，如果不考虑实际情况，虽然合适有些存储引擎更加合适，但是强行使用反而适得其反，总而言之，适合自己的才是最好的。</p><h3 id="转载-五月的仓颉-Sql-Or-NoSql"><a href="#转载-五月的仓颉-Sql-Or-NoSql" class="headerlink" title="转载: 五月的仓颉:Sql Or NoSql"></a>转载:<a href="https://mp.weixin.qq.com/s/pjQeyb7dHm0YC2hQVffvFw" target="_blank" rel="noopener"> 五月的仓颉:Sql Or NoSql</a></h3>]]></content>
      
      
      <categories>
          
          <category> 架构方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sql </tag>
            
            <tag> NoSql </tag>
            
            <tag> 架构方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis使用接口访问数据库原理</title>
      <link href="/2019/08/16/Mybatis%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/"/>
      <url>/2019/08/16/Mybatis%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Mybatis使用接口访问数据库原理"><a href="#Mybatis使用接口访问数据库原理" class="headerlink" title="Mybatis使用接口访问数据库原理"></a>Mybatis使用接口访问数据库原理</h2><h3 id="相关类"><a href="#相关类" class="headerlink" title="相关类:"></a>相关类:</h3><ul><li><p><code>MapperProxyFactory</code></p></li><li><p><code>MapperProxy</code></p></li><li><p><code>MapperMethod</code></p><p>最终委托给了SqlSession,通过sqlStatement进行匹配方法,这里的<code>statement等于接口的全类限定名+方法名</code>,也就<code>意味着Mybatis的dao接口</code>,不要出现相同的方法签名。而Mybatis存储访问数据库的一个<strong>MappedStatement(很重要,存储SQL,输入参数,输出参数等等)</strong>是使用<code>StrictMap</code>结构存储,该类继承了HashMap,在内部重写了put()方法,限定了dao接口不能出现相同的方法签名,该类是org.apache.ibatis.session.Configuration的静态内部类。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// MapperMethod的执行查询的主要方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperMethod</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlCommand command;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MethodSignature method;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperMethod</span><span class="params">(Class&lt;?&gt; mapperInterface, Method method, Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.command = <span class="keyword">new</span> SqlCommand(config, mapperInterface, method);</span><br><span class="line">    <span class="keyword">this</span>.method = <span class="keyword">new</span> MethodSignature(config, mapperInterface, method);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">switch</span> (command.getType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> INSERT: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        <span class="comment">// 取出MappedStatement的id,即dao的接口全限定名+方法名</span></span><br><span class="line">        result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> UPDATE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> DELETE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> SELECT:</span><br><span class="line">        <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">          executeWithResultHandler(sqlSession, args);</span><br><span class="line">          result = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">          result = executeForMany(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">          result = executeForMap(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</span><br><span class="line">          result = executeForCursor(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">          result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">          <span class="keyword">if</span> (method.returnsOptional()</span><br><span class="line">              &amp;&amp; (result == <span class="keyword">null</span> || !method.getReturnType().equals(result.getClass()))) &#123;</span><br><span class="line">            result = Optional.ofNullable(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FLUSH:</span><br><span class="line">        result = sqlSession.flushStatements();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Unknown execution method for: "</span> + command.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Mapper method '"</span> + command.getName()</span><br><span class="line">          + <span class="string">" attempted to return null from a method with a primitive return type ("</span> + method.getReturnType() + <span class="string">")."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// MapperProxy,生成Mapper类的代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6424540398559729838L</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSession;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperProxy</span><span class="params">(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sqlSession = sqlSession;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">    <span class="keyword">this</span>.methodCache = methodCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> MapperMethod <span class="title">cachedMapperMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> methodCache.computeIfAbsent(method, k -&gt; <span class="keyword">new</span> MapperMethod(mapperInterface, method, sqlSession.getConfiguration()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MapperProxyFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxyFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperProxyFactory</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getMapperInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;Method, MapperMethod&gt; <span class="title">getMethodCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> methodCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关流程"><a href="#相关流程" class="headerlink" title="相关流程:"></a>相关流程:</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1565684597952-b2fda8f4-1651-438b-b8db-5db8374e7281.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1565684748523-e96b9043-ff1c-4190-b236-1251320462ce.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1565684753852-e49e88bb-5d1d-4833-a26d-83ff51709f34.png" alt="img"></p><h3 id="设计模式使用"><a href="#设计模式使用" class="headerlink" title="设计模式使用"></a>设计模式使用</h3><ul><li><code>代理模式(Jdk代理)</code></li><li><code>命令模式</code></li><li><code>委托模式</code></li></ul><h3 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h3><ul><li><code>你无法通过反射的方式来调用接口的方法。</code></li><li>你需要使用SqlSession来进行一次数据库查询或者更新。利用<strong>MappedStatement的id属性,即接口的全类限定名+方法名。这样可以写出通用的Mybatis程序。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
            <tag> 代理模式 </tag>
            
            <tag> 命令模式 </tag>
            
            <tag> Jdk代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8 Stream学习</title>
      <link href="/2019/08/15/Java8-Stream%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/08/15/Java8-Stream%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="Java8-Stream学习"><a href="#Java8-Stream学习" class="headerlink" title="Java8 Stream学习"></a>Java8 Stream学习</h2><p>   Java 8 中的 Stream 俗称为流，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。Stream 用于<code>对集合对象进行各种非常便利、高效的聚合操作，或者大批量数据操作</code>。Stream API 借助于Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势。通过下面的例子我们可以初步体会到使用 Stream 处理集合的便利性。</p><h3 id="初探Stream"><a href="#初探Stream" class="headerlink" title="初探Stream"></a>初探Stream</h3><p>有如下一个List，现要从中筛选出以<code>J</code>开头的元素，然后转换为大写，最后输出结果。Java 8之前我们是这样做的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"Java"</span>, <span class="string">"JavaScript"</span>, <span class="string">"python"</span>, <span class="string">"PHP"</span>, <span class="string">"C#"</span>, <span class="string">"Golang"</span>, <span class="string">"Swift"</span>);</span><br><span class="line">List&lt;String&gt; filterList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str.startsWith(<span class="string">"J"</span>)) &#123;</span><br><span class="line">        filterList.add(str.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String str : filterList) &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了筛选集合我们进行了两次外部迭代，并且还创建了一个用来临时存放筛选元素的集合对象。借助Java 8中的Stream我们可以极大的简化这个处理过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"Java"</span>, <span class="string">"JavaScript"</span>, <span class="string">"python"</span>, <span class="string">"PHP"</span>, <span class="string">"C#"</span>, <span class="string">"Golang"</span>, <span class="string">"Swift"</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .filter(s -&gt; s.startsWith(<span class="string">"J"</span>))</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p> 上面的例子中，集合使用<code>stream</code>方法创建了一个流，然后使用<code>filter</code>和<code>map</code>方法来处理这个集合，它们统称为<strong>中间操作</strong>。中间操作都会返回另一个流，以便于将各种对集合的操作连接起来形成一条流水线。最后我们使用了<code>forEach</code>方法迭代筛选结果，这种位于流的末端，对流进行处理并且生成结果的方法称为<strong>终端操作</strong>。</p><p>总而言之，流的使用一般包括三件事情：</p><ol><li>一个<strong>数据源</strong>（如集合）来执行一个查询；</li><li>一个<strong>中间操作</strong>链，形成一条流的流水线；</li><li>一个<strong>终端操作</strong>，执行流水线，并能生成结果。</li></ol><p>下表列出了流中常见的中间操作和终端操作：</p><table><thead><tr><th align="left"></th><th align="left"></th><th align="left"></th><th align="left"></th><th align="left"></th></tr></thead><tbody><tr><td align="left">操作</td><td align="left">类型</td><td align="left">返回类型</td><td align="left">使用的类型/函数式接口</td><td align="left">函数描述符</td></tr><tr><td align="left">filter</td><td align="left">中间</td><td align="left"><code>Stream&lt;T&gt;</code></td><td align="left"><code>Predicate&lt;T&gt;</code></td><td align="left"><code>T -&gt; boolean</code></td></tr><tr><td align="left">distinct</td><td align="left">中间</td><td align="left"><code>Stream&lt;T&gt;</code></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">skip</td><td align="left">中间</td><td align="left"><code>Stream&lt;T&gt;</code></td><td align="left"><code>long</code></td><td align="left"></td></tr><tr><td align="left">limit</td><td align="left">中间</td><td align="left"><code>Stream&lt;T&gt;</code></td><td align="left"><code>long</code></td><td align="left"></td></tr><tr><td align="left">map</td><td align="left">中间</td><td align="left"><code>Stream&lt;R&gt;</code></td><td align="left"><code>Function&lt;T, R&gt;</code></td><td align="left"><code>T -&gt; R</code></td></tr><tr><td align="left">flatMap</td><td align="left">中间</td><td align="left"><code>Stream&lt;R&gt;</code></td><td align="left"><code>Function&lt;T, Stream&lt;R&gt;&gt;</code></td><td align="left"><code>T -&gt; Stream&lt;R&gt;</code></td></tr><tr><td align="left">sorted</td><td align="left">中间</td><td align="left"><code>Stream&lt;T&gt;</code></td><td align="left"><code>Comparator&lt;T&gt;</code></td><td align="left"><code>(T, T) -&gt; int</code></td></tr><tr><td align="left">anyMatch</td><td align="left">终端</td><td align="left"><code>boolean</code></td><td align="left"><code>Predicate&lt;T&gt;</code></td><td align="left"><code>T -&gt; boolean</code></td></tr><tr><td align="left">noneMatch</td><td align="left">终端</td><td align="left"><code>boolean</code></td><td align="left"><code>Predicate&lt;T&gt;</code></td><td align="left"><code>T -&gt; boolean</code></td></tr><tr><td align="left">allMatch</td><td align="left">终端</td><td align="left"><code>boolean</code></td><td align="left"><code>Predicate&lt;T&gt;</code></td><td align="left"><code>T -&gt; boolean</code></td></tr><tr><td align="left">findAny</td><td align="left">终端</td><td align="left"><code>Optional&lt;T&gt;</code></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">findFirst</td><td align="left">终端</td><td align="left"><code>Optional&lt;T&gt;</code></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">forEach</td><td align="left">终端</td><td align="left"><code>void</code></td><td align="left"><code>Consumer&lt;T&gt;</code></td><td align="left"><code>T -&gt; void</code></td></tr><tr><td align="left">collect</td><td align="left">终端</td><td align="left"><code>R</code></td><td align="left"><code>Collector&lt;T, A, R&gt;</code></td><td align="left"></td></tr><tr><td align="left">reduce</td><td align="left">终端</td><td align="left"><code>Optional&lt;T&gt;</code></td><td align="left"><code>BinaryOperator&lt;T&gt;</code></td><td align="left"><code>(T, T) -&gt; T</code></td></tr><tr><td align="left">count</td><td align="left">终端</td><td align="left"><code>long</code></td><td align="left"></td><td align="left"></td></tr></tbody></table><p>下面详细介绍这些操作的使用。除了特殊说明，默认使用下面这个集合作为演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"Java"</span>, <span class="string">"JavaScript"</span>, <span class="string">"python"</span>, <span class="string">"PHP"</span>, <span class="string">"C#"</span>, <span class="string">"Golang"</span>, <span class="string">"Swift"</span>, <span class="string">"C++"</span>, <span class="string">"Ruby"</span>);</span><br></pre></td></tr></table></figure><h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>Streams接口支持·<code>filter</code>方法，该方法接收一个<code>Predicate&lt;T&gt;</code>，函数描述符为<code>T -&gt; boolean</code>，用于对集合进行筛选，返回所有满足的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().filter(s -&gt; s.contains(<span class="string">"#"</span>))    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>结果输出<code>C#</code>。</p><h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h4><p><code>distinct</code>方法用于<code>排除流中重复的元素</code>，类似于SQL中的distinct操作。比如筛选中集合中所有的偶数，并排除重复的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">numbers.stream()</span><br><span class="line">       .filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">       .distinct()</span><br><span class="line">       .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>结果输出<code>2 4</code>。</p><h4 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h4><p><code>skip(n)</code>方法用于跳过流中的前n个元素，如果集合元素小于n，则返回空流。比如筛选出以<code>J</code>开头的元素，并排除第一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .filter(s -&gt; s.startsWith(<span class="string">"J"</span>))</span><br><span class="line">    .skip(<span class="number">1</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>结果输出<code>JavaScript</code>。</p><h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p><code>limit(n)</code>方法返回一个长度不超过n的流，比如下面的例子将输出<code>Java JavaScript python</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .limit(<span class="number">3</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p><code>map</code>方法接收一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .map(String::length)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>结果输出<code>4 10 6 3 2 6 5 3 4</code>。</p><p><code>map</code>还支持将流特化为指定原始类型的流，如通过<code>mapToInt</code>，<code>mapToDouble</code>和<code>mapToLong</code>方法，可以将流转换为<code>IntStream</code>，<code>DoubleStream</code>和<code>LongStream</code>。特化后的流支持<code>sum</code>，<code>min</code>和<code>max</code>方法来对流中的元素进行计算。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">IntStream intStream = numbers.stream().mapToInt(a -&gt; a);</span><br><span class="line">System.out.println(intStream.sum()); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure><p>也可以通过下面的方法，将<code>IntStream</code>转换为<code>Stream</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; s = intStream.boxed();</span><br></pre></td></tr></table></figure><h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h4><p><code>flatMap</code>用于将多个流合并成一个流，俗称流的扁平化。这么说有点抽象，举个例子，比如现在需要将list中的各个元素拆分为一个个字母，并过滤掉重复的结果，你可能会这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">   .map(s -&gt; s.split(<span class="string">""</span>))</span><br><span class="line">   .distinct()</span><br><span class="line">   .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Ljava.lang.String;<span class="meta">@e</span>9e54c2</span><br><span class="line">[Ljava.lang.String;@<span class="number">65</span>ab7765</span><br><span class="line">[Ljava.lang.String;@<span class="number">1</span>b28cdfa</span><br><span class="line">[Ljava.lang.String;<span class="meta">@eed</span>1f14</span><br><span class="line">[Ljava.lang.String;@<span class="number">7229724f</span></span><br><span class="line">[Ljava.lang.String;@<span class="number">4</span>c873330</span><br><span class="line">[Ljava.lang.String;@<span class="number">119</span>d7047</span><br><span class="line">[Ljava.lang.String;@<span class="number">776</span>ec8df</span><br><span class="line">[Ljava.lang.String;@<span class="number">4</span>eec7777</span><br></pre></td></tr></table></figure><p>这明显不符合我们的预期。实际上在<code>map(s -&gt; s.split(&quot;&quot;))</code>操作后，返回了一个<code>Stream&lt;String[]&gt;</code>类型的流，所以输出结果为每个数组对象的句柄，而我们真正想要的结果是<code>Stream&lt;String&gt;</code>。在Stream中，可以使用<code>Arrays.stream()</code>方法来将数组转换为流，改造上面的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .map(s -&gt; s.split(<span class="string">""</span>))</span><br><span class="line">    .map(Arrays::stream)</span><br><span class="line">    .distinct()</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.util.stream.ReferencePipeline$Head<span class="meta">@eed</span>1f14</span><br><span class="line">java.util.stream.ReferencePipeline$Head@<span class="number">7229724f</span></span><br><span class="line">java.util.stream.ReferencePipeline$Head@<span class="number">4</span>c873330</span><br><span class="line">java.util.stream.ReferencePipeline$Head@<span class="number">119</span>d7047</span><br><span class="line">java.util.stream.ReferencePipeline$Head@<span class="number">776</span>ec8df</span><br><span class="line">java.util.stream.ReferencePipeline$Head@<span class="number">4</span>eec7777</span><br><span class="line">java.util.stream.ReferencePipeline$Head@<span class="number">3</span>b07d329</span><br><span class="line">java.util.stream.ReferencePipeline$Head@<span class="number">41629346</span></span><br><span class="line">java.util.stream.ReferencePipeline$Head@<span class="number">404</span>b9385</span><br></pre></td></tr></table></figure><p>因为上面的流经过<code>map(Arrays::stream)</code>处理后，将每个数组变成了一个新的流，返回结果为流的数组<code>Stream&lt;String&gt;[]</code>，所以输出是各个流的句柄。我们还需将这些新的流连接成一个流，使用<code>flatMap</code>来改写上面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .map(s -&gt; s.split(<span class="string">""</span>))</span><br><span class="line">    .flatMap(Arrays::stream)</span><br><span class="line">    .distinct()</span><br><span class="line">    .forEach(s -&gt; System.out.print(s + <span class="string">" "</span>));</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">J a v S c r i p t y h o n P H C # G l g w f + R u b</span><br></pre></td></tr></table></figure><p>和<code>map</code>类似，<code>flatMap</code>方法也有相应的原始类型特化方法，如<code>flatMapToInt</code>等。</p><h3 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h3><h4 id="anyMatch"><a href="#anyMatch" class="headerlink" title="anyMatch"></a>anyMatch</h4><p><code>anyMatch</code>方法用于判断流中是否有符合判断条件的元素，返回值为boolean类型。比如判断list中是否含有<code>SQL</code>元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .anyMatch(s -&gt; <span class="string">"SQL"</span>.equals(s)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="allMatch"><a href="#allMatch" class="headerlink" title="allMatch"></a>allMatch</h3><p><code>allMatch</code>方法用于判断流中是否所有元素都满足给定的判断条件，返回值为boolean类型。比如判断list中是否所有元素长度都不大于10：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .allMatch(s -&gt; s.length() &lt;= <span class="number">10</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="noneMatch"><a href="#noneMatch" class="headerlink" title="noneMatch"></a>noneMatch</h4><p><code>noneMatch</code>方法用于判断流中是否所有元素都不满足给定的判断条件，返回值为boolean类型。比如判断list中不存在长度大于10的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .noneMatch(s -&gt; s.length() &gt; <span class="number">10</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="findAny"><a href="#findAny" class="headerlink" title="findAny"></a>findAny</h3><p><code>findAny</code>方法用于返回流中的任意元素的Optional类型，例如筛选出list中任意一个以<code>J</code>开头的元素，如果存在，则输出它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().filter(s -&gt; s.startsWith(<span class="string">"J"</span>)).findAny().ifPresent(System.out::println); <span class="comment">// Java</span></span><br></pre></td></tr></table></figure><h3 id="findFirst"><a href="#findFirst" class="headerlink" title="findFirst"></a>findFirst</h3><p><code>findFirst</code>方法用于返回流中的第一个元素的Optional类型，例如筛选出list中长度大于5的元素，如果存在，则输出第一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .filter(s -&gt; s.length() &gt; 5)</span><br><span class="line">    .findFirst()</span><br><span class="line">    .ifPresent(System.out::println); // JavaScript</span><br></pre></td></tr></table></figure><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p><code>reduce</code>函数从字面上来看就是压缩，缩减的意思，它可以用于数字类型的流的求和，求最大值和最小值。如对numbers中的元素求和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">numbers.stream()</span><br><span class="line">       .reduce(<span class="number">0</span>, Integer::sum); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure><p><code>reduce</code>函数也可以不指定初始值，但这时候将返回一个Optional对象，比如求最大值和最小值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numbers.stream().reduce(Integer::max.ifPresent(System.out::println); <span class="comment">// 4</span></span><br><span class="line">numbers.stream().reduce(Integer::min).ifPresent(System.out::println); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p><code>forEach</code>用于迭代流中的每个元素，最为常见的就是迭代输出，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p><code>count</code>方法用于统计流中元素的个数，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().count(); // 9</span><br></pre></td></tr></table></figure><h3 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h3><p><code>collect</code>方法用于收集流中的元素，并放到不同类型的结果中，比如<code>List</code>、<code>Set</code>或者<code>Map</code>。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; filterList = list.stream().filter(s -&gt; s.startsWith(<span class="string">"J"</span>)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>如果需要以<code>Set</code>来替代<code>List</code>，只需要使用<code>Collectors.toSet()</code>就好了。</p><h3 id="流的构建"><a href="#流的构建" class="headerlink" title="流的构建"></a>流的构建</h3><p>除了使用集合对象的<code>stream</code>方法构建流之外，我们可以手动构建一些流。</p><h4 id="数值范围构建"><a href="#数值范围构建" class="headerlink" title="数值范围构建"></a>数值范围构建</h4><p><code>IntStream</code>和<code>LongStream</code>对象支持<code>range</code>和<code>rangeClosed</code>方法来构建数值流。这两个方法都是第一个参数接受起始值，第二个参数接受结束值。但range是不包含结束值的，而rangeClosed则包含结束值。比如对1到100的整数求和：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream.rangeClosed(1, 100).sum(); // 5050</span><br></pre></td></tr></table></figure><h4 id="由值构建"><a href="#由值构建" class="headerlink" title="由值构建"></a>由值构建</h4><p>静态方法<code>Stream.of</code>可以显式值创建一个流。它可以接受任意数量的参数。例如，以下代码直接使用<code>Stream.of</code>创建了一个字符串流:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; s = Stream.of(<span class="string">"Java"</span>, <span class="string">"JavaScript"</span>, <span class="string">"C++"</span>, <span class="string">"Ruby"</span>);</span><br></pre></td></tr></table></figure><p>也可以使用<code>Stream.empty()</code>构建一个空流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Object&gt; emptyStream = Stream.empty();</span><br></pre></td></tr></table></figure><h4 id="由数组构建"><a href="#由数组构建" class="headerlink" title="由数组构建"></a>由数组构建</h4><p>静态方法<code>Arrays.stream</code>可以通过数组创建一个流。它接受一个数组作为参数。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">IntStream intStream = Arrays.stream(arr);</span><br></pre></td></tr></table></figure><h4 id="由文件生成流"><a href="#由文件生成流" class="headerlink" title="由文件生成流"></a>由文件生成流</h4><p><code>java.nio.file.Files</code>中的很多静态方法都会返回一个流。例如<code>Files.lines</code>方法会返回一个由指定文件中的各行构成的字符串流。比如统计一个文件中共有多少个字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> wordCout = <span class="number">0L</span>;</span><br><span class="line"><span class="keyword">try</span> (Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="string">"file.txt"</span>), Charset.defaultCharset())) &#123;</span><br><span class="line">    wordCout = lines.map(l -&gt; l.split(<span class="string">""</span>))</span><br><span class="line">                    .flatMap(Arrays::stream)</span><br><span class="line">                    .count();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ignore) &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="由函数构造"><a href="#由函数构造" class="headerlink" title="由函数构造"></a>由函数构造</h4><p>Stream API提供了两个静态方法来从函数生成流：<code>Stream.iterate</code>和<code>Stream.generate</code>。这两个操作可以创建所谓的无限流。比如下面的例子构建了10个偶数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p><code>iterate</code>方法接受一个初始值（在这里是0），还有一个依次应用在每个产生的新值上的Lambda（UnaryOperator类型）。这里，我们使用Lambda <code>n -&gt; n + 2</code>，返回的是前一个元 素加上2。因此，<code>iterate</code>方法生成了一个所有正偶数的流：流的第一个元素是初始值0。然后加上2来生成新的值2，再加上2来得到新的值4，以此类推。</p><p>与<code>iterate</code>方法类似，<code>generate</code>方法也可让你按需生成一个无限流。但<code>generate</code>不是依次对每个新生成的值应用函数，比如下面的例子生成了5个0到1之间的随机双精度数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.generate(Math::random).limit(<span class="number">5</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.6334646850587863</span></span><br><span class="line"><span class="number">0.4190147641834009</span></span><br><span class="line"><span class="number">0.4361968394515475</span></span><br><span class="line"><span class="number">0.6911796456838655</span></span><br><span class="line"><span class="number">0.08156838267267075</span></span><br></pre></td></tr></table></figure><h3 id="转载-https-mrbird-cc-java8stream1-html"><a href="#转载-https-mrbird-cc-java8stream1-html" class="headerlink" title="转载:https://mrbird.cc/java8stream1.html"></a>转载:<a href="https://mrbird.cc/java8stream1.html" target="_blank" rel="noopener">https://mrbird.cc/java8stream1.html</a></h3>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lamdba </tag>
            
            <tag> Java8 Stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet状态管理</title>
      <link href="/2019/08/11/Servlet%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
      <url>/2019/08/11/Servlet%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用Jsoup防御XSS攻击</title>
      <link href="/2019/08/11/%E4%BD%BF%E7%94%A8Jsoup%E9%98%B2%E5%BE%A1XSS%E6%94%BB%E5%87%BB/"/>
      <url>/2019/08/11/%E4%BD%BF%E7%94%A8Jsoup%E9%98%B2%E5%BE%A1XSS%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot异常处理</title>
      <link href="/2019/08/11/Spring-Boot%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2019/08/11/Spring-Boot%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot开启Spring Security</title>
      <link href="/2019/08/11/Spring-Boot%E5%BC%80%E5%90%AFSpring-Security/"/>
      <url>/2019/08/11/Spring-Boot%E5%BC%80%E5%90%AFSpring-Security/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security自定义用户登录</title>
      <link href="/2019/08/11/Spring-Security%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95/"/>
      <url>/2019/08/11/Spring-Security%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security添加图像验证码</title>
      <link href="/2019/08/11/Spring-Security%E6%B7%BB%E5%8A%A0%E5%9B%BE%E5%83%8F%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
      <url>/2019/08/11/Spring-Security%E6%B7%BB%E5%8A%A0%E5%9B%BE%E5%83%8F%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security添加记住我功能</title>
      <link href="/2019/08/11/Spring-Security%E6%B7%BB%E5%8A%A0%E8%AE%B0%E4%BD%8F%E6%88%91%E5%8A%9F%E8%83%BD/"/>
      <url>/2019/08/11/Spring-Security%E6%B7%BB%E5%8A%A0%E8%AE%B0%E4%BD%8F%E6%88%91%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security短信验证码登录</title>
      <link href="/2019/08/11/Spring-Security%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E7%99%BB%E5%BD%95/"/>
      <url>/2019/08/11/Spring-Security%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security退出登录</title>
      <link href="/2019/08/11/Spring-Security%E9%80%80%E5%87%BA%E7%99%BB%E5%BD%95/"/>
      <url>/2019/08/11/Spring-Security%E9%80%80%E5%87%BA%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security Session管理</title>
      <link href="/2019/08/11/Spring-Security-Session%E7%AE%A1%E7%90%86/"/>
      <url>/2019/08/11/Spring-Security-Session%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security权限控制</title>
      <link href="/2019/08/11/Spring-Security%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/08/11/Spring-Security%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security Oauth2入门</title>
      <link href="/2019/08/11/Spring-Security-Oauth2%E5%85%A5%E9%97%A8/"/>
      <url>/2019/08/11/Spring-Security-Oauth2%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security Oauth2自定义Token获取方式</title>
      <link href="/2019/08/11/Spring-Security-Oauth2%E8%87%AA%E5%AE%9A%E4%B9%89Token%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F/"/>
      <url>/2019/08/11/Spring-Security-Oauth2%E8%87%AA%E5%AE%9A%E4%B9%89Token%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security OAuth2自定义令牌控制</title>
      <link href="/2019/08/11/Spring-Security-OAuth2%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BB%A4%E7%89%8C%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/08/11/Spring-Security-OAuth2%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BB%A4%E7%89%8C%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security OAuth2 SSO</title>
      <link href="/2019/08/11/Spring-Security-OAuth2-SSO/"/>
      <url>/2019/08/11/Spring-Security-OAuth2-SSO/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot配合Hibernate Validator参数校验</title>
      <link href="/2019/08/11/SpringBoot%E9%85%8D%E5%90%88Hibernate-Validator%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"/>
      <url>/2019/08/11/SpringBoot%E9%85%8D%E5%90%88Hibernate-Validator%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型</title>
      <link href="/2019/08/11/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/08/11/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JUC之CyclicBarrier</title>
      <link href="/2019/08/11/JUC%E4%B9%8BCyclicBarrier/"/>
      <url>/2019/08/11/JUC%E4%B9%8BCyclicBarrier/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JUC之Exchanger</title>
      <link href="/2019/08/11/JUC%E4%B9%8BExchanger/"/>
      <url>/2019/08/11/JUC%E4%B9%8BExchanger/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>深入理解volatile关键字</title>
      <link href="/2019/08/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2019/08/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JUC之Semaphore</title>
      <link href="/2019/08/11/JUC%E4%B9%8BSemaphore/"/>
      <url>/2019/08/11/JUC%E4%B9%8BSemaphore/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Fork/Join学习</title>
      <link href="/2019/08/11/Fork-Join%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/08/11/Fork-Join%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal学习</title>
      <link href="/2019/08/11/ThreadLocal%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/08/11/ThreadLocal%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java Concurrentcy Lock</title>
      <link href="/2019/08/11/Java-Concurrentcy-Lock/"/>
      <url>/2019/08/11/Java-Concurrentcy-Lock/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>深入学习Java线程池</title>
      <link href="/2019/08/11/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2019/08/11/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  在前面的例子中，我们都是通过<code>new Thread</code>来创建一个线程，由于线程的创建和销毁都需要消耗一定的CPU资源，所以在高并发下这种创建线程的方式将严重影响代码执行效率。而线程池的作用就是让一个线程执行结束后不马上销毁，继续执行新的任务，这样就节省了不断创建线程和销毁线程的开销。</p><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>创建Java线程池最为核心的类为<code>ThreadPoolExecutor</code>：</p><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190630215357.png" alt="QQ截图20190630215357.png"></p><p>它提供了四种构造函数来创建线程池，其中最为核心的构造函数如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><p>这7个参数的含义如下：</p><ol><li><strong>corePoolSize</strong> 线程池核心线程数。即线程池中保留的线程个数，即使这些线程是空闲的，也不会被销毁，除非通过ThreadPoolExecutor的<code>allowCoreThreadTimeOut(true)</code>方法开启了核心线程的超时策略；</li><li><strong>maximumPoolSize</strong> 线程池中允许的最大线程个数；</li><li><strong>keepAliveTime</strong> 用于设置那些超出核心线程数量的线程的最大等待时间，超过这个时间还没有新任务的话，超出的线程将被销毁；</li><li><strong>unit</strong> 超时时间单位；</li><li><strong>workQueue</strong> 线程队列。用于保存通过execute方法提交的，等待被执行的任务；</li><li><strong>threadFactory</strong> 线程创建工程，即指定怎样创建线程；</li><li><strong>handler</strong> 拒绝策略。<code>当ThreadPoolExecutor已经关闭或者ThreadPoolExecutor已经饱和时(达到了最大线程池大小且工作对了已满),execute()方法将要调用Handler。</code></li></ol><p>在通过这个构造方法创建线程池的时候，这几个参数必须满足以下条件，否则将抛出<code>IllegalArgumentException</code>异常：</p><ol><li>corePoolSize不能小于0；</li><li>keepAliveTime不能小于0；</li><li>maximumPoolSize 不能小于等于0；</li><li>maximumPoolSize不能小于corePoolSize；</li></ol><p>此外，workQueue、threadFactory和handler不能为null，否则将抛出空指针异常。</p><p>下面举些例子来深入理解这几个参数的含义。</p><p>使用上面的构造方法创建一个线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">    System.out.println(<span class="string">"线程池创建完毕"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> activeCount = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> queueSize = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (activeCount != threadPoolExecutor.getActiveCount()</span><br><span class="line">                || queueSize != threadPoolExecutor.getQueue().size()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"活跃线程个数 "</span> + threadPoolExecutor.getActiveCount());</span><br><span class="line">            System.out.println(<span class="string">"核心线程个数 "</span> + threadPoolExecutor.getCorePoolSize());</span><br><span class="line">            System.out.println(<span class="string">"队列线程个数 "</span> + threadPoolExecutor.getQueue().size());</span><br><span class="line">            System.out.println(<span class="string">"最大线程数 "</span> + threadPoolExecutor.getMaximumPoolSize());</span><br><span class="line">            System.out.println(<span class="string">"------------------------------------"</span>);</span><br><span class="line">            activeCount = threadPoolExecutor.getActiveCount();</span><br><span class="line">            queueSize = threadPoolExecutor.getQueue().size();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码创建了一个核心线程数量为1，允许最大线程数量为2，最大活跃时间为10秒，线程队列长度为1的线程池。</p><p>假如我们通过execute方法向线程池提交1个任务，看看结果如何：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">System.out.println(<span class="string">"线程池创建完毕"</span>);</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> activeCount = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> queueSize = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (activeCount != threadPoolExecutor.getActiveCount()</span><br><span class="line">                || queueSize != threadPoolExecutor.getQueue().size()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"活跃线程个数 "</span> + threadPoolExecutor.getActiveCount());</span><br><span class="line">            System.out.println(<span class="string">"核心线程个数 "</span> + threadPoolExecutor.getCorePoolSize());</span><br><span class="line">            System.out.println(<span class="string">"队列线程个数 "</span> + threadPoolExecutor.getQueue().size());</span><br><span class="line">            System.out.println(<span class="string">"最大线程数 "</span> + threadPoolExecutor.getMaximumPoolSize());</span><br><span class="line">            System.out.println(<span class="string">"------------------------------------"</span>);</span><br><span class="line">            activeCount = threadPoolExecutor.getActiveCount();</span><br><span class="line">            queueSize = threadPoolExecutor.getQueue().size();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadPoolExecutor的execute和submit方法都可以向线程池提交任务，区别是，submit方法能够返回执行结果，返回值类型为Future</p><p>sleep方法代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="keyword">try</span> &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">"线程执行sleep方法"</span>);        TimeUnit.SECONDS.sleep(value);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;&#125;</span><br></pre></td></tr></table></figure><p>启动程序，控制台输出如下：<img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190630222238.png" alt="QQ截图20190630222238.png"></p><p>线程池核心线程数量为1，通过execute提交了一个任务后，由于核心线程是空闲的，所以任务被执行了。由于这个任务的逻辑是休眠100秒，所以在这100秒内，线程池的活跃线程数量为1。此外，因为提交的任务被核心线程执行了，所以并没有线程需要被放到线程队列里等待，线程队列长度为0。</p><p>假如我们通过execute方法向线程池提交2个任务，看看结果如何：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br></pre></td></tr></table></figure><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190701183457.png" alt="QQ截图20190701183457.png"></p><p>线程池核心线程数量为1，通过execute提交了2个任务后，一开始核心线程是空闲的，Thread-0被执行。由于这个任务的逻辑是休眠100秒，所以在这100秒内，线程池的活跃线程数量为1。因为核心线程数量为1，所以另外一个任务在这100秒内不能被执行，于是被放到线程队列里等待，线程队列长度为1。</p><p>假如我们通过execute方法向线程池提交3个任务，看看结果如何：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br></pre></td></tr></table></figure><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190701184303.png" alt="QQ截图20190701184303.png"></p><p>这三个任务都是休眠100秒，所以核心线程池中第一个任务正在被执行，第二个任务被放入到了线程队列。而当第三个任务被提交进来时，线程队列满了（我们定义的长度为1），由于该线程池允许的最大线程数量为2，所以线程池还可以再创建一个线程来执行另外一个任务，于是乎之前在线程队列里的线程被取出执行（FIFO），第三个任务被放入到了线程队列。</p><p>改变第二个和第三个任务的睡眠时间，观察输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));threadPoolExecutor.execute(() -&gt; sleep(<span class="number">5</span>));</span><br><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190701185215.png" alt="QQ截图20190701185215.png"></p><p>第二个任务提交5秒后，任务执行完毕，所以线程队列里的任务被执行，于是队列线程个数为0，活跃线程数量为2（第一个和第三个任务）。再过5秒后，第三个任务执行完毕，于是活跃线程数量为1（第一个100秒还没执行完毕）。</p><p>在第三个任务结束的瞬间，我们观察线程快照:</p><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190701185617.png" alt="QQ截图20190701185617.png"></p><p>可以看到，线程池中有两个线程，Thread-0在执行第一个任务（休眠100秒，还没结束），Thread-1执行完第三个任务后并没有马上被销毁。过段时间后（10秒钟后）再观察线程快照:</p><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190701190444.png" alt="QQ截图20190701190444.png"></p><p>可以看到，Thread-1这个线程被销毁了，因为我们在创建线程池的时候，指定keepAliveTime 为10秒，10秒后，超出核心线程池线程外的那些线程将被销毁。</p><p>假如一次性提交4个任务，看看会怎样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br></pre></td></tr></table></figure><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190701190808.png" alt="QQ截图20190701190808.png"></p><p>因为我们设置的拒绝策略为AbortPolicy，所以最后提交的那个任务直接被拒绝了。更多拒绝策略下面会介绍到。</p><h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>线程池包含以下几个状态：</p><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190702100110.png" alt="QQ截图20190702100110.png"></p><p>当线程池中所有任务都处理完毕后，线程并不会自己关闭。我们可以通过调用<code>shutdown</code>和<code>shutdownNow</code>方法来关闭线程池。两者的区别在于：</p><ol><li><code>shutdown</code>方法将线程池置为shutdown状态，<code>拒绝新的任务提交，但线程池并不会马上关闭，而是等待所有正在执行的和线程队列里的任务都执行完毕后，线程池才会被关闭</code>。所以这个方法是平滑的关闭线程池。</li><li><code>shutdownNow</code>方法将线程池置为stop状态，拒绝新的任务提交，中断正在执行的那些任务，并且清除线程队列里的任务并返回。所以这个方法是比较“暴力”的。</li></ol><p>举两个例子观察下两者的区别：</p><p><code>shutdown</code>例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">2</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">    System.out.println(<span class="string">"已经执行了线程池shutdown方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行shortTask完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"shortTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">longTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行longTask完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"longTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动程序，控制台输出如下：</p><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190702101041.png" alt="QQ截图20190702101041.png"></p><p>可以看到，虽然在任务都被提交后马上执行了<code>shutdown</code>方法，但是并不会马上关闭线程池，而是等待所有被提交的任务都执行完了才关闭。</p><p><code>shutdownNow</code>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">2</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask());</span><br><span class="line"></span><br><span class="line">    List&lt;Runnable&gt; runnables = threadPoolExecutor.shutdownNow(); <span class="comment">// 马上关闭，并返回还未被执行的任务</span></span><br><span class="line">    System.out.println(runnables);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"已经执行了线程池shutdownNow方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行shortTask完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"shortTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">longTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行longTask完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"longTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动程序，控制台输出如下：<img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190702101355.png" alt="QQ截图20190702101355.png"></p><p>可以看到，在执行<code>shutdownNow</code>方法后，线程池马上就被关闭了，正在执行中的两个任务被打断，并且返回了线程队列中等待被执行的两个任务。</p><p>通过上面两个例子我们还可以看到<code>shutdown</code>和<code>shutdownNow</code>方法都不是阻塞的。常与<code>shutdown</code>搭配的方法有<code>awaitTermination</code>。</p><p><code>awaitTermination</code>方法接收timeout和TimeUnit两个参数，用于设定超时时间及单位。当等待超过设定时间时，会监测ExecutorService是否已经关闭，若关闭则返回true，否则返回false。该方法是阻塞的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">2</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">    <span class="keyword">boolean</span> isShutdown = threadPoolExecutor.awaitTermination(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span> (isShutdown) &#123;</span><br><span class="line">        System.out.println(<span class="string">"线程池在3秒内成功关闭"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"等了3秒还没关闭，不等了╰（‵□′）╯"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行shortTask完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"shortTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">longTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行longTask完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"longTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动程序输出如下：</p><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190702102156.png" alt="QQ截图20190702102156.png"></p><h3 id="4大拒绝策略"><a href="#4大拒绝策略" class="headerlink" title="4大拒绝策略"></a>4大拒绝策略</h3><p>当线程池无法再接收新的任务的时候，可采取如下四种策略：<img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190302111014.png" alt="QQ截图20190302111014.png"></p><h4 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h4><p><code>CallerRunsPolicy</code>策略：由调用线程处理该任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">"任务1"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask(<span class="string">"任务2"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask(<span class="string">"任务3"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">"任务4"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">"任务5"</span>));</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">shortTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行shortTask-name-"</span> + name + <span class="string">"完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"shortTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">longTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">longTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行longTask-name-"</span> + name + <span class="string">"完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"longTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的线程池最多只能一次性提交4个任务，第5个任务提交后会被拒绝策略处理。启动程序输出如下：</p><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190702103818.png" alt="QQ截图20190702103818.png"></p><p>可以看到，第5个提交的任务由调用线程（即main线程）处理该任务。</p><h4 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h4><p><code>AbortPolicy</code>策略：丢弃任务，并抛出<code>RejectedExecutionException</code>异常。前面的例子就是使用该策略，所以不再演示。</p><h4 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h4><p><code>DiscardOldestPolicy</code>策略：丢弃最早被放入到线程队列的任务，将新提交的任务放入到线程队列末端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">"任务1"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask(<span class="string">"任务2"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask(<span class="string">"任务3"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">"任务4"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">"任务5"</span>));</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">shortTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行shortTask-name-"</span> + name + <span class="string">"完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"shortTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">longTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">longTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行longTask-name-"</span> + name + <span class="string">"完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"longTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动程序输出如下：</p><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190702105646.png" alt="QQ截图20190702105646.png"></p><p>可以看到最后提交的任务被执行了，而第3个任务是第一个被放到线程队列的任务，被丢弃了。</p><h4 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h4><p><code>DiscardPolicy</code>策略：直接丢弃新的任务，不抛异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">"任务1"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask(<span class="string">"任务2"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask(<span class="string">"任务3"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">"任务4"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">"任务5"</span>));</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">shortTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行shortTask-name-"</span> + name + <span class="string">"完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"shortTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">longTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">longTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行longTask-name-"</span> + name + <span class="string">"完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"longTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动程序，输出如下：<img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190702110022.png" alt="QQ截图20190702110022.png"></p><p>第5个任务直接被拒绝丢弃了，而没有抛出任何异常</p><h4 id="线程池工厂方法"><a href="#线程池工厂方法" class="headerlink" title="线程池工厂方法"></a>线程池工厂方法</h4><p>除了使用ThreadPoolExecutor的构造方法创建线程池外，我们也可以使用<code>Executors</code>提供的工厂方法来创建不同类型的线程池：</p><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190702110350.png" alt="QQ截图20190702110350.png"></p><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><p><strong><code>适用于为了满足资源管理的请求,而需要限制当前线程数量的应用场景,它适用于负载比较重的服务器。</code></strong></p><p>查看<code>newFixedThreadPool</code>方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，通过<code>newFixedThreadPool</code>创建的是一个固定大小的线程池，大小由<code>nThreads</code>参数指定，它具有如下几个特点:</p><ol><li>当线程池中的线程数达到corePoolSize后，新任务将在无界队列中等待，因此线程池中<br>的线程数不会超过corePoolSize。</li><li>由于1,使用无界队列时,使用无界队列时maximumPoolSize将是一个无效参数。</li><li>由于1和2，使用无界队列时keepAliveTime将是一个无效参数</li><li>由于使用无界队列，运行中的FixedThreadPool（未执行方法shutdown()或shutdownNow()）不会拒绝任务（不会调用RejectedExecutionHandler.rejectedExecution方法）。</li></ol><h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><p><strong><code>适用于执行很多的短期异步任务的小程序,或者负载较轻的服务器。</code></strong></p><p>查看<code>newCachedThreadPool</code>方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个理论上无限大小的线程池：</p><ol><li>核心线程数为0，SynchronousQueue队列是没有长度的队列，所以当有新的任务提交，如果有空闲的还未超时的（最大空闲时间60秒）线程则执行该任务，否则新增一个线程来处理该任务。</li><li>因为线程数量没有限制，理论上可以接收无限个新任务，所以这里也没有指定拒绝策略。</li><li>CachedThreadPool的maximumPool是无界的。这意味着，如果主线程提交任务的速度高于maximumPool中线程处理任务的速度时，CachedThreadPool会不断创建新线程。极端情况下，CachedThreadPool会因为创建过多线程而耗尽CPU和内存资源。</li></ol><h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><p><strong><code>适用于需要保证顺序的执行各个任务;并且在任意时间点,不会有多个线程活动的场景。</code></strong></p><p>查看<code>newSingleThreadExecutor</code>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>核心线程数和最大线程数都为1，每次只能有一个线程处理任务。</li><li>LinkedBlockingQueue队列可以接收无限个新任务。</li></ol><h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h4><ul><li>ScheduledThreadPoolExecutor：<strong><code>适用于多个后台线程执行周期任务,同时为了满足资源管理需求而需要限制后台线程的数量的应用场景。</code></strong></li><li>SingleThreadScheduledExecutor：<strong><code>适用于需要单个后台线程执行周期任务，同时需要保证顺序地执行各个任务的应用场景。</code></strong></li></ul><p>查看<code>newScheduledThreadPool</code>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以<code>newScheduledThreadPool</code>理论是也是可以接收无限个任务，DelayedWorkQueue也是一个无界队列。</p><p>使用newScheduledThreadPool创建的线程池除了可以处理普通的Runnable任务外，它还具有调度的功能：</p><p>1.延迟指定时间后执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 延迟5秒执行</span></span><br><span class="line">executorService.schedule(() -&gt; System.out.println(<span class="string">"hello"</span>), <span class="number">5</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>2.按指定的速率执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 延迟1秒执行，然后每5秒执行一次</span></span><br><span class="line">executorService.scheduleAtFixedRate(</span><br><span class="line">        () -&gt; System.out.println(LocalTime.now()), <span class="number">1</span>, <span class="number">5</span>, TimeUnit.SECONDS</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190702152117.png" alt="QQ截图20190702152117.png"></p><p>3.按指定的时延执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">1</span>);executorService.scheduleWithFixedDelay(() -&gt; System.out.println(LocalTime.now()), <span class="number">1</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190702152440.png" alt="QQ截图20190702152440.png"></p><p>乍一看，scheduleAtFixedRate和scheduleWithFixedDelay没啥区别，实际它们还是有区别的：</p><ul><li>scheduleAtFixedRate按照固定速率执行任务，比如每5秒执行一个任务，即使上一个任务没有结束，5秒后也会开始处理新的任务；</li><li>scheduleWithFixedDelay按照固定的时延处理任务，比如每延迟5秒执行一个任务，无论上一个任务处理了1秒，1分钟还是1小时，下一个任务总是在上一个任务执行完毕后5秒钟后开始执行。</li></ul><p>对于这些线程池工厂方法的使用，阿里巴巴编程规程指出：</p><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190702153306.png" alt="QQ截图20190702153306.png"></p><p>因为这几个线程池理论是都可以接收无限个任务，所以这就有内存溢出的风险。实际上只要我们掌握了ThreadPoolExecutor构造函数7个参数的含义，我们就可以根据不同的业务来创建出符合需求的线程池。一般线程池的创建可以参考如下规则：</p><ul><li>IO密集型任务，线程池线程数量可以设置为2 X CPU核心数；</li><li>计算密集型任务，线程池线程数量可以设置为CPU核心数 + 1。</li><li>混合型: 可以拆分成IO密集型任务和计算密集型任务。</li></ul><h3 id="一些API的用法"><a href="#一些API的用法" class="headerlink" title="一些API的用法"></a>一些API的用法</h3><p>ThreadPoolExecutor提供了几个判断线程池状态的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">    System.out.println(<span class="string">"线程池为shutdown状态："</span> + threadPoolExecutor.isShutdown());</span><br><span class="line">    System.out.println(<span class="string">"线程池正在关闭："</span> + threadPoolExecutor.isTerminating());</span><br><span class="line">    System.out.println(<span class="string">"线程池已经关闭："</span> + threadPoolExecutor.isTerminated());</span><br><span class="line">    threadPoolExecutor.awaitTermination(<span class="number">6</span>, TimeUnit.SECONDS);</span><br><span class="line">    System.out.println(<span class="string">"线程池已经关闭"</span> + threadPoolExecutor.isTerminated());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出如下：</p><p><img src="https://mrbird.cc/img/20190703205843.png" alt="20190703205843.png"></p><p>前面我们提到，线程池核心线程即使是空闲状态也不会被销毁，除非使用<code>allowCoreThreadTimeOut</code>设置了允许核心线程超时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">               <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">               <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">               <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">       );</span><br><span class="line">       threadPoolExecutor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</span><br><span class="line">       threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">               System.out.println(<span class="string">"任务执行完毕"</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>程序输出如下所示：</p><p><img src="https://mrbird.cc/img/asdfasdfaaaaa.gif" alt="asdfasdfaaaaa.gif"></p><p>5秒后任务执行完毕，核心线程处于空闲的状态。因为通过<code>allowCoreThreadTimeOut</code>方法设置了允许核心线程超时，所以3秒后（keepAliveTime设置为3秒），核心线程被销毁。核心线程被销毁后，线程池也就没有作用了，于是就自动关闭了。</p><p><strong>值得注意的是，如果一个线程池调用了<code>allowCoreThreadTimeOut(true)</code>方法，那么它的<code>keepAliveTime</code>不能为0。</strong></p><p>ThreadPoolExecutor提供了一<code>remove</code>方法，查看其源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = workQueue.remove(task);</span><br><span class="line">    tryTerminate(); <span class="comment">// In case SHUTDOWN and now empty</span></span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可看到，它删除的是线程队列中的任务，而非正在被执行的任务。举个例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">    );</span><br><span class="line">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(<span class="string">"任务执行完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Runnable r = () -&gt; System.out.println(<span class="string">"看看我是否会被删除"</span>);</span><br><span class="line">    threadPoolExecutor.execute(r);</span><br><span class="line">    threadPoolExecutor.remove(r);</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行程序，输出如下：</p><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190703211746.png" alt="QQ截图20190703211746.png"></p><p>可看到任务并没有被执行，已经被删除，因为唯一一个核心线程已经在执行任务了，所以后提交的这个任务被放到了线程队列里，然后通过remove方法删除。</p><p>默认情况下，只有当往线程池里提交了任务后，线程池才会启动核心线程处理任务。我们可以通过调用<code>preStartCoreThread</code>方法，<code>让核心线程即使没有任务提交，也处于等待执行任务的活跃状态：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">    );</span><br><span class="line">    System.out.println(<span class="string">"活跃线程数: "</span> + threadPoolExecutor.getActiveCount());</span><br><span class="line">    threadPoolExecutor.prestartCoreThread();</span><br><span class="line">    System.out.println(<span class="string">"活跃线程数: "</span> + threadPoolExecutor.getActiveCount());</span><br><span class="line">    threadPoolExecutor.prestartCoreThread();</span><br><span class="line">    System.out.println(<span class="string">"活跃线程数: "</span> + threadPoolExecutor.getActiveCount());</span><br><span class="line">    threadPoolExecutor.prestartCoreThread();</span><br><span class="line">    System.out.println(<span class="string">"活跃线程数: "</span> + threadPoolExecutor.getActiveCount());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出如下所示：</p><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190703213145.png" alt="QQ截图20190703213145.png"></p><p>该方法返回boolean类型值，如果所以核心线程都启动了，返回false，反之返回true。</p><p>还有一个和它类似的<code>preStartAllCoreThreads</code>方法，它的作用是一次性启动所有核心线程，让其处于活跃地等待执行任务的状态。</p><p><strong>ThreadPoolExecutor的invokeAny方法用于随机执行任务集合中的某个任务，并返回执行结果，该方法是同步方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务集合</span></span><br><span class="line">    List&lt;Callable&lt;Integer&gt;&gt; tasks = IntStream.range(<span class="number">0</span>, <span class="number">4</span>).boxed().map(i -&gt; (Callable&lt;Integer&gt;) () -&gt; &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(<span class="number">5</span>));</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">// 随机执行结果</span></span><br><span class="line">    Integer result = threadPoolExecutor.invokeAny(tasks);</span><br><span class="line">    System.out.println(<span class="string">"-------------------"</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    threadPoolExecutor.shutdownNow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动程序，输出如下：</p><p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190704091530.png" alt="QQ截图20190704091530.png"></p><p><strong>ThreadPoolExecutor的invokeAll则是执行任务集合中的所有任务，返回Future集合：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    List&lt;Callable&lt;Integer&gt;&gt; tasks = IntStream.range(<span class="number">0</span>, <span class="number">4</span>).boxed().map(i -&gt; (Callable&lt;Integer&gt;) () -&gt; &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(<span class="number">5</span>));</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    List&lt;Future&lt;Integer&gt;&gt; futureList = threadPoolExecutor.invokeAll(tasks);</span><br><span class="line">    futureList.stream().map(f-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> f.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdownNow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：<img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20190704091836.png" alt="QQ截图20190704091836.png"></p><p>总结下这些方法：</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">allowCoreThreadTimeOut(boolean value)</td><td align="left">是否允许核心线程空闲后超时，是的话超时后核心线程将销毁，线程池自动关闭</td></tr><tr><td align="left">awaitTermination(long timeout, TimeUnit unit)</td><td align="left">阻塞当前线程，等待线程池关闭，timeout用于指定等待时间。</td></tr><tr><td align="left">execute(Runnable command)</td><td align="left">向线程池提交任务，没有返回值</td></tr><tr><td align="left">submit(Runnable task)</td><td align="left">向线程池提交任务，返回Future</td></tr><tr><td align="left">isShutdown()</td><td align="left">判断线程池是否为shutdown状态</td></tr><tr><td align="left">isTerminating()</td><td align="left">判断线程池是否正在关闭</td></tr><tr><td align="left">isTerminated()</td><td align="left">判断线程池是否已经关闭</td></tr><tr><td align="left">remove(Runnable task)</td><td align="left">移除线程队列中的指定任务</td></tr><tr><td align="left">prestartCoreThread()</td><td align="left">提前让一个核心线程处于活跃状态，等待执行任务</td></tr><tr><td align="left">prestartAllCoreThreads()</td><td align="left">提前让所有核心线程处于活跃状态，等待执行任务</td></tr><tr><td align="left">getActiveCount()</td><td align="left">获取线程池活跃线程数</td></tr><tr><td align="left">getCorePoolSize()</td><td align="left">获取线程池核心线程数</td></tr><tr><td align="left">threadPoolExecutor.getQueue()</td><td align="left">获取线程池线程队列</td></tr><tr><td align="left">getMaximumPoolSize()</td><td align="left">获取线程池最大线程数</td></tr><tr><td align="left">shutdown()</td><td align="left">让线程池处于shutdown状态，不再接收任务，等待所有正在运行中的任务结束后，关闭线程池。</td></tr><tr><td align="left">shutdownNow()</td><td align="left">让线程池处于stop状态，不再接受任务，尝试打断正在运行中的任务，并关闭线程池，返回线程队列中的任务。</td></tr></tbody></table><h4 id="转载-https-mrbird-cc-Java-Thread-Pool-html"><a href="#转载-https-mrbird-cc-Java-Thread-Pool-html" class="headerlink" title="转载:https://mrbird.cc/Java-Thread-Pool.html"></a>转载:<a href="https://mrbird.cc/Java-Thread-Pool.html" target="_blank" rel="noopener">https://mrbird.cc/Java-Thread-Pool.html</a></h4>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC之CountDownLatch</title>
      <link href="/2019/08/11/JUC%E4%B9%8BCountDownLatch/"/>
      <url>/2019/08/11/JUC%E4%B9%8BCountDownLatch/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git标签管理</title>
      <link href="/2019/08/11/Git%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86/"/>
      <url>/2019/08/11/Git%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="创建标签-tag"><a href="#创建标签-tag" class="headerlink" title="创建标签(tag)"></a>创建标签(tag)</h2><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br></pre></td></tr></table></figure><p>然后，敲命令<code>git tag &lt;name&gt;</code>就可以打一个新标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.0</span><br></pre></td></tr></table></figure><p>可以用命令<code>git tag</code>查看所有标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p><p>方法是找到历史提交的commit id，然后打上就可以了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline --abbrev-commit</span><br><span class="line">12a631b (HEAD -&gt; master, tag: v1.0, origin/master) merged bug fix 101</span><br><span class="line">4c805e2 fix bug 101</span><br><span class="line">e1e9c68 merge with no-ff</span><br><span class="line">f52c633 add merge</span><br><span class="line">cf810e4 conflict fixed</span><br><span class="line">5dc6824 &amp; simple</span><br><span class="line">14096d0 AND simple</span><br><span class="line">b17d20e branch <span class="built_in">test</span></span><br><span class="line">d46f35e remove test.txt</span><br><span class="line">b84166e add test.txt</span><br><span class="line">519219b git tracks changes</span><br><span class="line">e43a48b understand how stage works</span><br><span class="line">1094adb append GPL</span><br><span class="line">e475afc add distributed</span><br><span class="line">eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure><p>比方说要对<code>add merge</code>这次提交打标签，它对应的commit id是<code>f52c633</code>，敲入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v0.9 f52c633</span><br></pre></td></tr></table></figure><p>再用命令<code>git tag</code>查看标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v0.9</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><p><strong>注意，标签不是按时间顺序列出，而是按字母排序的</strong>。可以用<code>git show &lt;tagname&gt;</code>查看标签信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.9</span><br><span class="line">commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:56:54 2018 +0800</span><br><span class="line"></span><br><span class="line">    add merge</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到，<code>v0.9</code>确实打在<code>add merge</code>这次提交上。</p><p>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v0.1 -m <span class="string">"version 0.1 released"</span> 1094adb</span><br></pre></td></tr></table></figure><p>用命令<code>git show &lt;tagname&gt;</code>可以看到说明文字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.1</span><br><span class="line">tag v0.1</span><br><span class="line">Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 22:48:43 2018 +0800</span><br><span class="line"></span><br><span class="line">version 0.1 released</span><br><span class="line"></span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签</strong></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</li><li>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</li><li>命令<code>git tag</code>可以查看所有标签。</li></ul><hr><hr><hr><h2 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h2><p>如果标签打错了，也可以删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.1</span><br><span class="line">Deleted tag <span class="string">'v0.1'</span> (was f15b0dd)</span><br></pre></td></tr></table></figure><p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p><p>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v1.0</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v1.0 -&gt; v1.0</span><br></pre></td></tr></table></figure><p>或者，一次性推送全部尚未推送到远程的本地标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v0.9 -&gt; v0.9</span><br></pre></td></tr></table></figure><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.9</span><br><span class="line">Deleted tag <span class="string">'v0.9'</span> (was f52c633)</span><br></pre></td></tr></table></figure><p>然后，从远程删除。删除命令也是push，但是格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :refs/tags/v0.9</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> - [deleted]         v0.9</span><br></pre></td></tr></table></figure><p>要看看是否真的从远程库删除了标签，可以登陆GitHub查看。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li><li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li><li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li><li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git多人协作</title>
      <link href="/2019/08/11/Git%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C/"/>
      <url>/2019/08/11/Git%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>当你从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。</p><p>要查看远程库的信息，用<code>git remote</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><p>或者，用<code>git remote -v</code>显示更详细的信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure><p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p><h3 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h3><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>如果要推送其他分支，比如<code>dev</code>，就改成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p><ul><li><strong><code>master</code>分支是主分支，因此要时刻与远程同步；</strong></li><li><strong><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</strong></li><li><strong>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</strong></li><li><strong>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</strong></li></ul><p>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p><h3 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h3><p>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。</p><p>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:michaelliao/learngit.git</span><br><span class="line">Cloning into &apos;learngit&apos;...</span><br><span class="line">remote: Counting objects: 40, done.</span><br><span class="line">remote: Compressing objects: 100% (21/21), done.</span><br><span class="line">remote: Total 40 (delta 14), reused 40 (delta 14), pack-reused 0</span><br><span class="line">Receiving objects: 100% (40/40), done.</span><br><span class="line">Resolving deltas: 100% (14/14), done.</span><br></pre></td></tr></table></figure><p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的<code>master</code>分支。不信可以用<code>git branch</code>命令看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>现在，你的小伙伴要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支：</p><p>在，你的小伙伴要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><p>现在，他就可以在<code>dev</code>上继续修改，然后，时不时地把<code>dev</code>分支<code>push</code>到远程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git add env.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">"add env"</span></span><br><span class="line">[dev 7a5e5dd] add env</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 env.txt</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (3/3), 308 bytes | 308.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   f52c633..7a5e5dd  dev -&gt; dev</span><br></pre></td></tr></table></figure><p>你的小伙伴已经向<code>origin/dev</code>分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cat env.txt</span><br><span class="line">env</span><br><span class="line"></span><br><span class="line">$ git add env.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">"add new env"</span></span><br><span class="line">[dev 7bd91f1] add new env</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 env.txt</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> ! [rejected]        dev -&gt; dev (non-fast-forward)</span><br><span class="line">error: failed to push some refs to <span class="string">'git@github.com:michaelliao/learngit.git'</span></span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: <span class="string">'git pull ...'</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">'Note about fast-forwards'</span> <span class="keyword">in</span> <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p>推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，<strong>先用<code>git pull</code></strong>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">There is no tracking information <span class="keyword">for</span> the current branch.</span><br><span class="line">Please specify <span class="built_in">which</span> branch you want to merge with.</span><br><span class="line">See git-pull(1) <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to <span class="built_in">set</span> tracking information <span class="keyword">for</span> this branch you can <span class="keyword">do</span> so with:</span><br><span class="line"></span><br><span class="line">    git branch --<span class="built_in">set</span>-upstream-to=origin/&lt;branch&gt; dev</span><br></pre></td></tr></table></figure><p><code>git pull</code>也失败了，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --<span class="built_in">set</span>-upstream-to=origin/dev dev</span><br><span class="line">Branch <span class="string">'dev'</span> <span class="built_in">set</span> up to track remote branch <span class="string">'dev'</span> from <span class="string">'origin'</span>.</span><br></pre></td></tr></table></figure><p>再pull：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">Auto-merging env.txt</span><br><span class="line">CONFLICT (add/add): Merge conflict <span class="keyword">in</span> env.txt</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure><p>这回<code>git pull</code>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的<a href="http://www.liaoxuefeng.com/wiki/896043488029600/900004111093344" target="_blank" rel="noopener">解决冲突</a>完全一样。解决后，提交，再push：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"fix env conflict"</span></span><br><span class="line">[dev 57c53ab] fix env conflict</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: 6, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (4/4), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 6 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   7a5e5dd..57c53ab  dev -&gt; dev</span><br></pre></td></tr></table></figure><p>因此，多人协作的工作模式通常是这样：</p><ol><li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li></ol><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>查看远程库信息，使用<code>git remote -v</code>；</li><li><strong>本地新建的分支如果不推送到远程，对其他人就是不可见的；</strong></li><li><strong>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</strong></li><li>在<strong>本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</strong></li><li><strong>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</strong></li><li><strong>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git中Feature分支</title>
      <link href="/2019/08/11/Git%E4%B8%ADFeature%E5%88%86%E6%94%AF/"/>
      <url>/2019/08/11/Git%E4%B8%ADFeature%E5%88%86%E6%94%AF/</url>
      
        <content type="html"><![CDATA[<p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p><p><strong>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</strong></p><p>现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。</p><p>于是准备开发：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b feature-vulcan</span><br><span class="line">Switched to a new branch <span class="string">'feature-vulcan'</span></span><br></pre></td></tr></table></figure><p>5分钟后，开发完毕：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git add vulcan.py</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch feature-vulcan</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   vulcan.py</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add feature vulcan&quot;</span><br><span class="line">[feature-vulcan 287773e] add feature vulcan</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 vulcan.py</span><br></pre></td></tr></table></figure><p>切回<code>dev</code>，准备合并：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br></pre></td></tr></table></figure><p>一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。</p><p>但是！就在此时，接到上级命令，因经费不足，新功能必须取消！虽然白干了，但是这个包含机密资料的分支还是必须就地销毁：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d feature-vulcan</span><br><span class="line">error: The branch <span class="string">'feature-vulcan'</span> is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run <span class="string">'git branch -D feature-vulcan'</span>.</span><br></pre></td></tr></table></figure><p>销毁失败。Git友情提醒，<code>feature-vulcan</code>分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的<code>-D</code>参数。。</p><p>现在我们强行删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -D feature-vulcan</span><br><span class="line">Deleted branch feature-vulcan (was 287773e).</span><br></pre></td></tr></table></figure><p>终于删除成功！</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>开发一个新feature，最好新建一个分支；</p><p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git中bug分支</title>
      <link href="/2019/08/11/Git%E4%B8%ADbug%E5%88%86%E6%94%AF/"/>
      <url>/2019/08/11/Git%E4%B8%ADbug%E5%88%86%E6%94%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h2><p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p><p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支<code>issue-101</code>来修复它，但是，等等，当前正在<code>dev</code>上进行的工作还没有提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   hello.py</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br></pre></td></tr></table></figure><p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p><p>幸好，<strong>Git还提供了一个<code>stash</code>功能(该命令需要文件被加入缓存区，即add过后)</strong>，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 先add文件</span></span><br><span class="line">$ git add filename</span><br><span class="line">$ git stash</span><br><span class="line"><span class="comment">## 记录工作目录和索引的当前状态,但是想要返回到干净目录,保存了本地修改,并恢复工作目录</span></span><br><span class="line"><span class="comment">## 以匹配HEAD提交</span></span><br><span class="line">Saved working directory and index state WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure><p>命令介绍</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 查看储藏修改</span></span><br><span class="line">git stash list [&lt;options&gt;]</span><br><span class="line"><span class="comment">### 储藏的列表进行检查</span></span><br><span class="line">git stash show [&lt;stash&gt;]</span><br><span class="line"><span class="comment">### 重新应用储藏</span></span><br><span class="line">git stash ( pop | apply ) [--index] [-q|--quiet] [&lt;stash&gt;]</span><br><span class="line">git stash branch &lt;branchname&gt; [&lt;stash&gt;]</span><br><span class="line"><span class="comment">### git stash相当于git stash save,默认情况下,储藏列表为"分支名称的WIP"</span></span><br><span class="line"><span class="comment">### stash@&#123;0&#125;是最近创建的垃圾邮件,stash@&#123;1&#125;依次内推</span></span><br><span class="line">git stash save [-p|--patch] [-k|--[no-]keep-index] [-q|--quiet]</span><br><span class="line">         [-u|--include-untracked] [-a|--all] [&lt;message&gt;]</span><br><span class="line">git stash [push [-p|--patch] [-k|--[no-]keep-index] [-q|--quiet]</span><br><span class="line">         [-u|--include-untracked] [-a|--all] [-m|--message &lt;message&gt;]]</span><br><span class="line">         [--] [&lt;pathspec&gt;…​]]</span><br></pre></td></tr></table></figure><p>现在，用<code>git status</code>查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p><p><strong>首先确定要在哪个分支上修复bug</strong>，假定需要在<code>master</code>分支上修复，就从<code>master</code>创建临时分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 6 commits.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">$ git checkout -b issue-101</span><br><span class="line">Switched to a new branch <span class="string">'issue-101'</span></span><br></pre></td></tr></table></figure><p>现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"fix bug 101"</span></span><br><span class="line">[issue-101 4c805e2] fix bug 101</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>修复完成后，切换到<code>master</code>分支，并完成合并，最后删除<code>issue-101</code>分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 6 commits.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">$ git merge --no-ff -m <span class="string">"merged bug fix 101"</span> issue-101</span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> readme.txt | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到<code>dev</code>分支干活了！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>工作区是干净的，刚才的工作现场存到哪去了？用<code>git stash list</code>命令看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p><p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p><p><strong>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git stash pop</span><br><span class="line">On branch dev</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   hello.py</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Dropped refs/stash@&#123;0&#125; (5d677e2ee266f39ea296182fb2354265b91b3b2a)</span><br></pre></td></tr></table></figure><p>再用<code>git stash list</code>查看，就看不到任何stash内容了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br></pre></td></tr></table></figure><p>你可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p><p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git rebase命令实战</title>
      <link href="/2019/08/10/Git-rebase%E5%91%BD%E4%BB%A4%E5%AE%9E%E6%88%98/"/>
      <url>/2019/08/10/Git-rebase%E5%91%BD%E4%BB%A4%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p>多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。</p><p>每次合并再push后，分支变成了这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* d1be385 (HEAD -&gt; master, origin/master) init hello</span><br><span class="line">*   e5e69f1 Merge branch <span class="string">'dev'</span></span><br><span class="line">|\  </span><br><span class="line">| *   57c53ab (origin/dev, dev) fix env conflict</span><br><span class="line">| |\  </span><br><span class="line">| | * 7a5e5dd add env</span><br><span class="line">| * | 7bd91f1 add new env</span><br><span class="line">| |/  </span><br><span class="line">* |   12a631b merged bug fix 101</span><br><span class="line">|\ \  </span><br><span class="line">| * | 4c805e2 fix bug 101</span><br><span class="line">|/ /  </span><br><span class="line">* |   e1e9c68 merge with no-ff</span><br><span class="line">|\ \  </span><br><span class="line">| |/  </span><br><span class="line">| * f52c633 add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br></pre></td></tr></table></figure><p>总之看上去很乱，有强迫症的童鞋会问：为什么Git的提交历史不能是一条干净的直线？</p><p>其实是可以做到的！</p><p>Git有一种称为rebase的操作，有人把它翻译成“变基”。</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1216294032394112/l" alt="rebase"></p><p>先不要随意展开想象。我们还是从实际问题出发，看看怎么把分叉的提交变成直线。</p><p>在和远程分支同步后，我们对<code>hello.py</code>这个文件做了两次提交。用<code>git log</code>命令看看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 582d922 (HEAD -&gt; master) add author</span><br><span class="line">* 8875536 add comment</span><br><span class="line">* d1be385 (origin/master) init hello</span><br><span class="line">*   e5e69f1 Merge branch <span class="string">'dev'</span></span><br><span class="line">|\  </span><br><span class="line">| *   57c53ab (origin/dev, dev) fix env conflict</span><br><span class="line">| |\  </span><br><span class="line">| | * 7a5e5dd add env</span><br><span class="line">| * | 7bd91f1 add new env</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注意到Git用<code>(HEAD -&gt; master)</code>和<code>(origin/master)</code>标识出当前分支的HEAD和远程origin的位置分别是<code>582d922 add author</code>和<code>d1be385 init hello</code>，本地分支比远程分支快两个提交。</p><p>现在我们尝试推送本地分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> ! [rejected]        master -&gt; master (fetch first)</span><br><span class="line">error: failed to push some refs to <span class="string">'git@github.com:michaelliao/learngit.git'</span></span><br><span class="line">hint: Updates were rejected because the remote contains work that you <span class="keyword">do</span></span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., <span class="string">'git pull ...'</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">'Note about fast-forwards'</span> <span class="keyword">in</span> <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p>很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (1/1), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">From github.com:michaelliao/learngit</span><br><span class="line">   d1be385..f005ed4  master     -&gt; origin/master</span><br><span class="line"> * [new tag]         v1.0       -&gt; v1.0</span><br><span class="line">Auto-merging hello.py</span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> hello.py | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>再用<code>git status</code>看看状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 3 commits.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。</p><p>用<code>git log</code>看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   e0ea545 (HEAD -&gt; master) Merge branch &apos;master&apos; of github.com:michaelliao/learngit</span><br><span class="line">|\  </span><br><span class="line">| * f005ed4 (origin/master) set exit=1</span><br><span class="line">* | 582d922 add author</span><br><span class="line">* | 8875536 add comment</span><br><span class="line">|/  </span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>对强迫症童鞋来说，现在事情有点不对头，提交历史分叉了。如果现在把本地分支push到远程，有没有问题？不好看。</p><p>这个时候，rebase就派上了用场。我们输入命令<code>git rebase</code>试试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: add comment</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">Mhello.py</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging hello.py</span><br><span class="line">Applying: add author</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">Mhello.py</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging hello.py</span><br></pre></td></tr></table></figure><p>输出了一大堆操作，到底是啥效果？再用<code>git log</code>看看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 7e61ed4 (HEAD -&gt; master) add author</span><br><span class="line">* 3611cfe add comment</span><br><span class="line">* f005ed4 (origin/master) <span class="built_in">set</span> <span class="built_in">exit</span>=1</span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了<code>f005ed4 (origin/master) set exit=1</code>之后，这样，整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的，但是，我们本地的commit修改内容已经变化了，它们的修改不再基于<code>d1be385 init hello</code>，而是基于<code>f005ed4 (origin/master) set exit=1</code>，但最后的提交<code>7e61ed4</code>内容是一致的。</p><p>这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。</p><p>最后，通过push操作把本地分支推送到远程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Mac:~/learngit michael$ git push origin master</span><br><span class="line">Counting objects: 6, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (5/5), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (6/6), 576 bytes | 576.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 6 (delta 2), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (2/2), completed with 1 <span class="built_in">local</span> object.</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   f005ed4..7e61ed4  master -&gt; master</span><br></pre></td></tr></table></figure><p>再用<code>git log</code>看看效果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 7e61ed4 (HEAD -&gt; master, origin/master) add author</span><br><span class="line">* 3611cfe add comment</span><br><span class="line">* f005ed4 <span class="built_in">set</span> <span class="built_in">exit</span>=1</span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>远程分支的提交历史也是一条直线。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><strong>rebase操作可以把本地未push的分叉提交历史整理成直线；</strong></li><li><strong>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git命令总结</title>
      <link href="/2019/08/10/Git%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2019/08/10/Git%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Git命令文档"><a href="#Git命令文档" class="headerlink" title="Git命令文档"></a>Git命令文档</h2><p><img src="https://img-blog.csdnimg.cn/20190811223221553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70" alt="git常用命令"></p><p><img src="https://img-blog.csdnimg.cn/20190811223320138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70" alt="git命令1"></p><p><img src="https://img-blog.csdnimg.cn/20190811223352123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70" alt="git命令2"></p><p><img src="https://img-blog.csdnimg.cn/20190811223417984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70" alt="git命令4"></p><p><img src="https://img-blog.csdnimg.cn/20190811164604560.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20190811223601734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExNjkzODg4NDI=,size_16,color_FFFFFF,t_70" alt="git图片3"></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git差异和冲突解决</title>
      <link href="/2019/08/10/Git%E5%B7%AE%E5%BC%82%E5%92%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3/"/>
      <url>/2019/08/10/Git%E5%B7%AE%E5%BC%82%E5%92%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="Git差异和冲突解决"><a href="#Git差异和冲突解决" class="headerlink" title="Git差异和冲突解决"></a>Git差异和冲突解决</h2><h3 id="Git冲突解决"><a href="#Git冲突解决" class="headerlink" title="Git冲突解决"></a>Git冲突解决</h3><p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p><p>准备新的<code>feature1</code>分支，继续我们的新分支开发：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b feature1</span><br><span class="line">Switched to a new branch <span class="string">'feature1'</span></span><br></pre></td></tr></table></figure><p>修改<code>readme.txt</code>最后一行，改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick AND simple.</span><br></pre></td></tr></table></figure><p>在<code>feature1</code>分支上提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">"AND simple"</span></span><br><span class="line">[feature1 14096d0] AND simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>切换到<code>master</code>分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 1 commit.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br></pre></td></tr></table></figure><p>Git还会自动提示我们当前<code>master</code>分支比远程的<code>master</code>分支要超前1个提交。</p><p>在<code>master</code>分支上把<code>readme.txt</code>文件的最后一行改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick &amp; simple.</span><br></pre></td></tr></table></figure><p>提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"&amp; simple"</span></span><br><span class="line">[master 5dc6824] &amp; simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>现在，<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了这样：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919023000423040/0" alt="git-br-feature1"></p><p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge feature1</span><br><span class="line">Auto-merging readme.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> readme.txt</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure><p>果然冲突了！Git告诉我们，<code>readme.txt</code>文件存在冲突，必须手动解决冲突后再提交。<code>git status</code>也可以告诉我们冲突的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 2 commits.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">"git commit"</span>)</span><br><span class="line">  (use <span class="string">"git merge --abort"</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to mark resolution)</span><br><span class="line"></span><br><span class="line">both modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><p>我们可以直接查看readme.txt的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick and simple.</span><br></pre></td></tr></table></figure><p>再提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"conflict fixed"</span></span><br><span class="line">[master cf810e4] conflict fixed</span><br></pre></td></tr></table></figure><p>现在，<code>master</code>分支和<code>feature1</code>分支变成了下图所示：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919023031831104/0" alt="git-br-conflict-merged"></p><p>用带参数的<code>git log</code>也可以看到分支的合并情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   cf810e4 (HEAD -&gt; master) conflict fixed</span><br><span class="line">|\  </span><br><span class="line">| * 14096d0 (feature1) AND simple</span><br><span class="line">* | 5dc6824 &amp; simple</span><br><span class="line">|/  </span><br><span class="line">* b17d20e branch <span class="built_in">test</span></span><br><span class="line">* d46f35e (origin/master) remove test.txt</span><br><span class="line">* b84166e add test.txt</span><br><span class="line">* 519219b git tracks changes</span><br><span class="line">* e43a48b understand how stage works</span><br><span class="line">* 1094adb append GPL</span><br><span class="line">* e475afc add distributed</span><br><span class="line">* eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure><p>最后，删除<code>feature1</code>分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d feature1</span><br><span class="line">Deleted branch feature1 (was 14096d0)</span><br></pre></td></tr></table></figure><h3 id="Git差异比较"><a href="#Git差异比较" class="headerlink" title="Git差异比较"></a>Git差异比较</h3><h4 id="工作目录-vs-暂存区"><a href="#工作目录-vs-暂存区" class="headerlink" title="工作目录 vs 暂存区"></a>工作目录 vs 暂存区</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>意义：查看文件在工作目录与暂存区的差别。如果还没 add 进暂存区，则查看文件自身修改前后的差别。也可查看和另一分支的区别。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff &lt;branch&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure><h4 id="暂存区-vs-Git仓库-–cached-代表进暂存区-即add过后"><a href="#暂存区-vs-Git仓库-–cached-代表进暂存区-即add过后" class="headerlink" title="暂存区 vs Git仓库(–cached :代表进暂存区,即add过后)"></a>暂存区 vs Git仓库(–cached :代表进暂存区,即add过后)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>意义：表示查看已经 add 进暂存区但是尚未 commit 的内容同最新一次 commit 时的内容的差异。 也可以指定仓库版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached &lt;commit&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure><h4 id="工作目录-vs-Git仓库"><a href="#工作目录-vs-Git仓库" class="headerlink" title="工作目录 vs Git仓库"></a>工作目录 vs Git仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;commit&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>意义：查看工作目录同Git仓库指定 commit 的内容的差异。 <code>&lt;commit&gt;</code>=<code>HEAD</code> 时：查看工作目录同最近一次 commit 的内容的差异。</p><h4 id="Git仓库-vs-Git仓库"><a href="#Git仓库-vs-Git仓库" class="headerlink" title="Git仓库 vs Git仓库"></a>Git仓库 vs Git仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;commit&gt; &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>意义：Git仓库任意两次 commit 之间的差别。</p><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>以上命令可以不指定 <code>&lt;filename&gt;</code>，则对全部文件操作。 以上命令涉及和 Git仓库 对比的，均可指定 commit 的版本。</p><ul><li><code>HEAD</code> 最近一次 commit</li><li><code>HEAD^</code>  上次提交</li><li><code>HEAD~100</code> 上100次提交</li><li>每次提交产生的哈希值</li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis Dynamic SQL</title>
      <link href="/2019/08/07/Mybatis-Dynamic-SQL/"/>
      <url>/2019/08/07/Mybatis-Dynamic-SQL/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>钉钉消息推送开发总结</title>
      <link href="/2019/08/07/%E9%92%89%E9%92%89%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
      <url>/2019/08/07/%E9%92%89%E9%92%89%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot中的JSON技术</title>
      <link href="/2019/08/07/Spring-Boot%E4%B8%AD%E7%9A%84JSON%E6%8A%80%E6%9C%AF/"/>
      <url>/2019/08/07/Spring-Boot%E4%B8%AD%E7%9A%84JSON%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>平日里在项目中处理<strong>JSON</strong>一般用的都是阿里巴巴的<strong>Fastjson</strong>，后来发现使用Spring Boot内置的<strong>Jackson</strong>来完成JSON的序列化和反序列化操作也挺方便。Jackson不但可以完成简单的序列化和反序列化操作，也能实现复杂的个性化的序列化和反序列化操作。</p><h3 id="自定义ObjectMapper"><a href="#自定义ObjectMapper" class="headerlink" title="自定义ObjectMapper"></a>自定义ObjectMapper</h3><p>我们都知道，在Spring中使用<code>@ResponseBody</code>注解可以将方法返回的对象序列化成JSON，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"getuser"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setUserName(<span class="string">"mrbird"</span>);</span><br><span class="line">    user.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>User类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6222176558369919436L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问<code>getuser</code>页面输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"userName"</span>:<span class="string">"mrbird"</span>,<span class="attr">"age"</span>:<span class="number">0</span>,<span class="attr">"password"</span>:<span class="literal">null</span>,<span class="attr">"birthday"</span>:<span class="number">1522634892365</span>&#125;</span><br></pre></td></tr></table></figure><p>可看到时间默认以时间戳的形式输出，如果想要改变这个默认行为，我们可以自定义一个<strong>ObjectMapper</strong>来替代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JacksonConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectMapper <span class="title">getObjectMapper</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.setDateFormat(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</span><br><span class="line">        <span class="keyword">return</span> mapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面配置获取了ObjectMapper对象，并且设置了时间格式。再次访问<code>getuser</code>，页面输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;userName&quot;:&quot;mrbird&quot;,&quot;age&quot;:0,&quot;password&quot;:null,&quot;birthday&quot;:&quot;2018-04-02 10:14:24&quot;&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>Jackson通过使用mapper的<code>writeValueAsString</code>方法将Java对象序列化为JSON格式字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ObjectMapper mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"serialization"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUserName(<span class="string">"mrbird"</span>);</span><br><span class="line">        user.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">        String str = mapper.writeValueAsString(user);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>使用<code>@ResponseBody</code>注解可以使对象序列化为JSON格式字符串，除此之外，Jackson也提供了反序列化方法。</p><h4 id="树遍历"><a href="#树遍历" class="headerlink" title="树遍历"></a>树遍历</h4><p>当采用树遍历的方式时，JSON被读入到JsonNode对象中，可以像操作XML DOM那样读取JSON。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ObjectMapper mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"readjsonstring"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">readJsonString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String json = <span class="string">"&#123;\"name\":\"mrbird\",\"age\":26&#125;"</span>;</span><br><span class="line">        JsonNode node = <span class="keyword">this</span>.mapper.readTree(json);</span><br><span class="line">        String name = node.get(<span class="string">"name"</span>).asText();</span><br><span class="line">        <span class="keyword">int</span> age = node.get(<span class="string">"age"</span>).asInt();</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">" "</span> + age;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>readTree</code>方法可以接受一个字符串或者字节数组、文件、InputStream等， 返回<strong>JsonNode</strong>作为根节点，你可以像操作<strong>XML DOM</strong>那样操作遍历<strong>JsonNode</strong>以获取数据。</p><p>解析多级JSON例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String json = <span class="string">"&#123;\"name\":\"mrbird\",\"hobby\":&#123;\"first\":\"sleep\",\"second\":\"eat\"&#125;&#125;"</span>;;</span><br><span class="line">JsonNode node = <span class="keyword">this</span>.mapper.readTree(json);</span><br><span class="line">JsonNode hobby = node.get(<span class="string">"hobby"</span>);</span><br><span class="line">String first = hobby.get(<span class="string">"first"</span>).asText();</span><br></pre></td></tr></table></figure><h4 id="绑定对象"><a href="#绑定对象" class="headerlink" title="绑定对象"></a>绑定对象</h4><p>我们也可以将Java对象和JSON数据进行绑定，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ObjectMapper mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"readjsonasobject"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">readJsonAsObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String json = <span class="string">"&#123;\"name\":\"mrbird\",\"age\":26&#125;"</span>;</span><br><span class="line">        User user = mapper.readValue(json, User.class);</span><br><span class="line">        String name = user.getUserName();</span><br><span class="line">        <span class="keyword">int</span> age = user.getAge();</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">" "</span> + age;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Jackson注解"><a href="#Jackson注解" class="headerlink" title="Jackson注解"></a>Jackson注解</h3><p>Jackson包含了一些实用的注解：</p><h4 id="JsonProperty"><a href="#JsonProperty" class="headerlink" title="@JsonProperty"></a>@JsonProperty</h4><p><code>@JsonProperty</code>，作用在属性上，用来为JSON Key指定一个别名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonProperty</span>(<span class="string">"bth"</span>)<span class="keyword">private</span> Date birthday;</span><br></pre></td></tr></table></figure><p>再次访问<code>getuser</code>页面输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"userName"</span>:<span class="string">"mrbird"</span>,<span class="string">"age"</span>:<span class="number">0</span>,<span class="string">"password"</span>:<span class="keyword">null</span>,<span class="string">"bth"</span>:<span class="string">"2018-04-02 10:38:37"</span>&#125;</span><br></pre></td></tr></table></figure><p>key birthday已经被替换为了bth。</p><h4 id="Jsonlgnore"><a href="#Jsonlgnore" class="headerlink" title="@Jsonlgnore"></a>@Jsonlgnore</h4><p><code>@Jsonlgnore</code>，作用在属性上，用来忽略此属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonIgnoreprivate</span> String password;</span><br></pre></td></tr></table></figure><p>再次访问<code>getuser</code>页面输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"userName"</span>:<span class="string">"mrbird"</span>,<span class="string">"age"</span>:<span class="number">0</span>,<span class="string">"bth"</span>:<span class="string">"2018-04-02 10:40:45"</span>&#125;</span><br></pre></td></tr></table></figure><p>password属性已被忽略。</p><h4 id="JsonIgnoreProperties"><a href="#JsonIgnoreProperties" class="headerlink" title="@JsonIgnoreProperties"></a>@JsonIgnoreProperties</h4><p><code>@JsonIgnoreProperties</code>，忽略一组属性，作用于类上，比如<code>JsonIgnoreProperties({ &quot;password&quot;, &quot;age&quot; })</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonIgnoreProperties</span>(&#123; <span class="string">"password"</span>, <span class="string">"age"</span> &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次访问<code>getuser</code>页面输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"userName"</span>:<span class="string">"mrbird"</span>,<span class="attr">"bth"</span>:<span class="string">"2018-04-02 10:45:34"</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="JsonFormat"><a href="#JsonFormat" class="headerlink" title="@JsonFormat"></a>@JsonFormat</h4><p><code>@JsonFormat</code>，用于日期格式化，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonFormat</span>(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line"><span class="keyword">private</span> Date birthday;</span><br></pre></td></tr></table></figure><h4 id="JsonNaming"><a href="#JsonNaming" class="headerlink" title="@JsonNaming"></a>@JsonNaming</h4><p><code>@JsonNaming</code>，用于指定一个命名策略，作用于类或者属性上。Jackson自带了多种命名策略，你可以实现自己的命名策略，比如输出的key 由Java命名方式转为下面线命名方法 —— userName转化为user-name。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonNaming</span>(PropertyNamingStrategy.LowerCaseWithUnderscoresStrategy.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次访问<code>getuser</code>页面输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"user_name"</span>:<span class="string">"mrbird"</span>,<span class="attr">"bth"</span>:<span class="string">"2018-04-02 10:52:12"</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="JsonSerialize"><a href="#JsonSerialize" class="headerlink" title="@JsonSerialize"></a>@JsonSerialize</h4><p><code>@JsonSerialize</code>，指定一个实现类来自定义序列化。类必须实现<code>JsonSerializer</code>接口，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonGenerator;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JsonSerializer;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.SerializerProvider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserSerializer</span> <span class="keyword">extends</span> <span class="title">JsonSerializer</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(User user, JsonGenerator generator, SerializerProvider provider)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, JsonProcessingException </span>&#123;</span><br><span class="line">        generator.writeStartObject();</span><br><span class="line">        generator.writeStringField(<span class="string">"user-name"</span>, user.getUserName());</span><br><span class="line">        generator.writeEndObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中我们仅仅序列化userName属性，且输出的key是<code>user-name</code>。 使用注解<code>@JsonSerialize</code>来指定User对象的序列化方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonSerialize</span>(using = UserSerializer.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次访问<code>getuser</code>页面输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"user-name"</span>:<span class="string">"mrbird"</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="JsonDeserialize"><a href="#JsonDeserialize" class="headerlink" title="@JsonDeserialize"></a>@JsonDeserialize</h4><p><code>@JsonDeserialize</code>，用户自定义反序列化，同<code>@JsonSerialize</code> ，类需要实现<code>JsonDeserializer</code>接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonParser;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.DeserializationContext;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JsonDeserializer;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JsonNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDeserializer</span> <span class="keyword">extends</span> <span class="title">JsonDeserializer</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">deserialize</span><span class="params">(JsonParser parser, DeserializationContext context)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, JsonProcessingException </span>&#123;</span><br><span class="line">        JsonNode node = parser.getCodec().readTree(parser);</span><br><span class="line">        String userName = node.get(<span class="string">"user-name"</span>).asText();</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUserName(userName);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用注解<code>@JsonDeserialize</code>来指定User对象的序列化方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonDeserialize</span> (using = UserDeserializer.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ObjectMapper mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"readjsonasobject"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">readJsonAsObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String json = <span class="string">"&#123;\"user-name\":\"mrbird\"&#125;"</span>;</span><br><span class="line">        User user = mapper.readValue(json, User.class);</span><br><span class="line">        String name = user.getUserName();</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问<code>readjsonasobject</code>，页面输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mrbird</span><br></pre></td></tr></table></figure><h4 id="JsonView"><a href="#JsonView" class="headerlink" title="@JsonView"></a>@JsonView</h4><p><code>@JsonView</code>，作用在类或者属性上，用来定义一个序列化组。 比如对于User对象，某些情况下只返回userName属性就行，而某些情况下需要返回全部属性。 因此User对象可以定义成如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6222176558369919436L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserNameView</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AllUserFieldView</span> <span class="keyword">extends</span> <span class="title">UserNameView</span> </span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@JsonView</span>(UserNameView.class)</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@JsonView</span>(AllUserFieldView.class)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@JsonView</span>(AllUserFieldView.class)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@JsonView</span>(AllUserFieldView.class)</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>User定义了两个接口类，一个为<code>userNameView</code>，另外一个为<code>AllUserFieldView</code>继承了<code>userNameView</code>接口。这两个接口代表了两个序列化组的名称。属性userName使用了<code>@JsonView(UserNameView.class)</code>，而剩下属性使用了<code>@JsonView(AllUserFieldView.class)</code>。</p><p>Spring中Controller方法允许使用<code>@JsonView</code>指定一个组名，被序列化的对象只有在这个组的属性才会被序列化，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonView</span>(User.UserNameView.class)</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"getuser"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setUserName(<span class="string">"mrbird"</span>);</span><br><span class="line">    user.setAge(<span class="number">26</span>);</span><br><span class="line">    user.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">    user.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问<code>getuser</code>页面输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"userName"</span>:<span class="string">"mrbird"</span>&#125;</span><br></pre></td></tr></table></figure><p>如果将<code>@JsonView(User.UserNameView.class)</code>替换为<code>@JsonView(User.AllUserFieldView.class)</code>，输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"userName"</span>:<span class="string">"mrbird"</span>,<span class="attr">"age"</span>:<span class="number">26</span>,<span class="attr">"password"</span>:<span class="string">"123456"</span>,<span class="attr">"birthday"</span>:<span class="string">"2018-04-02 11:24:00"</span>&#125;</span><br></pre></td></tr></table></figure><p>因为接口<code>AllUserFieldView</code>继承了接口<code>UserNameView</code>所以userName也会被输出。</p><h3 id="集合的反序列化"><a href="#集合的反序列化" class="headerlink" title="集合的反序列化"></a>集合的反序列化</h3><p>在Controller方法中，可以使用<code>＠RequestBody</code>将提交的JSON自动映射到方法参数上，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"updateuser"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(@RequestBody List&lt;User&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面方法可以接受如下一个JSON请求，并自动映射到User对象上：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;<span class="attr">"userName"</span>:<span class="string">"mrbird"</span>,<span class="attr">"age"</span>:<span class="number">26</span>&#125;,&#123;<span class="attr">"userName"</span>:<span class="string">"scott"</span>,<span class="attr">"age"</span>:<span class="number">27</span>&#125;]</span><br></pre></td></tr></table></figure><p><strong>Spring Boot</strong> 能自动识别出<strong>List</strong>对象包含的是<strong>User</strong>类<strong>，因为在方法中定义的泛型的类型会被保留在字节码中，所以Spring Boot能识别List包含的泛型类型从而能正确反序列化。</strong></p><p><strong>有些情况下，集合对象并没有包含泛型定义，如下代码所示，反序列化并不能得到期望的结果。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ObjectMapper mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"customize"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">customize</span><span class="params">()</span> <span class="keyword">throws</span> JsonParseException, JsonMappingException, IOException </span>&#123;</span><br><span class="line">    String jsonStr = <span class="string">"[&#123;\"userName\":\"mrbird\",\"age\":26&#125;,&#123;\"userName\":\"scott\",\"age\":27&#125;]"</span>;</span><br><span class="line">    List&lt;User&gt; list = mapper.readValue(jsonStr, List.class);</span><br><span class="line">    String msg = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">        msg += user.getUserName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问<code>customize</code>，控制台抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassCastException: java.util.LinkedHashMap cannot be cast to com.example.pojo.User</span><br></pre></td></tr></table></figure><p>这是因为在运行时刻，泛型己经被擦除了（不同于方法参数定义的泛型，不会被擦除）。为了提供泛型信息，Jackson提供了JavaType ，用来指明集合类型，将上述方法改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ObjectMapper mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"customize"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">customize</span><span class="params">()</span> <span class="keyword">throws</span> JsonParseException, JsonMappingException, IOException </span>&#123;</span><br><span class="line">    String jsonStr = <span class="string">"[&#123;\"userName\":\"mrbird\",\"age\":26&#125;,&#123;\"userName\":\"scott\",\"age\":27&#125;]"</span>;</span><br><span class="line">    JavaType type = mapper.getTypeFactory().constructParametricType(List.class, User.class);</span><br><span class="line">    List&lt;User&gt; list = mapper.readValue(jsonStr, type);</span><br><span class="line">    String msg = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">        msg += user.getUserName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Jackson </tag>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git分支管理</title>
      <link href="/2019/08/07/Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"/>
      <url>/2019/08/07/Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Git分支管理"><a href="#Git分支管理" class="headerlink" title="Git分支管理"></a>Git分支管理</h2><p><strong>git branch</strong> 命令不仅仅能创建和删除分支，如果不加任何参数，它会给出当前所有的分支清单。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">  develop</span><br><span class="line">* master</span><br><span class="line">   <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>带 * 表示当前所在分支。使用命令 <strong><em>git branch -v</em></strong> 可以查看各个分支最后一个提交对象的信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -v</span><br><span class="line">  develop ef993bc update About.html</span><br><span class="line">* master  0986092 [ahead 26] update index.html</span><br><span class="line">  <span class="built_in">test</span>    19fffc0 add <span class="built_in">test</span> file</span><br></pre></td></tr></table></figure><p>使用命令 <strong>git branch –merged</strong> 可以查看哪些分支与当前分支进行了合并操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --merged</span><br><span class="line">  develop</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>与之相反的命令为 <strong><em>git branch –no-merged</em></strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --no-merged</span><br><span class="line">  <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>test分支中还包含着尚未合并进来的工作成果，所以简单地用<strong><em>git branch -d</em></strong>删除该分支会提示错误，因为那样做会丢失数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d <span class="built_in">test</span></span><br><span class="line">error: The branch <span class="string">'test'</span> is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run <span class="string">'git branch -D test'</span>.</span><br></pre></td></tr></table></figure><p>Git提示可以用大写的删除选项 -D 强制执行。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git版本回退</title>
      <link href="/2019/08/07/Git%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/"/>
      <url>/2019/08/07/Git%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Git版本回退"><a href="#Git版本回退" class="headerlink" title="Git版本回退"></a>Git版本回退</h2><p>Git中，每次commit提交都会生成一个历史纪录。使用 <strong><em>git log</em></strong> 查看commit历史：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline </span><br><span class="line">ec88247 modifyed bar.html,foo.txt add new.txt</span><br><span class="line">47384c8 modify bar.html <span class="keyword">in</span> <span class="built_in">clone</span> again</span><br><span class="line">31e1f6f modify foo.txt <span class="keyword">in</span> original again</span><br><span class="line">8747b24 Merge branch <span class="string">'master'</span> of /home/mrbird/projects/first-project</span><br><span class="line">27b76ec modify foo.txt <span class="keyword">in</span> original</span><br><span class="line">796e40d modify bar.html <span class="keyword">in</span> <span class="built_in">clone</span></span><br><span class="line">8e1b132 modify foo.txt,add <span class="string">'hello msg'</span></span><br><span class="line">94418b1 add bar.html,modify foo.txt,delete bar.txt</span><br><span class="line">c2e4810 add foo.txt bar.txt</span><br></pre></td></tr></table></figure><p>每个记录都有一个与之对应的<strong>commit id</strong>，所以可以使用命令 <strong><em>git reset –hard commit-id</em></strong>  来回退到相应的版本。除此之卡，在Git中，使用<strong>HEAD</strong>来代表当前版本，如需回退到前一个版本，可以使用命令<code>git reset --hard HEAD^</code>，前两个版本则用<code>HEAD~2</code>表示，以此类推。</p><p>当前版本id为ec88247…比如，现要回退到commit_id为47384c8…的版本，可以使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 47384c8</span><br><span class="line">HEAD is now at 47384c8again modify bar.html <span class="keyword">in</span> <span class="built_in">clone</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD~1</span><br><span class="line">HEAD is now at 47384c8 modify bar.html <span class="keyword">in</span> <span class="built_in">clone</span> again</span><br></pre></td></tr></table></figure><p>再次查看commit历史</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline </span><br><span class="line">47384c8 modify bar.html <span class="keyword">in</span> <span class="built_in">clone</span> again</span><br><span class="line">31e1f6f modify foo.txt <span class="keyword">in</span> original again</span><br><span class="line">8747b24 Merge branch <span class="string">'master'</span> of /home/mrbird/projects/first-project</span><br><span class="line">27b76ec modify foo.txt <span class="keyword">in</span> original</span><br><span class="line">796e40d modify bar.html <span class="keyword">in</span> <span class="built_in">clone</span></span><br><span class="line">8e1b132 modify foo.txt,add <span class="string">'hello msg'</span></span><br><span class="line">94418b1 add bar.html,modify foo.txt,delete bar.txt</span><br><span class="line">c2e4810 add foo.txt bar.txt</span><br></pre></td></tr></table></figure><p>可发现，commit_id为ec88247…的记录已经不见了，如果要回退到这个版本，又忘记了与之对应的commit_id该怎么办呢。这时候可以使用 <strong><em>git reflog</em></strong> 命令来查看操作历史：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">47384c8 HEAD@&#123;0&#125;: reset: moving to 47384c8</span><br><span class="line">ec88247 HEAD@&#123;1&#125;: reset: moving to ec88247</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可看到，回退到commit_id为47384c8…的上一个版本的commit_id为ec88247…，所以，使用如下命令即可回到一开始回退前的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard ec88247</span><br><span class="line">HEAD is now at ec88247 modifyed bar.html,foo.txt add new.txt</span><br></pre></td></tr></table></figure><p>Git回退的三种类型: <code>git reset</code></p><ul><li>git reset –mixed HEAD~1:<strong><code>回退一个版本,且会将暂存区的内容和本地已提交的内容全部恢复到未暂存的状态,不影响原来本地文件(未提交的也不受影响)</code>。</strong></li><li>git reset –soft HEAD~1：<strong><code>回退一个版本,不清空暂存区,将已提交的内容恢复到暂存区,不影响原来本地的文件(未提交的也不受影响)</code></strong></li><li>git reset –hard HEAD~1：<strong><code>回退一个版本,清空暂存区,将已提交的内容的版本恢复到本地,本地的文件也将被恢复的版本替换</code></strong>。<strong>注意,这种方式是改变本地代码仓库源码</strong>。</li></ul><h3 id="Git版本回退：reset和revert的区别和使用场景"><a href="#Git版本回退：reset和revert的区别和使用场景" class="headerlink" title="Git版本回退：reset和revert的区别和使用场景"></a>Git版本回退：reset和revert的区别和使用场景</h3><h4 id="1-未使用git-add缓存代码"><a href="#1-未使用git-add缓存代码" class="headerlink" title="(1):未使用git add缓存代码"></a>(1):未使用git add缓存代码</h4><p>git checkout – filepathname 进行放弃文件修改。</p><p>git checkout . 放弃所有的文件修改。</p><p><code>该命令不会删除掉刚新建的文件。</code></p><h4 id="2-没有push-本地分支版本回退"><a href="#2-没有push-本地分支版本回退" class="headerlink" title="(2):没有push(本地分支版本回退)"></a>(2):没有push(本地分支版本回退)</h4><p><code>这种情况发生在你的本地代码仓库,可能你add ,commit 以后发现代码有点问题,准备取消提交,用到下面命令</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//找到需要回退的版本commit id</span><br><span class="line">git reflog</span><br><span class="line">// 回退版本</span><br><span class="line">git reset [--soft | --mixed | --hard</span><br><span class="line">git reset HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure><h4 id="3-已经push-公共远程分支版本"><a href="#3-已经push-公共远程分支版本" class="headerlink" title="(3):已经push(公共远程分支版本)"></a>(3):已经push(公共远程分支版本)</h4><p>对于已经把代码push到线上仓库,<strong>你回退本地代码其实也想同时回退线上代码,回滚到某个指定的版本,线上,线下代码保持一致</strong>。你要用到下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD //撤销最近一次提交</span><br><span class="line">git revert HEAD~1 //撤销上上次的提交,注意: 数字从0开始。</span><br><span class="line">git revert commit_id //撤销commit_id这次提交</span><br></pre></td></tr></table></figure><p>git revert用于反转提交,执行evert命令时要求<code>工作树必须是干净</code>的.</p><p><code>git revert用一个新提交来消除一个历史提交所做的任何修改.</code></p><p><strong><code>revert 之后你的本地代码会回滚到指定的历史版本</code></strong>,这时你再 git push 既可以把线上的代码更新.(这里不会像reset造成冲突的问题)。</p><p><code>revert 使用,需要先找到你想回滚版本唯一的commit标识代码</code>,可以用 git log 或者在adgit搭建的web环境历史提交记录里查看。通常是前几位即可。</p><p><strong>特别注意</strong>:不要使用下面方式来回滚公共远程分支版本(使用reset+push -f命令)。因为同事的本地分支并没有主动回退。(如果是一个人开发的，可以这样做)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//找到回退的版本</span><br><span class="line">git reflog</span><br><span class="line">git reset --hard HEAD~1(commit_id)</span><br><span class="line">git push -f</span><br></pre></td></tr></table></figure><blockquote><ol><li>revert是撤销一次提交,所以后面的commit id是你需要回滚到的版本的前一次提交。</li><li>使用revert HEAD是撤销最近的一次提交，如果你最近一次提交是用revert命令产生的，那么你再执行一次，就相当于撤销了上次的撤销操作，换句话说，你连续执行两次revert HEAD命令，就跟没执行是一样的。</li><li>使用revert HEAD~1 表示撤销最近2次提交，这个数字是从0开始的，如果你之前撤销过产生了commi id，那么也会计算在内的。</li><li>如果使用 revert 撤销的不是最近一次提交，那么一定会有代码冲突，需要你合并代码，合并代码只需要把当前的代码全部去掉，保留之前版本的代码就可以了。</li></ol></blockquote><h4 id="4-区别"><a href="#4-区别" class="headerlink" title="(4):区别"></a>(4):区别</h4><p><code>git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit</code></p><ul><li><p><code>git reset只是在本地仓库中回退版本，而远程仓库版本不会变化</code>。这样，即使本地reset,但是如果在git pull，</p><p>那么远程仓库内容又会和本地之前版本内容进行merge。</p></li><li><p>上面我们说的如果<code>你已经push到线上代码库, reset 删除指定commit以后,你git push可能导致一大堆冲突</code>。但是revert 并不会。</p></li><li><p>如果在日后现有分支和历史分支需要合并的时候,<code>reset 恢复部分的代码依然会出现在历史分支里</code>。但是revert 方向提交的commit 并不会出现在历史分支里。</p></li><li><p><code>reset 是在正常的commit历史中,删除了指定的commit,这时 HEAD 是向后移动了</code>,而 revert 是在正常的commit历史中再commit一次,只不过是反向提交,他的 HEAD 是一直向前的。</p></li></ul><h4 id="4-实例"><a href="#4-实例" class="headerlink" title="(4):实例"></a>(4):实例</h4><p>下面来看一个revert的使用例子</p><p>创建A.txt 内容为AAAA。然后添加到git</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"A.txt"</span></span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>修改A.txt 添加内容”BBBB”。然后添加到git</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"A.txt add BBBB"</span></span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>此时A.txt文件内容如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AAAA</span><br><span class="line">BBBB</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>此时的提交记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> </span><br><span class="line">---</span><br><span class="line">commit 329515ee5d367bda3effa3e8f0c958e98e93ce31</span><br><span class="line">Author: *****</span><br><span class="line">Date:   Tue Mar 6 19:25:39 2018 +0800</span><br><span class="line"></span><br><span class="line">    A.txt add BBBB</span><br><span class="line"></span><br><span class="line">commit fe0d9b1d7ed0176f542a52835b1923584a4ba060</span><br><span class="line">Author: *****</span><br><span class="line">Date:   Tue Mar 6 19:24:34 2018 +0800</span><br><span class="line"></span><br><span class="line">    A.txt</span><br><span class="line">12345678910111213</span><br></pre></td></tr></table></figure><p>现在我要撤回内容BBBB，如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git revert 329515</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>现在A.txt里的文件内容变为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AAAA</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>再次查看提交记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br><span class="line">---</span><br><span class="line">commit 23880e1f7649b7dca14cfda7553b2ff2e6088d6e</span><br><span class="line">Author: *****</span><br><span class="line">Date:   Tue Mar 6 19:29:35 2018 +0800</span><br><span class="line"></span><br><span class="line">    Revert <span class="string">"A.txt add BBBB"</span></span><br><span class="line"></span><br><span class="line">    This reverts commit 329515ee5d367bda3effa3e8f0c958e98e93ce31.</span><br><span class="line"></span><br><span class="line">commit 329515ee5d367bda3effa3e8f0c958e98e93ce31</span><br><span class="line">Author: *****</span><br><span class="line">Date:   Tue Mar 6 19:25:39 2018 +0800</span><br><span class="line"></span><br><span class="line">    A.txt add BBBB</span><br><span class="line"></span><br><span class="line">commit fe0d9b1d7ed0176f542a52835b1923584a4ba060</span><br><span class="line">Author: *****</span><br><span class="line">Date:   Tue Mar 6 19:24:34 2018 +0800</span><br><span class="line"></span><br><span class="line">    A.txt</span><br><span class="line">123456789101112131415161718192021</span><br></pre></td></tr></table></figure><p>可以看到我们撤回了提交的内容同时增加了一条commit记录。</p><p>如果<code>撤回到之前版本出现冲突</code>怎么办？我们先回到329515版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 329515</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>恢复后在往里面添加内容“CCCC”并提交。<br>此时A.txt文件内容为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AAAA</span><br><span class="line">BBBB</span><br><span class="line">CCCC</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>此时的提交记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> </span><br><span class="line">---</span><br><span class="line">commit f1258438d3b63e78bb747c510f9af3e56be5b3b0</span><br><span class="line">Author: *****</span><br><span class="line">Date:   Tue Mar 6 19:39:20 2018 +0800</span><br><span class="line"></span><br><span class="line">    A.txt add CCCC</span><br><span class="line"></span><br><span class="line">commit 329515ee5d367bda3effa3e8f0c958e98e93ce31</span><br><span class="line">Author: *****</span><br><span class="line">Date:   Tue Mar 6 19:25:39 2018 +0800</span><br><span class="line"></span><br><span class="line">    A.txt add BBBB</span><br><span class="line"></span><br><span class="line">commit fe0d9b1d7ed0176f542a52835b1923584a4ba060</span><br><span class="line">Author: *****</span><br><span class="line">Date:   Tue Mar 6 19:24:34 2018 +0800</span><br><span class="line"></span><br><span class="line">    A.txt</span><br><span class="line">12345678910111213141516171819</span><br></pre></td></tr></table></figure><p>然后我们撤回329515的修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git revert 329515</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>这个时候git提示你有冲突要解决。我们打开A.txt保留parent … 329515这个版本的内容(git add A.txt)，即”AAAA”。并执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git revert --<span class="built_in">continue</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>这个时候git会继续撤回，如果发现冲突会继续提示。此时的提交日志为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">commit 78979e45add34a0f009263e49cc1c6c48a0f93d4</span><br><span class="line">Author: *****</span><br><span class="line">Date:   Tue Mar 6 19:46:40 2018 +0800</span><br><span class="line"></span><br><span class="line">    Revert <span class="string">"A.txt add BBBB"</span></span><br><span class="line"></span><br><span class="line">    This reverts commit 329515ee5d367bda3effa3e8f0c958e98e93ce31.</span><br><span class="line"></span><br><span class="line">commit f1258438d3b63e78bb747c510f9af3e56be5b3b0</span><br><span class="line">Author: *****</span><br><span class="line">Date:   Tue Mar 6 19:39:20 2018 +0800</span><br><span class="line"></span><br><span class="line">    A.txt add CCCC</span><br><span class="line"></span><br><span class="line">commit 329515ee5d367bda3effa3e8f0c958e98e93ce31</span><br><span class="line">Author: *****</span><br><span class="line">Date:   Tue Mar 6 19:25:39 2018 +0800</span><br><span class="line"></span><br><span class="line">    A.txt add BBBB</span><br><span class="line"></span><br><span class="line">commit fe0d9b1d7ed0176f542a52835b1923584a4ba060</span><br><span class="line">Author: *****</span><br><span class="line">Date:   Tue Mar 6 19:24:34 2018 +0800</span><br><span class="line"></span><br><span class="line">    A.txt</span><br><span class="line">12345678910111213141516171819202122232425</span><br></pre></td></tr></table></figure><p>如果不想解决冲突的话可以取消撤回：<code>git revert --abort</code>。</p><h4 id="5-revert合并代码-解决冲突"><a href="#5-revert合并代码-解决冲突" class="headerlink" title="(5):revert合并代码,解决冲突"></a>(5):revert合并代码,解决冲突</h4><p>使用revert命令，如果不是撤销的最近一次提交，那么一定会有冲突，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">全部清空</span><br><span class="line">第一次提交</span><br><span class="line">=======</span><br><span class="line">全部清空</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; parent of c24cde7... 全部清空</span><br></pre></td></tr></table></figure><p>解决冲突很简单，因为我们只想回到某次提交，因此需要把当前最新的代码去掉即可，也就是HEAD标记的代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; </span><br><span class="line">HEAD全部清空</span><br><span class="line">第一次提交</span><br><span class="line">=======</span><br></pre></td></tr></table></figure><p>把上面部分代码去掉就可以了，然后再提交一次代码就可以解决冲突了。</p><h4 id="6-继续扩展-简单扩展的回滚方法"><a href="#6-继续扩展-简单扩展的回滚方法" class="headerlink" title="(6):继续扩展,简单扩展的回滚方法"></a>(6):继续扩展,简单扩展的回滚方法</h4><p>看到这里也许你已经觉得学会了远程仓库版本回滚方法了，但是实践中总是会遇到很多不按套路来的问题，考虑下面一种情况：</p><blockquote><p>如果你们开发中，忽然发现前面很远的地方有一次错误的合并代码，把本来下一次才能发的功能的代码合并到了这一次来了，这个时候全体成员都觉得直接回滚比较快，因为他们都有备份，覆盖了无所谓，这个时候用reset的话对队友的要求比较高，用revert的话呢要大面积的解决冲突，也很麻烦呀，怎么办呢？</p></blockquote><p>这个时候，可以使用简单粗暴的办法，直接从那个错误的提交的前一次拉取一份代码放到其他目录，然后将master代码全部删除，把那份新代码方进去，然后提交，果然简单粗暴啊，虽然这种方法不入流，但是，实践中发现很好使啊，所以，实践是检验真理的唯一标准。遇到问题还是要灵活应对。</p><h4 id="7-撤销文件三种情况"><a href="#7-撤销文件三种情况" class="headerlink" title="(7): 撤销文件三种情况"></a>(7): 撤销文件三种情况</h4><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192" target="_blank" rel="noopener">版本回退</a>一节，不过前提是没有推送到远程库。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git状态跟踪</title>
      <link href="/2019/08/07/Git%E7%8A%B6%E6%80%81%E8%B7%9F%E8%B8%AA/"/>
      <url>/2019/08/07/Git%E7%8A%B6%E6%80%81%E8%B7%9F%E8%B8%AA/</url>
      
        <content type="html"><![CDATA[<h2 id="Git状态跟踪"><a href="#Git状态跟踪" class="headerlink" title="Git状态跟踪"></a>Git状态跟踪</h2><p><strong>对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。</strong></p><p>1.已提交：表示该文件已经被安全地保存在版本库中了。</p><p>2.已修改：表示修改了某个文件，但还没有提交到暂存区。</p><p>3.已暂存：表示把已修改的文件已经放到暂存区了，下次提交时一并被保存到版本库中。</p><h3 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h3><p>要确定哪些文件当前处于什么状态，可以用   <strong>git status</strong> 命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>说明现在的工作目录相当干净，并且当前所在分支为master。</p><p>在当前目录下创建一个<strong>README</strong>文件，然后运行 <strong><em>git status</em></strong> 会看到该文件出现在未跟踪文件列表中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        README</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure><p>未跟踪的文件意味着Git在之前的快照（提交）中没有这些文件。</p><h3 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h3><p>使用命令 <strong><em>git add</em></strong> 开始跟踪文件README：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add README</span><br></pre></td></tr></table></figure><p>再运行 <strong><em>git status</em></strong> 命令，会看到 README 文件已被跟踪，并处于暂存状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   README</span><br></pre></td></tr></table></figure><p>只要在 “Changes to be committed” 这行下面的，就说明是已暂存状态。<code>git add</code> 后面可以指明要跟踪的文件或目录路径。如果是目录的话，就说明要递归跟踪该目录下的所有文件。</p><h3 id="暂存已修改的文件"><a href="#暂存已修改的文件" class="headerlink" title="暂存已修改的文件"></a>暂存已修改的文件</h3><p>修改已跟踪过的文件 README，然后再次运行 <strong><em>git status</em></strong> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   README</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   README</span><br></pre></td></tr></table></figure><p>README文件出现了两次，一次是未暂存，一次是一暂存。如果现在提交的话，那么提交的将是已暂存的README，对README的修改并不会被提交。</p><p>重新运行 <strong>git add</strong> 把最新版本README重新暂存起来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git add README</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &apos;origin/master&apos;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   README</span><br></pre></td></tr></table></figure><h4 id="忽略某些文件"><a href="#忽略某些文件" class="headerlink" title="忽略某些文件"></a>忽略某些文件</h4><p><strong>如日志文件，编译缓存文件等没必要纳入Git管理的文件</strong>，我们可以创建一个<strong>.gitignore</strong>文件来将这些文件排除在外。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitignore</span><br><span class="line">*.[oa]</span><br><span class="line">*~</span><br></pre></td></tr></table></figure><p>第一行告诉 Git 忽略所有以 <code>.o</code> 或 <code>.a</code> 结尾的文件。</p><p>第二行告诉 Git 忽略所有以波浪符（~）结尾的文件。</p><p><strong>文件 .gitignore 的格式规范如下：</strong></p><ul><li>所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配（glob指shell简化后的正则表达式）。</li><li>匹配模式最后跟反斜杠（/）说明要忽略的是目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li><li>例子如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 此为注释 – 将被 Git 忽略</span><br><span class="line"># 忽略所有 .a 结尾的文件</span><br><span class="line">*.a</span><br><span class="line"># 但 lib.a 除外</span><br><span class="line">!lib.a</span><br><span class="line"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">/TODO</span><br><span class="line"># 忽略 build/ 目录下的所有文件</span><br><span class="line">build/</span><br><span class="line"># 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br><span class="line"># ignore all .txt files in the doc/ directory</span><br><span class="line">doc/**/*.txt</span><br></pre></td></tr></table></figure><h3 id="查看已暂存和未暂存的更新"><a href="#查看已暂存和未暂存的更新" class="headerlink" title="查看已暂存和未暂存的更新"></a>查看已暂存和未暂存的更新</h3><p>再次修改README文件，但不添加到暂存区。现在README已经修改了两次，第一次添加内容“hello git”并且使用 git add 添加到了暂存区。第二次添加内容“hello world”，但并未添加到暂存区。</p><p>若要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用 <strong><em>git diff –staged</em></strong> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --staged</span><br><span class="line">diff --git a/README b/README</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..8d0e412</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/README</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+hello git</span><br></pre></td></tr></table></figure><p>直接使用 <strong><em>git diff</em></strong> 命令查看已暂存和未暂存文件之间的差异：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/README b/README</span><br><span class="line">index 8d0e412..05fe86c 100644</span><br><span class="line">--- a/README</span><br><span class="line">+++ b/README</span><br><span class="line">@@ -1 +1,2 @@</span><br><span class="line"> hello git</span><br><span class="line">+hello world</span><br></pre></td></tr></table></figure><p>可看到，对于README文件来说，未暂存和已暂存文件相比，添加了一行“hello world”。</p><h3 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h3><p>使用 <strong><em>git commit -m</em></strong> 命令来提交更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &apos;创建README文件，内容为hello git&apos;</span><br><span class="line">[master 1f9882d] 创建README文件，内容为hello git</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 README</span><br></pre></td></tr></table></figure><h3 id="跳过暂存区"><a href="#跳过暂存区" class="headerlink" title="跳过暂存区"></a>跳过暂存区</h3><p>假如你觉得 <strong><em>git add</em></strong> 过程繁琐，可以使用 <strong><em>git commit -a</em></strong> 命令来跳过添加文件到暂存区的步骤，直接提交。</p><p>比如，对于README的第二次修改，我们还未将其添加到暂存区，所以第一次使用 <strong><em>git commit</em></strong> 命令只是提交了对README文件的第一次修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of &apos;origin/master&apos; by 1 commit.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   README</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>使用 <strong><em>git commit -a</em></strong> 命令直接将README文件的第二次修改提交到版本库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -a -m &quot;添加hello world&quot;</span><br><span class="line">[master db06721] 添加hello world</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>移除文件分为两种情况：从版本库和本地工作目录中移除；仅从版本库移除。</p><p>1.从版本库和本地工作目录中移除。使用 <strong><em>git rm</em></strong> 命令来移除README:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git rm README</span><br><span class="line">rm &apos;README&apos;</span><br><span class="line">$ git commit -m &apos;删除README&apos;</span><br><span class="line">[master 99a0462] 删除README</span><br><span class="line"> 1 file changed, 3 deletions(-)</span><br><span class="line"> delete mode 100644 README</span><br></pre></td></tr></table></figure><p>到本地工作目录下查看，会发现README文件已经不存在了。</p><p>这里有种情况，假如README文件还在暂存区并未提交，使用 git rm 命令将会出错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git rm README</span><br><span class="line">error: the following file has changes staged in the index:</span><br><span class="line">    README</span><br><span class="line">(use --cached to keep the file, or -f to force removal)</span><br></pre></td></tr></table></figure><p>Git提示我们使用 <strong><em>git rm -f</em></strong> 命令来删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git rm -f temp.log</span><br><span class="line">rm &apos;temp.log&apos;</span><br></pre></td></tr></table></figure><p>2.仅从版本库移除。</p><p>比如现在不小心将temp.log文件添加并提交到版本库中了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git add temp.log</span><br><span class="line">$ git commit -m &quot;add temp.log&quot;</span><br><span class="line">[master fa31ea5] add temp.log</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 temp.log</span><br></pre></td></tr></table></figure><p>现在想将其从版本库中删除，但并不删除本地文件，而是随后将其添加到.gitignore文件中，可以使用命令 <strong><em>git rm –cached</em></strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git rm --cached  temp.log</span><br><span class="line">rm &apos;temp.log&apos;</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;delete temp.log&quot;</span><br><span class="line">[master e512a82] delete temp.log</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> delete mode 100644 temp.log</span><br></pre></td></tr></table></figure><h3 id="移动文件（重命名）"><a href="#移动文件（重命名）" class="headerlink" title="移动文件（重命名）"></a>移动文件（重命名）</h3><p>git mv 命令用来重命名文件，比如将REAME文件重命名为README.config：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git mv README README.config</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 7 commits.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">        renamed:    README -&gt; README.config</span><br></pre></td></tr></table></figure><p>其过程类似于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv README README.config</span><br><span class="line">$ git rm README</span><br><span class="line">$ git add README.config</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git撤销操作</title>
      <link href="/2019/08/07/Git%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/08/07/Git%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="Git撤销操作"><a href="#Git撤销操作" class="headerlink" title="Git撤销操作"></a>Git撤销操作</h2><h3 id="修改最后一次提交"><a href="#修改最后一次提交" class="headerlink" title="修改最后一次提交"></a>修改最后一次提交</h3><p>如果提交后发现想要修改提交信息，可以直接使用  <strong><em>git commit –amend，</em></strong>使用该命令后，Git会启动文本编辑器，然后可看到上次提交时的说明，编辑它确认没问题后保存退出，就会使用新的提交说明覆盖刚才的提交信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><p>如果刚才提交时忘了暂存某些修改，可以先补上暂存操作，然后再运行 <code>--amend</code> 提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add forgotten_file</span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><h3 id="取消已经暂存的文件"><a href="#取消已经暂存的文件" class="headerlink" title="取消已经暂存的文件"></a>取消已经暂存的文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 8 commits.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   README.config</span><br><span class="line">        modified:   README.md</span><br></pre></td></tr></table></figure><p>使用命令 <strong><em>git reset HEAD README.config</em></strong>  将<strong>README.config</strong>移出暂存区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD README.config</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       README.config</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 8 commits.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">        modified:   README.config</span><br></pre></td></tr></table></figure><p>可看到，README.config已经为Changes not staged for commit状态。</p><h3 id="取消对文件的修改"><a href="#取消对文件的修改" class="headerlink" title="取消对文件的修改"></a>取消对文件的修改</h3><p>将README.config移出暂存区后，可以进一步使用命令，<strong><em>git checkout – README.config</em></strong> 取消对README.config的修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cat README.config</span><br><span class="line">hello</span><br><span class="line"></span><br><span class="line">$ git checkout -- README.config</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 8 commits.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">$ cat README.config</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ListenableFuture的使用心得</title>
      <link href="/2019/08/06/ListenableFuture%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
      <url>/2019/08/06/ListenableFuture%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<h3 id="1-由来"><a href="#1-由来" class="headerlink" title="1.由来"></a>1.由来</h3><p>​    <strong>ListenableFuture是可以监听的Future任务执行情况，是执行成功还是执行失败，并提供响应接口用于对不同结果进行处理。如果异步任务完成自动调用回调函数，减少并发程序复杂度。</strong></p><p>​     <strong>Future以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。</strong>阻塞的方式显然和我们的异步编程的初衷相违背，轮询的方式又会耗费无谓的CPU资源，而且也不能及时地得到计算结果，为什么不能用观察者设计模式当计算结果完成及时通知监听者呢？</p><h3 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2.适用场景"></a>2.适用场景</h3><ul><li>如果一个主任务开始执行，然后需要执行各个小任务，并且需要等待返回结果，统一返回给前端，此时Future和ListenableFuture作用几乎差不多，都是通过get()方法阻塞等待每个任务执行完毕返回。</li><li>如果一个主任务开始执行，然后执行各个小任务，主任务不需要等待每个小任务执行完，不需要每个小任务的结果，此时用ListenableFuture非常合适，它提供的FutureCallBack接口可以对每个任务的成功或失败单独做出响应。</li></ul><h3 id="3-使用示例"><a href="#3-使用示例" class="headerlink" title="3.使用示例"></a>3.使用示例</h3><p>(1):<strong>使用Future示例: 需要阻塞轮训，查看异步任务是否完成。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> denny.zhang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: FutureDemo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: Future多线程并发任务结果归集</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016年11月4日 下午1:50:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Long start = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//开启多线程</span></span><br><span class="line">        ExecutorService exs = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//结果集</span></span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            List&lt;Future&lt;Integer&gt;&gt; futureList = <span class="keyword">new</span> ArrayList&lt;Future&lt;Integer&gt;&gt;();</span><br><span class="line"><span class="comment">//1.高速提交10个任务，每个任务返回一个Future入list</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                futureList.add(exs.submit(<span class="keyword">new</span> CallableTask(i + <span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            Long getResultStart = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">"结果归集开始时间="</span> + <span class="keyword">new</span> Date());</span><br><span class="line"><span class="comment">//2.结果归集，遍历futureList,高速轮询（模拟实现了并发）获取future状态成功完成后获取结果，退出当前循环</span></span><br><span class="line">            <span class="keyword">for</span> (Future&lt;Integer&gt; future : futureList) &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">//CPU高速轮询：每个future都并发轮循，判断完成状态然后获取结果，这一行，是本实现方案的精髓所在。即有10个future在高速轮询，完成一个future的获取结果，就关闭一个轮询</span></span><br><span class="line">                    <span class="keyword">if</span> (future.isDone() &amp;&amp; !future.isCancelled()) &#123;<span class="comment">//获取future成功完成状态，如果想要限制每个任务的超时时间，取消本行的状态判断+future.get(1000*1, TimeUnit.MILLISECONDS)+catch超时异常使用即可。</span></span><br><span class="line">                        Integer i = future.get();<span class="comment">//获取结果</span></span><br><span class="line">                        System.out.println(<span class="string">"任务i="</span> + i + <span class="string">"获取完成!"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">                        list.add(i);</span><br><span class="line">                        <span class="keyword">break</span>;<span class="comment">//当前future获取结果完毕，跳出while</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1</span>);<span class="comment">//每次轮询休息1毫秒（CPU纳秒级），避免CPU高速轮循耗空CPU---》新手别忘记这个</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"list="</span> + list);</span><br><span class="line">            System.out.println(<span class="string">"总耗时="</span> + (System.currentTimeMillis() - start) + <span class="string">",取结果归集耗时="</span> + (System.currentTimeMillis() - getResultStart));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            exs.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">        Integer i;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CallableTask</span><span class="params">(Integer i)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.i = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);<span class="comment">//任务1耗时3秒</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);<span class="comment">//任务5耗时5秒</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);<span class="comment">//其它任务耗时1秒</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"task线程："</span> + Thread.currentThread().getName() + <span class="string">"任务i="</span> + i + <span class="string">",完成！"</span>);</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2):<strong>使用**</strong>CompletionService，<strong>**任务先完成优先获取到，结果按照任务的完成先后顺序排序。内部通过阻塞队列+FutureTask。</strong></p><p>(3):<strong>使用ListenableFuture，异步任务完成之后进行回调，不用在主线程进行等待</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Guava 和 spring4.0</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestListenableFuture</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> ListeningExecutorService service = MoreExecutors.listeningDecorator(Executors.newCachedThreadPool());</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 任务1</span></span><br><span class="line">        ListenableFuture&lt;Boolean&gt; booleanTask = service.submit(<span class="keyword">new</span> Callable&lt;Boolean&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 增加回调函数</span></span><br><span class="line">        Futures.addCallback(booleanTask, <span class="keyword">new</span> FutureCallback&lt;Boolean&gt;() &#123;</span><br><span class="line">            <span class="comment">// 成功处理</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Boolean result)</span> </span>&#123;</span><br><span class="line">                System.err.println(<span class="string">"BooleanTask: "</span> + result);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 失败处理</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 任务2</span></span><br><span class="line">        ListenableFuture&lt;String&gt; stringTask = service.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-原理分析"><a href="#4-原理分析" class="headerlink" title="4.原理分析"></a>4.原理分析</h3><h5 id="1-Future增加监听机制相关类"><a href="#1-Future增加监听机制相关类" class="headerlink" title="(1):Future增加监听机制相关类"></a>(1):Future增加监听机制相关类</h5><ol><li><strong>ListenableFuture</strong>：增加扩展功能使用，addCallback()方法为了支持增加回调函数</li><li><strong>ListenableFutureCallback：</strong>Future回调函数接口</li><li><strong>ListenableFutureTask</strong>：<strong>FutureTask子类，主要是为了增加回调函数注册和回调函数调用功能。该类重写了done()方法，执行对回调函数队列的调用。</strong></li><li><strong>ListenableFutureCallbackRegistry</strong>：回调函数注册类，调用addCallback()注册ListenableFutureTask<t>。</t></li></ol><h5 id="2-ListenableFutureTask"><a href="#2-ListenableFutureTask" class="headerlink" title="(2):ListenableFutureTask"></a>(2):<strong>ListenableFutureTask</strong></h5><p><strong>该类继承了FutureTask，重写了done()方法。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Extension of &#123;<span class="doctag">@link</span> FutureTask&#125; that implements &#123;<span class="doctag">@link</span> ListenableFuture&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Arjen Poutsma</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenableFutureTask</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">ListenableFuture</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并发编程,尽量使用final关键字,让变量不可变.</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ListenableFutureCallbackRegistry&lt;T&gt; callbacks = <span class="keyword">new</span> ListenableFutureCallbackRegistry&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Create a new &#123;<span class="doctag">@code</span> ListenableFutureTask&#125; that will, upon running,</span></span><br><span class="line"><span class="comment">   * execute the given &#123;<span class="doctag">@link</span> Callable&#125;.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> callable the callable task</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ListenableFutureTask</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(callable);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Create a &#123;<span class="doctag">@code</span> ListenableFutureTask&#125; that will, upon running,</span></span><br><span class="line"><span class="comment">   * execute the given &#123;<span class="doctag">@link</span> Runnable&#125;, and arrange that &#123;<span class="doctag">@link</span> #get()&#125;</span></span><br><span class="line"><span class="comment">   * will return the given result on successful completion.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> runnable the runnable task</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> result the result to return on successful completion</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ListenableFutureTask</span><span class="params">(Runnable runnable, @Nullable T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(runnable, result);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Throwable cause;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 成功</span></span><br><span class="line">      T result = get();</span><br><span class="line">      <span class="keyword">this</span>.callbacks.success(result);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 第一处捕获异常</span></span><br><span class="line">    <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            <span class="comment">// 异常,则中断线程</span></span><br><span class="line">      Thread.currentThread().interrupt();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 第二处捕获异常</span></span><br><span class="line">    <span class="keyword">catch</span> (ExecutionException ex) &#123;</span><br><span class="line">            <span class="comment">// JUC并发异常,需要捕获ExecutionException异常</span></span><br><span class="line">      cause = ex.getCause();</span><br><span class="line">      <span class="keyword">if</span> (cause == <span class="keyword">null</span>) &#123;</span><br><span class="line">        cause = ex;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 第三处捕获异常</span></span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      cause = ex;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 失败添加</span></span><br><span class="line">    <span class="keyword">this</span>.callbacks.failure(cause);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-ListenableFutureCallbackRegistry：回调函数注册类"><a href="#3-ListenableFutureCallbackRegistry：回调函数注册类" class="headerlink" title="(3):ListenableFutureCallbackRegistry：回调函数注册类"></a>(3):ListenableFutureCallbackRegistry：回调函数注册类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenableFutureCallbackRegistry</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;SuccessCallback&lt;? <span class="keyword">super</span> T&gt;&gt; successCallbacks = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;FailureCallback&gt; failureCallbacks = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> State state = State.NEW;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">private</span> Object result;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      互斥锁,控制并发变量,这里需要控制线程执行状态。NEW,SUCCESS,FAILURE</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object mutex = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCallback</span><span class="params">(ListenableFutureCallback&lt;? <span class="keyword">super</span> T&gt; callback)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(callback, <span class="string">"'callback' must not be null"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.mutex) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">this</span>.state) &#123;</span><br><span class="line">        <span class="keyword">case</span> NEW:</span><br><span class="line">          <span class="keyword">this</span>.successCallbacks.add(callback);</span><br><span class="line">          <span class="keyword">this</span>.failureCallbacks.add(callback);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SUCCESS:</span><br><span class="line">          notifySuccess(callback);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FAILURE:</span><br><span class="line">          notifyFailure(callback);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifySuccess</span><span class="params">(SuccessCallback&lt;? <span class="keyword">super</span> T&gt; callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      callback.onSuccess((T) <span class="keyword">this</span>.result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="comment">// Ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyFailure</span><span class="params">(FailureCallback callback)</span> </span>&#123;</span><br><span class="line">    Assert.state(<span class="keyword">this</span>.result <span class="keyword">instanceof</span> Throwable, <span class="string">"No Throwable result for failure state"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      callback.onFailure((Throwable) <span class="keyword">this</span>.result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="comment">// Ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSuccessCallback</span><span class="params">(SuccessCallback&lt;? <span class="keyword">super</span> T&gt; callback)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(callback, <span class="string">"'callback' must not be null"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.mutex) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">this</span>.state) &#123;</span><br><span class="line">        <span class="keyword">case</span> NEW:</span><br><span class="line">          <span class="keyword">this</span>.successCallbacks.add(callback);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SUCCESS:</span><br><span class="line">          notifySuccess(callback);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFailureCallback</span><span class="params">(FailureCallback callback)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(callback, <span class="string">"'callback' must not be null"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.mutex) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">this</span>.state) &#123;</span><br><span class="line">        <span class="keyword">case</span> NEW:</span><br><span class="line">          <span class="keyword">this</span>.failureCallbacks.add(callback);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FAILURE:</span><br><span class="line">          notifyFailure(callback);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">success</span><span class="params">(@Nullable T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.mutex) &#123;</span><br><span class="line">      <span class="keyword">this</span>.state = State.SUCCESS;</span><br><span class="line">      <span class="keyword">this</span>.result = result;</span><br><span class="line">      SuccessCallback&lt;? <span class="keyword">super</span> T&gt; callback;</span><br><span class="line">      <span class="keyword">while</span> ((callback = <span class="keyword">this</span>.successCallbacks.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        notifySuccess(callback);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failure</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.mutex) &#123;</span><br><span class="line">      <span class="keyword">this</span>.state = State.FAILURE;</span><br><span class="line">      <span class="keyword">this</span>.result = ex;</span><br><span class="line">      FailureCallback callback;</span><br><span class="line">      <span class="keyword">while</span> ((callback = <span class="keyword">this</span>.failureCallbacks.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        notifyFailure(callback);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">enum</span> State &#123;NEW, SUCCESS, FAILURE&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5：设计模式运用"><a href="#5：设计模式运用" class="headerlink" title="5：设计模式运用"></a>5：设计模式运用</h2><h4 id="1-适配器模式：FutureAdapter-对象适配器-使用聚合的方式-，ListenableFutureAdapter-类适配器-使用继承的方式-。"><a href="#1-适配器模式：FutureAdapter-对象适配器-使用聚合的方式-，ListenableFutureAdapter-类适配器-使用继承的方式-。" class="headerlink" title="(1):适配器模式：FutureAdapter(对象适配器,使用聚合的方式)，ListenableFutureAdapter(类适配器,使用继承的方式)。"></a>(1):适配器模式：FutureAdapter(对象适配器,使用聚合的方式)，ListenableFutureAdapter(类适配器,使用继承的方式)。</h4><p><strong>对象适配器：**</strong>FutureAdapter**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureAdapter</span>&lt;<span class="title">T</span>, <span class="title">S</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Future&lt;S&gt; adaptee;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">private</span> Object result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> State state = State.NEW;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object mutex = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructs a new &#123;<span class="doctag">@code</span> FutureAdapter&#125; with the given adaptee.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> adaptee the future to delegate to</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">FutureAdapter</span><span class="params">(Future&lt;S&gt; adaptee)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(adaptee, <span class="string">"Delegate must not be null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the adaptee.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Future&lt;S&gt; <span class="title">getAdaptee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.adaptee;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> T <span class="title">adaptInternal</span><span class="params">(S adapteeResult)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.mutex) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">this</span>.state) &#123;</span><br><span class="line">        ...</span><br><span class="line">                ...</span><br><span class="line">                ...</span><br><span class="line">        <span class="keyword">case</span> NEW:</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            T adapted = adapt(adapteeResult);</span><br><span class="line">            <span class="keyword">this</span>.result = adapted;</span><br><span class="line">            <span class="keyword">this</span>.state = State.SUCCESS;</span><br><span class="line">            <span class="keyword">return</span> adapted;</span><br><span class="line">          &#125;</span><br><span class="line">          ...</span><br><span class="line">                    ...</span><br><span class="line">                    ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Adapts the given adaptee's result into T.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the adapted result</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title">adapt</span><span class="params">(S adapteeResult)</span> <span class="keyword">throws</span> ExecutionException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类适配器：**</strong>ListenableFutureAdapter**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenableFutureAdapter</span>&lt;<span class="title">T</span>, <span class="title">S</span>&gt; <span class="keyword">extends</span> <span class="title">FutureAdapter</span>&lt;<span class="title">T</span>, <span class="title">S</span>&gt; <span class="keyword">implements</span> <span class="title">ListenableFuture</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Construct a new &#123;<span class="doctag">@code</span> ListenableFutureAdapter&#125; with the given adaptee.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> adaptee the future to adapt to</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">ListenableFutureAdapter</span><span class="params">(ListenableFuture&lt;S&gt; adaptee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(adaptee);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCallback</span><span class="params">(<span class="keyword">final</span> SuccessCallback&lt;? <span class="keyword">super</span> T&gt; successCallback, <span class="keyword">final</span> FailureCallback failureCallback)</span> </span>&#123;</span><br><span class="line">    ListenableFuture&lt;S&gt; listenableAdaptee = (ListenableFuture&lt;S&gt;) getAdaptee();</span><br><span class="line">    listenableAdaptee.addCallback(<span class="keyword">new</span> ListenableFutureCallback&lt;S&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(@Nullable S result)</span> </span>&#123;</span><br><span class="line">        T adapted = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            adapted = adaptInternal(result);</span><br><span class="line">          &#125;</span><br><span class="line">          ...</span><br><span class="line">                    ...</span><br><span class="line">                    ...</span><br><span class="line">        &#125;</span><br><span class="line">        successCallback.onSuccess(adapted);</span><br><span class="line">      &#125;</span><br><span class="line">            </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">        failureCallback.onFailure(ex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Guava </tag>
            
            <tag> Spring </tag>
            
            <tag> ListenableFuture </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lamdba表达式学习(Java8)</title>
      <link href="/2019/08/06/Lamdba%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0-Java8/"/>
      <url>/2019/08/06/Lamdba%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0-Java8/</url>
      
        <content type="html"><![CDATA[<h2 id="1：lamdba语法"><a href="#1：lamdba语法" class="headerlink" title="1：lamdba语法"></a>1：lamdba语法</h2><p>java8新增了一个操作符-&gt;，称为lambda操作符或箭头操作符，它将lambda表达式分为两部分，箭头之前的是参数，箭头之后的是动作。例如：</p><blockquote><p>(Integer n1,Integer n2) -&gt; n1 + n2</p></blockquote><p>这个就相当于</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function">Integer <span class="title">method</span><span class="params">(Integer n1, Integer n2)</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">return</span> n1 + n2;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>参数类型可以忽略，可以推断出来。</p><blockquote><p>(n1,n2) -&gt; n1 + n2</p></blockquote><p>如果只有一个参数的话，圆括号也可以省略，像这样</p><blockquote><p>n1 -&gt; n1 * n1</p></blockquote><p>如果没有参数，如下所示：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; () -&gt; <span class="number">5</span>; <span class="comment">//固定返回5</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>箭头符号右侧是动作，除了我们看到的这种单行的形式之外，还可以声明一个代码段作为动作，像下面这样</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; n -&gt; &#123;</span><br><span class="line">&gt;     <span class="keyword">return</span> n * n;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>这个代码段可以写的很长很长。如果有返回值的话，需要使用return语句返回。</p><h2 id="2-函数接口-FunctionInterface"><a href="#2-函数接口-FunctionInterface" class="headerlink" title="2:函数接口: FunctionInterface"></a>2:函数接口: FunctionInterface</h2><p>在java中，lambda表达式一定要结合functional interface来使用，functional interface是指一个只包含一个抽象方法的接口，可以包含默认实现<strong>default</strong>。下面来看一个例子。这是一个functional interface：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs this operation on the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the input argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed &#123;<span class="doctag">@code</span> Consumer&#125; that performs, in sequence, this</span></span><br><span class="line"><span class="comment">     * operation followed by the &#123;<span class="doctag">@code</span> after&#125; operation. If performing either</span></span><br><span class="line"><span class="comment">     * operation throws an exception, it is relayed to the caller of the</span></span><br><span class="line"><span class="comment">     * composed operation.  If performing this operation throws an exception,</span></span><br><span class="line"><span class="comment">     * the &#123;<span class="doctag">@code</span> after&#125; operation will not be performed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> after the operation to perform after this operation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed &#123;<span class="doctag">@code</span> Consumer&#125; that performs in sequence this</span></span><br><span class="line"><span class="comment">     * operation followed by the &#123;<span class="doctag">@code</span> after&#125; operation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> after&#125; is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-变量捕获"><a href="#3-变量捕获" class="headerlink" title="3:变量捕获"></a>3:变量捕获</h3><p>说到lambda表达式，有一个话题是绕不开的，就是<strong>闭包</strong>。但这个问题在java中被简化了好多。这个问题可以分为两种情况来讨论：</p><ol><li>lambda表达式可以访问到所在的类中定义的字段(filed)，也可以修改这个字段。</li><li>lambda表达式可以访问到外层代码块(enclosing scope)中定义的局部变量(local varable)，但不能修改他们，并且，<strong>如果一个局部变量在lambda表达式中被读取的话，这个变量必须是final或事实上final</strong>（变量赋值以后就不能再任何地方再修改了）。<strong>如果在匿名类或 Lambda 表达式中访问的局部变量，如果不是 final 类型的话，编译器自动加上 final 修饰符。</strong></li><li><strong>为什么 Lambda 表达式(匿名类) 不能访问非 final 的局部变量呢？</strong></li></ol><blockquote><p><strong>因为实例变量存在堆中，而局部变量是在栈上分配，Lambda 表达(匿名类) 会在另一个线程中执行。如果在线程中要直接访问一个局部变量，可能线程执行时该局部变量已经被销毁了，而 final 类型的局部变量在 Lambda 表达式(匿名类) 中其实是局部变量的一个拷贝。</strong> </p></blockquote><p>  4.局部变量类型</p><p>   <strong>(1):对象类型，则对象的引用地址不可改变。</strong></p><p>  <strong>(2):基本类型,，则对象的值不能改变。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> filed1 = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> varable1 = <span class="number">10</span>;</span><br><span class="line">        MyInterface myInterface = n -&gt; &#123;</span><br><span class="line">            filed1 += <span class="number">2</span>;  <span class="comment">//可读取，可修改</span></span><br><span class="line">            <span class="keyword">int</span> m = varable1;  <span class="comment">//可读取</span></span><br><span class="line">            <span class="comment">//varable1 += 2;  //不可修改</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//varable1 += 2;    //已经在lambda表达式中被读取了，就是final了，不能被修改。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-方法引用"><a href="#4-方法引用" class="headerlink" title="4:方法引用"></a>4:方法引用</h3><p><strong>lambda表达式的本质是一个匿名方法</strong>，但如果有一个方法的签名（参数列表和返回值）和functional interface的签名一样并且逻辑正好是你需要的，那么你可以使用方法引用的方式来将它赋值给你的functional interface，而无需再编写lambda表达式。</p><p><strong>方法引用类型：</strong></p><ul><li>静态方法: 语法: <strong>ClassName::methodName</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myInterface = MyClass::staticMethod;</span><br><span class="line">myInterface.doSomething(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><ul><li>实例方法: 语法:  <strong>instance::methodName</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">myInterface = myClass::instanceMethod;</span><br><span class="line">myInterface.doSomething(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><ul><li>泛型方法: 语法：<strong>instace::<t>methodNam</t></strong>e</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">myInterface = myClass::&lt;integer&gt;genericMethod;</span><br><span class="line">myInterface.doSomething(5);&lt;/integer&gt;</span><br></pre></td></tr></table></figure><ul><li></li><li><p>构造方法: 语法: <strong>ClassName::new</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    String msg1, msg2;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">(String msg1, String msg2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg1 = msg1;</span><br><span class="line">        <span class="keyword">this</span>.msg2 = msg2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FooInterface</span> </span>&#123;</span><br><span class="line">    <span class="function">Foo <span class="title">fooMethod</span><span class="params">(String m1, String m2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FooInterface fooInterface = Foo::<span class="keyword">new</span>;</span><br><span class="line">Foo fooObj = fooInterface.fooMethod(<span class="string">"hello"</span>, <span class="string">"world"</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> lamdba </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot配置篇</title>
      <link href="/2019/08/06/Spring-Boot%E9%85%8D%E7%BD%AE%E7%AF%87/"/>
      <url>/2019/08/06/Spring-Boot%E9%85%8D%E7%BD%AE%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1:概述"></a>1:概述</h3><p>SpringBoot支持外部化配置,配置文件格式如下所示:</p><ul><li>properties files</li><li>yaml files</li><li>environment variables</li><li>command-line arguments</li></ul><p>使用外部化配置方式:</p><ul><li>@Value注解</li><li>Environment抽象(Spring环境接口抽象)</li><li>@ConfigurationProperties</li><li>PropertySource(文件属性抽象)</li></ul><p>2:自定义属性</p><p>POM内容如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--生成spring-configuration-metadata.json文件,提示属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当使用Spring Boot开发项目时,Spring Boot会默认读取classpath下application.properties</p><p>application.yml文件,详情请查看源码ConfigFileApplicationListener。这种自定义少量</p><p>属性常常通过@Value注解进行加载,但是@Value所在类必须在Spring IOC容器中。</p><p>application.yml自定义属性</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hello:</span></span><br><span class="line"><span class="attr">  user:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">"刘恩源"</span></span><br></pre></td></tr></table></figure><p>读取该属性常常通过@Value注解进行读取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloUser</span> </span>&#123;</span><br><span class="line"><span class="comment">//hello.user.name:default==&gt;&gt;表示当时该属性在</span></span><br><span class="line">    <span class="comment">//spring Environment没有找到取默认值default</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;hello.user.name:default&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类描述: spring boot config</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/6/16 11:36</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.annotation.Value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.annotation.PropertySource</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.boot.context.properties.ConfigurationProperties</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.boot.context.properties.EnableConfigurationProperties</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.core.env.Environment</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.annotation.Profile</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.support.PropertySourcesPlaceholderConfigurer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(ConfigApplication.class, args);</span><br><span class="line">        HelloUser helloUser = context.getBean(HelloUser.class);</span><br><span class="line">        System.out.println(String.format(<span class="string">"通过@Value注解读取自定义的少量属性: %s"</span>, helloUser.getUserName()));</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Value注解注入使用情况</p><p>转载自:<a href="https://www.cnblogs.com/wangbin2188/p/9014837.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangbin2188/p/9014837.html</a> </p><ul><li><p>注入普通字符串</p></li><li><p>注入操作系统属性</p></li><li><p>注入表达式结果</p></li><li><p>注入其他Bean属性</p></li><li><p>注入文件资源</p></li><li><p>注入URL资源</p></li><li><p>注入${…}来处理placeholder。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"normal"</span>)</span><br><span class="line"><span class="keyword">private</span> String normal; <span class="comment">// 注入普通字符串</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"#&#123;systemProperties['os.name']&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String systemPropertiesName; <span class="comment">// 注入操作系统属性</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"#&#123; T(java.lang.Math).random() * 100.0 &#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> randomNumber; <span class="comment">//注入表达式结果</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"#&#123;beanInject.another&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String fromAnotherBean; <span class="comment">// 注入其他Bean属性：注入beanInject对象的属性another，类具体定义见下面</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"classpath:com/hry/spring/configinject/config.txt"</span>)</span><br><span class="line"><span class="keyword">private</span> Resource resourceFile; <span class="comment">// 注入文件资源</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line"><span class="keyword">private</span> Resource testUrl; <span class="comment">// 注入URL资源</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-将配置文件属性赋给实体类"><a href="#3-将配置文件属性赋给实体类" class="headerlink" title="3:将配置文件属性赋给实体类"></a>3:将配置文件属性赋给实体类</h3><p>当有许多配置属性(建议超过5这样),可以将这些属性作为字段来创建一个JavaBean,并将属性赋给他们。例如</p><p>在application.yml配置属性如下:</p><pre><code>person:  name: &quot;刘恩源&quot;  age: 21  school: &quot;天津师范大学&quot;</code></pre><p>配置属性类PersonProperties</p><p>@ConfigurationProperties注解是将properties配置文件转换为bean使用,默认是将application.yml</p><p>或者application.properties属性转换成bean使用。@PropertySource只支持properties结尾的文件。</p><p>@EnableConfigurationProperties注解的作用是@ConfigurationProperties注解生效,并将属性</p><p>配置类注册到Spring IOC容器中。 如果需要加载指定配置文件,可以使用@PropertySource注解。    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String school;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;PersonProperties.class&#125;)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PersonProperties personProperties;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonConfiguration</span><span class="params">(PersonProperties personProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.personProperties = personProperties;</span><br><span class="line">        System.out.println(String.format(<span class="string">"PersonProperties: %s"</span>, <span class="keyword">this</span>.personProperties));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PersonProperties <span class="title">getPersonProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> personProperties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-自定义配置文件"><a href="#4-自定义配置文件" class="headerlink" title="4:自定义配置文件"></a>4:自定义配置文件</h3><p>上面介绍了读取默认配置文件application.yml|application.properties中的配置属性。当然,我们也可以读取</p><p>自定义的配置文件中属性。目前官方使用@PropertySource注解导入自定义的配置文件属性。</p><p>建立hello.properties</p><pre><code>#load config propertiesperson.name=刘恩源person.age=20person.school=天津师范大学</code></pre><p>建立PersonProperties.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立声明加载properties配置文件的encoding和name</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@PropertySource</span>(value = &#123;<span class="string">"classpath:/hello.properties"</span>&#125;, encoding = <span class="string">"UTF-8"</span>, name = <span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String school;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立PersonConfiguration,使用@EnableConfigurationProperties激活@ConfigurationProperties</p><p>注解,将其标注的JavaBean注入到Spring IOC容器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;PersonProperties.class&#125;)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PersonProperties personProperties    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonConfiguration</span><span class="params">(PersonProperties personProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.personProperties = personProperties;</span><br><span class="line">        System.out.println(String.format(<span class="string">"PersonProperties: %s"</span>, <span class="keyword">this</span>.personProperties));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PersonProperties <span class="title">getPersonProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> personProperties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载指定yml|yaml文件</p><p>配置如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YamlPropertiesConfiguration</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PropertySourcesPlaceholderConfigurer <span class="title">properties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PropertySourcesPlaceholderConfigurer configurer = <span class="keyword">new</span> PropertySourcesPlaceholderConfigurer();</span><br><span class="line">        YamlPropertiesFactoryBean yml = <span class="keyword">new</span> YamlPropertiesFactoryBean();</span><br><span class="line">        yml.setResources(<span class="keyword">new</span> ClassPathResource(<span class="string">"/hello.yml"</span>));</span><br><span class="line">        configurer.setProperties(yml.getObject());</span><br><span class="line">        <span class="keyword">return</span> configurer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以参照我实现的自定义注解@YmlPropertySource,加载yml|yaml文件,可以大致实现和@PropertySource</p><p>注解同样的功能。</p><p>@YmlPropertySource实现加载yml|yaml文件</p><h3 id="5-多环境配置"><a href="#5-多环境配置" class="headerlink" title="5:多环境配置"></a>5:多环境配置</h3><p>在企业开发环境中,需要不同的配置环境.SpringBoot使用spring.profiles.active属性加载不同环境的配置文件,配置文件格式为application-{profile}.properties|yml|yaml。{profile}对应环境标识。</p><ul><li>application-test.yml:测试环境</li><li>application-dev.yml:开发环境</li><li>application.prod:生产环境</li></ul><p>可以在springboot默认配置文件application.yml通过配置spring.profiles.active激活环境。也可以在</p><p>特定的类使用@Profile注解激活环境。该注解可以使用逻辑运算符。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 外部化配置 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强大JSON解析工具gson</title>
      <link href="/2019/08/06/%E5%BC%BA%E5%A4%A7JSON%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7gson/"/>
      <url>/2019/08/06/%E5%BC%BA%E5%A4%A7JSON%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7gson/</url>
      
        <content type="html"><![CDATA[<h2 id="1-GsonUtils工具类"><a href="#1-GsonUtils工具类" class="headerlink" title="1:GsonUtils工具类"></a>1:GsonUtils工具类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * google json utils</span></span><br><span class="line"><span class="comment"> * **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GsonUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATE_FORMAT=<span class="string">"yyyy-MM-dd HH:mm:ss"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get google json</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Gson</span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Gson <span class="title">getGson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> GsonBuilder()).serializeNulls().setDateFormat(GsonUtils.DATE_FORMAT).create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * object to json</span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toJson</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getGson().toJson(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * json to type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Gson#toJson(Object, Type)</span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toJson</span><span class="params">(Object obj, Type type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getGson().toJson(obj, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * generic t to json</span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">String <span class="title">t2Json</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getGson().toJson(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * json to generic t</span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">json2T</span><span class="params">(String jsonString, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getGson().fromJson(jsonString, clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * json to collection</span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">json2Collection</span><span class="params">(String jsonStr, Type type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (List&lt;T&gt;) getGson().fromJson(jsonStr, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * json to type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Gson#fromJson(String, Type)</span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">fromJson</span><span class="params">(String jsonStr, Type type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getGson().fromJson(jsonStr, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * json to class type</span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">fromJson</span><span class="params">(String jsonStr, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getGson().fromJson(jsonStr, clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="1-java-bean对象转换成json"><a href="#1-java-bean对象转换成json" class="headerlink" title="1:java bean对象转换成json"></a>1:java bean对象转换成json</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实体类</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBean2Json</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(GsonUtils.toJson(<span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"王旭"</span>, <span class="number">22</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-List对象转换成json"><a href="#2-List对象转换成json" class="headerlink" title="2:List对象转换成json"></a>2:List对象转换成json</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//方法1</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBeanList2Json</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(GsonUtils.toJson(Arrays.asList(</span><br><span class="line">               <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"王旭"</span>, <span class="number">22</span>),</span><br><span class="line">               <span class="keyword">new</span> User(<span class="number">2</span>, <span class="string">"王旭1"</span>, <span class="number">23</span>),</span><br><span class="line">               <span class="keyword">new</span> User(<span class="number">3</span>, <span class="string">"王旭2"</span>, <span class="number">24</span>)</span><br><span class="line">               )</span><br><span class="line">       ));</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//方法2,指定具体的泛型</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBeanList2Json2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(GsonUtils.toJson(Arrays.asList(</span><br><span class="line">               <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"王旭"</span>, <span class="number">22</span>),</span><br><span class="line">               <span class="keyword">new</span> User(<span class="number">2</span>, <span class="string">"王旭1"</span>, <span class="number">23</span>),</span><br><span class="line">               <span class="keyword">new</span> User(<span class="number">3</span>, <span class="string">"王旭2"</span>, <span class="number">24</span>)</span><br><span class="line">       ), <span class="keyword">new</span> TypeToken&lt;List&lt;User&gt;&gt;() &#123;</span><br><span class="line">       &#125;.getType()));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="3-Map对象转换成json"><a href="#3-Map对象转换成json" class="headerlink" title="3:Map对象转换成json"></a>3:Map对象转换成json</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, User&gt; userMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    userMap.put(<span class="string">"1"</span>, <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"王旭"</span>, <span class="number">22</span>));</span><br><span class="line">    userMap.put(<span class="string">"2"</span>, <span class="keyword">new</span> User(<span class="number">2</span>, <span class="string">"王旭"</span>, <span class="number">23</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMap2Json</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(GsonUtils.toJson(userMap));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Json转成java-bean对象"><a href="#4-Json转成java-bean对象" class="headerlink" title="4:Json转成java bean对象"></a>4:Json转成java bean对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJson2Bean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = GsonUtils.fromJson(<span class="string">"&#123;\"id\":1,\"name\":\"王旭\",\"age\":22&#125;"</span>, User.class);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Json转成List对象"><a href="#5-Json转成List对象" class="headerlink" title="5:Json转成List对象"></a>5:Json转成List对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TypeToken用来获取转换出来的泛型类型,如果转换成泛型请使用该类</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJson2List</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       String jsonList = <span class="string">"[&#123;\"id\":1,\"name\":\"王旭\",\"age\":22&#125;,&#123;\"id\":2,\"name\":\"王旭1\",\"age\":23&#125;,&#123;\"id\":3,\"name\":\"王旭2\",\"age\":24&#125;]"</span>;</span><br><span class="line">       List&lt;User&gt; userList = GsonUtils.fromJson(jsonList, <span class="keyword">new</span> TypeToken&lt;List&lt;User&gt;&gt;() &#123;</span><br><span class="line">       &#125;.getType());</span><br><span class="line">       System.out.println(userList);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="6-Json转成map对象"><a href="#6-Json转成map对象" class="headerlink" title="6:Json转成map对象"></a>6:Json转成map对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其中,使用TypeToken可以将json转换成对应的Java类型</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJson2Map</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       TypeToken&lt;Map&lt;String, User&gt;&gt; typeToken = <span class="keyword">new</span> TypeToken&lt;Map&lt;String, User&gt;&gt;() &#123;</span><br><span class="line">       &#125;;</span><br><span class="line">       Map&lt;String, User&gt; map = GsonUtils.fromJson(<span class="string">"&#123;\"1\":&#123;\"id\":1,\"name\":\"王旭\",\"age\":22&#125;,\"2\":&#123;\"id\":2,\"name\":\"王旭\",\"age\":23&#125;&#125;"</span>,</span><br><span class="line">               typeToken.getType());</span><br><span class="line">       System.out.println(map);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在转换json的时候</span></span><br><span class="line"><span class="comment">//第一步:知道json是什么构造的</span></span><br><span class="line"><span class="comment">//第二步:转换出相应的Java类型</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJson2Map</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       TypeToken&lt;TreeMap&lt;String, User&gt;&gt; typeToken = <span class="keyword">new</span> TypeToken&lt;TreeMap&lt;String, User&gt;&gt;() &#123;</span><br><span class="line">       &#125;;</span><br><span class="line">       TreeMap&lt;String, User&gt; map = GsonUtils.fromJson(<span class="string">"&#123;\"1\":&#123;\"id\":1,\"name\":\"王旭\",\"age\":22&#125;,\"2\":&#123;\"id\":2,\"name\":\"王旭\",\"age\":23&#125;&#125;"</span>,</span><br><span class="line">               typeToken.getType());</span><br><span class="line">       <span class="keyword">for</span> (Map.Entry&lt;String, User&gt; entry : map.entrySet()) &#123;</span><br><span class="line">           System.out.println(entry.getKey()+<span class="string">":"</span>+entry.getValue());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> json </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gson </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Request header is too large 的问题解决</title>
      <link href="/2019/08/06/Request-header-is-too-large-%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/2019/08/06/Request-header-is-too-large-%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="1-问题原因"><a href="#1-问题原因" class="headerlink" title="1:问题原因:"></a>1:问题原因:</h2><blockquote><p>后台接受前台传入的内容字符串,由于内容字符串太大,导致打印台报错.</p></blockquote><p><strong>1-1:错误描述:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: Request header is too large</span><br><span class="line">    at org.apache.coyote.http11.Http11InputBuffer.fill(Http11InputBuffer.java:<span class="number">701</span>)</span><br><span class="line">    at org.apache.coyote.http11.Http11InputBuffer.parseRequestLine(Http11InputBuffer.java:<span class="number">455</span>)</span><br><span class="line">    at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:<span class="number">667</span>)</span><br><span class="line">    at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:<span class="number">66</span>)</span><br><span class="line">    at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:<span class="number">798</span>)</span><br><span class="line">    at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:<span class="number">1434</span>)</span><br><span class="line">    at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:<span class="number">49</span>)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1142</span>)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">617</span>)</span><br><span class="line">    at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:<span class="number">61</span>)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></figure><p><strong>1-2:解决方案(服务器容器:tomcat):</strong></p><blockquote><p>1:请求头超过了tomcat的限值。本来post请求是没有参数大小限制，但是服务器有自己的默认大小。<br>2:配置 tomcat的server.xml文件,增加请求字段长度</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</span><br><span class="line">               connectionTimeout=&quot;20000&quot;</span><br><span class="line">               redirectPort=&quot;8443&quot; maxHttpHeaderSize=&quot;102400&quot; maxPostSize=&quot;0&quot;  </span><br><span class="line">               URIEncoding=&quot;UTF-8&quot;/&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>增加maxHttpHeaderSize参数配置,当maxPostSize=0时,表示不限制.</strong></p></blockquote><p><strong>1-3:SpringBoot项目:</strong></p><blockquote><p>在application.yml文件中,配置<strong>server.max-http-header-size=102400</strong>参数,即可改变内嵌tomcat容器的最大头大小.</p></blockquote><p><strong>1-4:详细错误原因:</strong></p><blockquote><p>在tomcat的org.apache.coyote.http11.AbstractHttp11Protocol类中定义了其默认值: </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Maximum size of the HTTP message header.</span><br><span class="line"> */</span><br><span class="line">private int maxHttpHeaderSize = 8 * 1024;</span><br><span class="line">//所以当请求头大于8*1024时,就会报错.增对大数据量的请求,需要单独配置maxHttpHeaderSize参数属性.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomcat </tag>
            
            <tag> maxHttpHeaderSize </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot中RedisTemplate注意问题</title>
      <link href="/2019/08/06/SpringBoot%E4%B8%ADRedisTemplate%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2019/08/06/SpringBoot%E4%B8%ADRedisTemplate%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="1-ERR-value-is-not-an-integer-or-out-of-range"><a href="#1-ERR-value-is-not-an-integer-or-out-of-range" class="headerlink" title="1:ERR value is not an integer or out of range"></a>1:ERR value is not an integer or out of range</h2><p>1-1:背景:使用redisTemplate.opsForValue().increment(key, delat)方法。</p><p>1-2:分析:redis对任何不合法的值,都称为ERR。只有使用StringRedisSerializer序列化器才能使用incrment或者decrement方法。</p><p>1-3:问题解决:</p><blockquote><ul><li><strong>GenericJackson2JsonRedisSerializer、Jackson2JsonRedisSerializer是先将对象转为json，然后再保存到redis，所以，1在redis中是字符串1，所以无法进行加1</strong></li><li><strong>JdkSerializationRedisSerializer使用的jdk对象序列化，序列化后的值有类信息、版本号等，所以是一个包含很多字母的字符串，所以根本无法加1,这个序列化器跟memcache的序列化规则很像memcache怎样存储的对象</strong></li><li><strong>GenericToStringSerializer、StringRedisSerializer将字符串的值直接转为字节数组，所以保存到redis中是数字，所以可以进行加1</strong></li></ul></blockquote><p>1-4:总结:</p><blockquote><p><strong>使用GenericToStringSerializer、StringRedisSerializer序列化器，都可以使用increment方法.</strong></p></blockquote><p>1-5:建议redis key序列化使用StringRedisSerializer,redis value序列化使用Jackson2JsonRedisSerializer。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * key redis serializer: &#123;@link StringRedisSerializer&#125; and</span><br><span class="line"> * key redis serializer: &#123;@link Jackson2JsonRedisSerializer&#125;</span><br><span class="line"> **/</span><br><span class="line">@Bean(name = &quot;genericRedisTemplate&quot;)</span><br><span class="line">public RedisTemplate&lt;String, String&gt; redisTemplate3(RedisConnectionFactory factory) &#123;</span><br><span class="line">    RedisTemplate&lt;String, String&gt; template = new RedisTemplate&lt;&gt;();</span><br><span class="line">    RedisSerializer valueRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">    RedisSerializer keyRedisSerializer = new StringRedisSerializer();</span><br><span class="line">    template.setKeySerializer(keyRedisSerializer);</span><br><span class="line">    template.setValueSerializer(valueRedisSerializer);</span><br><span class="line">    template.setHashKeySerializer(keyRedisSerializer);</span><br><span class="line">    template.setHashValueSerializer(valueRedisSerializer);</span><br><span class="line">    template.setConnectionFactory(factory);</span><br><span class="line">    template.afterPropertiesSet();</span><br><span class="line">    return template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-key前面会有一堆-xac-xed-x00-x05t-x00-tb"><a href="#2-key前面会有一堆-xac-xed-x00-x05t-x00-tb" class="headerlink" title="2:key前面会有一堆\xac\xed\x00\x05t\x00\tb"></a>2:key前面会有一堆\xac\xed\x00\x05t\x00\tb</h2><p>1-1:背景:使用SpringData对redis进行操作</p><p>1-2:分析</p><blockquote><p>分析spring-data的org.springframework.data.redis.core.RedisTemplate源代码以后发现.Spring默认采用defaultSerializer = new JdkSerializationRedisSerializer();<strong>来对key,value进行序列化操作，在经过查看JdkSerializationRedisSerializer中对序列化的一系列操作,即默认使用。</strong>由于spring操作redis是在jedis客户端基础上进行的，而jedis客户端与redis交互的时候协议中定义是用byte类型交互，jedis中提供了string类型转为byte[]类型.<br>原因其实就出现在这里，解决的办法就是手动定义序列化的方法。</p></blockquote><p>1-3:解决方法:</p><blockquote><p>建议redis key序列化使用StringRedisSerializer,redis value序列化使用Jackson2JsonRedisSerializer.</p></blockquote><p>// 使用SpringBoot默认配置的redisTemplate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Standard Redis configuration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(name = <span class="string">"redisTemplate"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">RedisConnectionFactory redisConnectionFactory)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;Object, Object&gt;();</span><br><span class="line">template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"><span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(StringRedisTemplate.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">stringRedisTemplate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">RedisConnectionFactory redisConnectionFactory)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"><span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> RedisTemplate </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring中RestTemplate的使用</title>
      <link href="/2019/08/06/Spring%E4%B8%ADRestTemplate%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/08/06/Spring%E4%B8%ADRestTemplate%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring中RestTemplate的使用"><a href="#Spring中RestTemplate的使用" class="headerlink" title="Spring中RestTemplate的使用"></a>Spring中RestTemplate的使用</h2><h3 id="Get请求"><a href="#Get请求" class="headerlink" title="Get请求"></a>Get请求</h3><p>1:带参数的Get请求</p><blockquote><p>请求URL示例:<a href="http://localhost:8080/test/sendSms?phone=手机号&amp;msg=短信内容" target="_blank" rel="noopener">http://localhost:8080/test/sendSms?phone=手机号&amp;msg=短信内容</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//错误使用:</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private RestOperations restOperations;</span><br><span class="line"></span><br><span class="line">public void test() throws Exception&#123;</span><br><span class="line">    String url = &quot;http://localhost:8080/test/sendSms&quot;;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; uriVariables = new HashMap&lt;String, Object&gt;();</span><br><span class="line">    uriVariables.put(&quot;phone&quot;, &quot;151xxxxxxxx&quot;);</span><br><span class="line">    uriVariables.put(&quot;msg&quot;, &quot;测试短信内容&quot;);</span><br><span class="line"></span><br><span class="line">    String result = restOperations.getForObject(url, String.class, uriVariables);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**服务器接收的时候你会发现，接收的该请求时没有参数的**</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//正确使用:</span><br><span class="line">public void test() throws Exception&#123;</span><br><span class="line">    String url = &quot;http://localhost:8080/test/sendSms?phone=&#123;phone&#125;&amp;msg=&#123;phone&#125;&quot;;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; uriVariables = new HashMap&lt;String, Object&gt;();</span><br><span class="line">    uriVariables.put(&quot;phone&quot;, &quot;151xxxxxxxx&quot;);</span><br><span class="line">    uriVariables.put(&quot;msg&quot;, &quot;测试短信内容&quot;);</span><br><span class="line"></span><br><span class="line">    String result = restOperations.getForObject(url, String.class, uriVariables);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void test() throws Exception&#123;</span><br><span class="line">    String url = &quot;http://localhost:8080/test/sendSms?phone=&#123;phone&#125;&amp;msg=&#123;phone&#125;&quot;;</span><br><span class="line">    String result = restOperations.getForObject(url, String.class,  &quot;151xxxxxxxx&quot;, &quot;测试短信内容&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2:Spring提供的Get请求方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; T getForObject(URI url, Class&lt;T&gt; responseType) throws RestClientException;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(String url, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(URI url, Class&lt;T&gt; responseType) throws RestClientException;</span><br></pre></td></tr></table></figure><h3 id="Post请求"><a href="#Post请求" class="headerlink" title="Post请求"></a>Post请求</h3><h5 id="1-带参数的POST请求"><a href="#1-带参数的POST请求" class="headerlink" title="1:带参数的POST请求"></a>1:带参数的POST请求</h5><blockquote><p>带参数的URL示例:<a href="http://api.map.baidu.com/geodata/v3/poi/create" target="_blank" rel="noopener">http://api.map.baidu.com/geodata/v3/poi/create</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//正确使用:</span><br><span class="line"></span><br><span class="line">        HttpHeaders headers = new HttpHeaders();</span><br><span class="line">        MultiValueMap&lt;String, String&gt; createPostParams = new LinkedMultiValueMap&lt;&gt;(16);</span><br><span class="line">        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);</span><br><span class="line">        createPostParams.add(&quot;ak&quot;, PositionConstants.AK);</span><br><span class="line">        createPostParams.add(&quot;geotable_id&quot;, PositionConstants.GEOTABLE_ID);</span><br><span class="line">        createPostParams.add(&quot;coord_type&quot;, PositionConstants.COORD_TYPE);</span><br><span class="line">        createPostParams.add(&quot;latitude&quot;, String.valueOf(article.getPositionX()));</span><br><span class="line">        createPostParams.add(&quot;longitude&quot;, String.valueOf(article.getPositionY()));</span><br><span class="line">        createPostParams.add(&quot;address&quot;, article.getPositionName());</span><br><span class="line">        createPostParams.add(&quot;title&quot;, article.getArticleName());</span><br><span class="line">        createPostParams.add(&quot;article_img&quot;, articleImg);</span><br><span class="line">        createPostParams.add(&quot;article_id&quot;, article.getArticleId());</span><br><span class="line">        createPostParams.add(&quot;article_title&quot;, article.getArticleName());</span><br><span class="line">        createPostParams.add(&quot;article_time&quot;, String.valueOf(article.getArticleTime()));</span><br><span class="line">        createPostParams.add(&quot;article_username&quot;, userName);</span><br><span class="line">        HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; requestEntity = new HttpEntity&lt;&gt;(createPostParams, headers);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ResponseEntity&lt;String&gt; responseEntity = restTemplate.postForEntity(PositionConstants.CREATE_URL, requestEntity, String.class);</span><br></pre></td></tr></table></figure><h5 id="2-Spring提供的POST方法"><a href="#2-Spring提供的POST方法" class="headerlink" title="2:Spring提供的POST方法"></a>2:Spring提供的POST方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; T postForObject(String url, Object request, Class&lt;T&gt; responseType, Object... uriVariables)</span><br><span class="line">throws RestClientException;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; T postForObject(String url, Object request, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span><br><span class="line">throws RestClientException;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; T postForObject(URI url, Object request, Class&lt;T&gt; responseType) throws RestClientException;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(String url, Object request, Class&lt;T&gt; responseType, Object... uriVariables)</span><br><span class="line">throws RestClientException;</span><br><span class="line"></span><br><span class="line">`&lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(String url, Object request, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span><br><span class="line">throws RestClientException;`</span><br><span class="line">&lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(URI url, Object request, Class&lt;T&gt; responseType) throws RestClientException;`</span><br></pre></td></tr></table></figure><h3 id="PUT请求"><a href="#PUT请求" class="headerlink" title="PUT请求:"></a>PUT请求:</h3><blockquote><p>PUT请求和POST请求差不多.</p></blockquote><p>1:Spring提供的PUT方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void put(String url, Object request, Object... uriVariables) throws RestClientException;</span><br><span class="line"></span><br><span class="line">void put(String url, Object request, Map&lt;String, ?&gt; uriVariables) throws RestClientException;</span><br><span class="line"></span><br><span class="line">void put(URI url, Object request) throws RestClientException;</span><br></pre></td></tr></table></figure><h3 id="DELETE请求"><a href="#DELETE请求" class="headerlink" title="DELETE请求:"></a>DELETE请求:</h3><p>1:Spring提供的DELETE方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void delete(String url, Object... uriVariables) throws RestClientException;</span><br><span class="line"></span><br><span class="line">void delete(String url, Map&lt;String, ?&gt; uriVariables) throws RestClientException;</span><br><span class="line"></span><br><span class="line">void delete(URI url) throws RestClientException;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RestTemplate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> RestTemplate </tag>
            
            <tag> Restful请求 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring的Bean生命周期</title>
      <link href="/2019/08/06/Spring%E7%9A%84Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2019/08/06/Spring%E7%9A%84Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p><strong>一：生命周期执行的过程如下:</strong></p><p><strong>对于一个Bean对象来说,它的生命周期有实例化–&gt;初始化–&gt;销毁三大块组成。所以会有如下对三大块前后做定制化Bean。</strong></p><p><strong>而对于Bean对象另一份的Spring感知接口来说,会有如下代码和类进行支持。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContextAwareProcessor对一些感知接口处理。详细看invokeAwareInterfaces方法。</span><br><span class="line">class ApplicationContextAwareProcessor implements BeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">    private final ConfigurableApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    private final StringValueResolver embeddedValueResolver;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Create a new ApplicationContextAwareProcessor for the given context.</span><br><span class="line">     */</span><br><span class="line">    public ApplicationContextAwareProcessor(ConfigurableApplicationContext applicationContext) &#123;</span><br><span class="line">        this.applicationContext = applicationContext;</span><br><span class="line">        this.embeddedValueResolver = new EmbeddedValueResolver(applicationContext.getBeanFactory());</span><br><span class="line">    &#125;</span><br><span class="line">private void invokeAwareInterfaces(Object bean) &#123;</span><br><span class="line">        if (bean instanceof Aware) &#123;</span><br><span class="line">            if (bean instanceof EnvironmentAware) &#123;</span><br><span class="line">                ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());</span><br><span class="line">            &#125;</span><br><span class="line">            if (bean instanceof EmbeddedValueResolverAware) &#123;</span><br><span class="line">                ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);</span><br><span class="line">            &#125;</span><br><span class="line">            if (bean instanceof ResourceLoaderAware) &#123;</span><br><span class="line">                ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);</span><br><span class="line">            &#125;</span><br><span class="line">            if (bean instanceof ApplicationEventPublisherAware) &#123;</span><br><span class="line">                ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);</span><br><span class="line">            &#125;</span><br><span class="line">            if (bean instanceof MessageSourceAware) &#123;</span><br><span class="line">                ((MessageSourceAware) bean).setMessageSource(this.applicationContext);</span><br><span class="line">            &#125;</span><br><span class="line">            if (bean instanceof ApplicationContextAware) &#123;</span><br><span class="line">                ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Bean感知接口处理。</strong></p><p><strong>AbstractAutowireCapableBeanFactory.java的</strong>invokeAwareMethods(final String beanName, final Object bean)方法上处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void invokeAwareMethods(final String beanName, final Object bean) &#123;</span><br><span class="line">    if (bean instanceof Aware) &#123;</span><br><span class="line">        if (bean instanceof BeanNameAware) &#123;</span><br><span class="line">            ((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        if (bean instanceof BeanClassLoaderAware) &#123;</span><br><span class="line">            ClassLoader bcl = getBeanClassLoader();</span><br><span class="line">            if (bcl != null) &#123;</span><br><span class="line">                ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (bean instanceof BeanFactoryAware) &#123;</span><br><span class="line">            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1) spring对bean进行实例化,默认bean是单例。<br>2) spring对bean进行依赖注入。<br>3) 如果bean实现了BeanNameAware接口,spring将bean的id传给setBeanName()方法。<br>4) 如果bean实现了BeanFactoryAware接口,spring将调用setBeanFactory方法,将BeanFactory实例传进来。<br>5) 如果bean实现了ApplicationContextAware()接口,spring将调用setApplicationContext()方法将应用上下文的引用传入。<br>6) 如果bean实现了BeanPostProcessor接口,spring将调用它们的postProcessBeforeInitialization接口方法。<br>7) 如果bean实现了InitializingBean接口,spring将调用它们的afterPropertiesSet接口方法,类似的如果bean使用了init-method属性声明了初始化方法,改方法也会被调用。<br>8) 如果bean实现了BeanPostProcessor接口,spring将调用它们的postProcessAfterInitialization接口方法。<br>9) 此时bean已经准备就绪,可以被应用程序使用了,他们将一直驻留在应用上下文中,直到该应用上下文被销毁。<br>10) 若bean实现了DisposableBean接口,spring将调用它的distroy()接口方法。同样的,如果bean使用了destroy-method属性声明了销毁方法,则该方法被调用。</p><p>这里一用仓颉的一幅图说明流程： 转载自 <a href="https://www.cnblogs.com/xrq730/p/6363055.html" target="_blank" rel="noopener">https://www.cnblogs.com/xrq730/p/6363055.html</a></p><p><img src="https://img2018.cnblogs.com/blog/1268938/201901/1268938-20190102121212137-1218561570.png" alt="img"></p><p>第二幅图解释：</p><p><img src="https://img2018.cnblogs.com/blog/1268938/201901/1268938-20190102121529874-1777117066.png" alt="img"></p><p><strong>二：代码测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/** * <span class="doctag">@see</span> org.springframework.beans.factory.config.BeanFactoryPostProcessor * <span class="doctag">@see</span> org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter * <span class="doctag">@see</span> org.springframework.beans.factory.InitializingBean * <span class="doctag">@see</span> org.springframework.beans.factory.DisposableBean * <span class="doctag">@see</span> org.springframework.beans.factory.BeanNameAware * <span class="doctag">@see</span> org.springframework.beans.factory.BeanFactoryAware * <span class="doctag">@see</span> org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean(String, RootBeanDefinition, Object[]) **/</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBean</span> <span class="keyword">implements</span> <span class="title">BeanNameAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">InitializingBean</span>, <span class="title">ApplicationContextAware</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpringBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"new SpringBean......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext context)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"ApplicationContextAware-setApplicationContext......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"InitializingBean-afterPropertiesSet......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory bf)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"BeanFactoryAware-setBeanFactory......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"BeanNameAware-setBeanName......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"DisposableBean-destroy....."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object o, String s)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> SpringBean) &#123;</span><br><span class="line">            log.info(<span class="string">"BeanPostProcessor-postProcessBeforeInitialization......"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object o, String s)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> SpringBean) &#123;</span><br><span class="line">            log.info(<span class="string">"BeanPostProcessor-postProcessAfterInitialization......"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果展示</strong></p><p><img src="https://img2018.cnblogs.com/blog/1268938/201901/1268938-20190102123254455-147967680.png" alt="img"></p><p><img src="https://img2018.cnblogs.com/blog/1268938/201901/1268938-20190102123325710-131759027.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Bean生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内省机制</title>
      <link href="/2019/08/06/Java%E5%86%85%E7%9C%81%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/08/06/Java%E5%86%85%E7%9C%81%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h4 id="一-内省"><a href="#一-内省" class="headerlink" title="一. 内省"></a>一. 内省</h4><h5 id="1-维基百科解释"><a href="#1-维基百科解释" class="headerlink" title="1:维基百科解释"></a>1:维基百科解释</h5><blockquote><p>在计算机科学中，内省是指计算机程序在运行时（Run time）检查对象（Object）类型的一种能力，通常也可以称作运行时类型检查。 不应该将内省和反射混淆。相对于内省，反射更进一步，是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力。</p></blockquote><h5 id="2-Java语言中解释"><a href="#2-Java语言中解释" class="headerlink" title="2:Java语言中解释"></a>2:Java语言中解释</h5><blockquote><p>内省(Introspector) 是Java 语言对 JavaBean 类属性、事件的一种缺省处理方法。JavaBean是一种特殊的类，主要用于传递数据信息，这种类中的方法主要用于访问私有的字段，且方法名符合某种命名规则。如果在两个模块之间传递信息，可以将信息封装进JavaBean中，这种对象称为“值对象”(Value Object)，或“VO”，方法比较少，这些信息储存在类的私有变量中，通过set()、get()获得</p></blockquote><h4 id="二-内省和反射的区别"><a href="#二-内省和反射的区别" class="headerlink" title="二:内省和反射的区别"></a>二:内省和反射的区别</h4><blockquote><p>1: 反射是在运行状态把Java类中的各种成分映射成相应的Java类，可以动态的获取所有的属性以及动态调用任意一个方法，强调的是运行状态。</p><p>2: 内省(Introspector)是Java 语言对 Bean 类属性、事件的一种缺省处理方法。　JavaBean是一种特殊的类，主要用于传递数据信息，这种类中的方法主要用于访问私有的字段，且方法名符合某种命名规则。如果在两个模块之间传递信息，可以将信息封装进JavaBean中，这种对象称为“值对象”(Value Object)，或“VO”。方法比较少。这些信息储存在类的私有变量中，通过set()、get()获得。内省机制是通过反射来实现的，BeanInfo用来暴露一个bean的属性、方法和事件，以后我们就可以操纵该JavaBean的属性。</p><p>3:比较</p><p><img src="https://img2018.cnblogs.com/blog/1268938/201901/1268938-20190109120602148-1027189775.png" alt="img"></p></blockquote><h4 id="三-JDK内省类库"><a href="#三-JDK内省类库" class="headerlink" title="三:JDK内省类库"></a>三:JDK内省类库</h4><blockquote><ul><li>java.beans.Introspector：Introspector 类为通过工具学习有关受目标 Java Bean 支持的属性、事件和方法的知识提供了一个标准方法。</li><li>java.beans.BeanInfo接口：希望提供有关其 bean 的显式信息的 bean 实现者可以提供某个 BeanInfo 类，该类实现此 BeanInfo 接口并提供有关其 bean 的方法、属性、事件等显式信息。</li><li>java.beans.PropertyDescriptor：PropertyDescriptor 描述 Java Bean 通过一对存储器方法导出的一个属性</li></ul></blockquote><h4 id="四-内省代码测试"><a href="#四-内省代码测试" class="headerlink" title="四:内省代码测试"></a>四:内省代码测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java内省机制测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.beans.BeanInfo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.beans.Introspector</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.beans.PropertyDescriptor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.beans.MethodDescriptor</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntrospectorTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setAge(<span class="number">20</span>);</span><br><span class="line">        user.setId(UUID.randomUUID().toString());</span><br><span class="line">        user.setName(<span class="string">"刘恩源"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIntrospector</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//get BeanInfo</span></span><br><span class="line">        BeanInfo beanInfo = Introspector.getBeanInfo(User.class);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//PropertyDescriptor</span></span><br><span class="line">        PropertyDescriptor[] pds = beanInfo.getPropertyDescriptors();</span><br><span class="line">        <span class="keyword">for</span> (PropertyDescriptor pd : pds) &#123;</span><br><span class="line">            Method method = pd.getReadMethod();</span><br><span class="line">            String methodName = method.getName();</span><br><span class="line">            Object result = method.invoke(user);</span><br><span class="line">            System.out.println(methodName + <span class="string">"--&gt;"</span> + result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//get name property descriptor</span></span><br><span class="line">        PropertyDescriptor namePropertyDescriptor = <span class="keyword">new</span> PropertyDescriptor(<span class="string">"name"</span>, User.class);</span><br><span class="line">        <span class="comment">//得到name属性的getter方法</span></span><br><span class="line">        Method readMethod = namePropertyDescriptor.getReadMethod();</span><br><span class="line">        <span class="comment">//执行getter方法，获取返回值，即name属性的值</span></span><br><span class="line">        String result = (String) readMethod.invoke(user);</span><br><span class="line">        System.out.println(<span class="string">"user.name"</span> + <span class="string">"--&gt;"</span> + result);</span><br><span class="line">        <span class="comment">//得到name属性的setter方法</span></span><br><span class="line">        Method writeMethod = namePropertyDescriptor.getWriteMethod();</span><br><span class="line">        <span class="comment">//执行setter方法，修改name属性的值</span></span><br><span class="line">        writeMethod.invoke(user, <span class="string">"刘恩源1"</span>);</span><br><span class="line">        System.out.println(<span class="string">"user.name"</span> + <span class="string">"--&gt;"</span> + user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java内省机制 </tag>
            
            <tag> Java反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT认证详解</title>
      <link href="/2019/08/06/JWT%E8%AE%A4%E8%AF%81%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/08/06/JWT%E8%AE%A4%E8%AF%81%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="JWT-Json-web-token-认证详解"><a href="#JWT-Json-web-token-认证详解" class="headerlink" title="JWT(Json web token) 认证详解"></a>JWT(Json web token) 认证详解</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1:概述"></a>1:概述</h3><p><code>JWT声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息,以便从资源服务器获取资源,增加一些额外的其他业务所必须的声明信息</code>。</p><p><strong><code>特别适用于分布式站点的单点登录(SSO)场景</code></strong></p><h3 id="2-起源"><a href="#2-起源" class="headerlink" title="2:起源"></a>2:起源</h3><p>基于token的认证和传统的session认证区别。</p><h5 id="1-传统的session认证"><a href="#1-传统的session认证" class="headerlink" title="(1):传统的session认证"></a>(1):传统的session认证</h5><p><strong><code>概述</code></strong></p><p><code>http协议本身是一种无状态的协议</code>,而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证,那么下一次请求时,用户还要再一次进行用户认证才行,<code>因为根据http协议,我们并不能知道是哪个用户发出的请求,所以为了让我们的应用能识别是哪个用户发出的请求,我们只能在服务器存储一份用户登录的信息</code>,这份登录信息会在响应时传递给浏览器,告诉其保存为cookie,以便下次请求时发送给我们的应用,这样我们的应用就能识别请求来自哪个用户了,这就是传统的基于session认证。</p><p><strong><code>基于session认证所显露的问题</code></strong></p><ul><li><code>session存储问题</code>:由于用户的信息存储在服务端,而且session都是保存在内存中,随之认证用户增多,服务端开销明显增大。</li><li><code>扩展性</code>:用户认证之后,服务端做认证记录,如果认证记录被保存在内存中,<code>意味着用户下次请求还必须要请求这台服务器,才能拿到授权资源</code>。在分布式应用中,相应的限制了负载均衡器的能力。</li><li><code>CSRF</code>:因为<code>基于cookie来进行用户识别</code>,如果cookie被截获,用户就会很容易受到<code>跨站请求伪造攻击</code>。</li></ul><h5 id="2-基于token的鉴权机制"><a href="#2-基于token的鉴权机制" class="headerlink" title="(2):基于token的鉴权机制"></a>(2):基于token的鉴权机制</h5><p><strong><code>概述</code></strong></p><p>基于token的鉴权机制类似于http协议也是无状态的,它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了,这就为应用的扩展提供了便利。</p><p><strong><code>流程</code></strong></p><ul><li>用户使用用户名密码来请求服务器。</li><li>服务器进行验证用户的信息。</li><li>服务器通过验证发送给用户一个token。</li><li>客户端存储token,并在每次请求时附送上这个token值。</li><li>服务端验证token值,并返回数据。</li></ul><p>这个<code>token</code>必须要在<code>每次请求时传递给服务端</code>,应该保存在<code>请求头里</code>。例外,服务端要支持<code>CORS(跨域请求)</code>。</p><h3 id="3-JWT"><a href="#3-JWT" class="headerlink" title="3:JWT"></a>3:JWT</h3><h5 id="1-设计"><a href="#1-设计" class="headerlink" title="(1):设计"></a>(1):设计</h5><p>jwt(json web token)有三部分构成。</p><ul><li><p><strong><code>header(头部)</code></strong></p><ul><li><p>声明类型:<code>jwt</code></p></li><li><p>加密算法:<code>HMAC</code>,<code>SHA256</code></p></li><li><p><strong><code>头部进行base64加密</code></strong>。</p></li><li><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//头部json</span><br><span class="line">&#123; </span><br><span class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">   <span class="attr">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>payload</code></strong>:存储有效信息。</p><ul><li>标准中注册声明(建议单不强制使用)<ul><li><strong>iss</strong>: jwt签发者</li><li><strong><code>sub</code></strong>: <code>jwt所面向的用户</code></li><li><strong>aud</strong>: 接收jwt的一方</li><li><strong>exp</strong>: jwt的过期时间，这个过期时间必须要大于签发时间</li><li><strong>nbf</strong>: 定义在什么时间之前，该jwt都是不可用的.</li><li><strong>iat</strong>: jwt的签发时间</li><li><strong>jti</strong>: jwt的唯一身份标识,主要用来作为一次性token,从而回避重放攻击。</li></ul></li><li>公共声明<ul><li>添加任何信息,一般添加用户的相关信息或者其他业务需要的必要信息。<code>不建议添加敏感信息。(可以在客户端进行解密)</code></li></ul></li><li>私有声明<ul><li><code>提供者和消费者所共同定义的声明,一般不建议存放敏感信息</code>,因为base64是对称解密的，意味着该部分信息可以归类为明文信息。</li></ul></li></ul></li><li><p><strong><code>signature</code></strong>:签证信息</p><ul><li><p>head(base64后的)</p></li><li><p>payload(base64后的)</p></li><li><p>secret:<code>保存在服务端,jwt签发生成也是在服务端。它是用来进行jwt签发和jwt验证,就是服务端的私钥。</code></p><blockquote><p>这个部分需要base64加密后的header和payload使用。连接组成的字符串,然后通过header中声明的加密方式进行加盐secret组合加密,构成jwt第三部分。</p></blockquote></li></ul></li></ul><h5 id="2-应用"><a href="#2-应用" class="headerlink" title="(2):应用"></a>(2):应用</h5><p>一般是在请求头里加入<code>Authorization</code>,并加上<code>Bearer</code>标注:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'api/user/1'</span>, &#123;</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Authorization'</span>: <span class="string">'Bearer '</span> + token</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://images2017.cnblogs.com/blog/1277635/201711/1277635-20171116141211968-1715750540.png" alt="img"></p><h5 id="3-总结"><a href="#3-总结" class="headerlink" title="(3):总结"></a>(3):总结</h5><p><strong><code>优点</code></strong></p><ul><li>由于json通用性,所以JWT可以跨语言。</li><li>因为有payload,所以jwt可以在自身存储一些其他业务所必要的非敏感信息。</li><li>便于传输,字节占用很小</li><li>不需要在服务端保存会话信息,易于扩展,特别适用于分布式微服务。</li></ul><p><strong><code>安全相关</code></strong></p><ul><li><code>不应该在jwt的payload部分存放敏感信息</code>,因为这部分客户端可解密的部分</li><li><code>保护好secret私钥</code>,该私钥非常重要。</li><li><code>如果可以,请使用https协议</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> jwt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON Web Token认证 </tag>
            
            <tag> Session认证 </tag>
            
            <tag> 分布式单点登录(SSO)场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot自定义注解加载yml或者yaml文件</title>
      <link href="/2019/08/06/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%8A%A0%E8%BD%BDyml%E6%88%96%E8%80%85yaml%E6%96%87%E4%BB%B6/"/>
      <url>/2019/08/06/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%8A%A0%E8%BD%BDyml%E6%88%96%E8%80%85yaml%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot自定义注解加载yml或者yaml文件"><a href="#SpringBoot自定义注解加载yml或者yaml文件" class="headerlink" title="SpringBoot自定义注解加载yml或者yaml文件"></a>SpringBoot自定义注解加载yml或者yaml文件</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1:概述"></a>1:概述</h3><p>SpringBoot的<code>@PropertySource</code>注解只支持加载    properties结尾的文件。当使用@ConfigurationProperties</p><p>注解配合<code>@EnableConfigurationProperties</code>注解将配置转换为JavaBean时,可能需要配合@PropertySource</p><p>注解加载指定的配置文件。所以为了支持以<code>yml或者yaml</code>文件,我自定义了注解<code>@YmlPropertySource</code>。</p><h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2:实现"></a>2:实现</h3><p><strong>声明注解@YamlPropertySource</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PropertySourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * yaml property source and extension &#123;<span class="doctag">@link</span> PropertySource&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.annotation.PropertySource</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Repeatable</span>(YamlPropertySources.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> YamlPropertySource &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicate the name of this property source. If omitted, a name will</span></span><br><span class="line"><span class="comment">     * be generated based on the description of the underlying resource.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.core.env.PropertySource#getName()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.core.io.Resource#getDescription()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicate the resource location(s) of the properties file to be loaded.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Both traditional and XML-based properties file formats are supported</span></span><br><span class="line"><span class="comment">     * &amp;mdash; for example, &#123;<span class="doctag">@code</span> "classpath:/com/myco/app.properties"&#125;</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@code</span> "file:/path/to/file.xml"&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Resource location wildcards (e.g. *&amp;#42;/*.properties) are not permitted;</span></span><br><span class="line"><span class="comment">     * each location must evaluate to exactly one &#123;<span class="doctag">@code</span> .properties&#125; resource.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;$&#123;...&#125; placeholders will be resolved against any/all property sources already</span></span><br><span class="line"><span class="comment">     * registered with the &#123;<span class="doctag">@code</span> Environment&#125;. See &#123;<span class="doctag">@linkplain</span> PropertySource above&#125;</span></span><br><span class="line"><span class="comment">     * for examples.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Each location will be added to the enclosing &#123;<span class="doctag">@code</span> Environment&#125; as its own</span></span><br><span class="line"><span class="comment">     * property source, and in the order declared.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicate if failure to find the a &#123;<span class="doctag">@link</span> #value() property resource&#125; should be</span></span><br><span class="line"><span class="comment">     * ignored.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&#123;<span class="doctag">@code</span> true&#125; is appropriate if the properties file is completely optional.</span></span><br><span class="line"><span class="comment">     * Default is &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 4.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">ignoreResourceNotFound</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A specific character encoding for the given resources, e.g. "UTF-8".</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 4.3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">encoding</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Specify a custom &#123;<span class="doctag">@link</span> PropertySourceFactory&#125;, if any.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;By default, a default factory for standard resource files will be used.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.core.io.support.DefaultPropertySourceFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.core.io.support.ResourcePropertySource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 4.3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? extends PropertySourceFactory&gt; factory() <span class="keyword">default</span> YamlPropertySourceFactory.class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> YamlPropertySource</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> YamlPropertySources &#123;</span><br><span class="line"></span><br><span class="line">    YamlPropertySource[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体实现如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.YamlPropertiesFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.EnvironmentAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ResourceLoaderAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.AnnotationUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ResourceLoader;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.Assert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类描述: &#123;<span class="doctag">@link</span> YamlPropertySource&#125; bean post processor.this class convert the yml or yaml file &#123;<span class="doctag">@link</span> YamlPropertySource#value()&#125; to &#123;<span class="doctag">@link</span> PropertiesPropertySource&#125;,and add the property source</span></span><br><span class="line"><span class="comment"> * named &#123;<span class="doctag">@link</span> YmlPropertySource#name()&#125; into &#123;<span class="doctag">@link</span> Environment&#125;.When you use this annotation,you</span></span><br><span class="line"><span class="comment"> * must for follow example:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@link</span> <span class="doctag">@ConfigurationProperties</span>(prefix = "person")</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@link</span> <span class="doctag">@YmlPropertySource</span>(value = &#123;"classpath:/hello.yml"&#125;, name = "hello")</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@link</span> <span class="doctag">@Data</span></span></span><br><span class="line"><span class="comment"> * public class PersonProperties &#123;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * private String name;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * private Integer age;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * private String school;</span></span><br><span class="line"><span class="comment"> * &#125;&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/6/16 20:13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> YamlPropertySource</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> InstantiationAwareBeanPostProcessorAdapter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnvironmentAware</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ResourceLoaderAware</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Configuration</span>(value = YamlPropertySourceAnnotationPostProcessor.BEAN_NAME)</span><br><span class="line"><span class="meta">@Order</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YamlPropertySourceAnnotationPostProcessor</span> <span class="keyword">extends</span> <span class="title">InstantiationAwareBeanPostProcessorAdapter</span> <span class="keyword">implements</span> <span class="title">EnvironmentAware</span>, <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String BEAN_NAME = <span class="string">"yamlPropertySourceAnnotationPostProcessor"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; propertySourceNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> PropertySourceFactory DEFAULT_PROPERTY_SOURCE_FACTORY = <span class="keyword">new</span> YamlPropertySourceFactory();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        Assert.isInstanceOf(ConfigurableEnvironment.class, environment, <span class="string">"environment must be instance of ConfigurableEnvironment."</span>);</span><br><span class="line">        <span class="keyword">this</span>.environment = environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// Process any @PropertySource annotations</span></span><br><span class="line">        Set&lt;YamlPropertySource&gt; yamlPropertySources = AnnotationUtils.getRepeatableAnnotations(bean.getClass(),</span><br><span class="line">                YamlPropertySource.class, YamlPropertySources.class);</span><br><span class="line">        <span class="keyword">if</span> (!yamlPropertySources.isEmpty()) &#123;</span><br><span class="line">            Set&lt;AnnotationAttributes&gt; attributesSet = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(yamlPropertySources.size());</span><br><span class="line">            <span class="keyword">for</span> (YamlPropertySource yamlPropertySource : yamlPropertySources) &#123;</span><br><span class="line">                AnnotationAttributes attributes = AnnotationUtils.getAnnotationAttributes(bean.getClass(),</span><br><span class="line">                        yamlPropertySource);</span><br><span class="line">                attributesSet.add(attributes);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (AnnotationAttributes propertySource : attributesSet) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        processPropertySource(propertySource);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        log.warn(<span class="string">"exception message: &#123;&#125;"</span>, e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.warn(<span class="string">"Ignoring @YamlPropertySource annotation on ["</span> + bean.getClass() +</span><br><span class="line">                            <span class="string">"]. Reason: Environment must implement ConfigurableEnvironment"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processPropertySource</span><span class="params">(AnnotationAttributes propertySource)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String name = propertySource.getString(<span class="string">"name"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasLength(name)) &#123;</span><br><span class="line">            name = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String encoding = propertySource.getString(<span class="string">"encoding"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasLength(encoding)) &#123;</span><br><span class="line">            encoding = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] locations = propertySource.getStringArray(<span class="string">"value"</span>);</span><br><span class="line">        Assert.isTrue(locations.length &gt; <span class="number">0</span>, <span class="string">"At least one @YamlPropertySource(value) location is required"</span>);</span><br><span class="line">        <span class="keyword">boolean</span> ignoreResourceNotFound = propertySource.getBoolean(<span class="string">"ignoreResourceNotFound"</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;? extends PropertySourceFactory&gt; factoryClass = propertySource.getClass(<span class="string">"factory"</span>);</span><br><span class="line">        PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?</span><br><span class="line">                DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String location : locations) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String resolvedLocation = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(location);</span><br><span class="line">                Resource resource = <span class="keyword">this</span>.resourceLoader.getResource(resolvedLocation);</span><br><span class="line">                addPropertySource(factory.createPropertySource(name, <span class="keyword">new</span> EncodedResource(resource, encoding)));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) &#123;</span><br><span class="line">                <span class="comment">// Placeholders not resolvable or resource not found when trying to open it</span></span><br><span class="line">                <span class="keyword">if</span> (ignoreResourceNotFound) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">                        log.info(<span class="string">"Properties or Yml or Yaml location ["</span> + location + <span class="string">"] not resolvable: "</span> + ex.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addPropertySource</span><span class="params">(PropertySource&lt;?&gt; propertySource)</span> </span>&#123;</span><br><span class="line">        String name = propertySource.getName();</span><br><span class="line">        MutablePropertySources propertySources = ((ConfigurableEnvironment) <span class="keyword">this</span>.environment).getPropertySources();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.propertySourceNames.contains(name)) &#123;</span><br><span class="line">            <span class="comment">// We've already added a version, we need to extend it</span></span><br><span class="line">            PropertySource&lt;?&gt; existing = propertySources.get(name);</span><br><span class="line">            <span class="keyword">if</span> (existing != <span class="keyword">null</span>) &#123;</span><br><span class="line">                PropertySource&lt;?&gt; newSource = (propertySource <span class="keyword">instanceof</span> ResourcePropertySource ?</span><br><span class="line">                        ((ResourcePropertySource) propertySource).withResourceName() : propertySource);</span><br><span class="line">                <span class="keyword">if</span> (existing <span class="keyword">instanceof</span> CompositePropertySource) &#123;</span><br><span class="line">                    ((CompositePropertySource) existing).addFirstPropertySource(newSource);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (existing <span class="keyword">instanceof</span> ResourcePropertySource) &#123;</span><br><span class="line">                        existing = ((ResourcePropertySource) existing).withResourceName();</span><br><span class="line">                    &#125;</span><br><span class="line">                    CompositePropertySource composite = <span class="keyword">new</span> CompositePropertySource(name);</span><br><span class="line">                    composite.addPropertySource(newSource);</span><br><span class="line">                    composite.addPropertySource(existing);</span><br><span class="line">                    propertySources.replace(name, composite);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.propertySourceNames.isEmpty()) &#123;</span><br><span class="line">            propertySources.addLast(propertySource);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String firstProcessed = <span class="keyword">this</span>.propertySourceNames.get(<span class="keyword">this</span>.propertySourceNames.size() - <span class="number">1</span>);</span><br><span class="line">            propertySources.addBefore(firstProcessed, propertySource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.propertySourceNames.add(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>想法</strong></p><p>使用<code>InstantiationAwareBeanPostProcessorAdapter</code>的postProcessAfterInstantiation(Object bean, String beanName)方法,然后通过<code>YamlPropertiesFactoryBean</code>将yml|yaml文件转换为properties文件,然后通过</p><p>实现<code>EnvironmentAware</code>接口,将配置文件属性写入到spring的<code>Environment</code>环境中。但是该实现有点</p><p>缺陷,就是如果使用<code>@ConfigurationProperties</code>和<code>@EnableConfigurationProperties</code>将配置属性</p><p>转换为<code>JavaBean</code>时,需要将<code>@YmlProperySource</code>注解标注到该<code>JavaBean</code>上。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 外部化配置 </tag>
            
            <tag> yml|yaml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring类型转换</title>
      <link href="/2019/08/06/Spring%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2019/08/06/Spring%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Type-Conversion-Spring类型转换"><a href="#Spring-Type-Conversion-Spring类型转换" class="headerlink" title="Spring Type Conversion(Spring类型转换)"></a>Spring Type Conversion(Spring类型转换)</h2><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1:概述:"></a>1:概述:</h4><p><code>Spring3</code>引入了<code>core.convert</code>包,提供了<code>通用类型转换系统</code>,定义了实现<code>类型转换和运行时执行类型的SPI</code>。</p><p>在<code>Spring3.0</code>之前,提供的<code>PropertyEditor</code>来将外部化bean属性值字符串转换成必需的实现类型。</p><h4 id="2-Converter-SPI"><a href="#2-Converter-SPI" class="headerlink" title="2:Converter SPI"></a>2:<code>Converter SPI</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A converter converts a source object of type &#123;<span class="doctag">@code</span> S&#125; to a target of type &#123;<span class="doctag">@code</span> T&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Implementations of this interface are thread-safe and can be shared.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Implementations may additionally implement &#123;<span class="doctag">@link</span> ConditionalConverter&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;S&gt; the source type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the target type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert the source object of type &#123;<span class="doctag">@code</span> S&#125; to target type &#123;<span class="doctag">@code</span> T&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> source the source object to convert, which must be an instance of &#123;<span class="doctag">@code</span> S&#125; (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the converted object, which must be an instance of &#123;<span class="doctag">@code</span> T&#125; (potentially &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the source cannot be converted to the desired target type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">T <span class="title">convert</span><span class="params">(S source)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   实现自定义的类型转换可以实现<code>Converter</code>接口。但是如果S是<code>集合或者数组</code>转换为<code>T的集合或者数组</code>,</p><p>建议参考诸如<code>ArrayToCollectionConverter</code>实现。前提是已经注册了委托<code>数组或集合转换器</code>。例如,</p><p><code>DefaultConversionService</code>实现。</p><p>  <code>Converter.convert(S source)中source确保不能为null,否则转换器可能抛出异常如果转换失败。</code>具体</p><p>说,应该会抛出<code>IllegalArgumentException</code>报告不合理的转换源。确保<code>Converter</code>实现是<code>线程安全</code>。</p><p>   在<code>core.convert.support</code>包下,注册了常见了类型转换器。例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Converts from a String any JDK-standard Number implementation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Support Number classes including Byte, Short, Integer, Float, Double, Long, BigInteger, BigDecimal. This class</span></span><br><span class="line"><span class="comment"> * delegates to &#123;<span class="doctag">@link</span> NumberUtils#parseNumber(String, Class)&#125; to perform the conversion.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Byte</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Short</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Integer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.math.BigInteger</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Float</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Double</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.math.BigDecimal</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> NumberUtils</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToNumberConverterFactory</span> <span class="keyword">implements</span> <span class="title">ConverterFactory</span>&lt;<span class="title">String</span>, <span class="title">Number</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Number&gt; <span class="function">Converter&lt;String, T&gt; <span class="title">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> StringToNumber&lt;&gt;(targetType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToNumber</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; targetType;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringToNumber</span><span class="params">(Class&lt;T&gt; targetType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.targetType = targetType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (source.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NumberUtils.parseNumber(source, <span class="keyword">this</span>.targetType);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-ConverterFactory"><a href="#3-ConverterFactory" class="headerlink" title="3:ConverterFactory"></a>3:<code>ConverterFactory</code></h4><p><code>当你需要集中整理类层次结构的类型转换器,可以使用ConverterFactory</code>。例如StringToNumberConverterFactory,</p><p>该接口定义如下,<code>当你需要范围转换器,可以转换这些对象从S类型转换成R的子类型。使用该接口</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A factory for "ranged" converters that can convert objects from S to subtypes of R.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Implementations may additionally implement &#123;<span class="doctag">@link</span> ConditionalConverter&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConditionalConverter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;S&gt; the source type converters created by this factory can convert from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;R&gt; the target range (or base) type converters created by this factory can convert to;</span></span><br><span class="line"><span class="comment"> * for example &#123;<span class="doctag">@link</span> Number&#125; for a set of number subtypes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConverterFactory</span>&lt;<span class="title">S</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the converter to convert from S to target type T, where T is also an instance of R.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the target type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetType the target type to convert to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a converter from S to T</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;T extends R&gt; <span class="function">Converter&lt;S, T&gt; <span class="title">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Converts from a String any JDK-standard Number implementation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Support Number classes including Byte, Short, Integer, Float, Double, Long, BigInteger, BigDecimal. This class</span></span><br><span class="line"><span class="comment"> * delegates to &#123;<span class="doctag">@link</span> NumberUtils#parseNumber(String, Class)&#125; to perform the conversion.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Byte</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Short</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Integer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.math.BigInteger</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Float</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Double</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.math.BigDecimal</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> NumberUtils</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToNumberConverterFactory</span> <span class="keyword">implements</span> <span class="title">ConverterFactory</span>&lt;<span class="title">String</span>, <span class="title">Number</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Number&gt; <span class="function">Converter&lt;String, T&gt; <span class="title">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> StringToNumber&lt;&gt;(targetType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToNumber</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; targetType;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringToNumber</span><span class="params">(Class&lt;T&gt; targetType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.targetType = targetType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (source.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NumberUtils.parseNumber(source, <span class="keyword">this</span>.targetType);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-GenericConverter"><a href="#4-GenericConverter" class="headerlink" title="4:GenericConverter"></a>4:<code>GenericConverter</code></h4><p>  <code>GenericConverter</code>提供<code>多种源和目标类型之间转换</code>,比<code>Converter更灵活但是对类型要求不高</code>。它提供了实现</p><p>转换逻辑的<code>源和目标上下文</code>。 这样的上下文允许类型转换由字段注释或在字段签名上声明的通用信息驱动。接口</p><p>如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="title">getConvertibleTypes</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConvertiblePair</code>持有<code>转换源和目标类型对</code>。<code>convert(Object, TypeDescriptor, TypeDescriptor)</code>。</p><p><code>源TypeDescriptor</code>提供对保存正在转换的值的源字段的访问。 <code>目标TypeDescriptor</code>提供对要设置转换值的目标字段的访问。<code>TypeDescriptor</code>类是<code>关于要转换类型的上下文</code>。</p><p>  一个好的实例是<code>GenericConverter</code>在Java数组和集合之间转换。例如<code>ArrayToCollectionConverter</code>。</p><p><strong><code>注意</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为GenericConverter是一个更复杂的SPI接口,所以只有在需要时才应该使用它.喜欢Converter或ConverterFactory以满足基本的类型转换需求。</span><br></pre></td></tr></table></figure><h4 id="5-ConditionalGenericConverter"><a href="#5-ConditionalGenericConverter" class="headerlink" title="5:ConditionalGenericConverter"></a>5:<code>ConditionalGenericConverter</code></h4><p>该接口是一个带有判断条件的类型转换器。该接口是<code>GenericConverter</code>和<code>ConditionalConverter</code>的组合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@link</span> GenericConverter&#125; that may conditionally execute based on attributes</span></span><br><span class="line"><span class="comment"> * of the &#123;<span class="doctag">@code</span> source&#125; and &#123;<span class="doctag">@code</span> target&#125; &#123;<span class="doctag">@link</span> TypeDescriptor&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;See &#123;<span class="doctag">@link</span> ConditionalConverter&#125; for details.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Phillip Webb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> GenericConverter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConditionalConverter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConditionalGenericConverter</span> <span class="keyword">extends</span> <span class="title">GenericConverter</span>, <span class="title">ConditionalConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConditionalGenericConverter</code> 的一个好示例是<code>StringToCollectionConverter</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Converts a comma-delimited String to a Collection.</span></span><br><span class="line"><span class="comment"> * If the target collection element type is declared, only matches if</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> String.class&#125; can be converted to it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToCollectionConverter</span> <span class="keyword">implements</span> <span class="title">ConditionalGenericConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConversionService conversionService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringToCollectionConverter</span><span class="params">(ConversionService conversionService)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.conversionService = conversionService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="title">getConvertibleTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> ConvertiblePair(String.class, Collection.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (targetType.getElementTypeDescriptor() == <span class="keyword">null</span> ||</span><br><span class="line"><span class="keyword">this</span>.conversionService.canConvert(sourceType, targetType.getElementTypeDescriptor()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">convert</span><span class="params">(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (source == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">String string = (String) source;</span><br><span class="line"></span><br><span class="line">String[] fields = StringUtils.commaDelimitedListToStringArray(string);</span><br><span class="line">TypeDescriptor elementDesc = targetType.getElementTypeDescriptor();</span><br><span class="line">Collection&lt;Object&gt; target = CollectionFactory.createCollection(targetType.getType(),</span><br><span class="line">(elementDesc != <span class="keyword">null</span> ? elementDesc.getType() : <span class="keyword">null</span>), fields.length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (elementDesc == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String field : fields) &#123;</span><br><span class="line">target.add(field.trim());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (String field : fields) &#123;</span><br><span class="line">Object targetElement = <span class="keyword">this</span>.conversionService.convert(field.trim(), sourceType, elementDesc);</span><br><span class="line">target.add(targetElement);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-ConversionService-API"><a href="#6-ConversionService-API" class="headerlink" title="6:ConversionService API"></a>6:<code>ConversionService API</code></h4><p><code>ConversionService定义了一个统一的API,用于在运行时执行类型转换逻辑</code>. 转换器通常在以下Facade接口后面执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConversionService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">convert</span><span class="params">(Object source, Class&lt;T&gt; targetType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  大多数ConversionService实现,同样也实现了<code>ConverterRegistry</code>,该接口提供了<code>SPI</code>来注册<code>Converters</code>.</p><p>在内部,<code>ConversionService</code>的实现,容器委托它来注册转换器来执行转换逻辑。</p><p>  <code>core.convert.support</code>提供一个强大的<code>ConversionService</code>实现,该实现是<code>GenericConversionSer</code></p><p>,它适用于大多数转换器环境实现。<code>ConversionServiceFactory</code> 来创建普通的<code>ConversionService</code></p><p>配置。</p><h4 id="7-配置ConversionService"><a href="#7-配置ConversionService" class="headerlink" title="7:配置ConversionService"></a>7:配置<code>ConversionService</code></h4><p>  <code>ConversionService</code>被设计成<code>无状态对象</code>,在<code>容器</code>启动时被实例化,在多线程间进行共享(线程安全)。</p><p>在Spring应用中,可以自定义<code>类型转换器</code>。当需要框架进行类型转换时,Spring会选择<code>合适的类型转换器</code></p><p>使用。你也可以注入<code>ConversionService</code>到beans或者直接调用。</p><p>   <strong><code>注意</code></strong></p><blockquote><p>如果没有<code>ConversionService</code>注册到Spring容器,基于的<code>PropertyEditor</code>实现的类型转换会被使用。</p></blockquote><p>​    使用如下的方式,注册默认<code>ConversionService进</code>Spring容器中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertersConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"conversionService"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConversionServiceFactoryBean <span class="title">conversionServiceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ConversionServiceFactoryBean conversionServiceFactoryBean = <span class="keyword">new</span> ConversionServiceFactoryBean();</span><br><span class="line">        <span class="keyword">return</span> conversionServiceFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   默认的<code>ConversionService</code>可以在<code>字符串，数字，枚举，集合，映射和其他常见类型之间进行转换</code>。要使用您自己的自定义转换器补充或覆盖默认转换器,请设置converter属性.属性值可以实现任何Converter,ConverterFactory或GenericConverter接口。默认<code>ConversionService</code>实现是<code>DefaultConversionService</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertersConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"conversionService"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConversionServiceFactoryBean <span class="title">conversionServiceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ConversionServiceFactoryBean conversionServiceFactoryBean = <span class="keyword">new</span> ConversionServiceFactoryBean();</span><br><span class="line">        <span class="comment">//实现自定义的类型转换器</span></span><br><span class="line">        conversionServiceFactoryBean.setConverters(Collections.singleton(<span class="keyword">new</span> StringToDateConverter()));</span><br><span class="line">        <span class="keyword">return</span> conversionServiceFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   也可以使用<code>ConversionService</code>在Spring MVC应用中,参考<code>WebMvcConfigurationSupport</code>类,该类方法</p><p><code>addFormatters(FormatterRegistry registry)</code>可以注册自定义的<code>converters</code>。</p><p>   在某些情况,希望在类型转换期间需要格式化,参考<code>FormatterRegistry</code>。</p><p>   <strong>在程序中使用<code>ConversionService</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(ConversionService conversionService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.conversionService = conversionService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doIt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.conversionService.convert(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-Spring域属性格式化"><a href="#8-Spring域属性格式化" class="headerlink" title="8:Spring域属性格式化"></a>8:Spring域属性格式化</h4><p>   <code>core.convert</code>是一个<code>通用的类型转换系统</code>.它提供了统一的ConversionService API以及强类型转换器SPI,用于实现从一种类型到另一种类型的转换逻辑.Spring容器使用这个系统来<code>绑定bean属性值</code>。额外的,还要<code>SpEL</code>和</p><p><code>DataBinder</code>。<code>Spring3</code>引入了<code>Formatter SPI</code>来实现格式化属性值。<code>ConversionService</code>为两个SPI提供统一的类型转换API。</p><h5 id="1-Formatter-SPI"><a href="#1-Formatter-SPI" class="headerlink" title="(1):Formatter SPI"></a>(1):<code>Formatter SPI</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Formats objects of type T.</span></span><br><span class="line"><span class="comment"> * A Formatter is both a Printer &lt;i&gt;and&lt;/i&gt; a Parser for an object type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of object this Formatter formats</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Formatter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Printer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Parser</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parses text strings to produce instances of T.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of object this Parser produces</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Parser</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse a text String to produce a T.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text the text string</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> locale the current user locale</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an instance of T</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ParseException when a parse exception occurs in a java.text parsing library</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException when a parse exception occurs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">T <span class="title">parse</span><span class="params">(String text, Locale locale)</span> <span class="keyword">throws</span> ParseException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prints objects of type T for display.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of object this Printer prints</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Printer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Print the object of type T for display.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> object the instance to print</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> locale the current user locale</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the printed text string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">print</span><span class="params">(T object, Locale locale)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-Annotation-Driven-Formatting"><a href="#2-Annotation-Driven-Formatting" class="headerlink" title="(2):Annotation-Driven Formatting"></a>(2):<code>Annotation-Driven Formatting</code></h5><p>域格式化可以通过<code>域类型或者注解配置.</code>为了绑定注解在一个<code>Formatter</code>,实现<code>AnnotationFormatterFactory</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.format;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A factory that creates formatters to format values of fields annotated with a particular</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Annotation&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;For example, a &#123;<span class="doctag">@code</span> DateTimeFormatAnnotationFormatterFactory&#125; might create a formatter</span></span><br><span class="line"><span class="comment"> * that formats &#123;<span class="doctag">@code</span> Date&#125; values set on fields annotated with &#123;<span class="doctag">@code</span> <span class="doctag">@DateTimeFormat</span>&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;A&gt; the annotation type that should trigger formatting</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnnotationFormatterFactory</span>&lt;<span class="title">A</span> <span class="keyword">extends</span> <span class="title">Annotation</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; getFieldTypes();</span><br><span class="line"></span><br><span class="line">    Printer&lt;?&gt; getPrinter(A annotation, Class&lt;?&gt; fieldType);</span><br><span class="line"></span><br><span class="line">    Parser&lt;?&gt; getParser(A annotation, Class&lt;?&gt; fieldType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如实现<code>NumberFormatAnnotationFormatterFactory</code>,绑定<code>@NumberFormat</code>注解到<code>Formatter</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberFormatAnnotationFormatterFactory</span> <span class="keyword">extends</span> <span class="title">EmbeddedValueResolutionSupport</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">AnnotationFormatterFactory</span>&lt;<span class="title">NumberFormat</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getFieldTypes() &#123;</span><br><span class="line"><span class="keyword">return</span> NumberUtils.STANDARD_NUMBER_TYPES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Printer&lt;Number&gt; <span class="title">getPrinter</span><span class="params">(NumberFormat annotation, Class&lt;?&gt; fieldType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> configureFormatterFrom(annotation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Parser&lt;Number&gt; <span class="title">getParser</span><span class="params">(NumberFormat annotation, Class&lt;?&gt; fieldType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> configureFormatterFrom(annotation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Formatter&lt;Number&gt; <span class="title">configureFormatterFrom</span><span class="params">(NumberFormat annotation)</span> </span>&#123;</span><br><span class="line">String pattern = resolveEmbeddedValue(annotation.pattern());</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(pattern)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> NumberStyleFormatter(pattern);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Style style = annotation.style();</span><br><span class="line"><span class="keyword">if</span> (style == Style.CURRENCY) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> CurrencyStyleFormatter();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (style == Style.PERCENT) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> PercentStyleFormatter();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> NumberStyleFormatter();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-格式化注解API"><a href="#3-格式化注解API" class="headerlink" title="(3):格式化注解API"></a>(3):格式化注解API</h5><p><code>DateTimeFormat</code>和<code>NumberFormat</code>。</p><h5 id="4-FormatterRegistry-SPI"><a href="#4-FormatterRegistry-SPI" class="headerlink" title="(4):FormatterRegistry SPI"></a>(4):<code>FormatterRegistry SPI</code></h5><p><code>FormatterRegistry</code>是用来注册<code>formatters 和 converters</code>的<code>SPI</code>。<code>FormattingConversionService</code></p><p>是<code>FormatterRegistry</code> 一个实现,可以支持大多数环境。可以通过FormattingConversionServiceFactoryBean</p><p>来配置。也可以通过Spring’s <code>DataBinder</code>和<code>SpEL</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.format;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FormatterRegistry</span> <span class="keyword">extends</span> <span class="title">ConverterRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFormatterForFieldType</span><span class="params">(Class&lt;?&gt; fieldType, Printer&lt;?&gt; printer, Parser&lt;?&gt; parser)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFormatterForFieldType</span><span class="params">(Class&lt;?&gt; fieldType, Formatter&lt;?&gt; formatter)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFormatterForFieldType</span><span class="params">(Formatter&lt;?&gt; formatter)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFormatterForAnnotation</span><span class="params">(AnnotationFormatterFactory&lt;?, ?&gt; factory)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-FormatterRegistrar-SPI"><a href="#5-FormatterRegistrar-SPI" class="headerlink" title="(5):FormatterRegistrar SPI"></a>(5):<code>FormatterRegistrar SPI</code></h5><p><code>FormatterRegistrar</code>是通过<code>FormatterRegistry</code>注册formatters和converters的<code>SPI</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.format;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FormatterRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerFormatters</span><span class="params">(FormatterRegistry registry)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-在Spring-MVC配置Formatting"><a href="#9-在Spring-MVC配置Formatting" class="headerlink" title="9:在Spring MVC配置Formatting"></a>9:在Spring MVC配置Formatting</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Configuration</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addFormatters</span><span class="params">(FormatterRegistry registry)</span> </span>&#123;</span><br><span class="line">       registry.addConverter(<span class="keyword">new</span> StringToDateConverter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-配置全局的Date和时间Format"><a href="#10-配置全局的Date和时间Format" class="headerlink" title="10:配置全局的Date和时间Format"></a>10:配置全局的Date和时间Format</h4><p><code>JodaTimeFormatterRegistrar</code>和<code>DateFormatterRegistrar</code>,使用Joda需要引入joda库</p><p>配置如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FormattingConversionService <span class="title">conversionService</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use the DefaultFormattingConversionService but do not register defaults</span></span><br><span class="line">        DefaultFormattingConversionService conversionService = <span class="keyword">new</span> DefaultFormattingConversionService(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ensure @NumberFormat is still supported</span></span><br><span class="line">        conversionService.addFormatterForFieldAnnotation(<span class="keyword">new</span> NumberFormatAnnotationFormatterFactory());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Register date conversion with a specific global format</span></span><br><span class="line">        DateFormatterRegistrar registrar = <span class="keyword">new</span> DateFormatterRegistrar();</span><br><span class="line">        registrar.setFormatter(<span class="keyword">new</span> DateFormatter(<span class="string">"yyyyMMdd"</span>));</span><br><span class="line">        registrar.registerFormatters(conversionService);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> conversionService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><blockquote><p>Joda-Time提供不同类型表示日期<code>date,time,datetime</code>,需要通过<code>JodaTimeFormatterRegistrar</code>进行</p><p>注册。或者使用<code>DateTimeFormatterFactoryBean</code>来进行创建formatters。</p></blockquote><blockquote><p>如果您使用Spring MVC,请记住明确配置使用的转换服务.对于基于Java的@Configuration,这意味着扩展WebMvcConfigurationSupport类并覆盖mvcConversionService()方法.对于XML,您应该使用mvc:annotation-driven元素的conversion-service属性。 有关详细信息，请参阅转换和格式。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> Spring Type Converter </tag>
            
            <tag> 单例设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring注解属性覆盖</title>
      <link href="/2019/08/06/Spring%E6%B3%A8%E8%A7%A3%E5%B1%9E%E6%80%A7%E8%A6%86%E7%9B%96/"/>
      <url>/2019/08/06/Spring%E6%B3%A8%E8%A7%A3%E5%B1%9E%E6%80%A7%E8%A6%86%E7%9B%96/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring注解属性覆盖"><a href="#Spring注解属性覆盖" class="headerlink" title="Spring注解属性覆盖"></a>Spring注解属性覆盖</h2><h3 id="1-隐性覆盖"><a href="#1-隐性覆盖" class="headerlink" title="1:隐性覆盖"></a>1:隐性覆盖</h3><p>较低层次的注解覆盖其元注解的同名属性</p><p>AnnotationAttributes采用注解就近覆盖的设计原则。</p><blockquote><p>@Component</p><p>​    | -@Service</p><p>​           | -@TransactionalService</p><p>@Service较@Component,距离@TransactionalService注解更近，属于较低层次的注解。</p></blockquote><h3 id="2-显性覆盖"><a href="#2-显性覆盖" class="headerlink" title="2:显性覆盖"></a>2:显性覆盖</h3><p>@AliasFor提供的属性覆盖能力。</p><h5 id="1-理解Spring注解属性别名-Aliases"><a href="#1-理解Spring注解属性别名-Aliases" class="headerlink" title="(1):理解Spring注解属性别名(Aliases)"></a>(1):理解Spring注解属性别名(Aliases)</h5><ul><li>@AliasFor可用于同一注解属性方法之间相互别名。<strong>同一注解两个属性方法需要相互</strong></li></ul><p><strong>“@AliasFor”，默认值必须相等</strong>。</p><ul><li>多层次注解属性之间的@AliasFor关系只能由较低层次向较高层次建立。即<strong>就近原则</strong>。</li><li>AnnotatedElementUtils.getMergedAnnotationAttributes方法也符合属性别名完整语义。</li><li>Spring为Spring元注解和@AliasFor提供了属性覆盖和别名特性，最终由AnnotationAttributes</li></ul><p>对象表达语义。</p><h5 id="2-代码实例"><a href="#2-代码实例" class="headerlink" title="(2):代码实例"></a>(2):代码实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类描述:组合注解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/4/25 20:11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="comment">//表明注解属性覆盖符合就近原则,由低层次向高层次建立。</span></span><br><span class="line"><span class="meta">@Service</span>(value = <span class="string">"transactionalService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TransactionalService &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 服务Bean名称</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> "txManager"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆盖&#123;<span class="doctag">@link</span> Transactional#transactionManager()&#125;默认值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> org.springframework.transaction.PlatformTransactionManager&#125;Bean名称,默认关联</span></span><br><span class="line"><span class="comment">     * &lt;br/&gt;</span></span><br><span class="line"><span class="comment">     * "txManager"Bean</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * String transactionManager() default "txManager";</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"name"</span>)</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "txManager"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立&#123;<span class="doctag">@link</span> Transactional#transactionManager()&#125;别名</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> org.springframework.transaction.PlatformTransactionManager&#125;Bean名称,默认关联</span></span><br><span class="line"><span class="comment">     * "txManager"Bean.</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(annotation = Transactional.class, attribute = <span class="string">"transactionManager"</span>)</span><br><span class="line">    <span class="function">String <span class="title">manager</span><span class="params">()</span> <span class="keyword">default</span> "txManager"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-重要的类"><a href="#3-重要的类" class="headerlink" title="3:重要的类"></a>3:重要的类</h3><p>1：ClassPathBeanDefinitionScanner</p><p>   读取类路径下的候选Bean，默认选取@Component，@Service，@Repository，@Controller注解的类。继承了ClassPathScanningCandidateComponentProvider。在该类BeanDefinition集合的候选条件由includeFilters和excludeFilters字段决定，在方法isCandidateComponent里实现。</p><p>  该类允许自定义类型过滤规则。常见的TypeFilter类。</p><ul><li>AnnotationTypeFilter：匹配类是否还有指定注解</li><li>AssignableTypeFilter：判定此 <code>Class</code> 对象所表示的类或接口与指定的 <code>Class</code> 参数所表示的类或接口是否相同，或是否是其超类或超接口。</li><li>RegexPatternTypeFilter：匹配全类限定名是否符合指定正则表达式。</li><li>AspectJTypeFilter：使用AspectJ类型模式进行匹配</li></ul><p>2：类元信息读取</p><p>(1)：MetadataReaderFactory：生成MetadataReader工厂</p><ul><li>SimpleMetadataReaderFactory：使用ASM字节码操作技术</li><li>CachingMetadataReaderFactory：使用ASM字节码操作技术和带缓存。</li></ul><p>(2)：使用Java反射获取类元信息</p><ul><li>StandardClassMetadata：读取Class元信息</li><li>StandardAnnotationMetadata：读取注解元信息</li><li>StandardMethodMetadata：读取方法</li></ul><p>(3)：使用ASM操作</p><ul><li>AnnotationMetadataReadingVisitor：查找类上元注解信息</li><li>MethodMetadataReadingVisitor：查找方法上元注解信息</li><li>AnnotationAttributesReadingVisitor：元注解属性读取</li></ul><p>(4)：类注解元信息读取接口</p><ul><li>AnnotationMetadata：读取注解。通过getAnnotationTypes(String)获取”元注解”</li></ul><p>信息，提供getAnnotationAttributes(String)方法获取指定注解的属性方法。</p><ul><li>ClassMetadata：类注解</li><li>AnnotatedTypeMetadata：注解的元注解</li></ul><p>3：Spring注解属性抽象</p><ul><li>AnnotationAttributes</li><li>AnnotatedElementUtils：对查找注解，元注解等注解的工具类</li><li>AnnotationUtils：用于处理注解的工具类。</li><li>ReflectionUtils：反射工具类。</li></ul><p>代码示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类描述: 组合注解启动类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/4/25 20:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@TransactionalService</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComposeAnnotationApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String className = ComposeAnnotationApplication.class.getName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建MetadataReaderFactory</span></span><br><span class="line">        MetadataReaderFactory metadataReaderFactory = <span class="keyword">new</span> CachingMetadataReaderFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取@TransactionalService MetadataReader信息</span></span><br><span class="line">        MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取@TransactionalService AnnotationMetadata信息</span></span><br><span class="line">        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();</span><br><span class="line"></span><br><span class="line">        annotationMetadata.getAnnotationTypes().forEach(annotationType -&gt; &#123;</span><br><span class="line">            Set&lt;String&gt; metaAnnotationTypes = annotationMetadata.getMetaAnnotationTypes(annotationType);</span><br><span class="line"></span><br><span class="line">            metaAnnotationTypes.forEach(metaAnnotationType -&gt; System.out.println(String.format(</span><br><span class="line">                    <span class="string">"注解 %s 元标注; %s\n"</span>, annotationType, metaAnnotationType)));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">springStandardAnnotationMetadata</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//读取@TransactionalService AnnotationMetadata信息</span></span><br><span class="line">        AnnotationMetadata annotationMetadata = <span class="keyword">new</span> StandardAnnotationMetadata(ComposeAnnotationReflectionApplication.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有的元注解(全类名)集合</span></span><br><span class="line">        Set&lt;String&gt; metaAnnotationTypes = annotationMetadata.getAnnotationTypes()</span><br><span class="line">                .stream()</span><br><span class="line">                <span class="comment">//读取单注解元注解类型集合</span></span><br><span class="line">                .map(annotationMetadata::getMetaAnnotationTypes)</span><br><span class="line">                <span class="comment">//合并元注解类型集合</span></span><br><span class="line">                .collect(LinkedHashSet::<span class="keyword">new</span>, Set::addAll, Set::addAll);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取所有元注解类型</span></span><br><span class="line">        metaAnnotationTypes.forEach(metaAnnotation -&gt; &#123;</span><br><span class="line">            <span class="comment">//读取元注解属性</span></span><br><span class="line">            Map&lt;String, Object&gt; annotationAttributes = annotationMetadata.getAnnotationAttributes(metaAnnotation);</span><br><span class="line">            <span class="keyword">if</span> (!CollectionUtils.isEmpty(annotationAttributes)) &#123;</span><br><span class="line">                annotationAttributes.forEach((name, value) -&gt; System.out.printf(<span class="string">"注解 %s 属性 %s = %s\n"</span>,</span><br><span class="line">                        ClassUtils.getShortName(metaAnnotation), name, value));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>Spring从4.0.0.RELEASE版本开始支持多层次@Component派生性。</strong></p><p>1:Spring中@Component,@Repository,@Service,@Controller就属于<strong>@Component派生注解</strong>。</p><p>称之为<strong>Spring模式注解</strong>。</p><h3 id="4-注解驱动过渡时代：Spring-Framework-2-x"><a href="#4-注解驱动过渡时代：Spring-Framework-2-x" class="headerlink" title="4:注解驱动过渡时代：Spring Framework 2.x"></a>4:注解驱动过渡时代：Spring Framework 2.x</h3><p>新引入了一些骨架式的Annotation</p><ul><li>依赖注入Annotation：@Autowired(可注入单个Bean，也可注入集合)—&gt;限定类型Class方式。</li><li>依赖查找Annotation：@Qualifier</li><li>组件声明Annotation：@Component,@Service</li><li>Spring MVC Annotation：@Controller,@RequestMapping,@ModelAttributes等。</li></ul><p>支持<strong>可扩展的XML编写</strong>。即Spring的Schema和Handlers机制。</p><p>支持<strong>JSR-250</strong>规范@Resource注入，@PostConstruct，@PreDestroy等。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>Spring2.5允许自定义Spring模式注解，不过该版本仅支持单层次的模式注解<strong>“派生”</strong>。但是编程手段不多，**主要</p><p>的原因在于框架层次仍未<strong>注解</strong>提供驱动注解的Spring应用上下文，并且仍需要XML配置驱动，即XML元素&lt;context:annotation-config&gt;和&lt;context-component-scan&gt;。</p><h3 id="5-注解驱动黄金时代：Spring-Framework-3-x"><a href="#5-注解驱动黄金时代：Spring-Framework-3-x" class="headerlink" title="5:注解驱动黄金时代：Spring Framework 3.x"></a>5:注解驱动黄金时代：Spring Framework 3.x</h3><p>全面拥抱Java5(泛型,变量参数等)，以及Spring Annotation引入。例如引入了配置类注解@Configuration,AnnotationConfigApplicationContext。但是没有引入替换&lt;context:component-scan/&gt;注解。</p><p>选择过渡方案@Import,@ImportResource(需要标注@Configuration注解)。Spring3.1引入注解@ComponentScan。<strong>引入了REST开发</strong>。</p><p>SpringWeb整合了<strong>Servlet3.0+</strong>按规范，利用<strong>javax.servlet.ServletContainerInitialier</strong> API实现传统Servlet容器</p><p><strong>自动装配</strong>的能力，替换了传统的web.xml。</p><p>1:Spring3.1抽象了一套全新并统一配置属性API,包括<strong>配置属性存储接口Environment,以及配置属性源抽象PropertySource</strong>，这两个核心API奠定了<strong>SpringBoot外部化配置的基础，也是SpringCloud分布式配置基石</strong>。</p><p>2:然后是<strong>缓存抽象</strong>，主要API包括<strong>缓存Cache和缓存管理器CacheManager</strong>。配套注解<strong>Caching和Cacheable等</strong></p><p>极大简化了数据缓存开发。</p><p>3:异步支持，引入了异步操作注解<strong>@Async,周期异步操作@Scheduled及异步Web请求处理操作DefferedResult</strong>。</p><p>4:校验方面，新增了注解<strong>@Validated</strong>，整合JSR-303和适配了Spring早期的Validator抽象。</p><p>5:<strong>Enabled模块驱动</strong>特性。将<strong>相同职责功能组件以模块化的方式装配</strong>。例如<strong>EnabledWebMvc</strong>。</p><h3 id="6-注解驱动完善时代-Spring-Framework-4-x"><a href="#6-注解驱动完善时代-Spring-Framework-4-x" class="headerlink" title="6:注解驱动完善时代:Spring Framework 4.x"></a>6:注解驱动完善时代:Spring Framework 4.x</h3><p>引入了<strong>条件化注解@Conditional</strong>，通过与自定义Condition实现配合，弥补之前版本条件化配置装配的</p><p>短板。SpringBoot的所有@ConditionalOn<em>注解均基于@Conditional派生注解，其抽象类*</em>SpringBootCondition**也是Condition的实现。</p><p>Spring4.x兼容了Java Time API(JSR-310),@Repeatable及参数名称发现。Java8的@Repeatable出现，解决了</p><p>以往Annotation无法重复标注同一个类的限制。<strong>Spring4.2引入了事件监听器注解@EventListener</strong>。</p><p>Spring的<strong>派生</strong>特性需要确保<strong>注解之间属性方法签名一致</strong>。限制在Spring4.2新注解<strong>@AliasFor</strong>解除，实现了</p><p>同一注解类属性方法之间的别名。Spring4.3引入<strong>REST请求注解</strong>。</p><p>Spring4.x在Web注解驱动编程也有提示，例如<strong>@RestController,@RestControllerAdvice(对RestController AOP拦截通知)</strong>。</p><h3 id="7-注解驱动当下时代-Spring-Framework5-x"><a href="#7-注解驱动当下时代-Spring-Framework5-x" class="headerlink" title="7:注解驱动当下时代:Spring Framework5.x"></a>7:注解驱动当下时代:Spring Framework5.x</h3><p>在SpringBoot应用场景中，大量使用注解@ComponentScan扫描指定package,当扫描package所包含的类越多时,</p><p>Spring模式注解耗费时间越长。针对这个问题,Spring5.x新引入了注解<strong>@Indexed</strong>,为Spring模式注解添加索引，提升启动性能。需要引入<strong>spring-context-indexer</strong>依赖。</p><h5 id="7-1-Spring核心注解场景分类"><a href="#7-1-Spring核心注解场景分类" class="headerlink" title="7-1:Spring核心注解场景分类"></a>7-1:Spring核心注解场景分类</h5><p><strong>Spring模式注解:</strong></p><table><thead><tr><th align="center">Spring注解</th><th align="center">场景说明</th><th align="center">起始版本</th></tr></thead><tbody><tr><td align="center">@Repository</td><td align="center">数据仓库模式注解</td><td align="center">2.0</td></tr><tr><td align="center">@Component</td><td align="center">通用组件模式注解</td><td align="center">2.5</td></tr><tr><td align="center">@Service</td><td align="center">服务模式</td><td align="center">2.5</td></tr><tr><td align="center">@Controller</td><td align="center">Web控制器模式注解</td><td align="center">2.5</td></tr><tr><td align="center">@Configuration</td><td align="center">配置类模式注解</td><td align="center">3.0</td></tr></tbody></table><p><strong>装配注解</strong></p><table><thead><tr><th align="center">Spring注解</th><th align="center">场景说明</th><th align="center">起始版本</th></tr></thead><tbody><tr><td align="center">@ImportResource</td><td align="center">替换XML元素&lt;import&gt;</td><td align="center">2.5</td></tr><tr><td align="center">@Import</td><td align="center">限定@Autowired依赖注解范围</td><td align="center">2.5</td></tr><tr><td align="center">@ComponentScan</td><td align="center">扫描指定package下标注Spring模式注解</td><td align="center">3.1</td></tr></tbody></table><p><strong>依赖注入注解</strong></p><table><thead><tr><th align="center">Spring注解</th><th align="center">场景说明</th><th align="center">起始版本</th></tr></thead><tbody><tr><td align="center">@Autowired</td><td align="center">Bean依赖注解,支持多种依赖查找方式</td><td align="center">2.5</td></tr><tr><td align="center">@Qualifier</td><td align="center">细粒度的@Autowired依赖查找</td><td align="center">2.5</td></tr><tr><td align="center">Java注解</td><td align="center">场景说明</td><td align="center">起始版本</td></tr><tr><td align="center">@Resource</td><td align="center">Bean依赖注入,仅支持名称依赖查找</td><td align="center">2.5</td></tr></tbody></table><p><strong>Bean定义注解</strong></p><table><thead><tr><th align="center">Spring注解</th><th align="center">场景说明</th><th align="center">起始版本</th></tr></thead><tbody><tr><td align="center">@Bean</td><td align="center">替换XML元素&lt;bean&gt;</td><td align="center">3.0</td></tr><tr><td align="center">@DependsOn</td><td align="center">替换XML属性&lt;bean depends-on=”…”/&gt;</td><td align="center">3.0</td></tr><tr><td align="center">@Lazy</td><td align="center">替换XML属性&lt;bean lazy-init=”trus|false”/&gt;</td><td align="center">3.0</td></tr><tr><td align="center">@Primary</td><td align="center">替换XML元素&lt;bean primary=”true|false”/&gt;</td><td align="center">3.0</td></tr><tr><td align="center">@Role</td><td align="center">替换XML元素&lt;bean role=”…”/&gt;</td><td align="center">3.1</td></tr><tr><td align="center">@Lookup</td><td align="center">替换XML属性&lt;bean lookup-method=”…”&gt;</td><td align="center">4.1</td></tr></tbody></table><p><strong>Spring条件装配注解</strong></p><table><thead><tr><th align="center">Spring注解</th><th align="center">场景说明</th><th align="center">起始版本</th></tr></thead><tbody><tr><td align="center">@Profile</td><td align="center">配置化条件装配</td><td align="center">3.1</td></tr><tr><td align="center">@Conditional</td><td align="center">编程条件装配</td><td align="center">3.1</td></tr></tbody></table><p><strong>配置属性注解</strong></p><table><thead><tr><th align="center">Spring注解</th><th align="center">场景说明</th><th align="center">起始版本</th></tr></thead><tbody><tr><td align="center">@PropertySource</td><td align="center">配置属性抽象PropertySource注解</td><td align="center">3.1</td></tr><tr><td align="center">@PropertySources</td><td align="center">@PropertySource集合注解</td><td align="center">4.0</td></tr></tbody></table><p><strong>生命周期回调注解</strong></p><table><thead><tr><th align="center">Java注解</th><th align="center">场景说明</th><th align="center">起始版本</th></tr></thead><tbody><tr><td align="center">@PostContruct</td><td align="center">替换XML元素&lt;bean init-method=”…”/&gt;</td><td align="center">2.5</td></tr><tr><td align="center">@PreDestroy</td><td align="center">替换XML元素&lt;bean destroy-method=”…”/&gt;</td><td align="center">2.5</td></tr></tbody></table><p><strong>注解属性注解</strong></p><table><thead><tr><th align="center">Spring注解</th><th align="center">场景说明</th><th align="center">起始版本</th></tr></thead><tbody><tr><td align="center">@AliasFor</td><td align="center">别名注解属性,实现复用目的</td><td align="center">4.2</td></tr></tbody></table><p><strong>性能注解</strong></p><table><thead><tr><th align="center">Spring注解</th><th align="center">场景说明</th><th align="center">起始版本</th></tr></thead><tbody><tr><td align="center">@Indexed</td><td align="center">提升Spring模式注解扫描效率</td><td align="center">5.0</td></tr></tbody></table><h5 id="8-AnnotationMetadata注解的实现"><a href="#8-AnnotationMetadata注解的实现" class="headerlink" title="8:AnnotationMetadata注解的实现"></a>8:AnnotationMetadata注解的实现</h5><blockquote><p>在AnnotationMetadata语义上,基于<code>Java反射StandardAnnotationMetadata</code>和<code>AnnotationMetadataReadingVisitor</code>保持一致。基于Java反射API实现必然需要<code>反射的Class被ClassLoader加载</code>，当指定Java Package扫描Spring模式注解时,StandardAnnotationMetadata显然不适应。</p><p>因为<code>应用不需要将指定Package下的Class全部加载</code>。基于ASM实现的<code>AnnotationMetadataReadingVisitor</code>更适合这种场景，解释了为什么该类出现ClassPathScanningCandidateComponentProvider实现中。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Annotation </tag>
            
            <tag> Spring注解属性覆盖 </tag>
            
            <tag> Spring核心注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Guava简介</title>
      <link href="/2019/08/06/Guava%E7%AE%80%E4%BB%8B/"/>
      <url>/2019/08/06/Guava%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h2><p>Guava工程包含了若干被Google的 Java项目广泛依赖 的核心库，例如：<strong>集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [common annotations] 、字符串处理 [string processing] 、I/O 等等</strong>。 所有这些工具每天都在被Google的工程师应用在产品服务中。</p><h2 id="2-基本工具"><a href="#2-基本工具" class="headerlink" title="2.基本工具"></a>2.基本工具</h2><ol><li><strong>使用和避免null: Optional</strong></li><li><strong>前置条件: Preconditions</strong></li><li><strong>常见Object方法: Objects</strong></li><li><strong>排序: Guava强大的”流畅风格比较器”:</strong> <strong>Ordering</strong></li><li><a href="http://ifeve.com/google-guava-throwables/" target="_blank" rel="noopener"><strong>Throwables</strong></a>: 简化了异常和错误的传播与检查 :  <strong>Throwables</strong></li><li><strong>编码类型:</strong> Charsets</li></ol><h2 id="3-集合"><a href="#3-集合" class="headerlink" title="3.集合"></a>3.集合</h2><ol><li><a href="http://ifeve.com/google-guava-immutablecollections/" target="_blank" rel="noopener"><strong>不可变集合</strong></a>: 用不变的集合进行防御性编程和性能提升:  Immutable开头。</li><li><a href="http://ifeve.com/google-guava-newcollectiontypes/" target="_blank" rel="noopener"><strong>新集合类型</strong></a>: multisets, multimaps, tables, bidirectional maps等</li><li><a href="http://ifeve.com/google-guava-collectionutilities/" target="_blank" rel="noopener"><strong>强大的集合工具类</strong></a>: 提供java.util.Collections中没有的集合工具</li><li><a href="http://ifeve.com/google-guava-collectionhelpersexplained/" target="_blank" rel="noopener"><strong>扩展工具类</strong></a>：让实现和扩展集合类变得更容易，比如创建Collection的装饰器，或实现迭代器</li></ol><h2 id="4-缓存-Caches"><a href="#4-缓存-Caches" class="headerlink" title="4.缓存[Caches]"></a>4.<a href="http://ifeve.com/google-guava-cachesexplained" target="_blank" rel="noopener">缓存</a>[Caches]</h2><p>Guava Cache: 本地缓存实现,支持多种缓存过期策略。</p><h2 id="5-函数式风格-Functional-idioms"><a href="#5-函数式风格-Functional-idioms" class="headerlink" title="5.函数式风格[Functional idioms]"></a>5.<a href="http://ifeve.com/google-guava-functional/" target="_blank" rel="noopener">函数式风格</a>[Functional idioms]</h2><p><strong>Guava函数式支持可以显著简化代码,但请谨慎使用。</strong></p><h2 id="6-并发-Concurrency"><a href="#6-并发-Concurrency" class="headerlink" title="6.并发[Concurrency]"></a>6.并发[Concurrency]</h2><ol><li><a href="http://ifeve.com/google-guava-listenablefuture/" target="_blank" rel="noopener"><strong>ListenableFuture</strong></a>：完成后触发回调的Future</li><li><a href="http://ifeve.com/google-guava-serviceexplained/" target="_blank" rel="noopener"><strong>Service框架</strong></a>：抽象可开启和关闭的服务，帮助你维护服务的状态逻辑</li></ol><h2 id="7-字符串处理-Strings"><a href="#7-字符串处理-Strings" class="headerlink" title="7.字符串处理[Strings]"></a>7.<a href="http://ifeve.com/google-guava-strings/" target="_blank" rel="noopener">字符串处理</a>[Strings]</h2><p>非常有用的字符串工具，包括分割、连接、填充等操作</p><h2 id="8-原生类型-Primitives"><a href="#8-原生类型-Primitives" class="headerlink" title="8.原生类型[Primitives]"></a>8.<a href="http://ifeve.com/google-guava-primitives/" target="_blank" rel="noopener">原生类型</a>[Primitives]</h2><p>扩展 JDK 未提供的原生类型（如int、char）操作， 包括某些类型的无符号形式</p><h2 id="9-区间-Ranges"><a href="#9-区间-Ranges" class="headerlink" title="9.区间[Ranges]"></a>9.<a href="http://ifeve.com/google-guava-ranges/" target="_blank" rel="noopener">区间</a>[Ranges]</h2><p>可比较类型的区间API，包括连续和离散类型</p><h2 id="10-I-O"><a href="#10-I-O" class="headerlink" title="10.I/O"></a>10.<a href="http://ifeve.com/google-guava-io/" target="_blank" rel="noopener">I/O</a></h2><p>简化I/O尤其是I/O流和文件的操作，<strong>针对Java5和6版本</strong></p><h2 id="11-散列-Hash"><a href="#11-散列-Hash" class="headerlink" title="11.散列[Hash]"></a>11.<a href="http://ifeve.com/google-guava-hashing/" target="_blank" rel="noopener">散列</a>[Hash]</h2><p>提供比Object.hashCode()更复杂的散列实现，<strong>并提供布鲁姆过滤器的实现</strong></p><h2 id="12-事件总线-EventBus"><a href="#12-事件总线-EventBus" class="headerlink" title="12. 事件总线[EventBus]"></a>12. <a href="http://ifeve.com/google-guava-eventbus/" target="_blank" rel="noopener">事件总线</a>[EventBus]</h2><p>发布-订阅模式的组件通信，但组件不需要显式地注册到其他组件中</p><h2 id="13-数学运算-Math"><a href="#13-数学运算-Math" class="headerlink" title="13.数学运算[Math]"></a>13.<a href="http://ifeve.com/google-guava-math/" target="_blank" rel="noopener">数学运算</a>[Math]</h2><p>优化的、充分测试的数学工具类</p><h2 id="14-反射-Reflection"><a href="#14-反射-Reflection" class="headerlink" title="14.反射[Reflection]"></a>14.<a href="http://ifeve.com/guava-reflection/" target="_blank" rel="noopener">反射</a>[Reflection]</h2><p>Guava 的 Java 反射机制工具类</p>]]></content>
      
      
      <categories>
          
          <category> Guava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Guava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot自动配置原理</title>
      <link href="/2019/08/05/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/"/>
      <url>/2019/08/05/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot自动配置原理"><a href="#SpringBoot自动配置原理" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h2><h4 id="1-产生背景"><a href="#1-产生背景" class="headerlink" title="1:产生背景"></a>1:产生背景</h4><p>  在Spring Framework时代,当Spring应用的@Component或者@Configuration Class需要被装配</p><p>时,应用需要借助@Import或者@ComponentScan的能力。由于应用依赖的Jar存在变化的可能,</p><p>因此其中的@Component或者@Configuration Class所在的包路径也会发生变化。</p><p>  <code>不鼓励开发人员通过@ComponentScan或者@SpringApplication</code>注解方式扫描默认包。<strong>因为</strong></p><p><strong>它读取所有JAR中类,并且可能会造成默认Spring Boot错误</strong></p><p>   当Spring应用自动装配某些组件时,它需要一种综合性技术手段,<strong>重新深度结合Spring注解编程</strong></p><p><strong>模型,@Enable模块驱动和条件装配等Spring Framework原生特性,这种技术就是Spring Boot</strong></p><p><strong>自动装配。</strong></p><h4 id="2-理解Spring-Boot自动装配"><a href="#2-理解Spring-Boot自动装配" class="headerlink" title="2:理解Spring Boot自动装配"></a>2:理解Spring Boot自动装配</h4><p>(1):理解@EnableAutoConfiguration</p><p>用于激活Spring Boot自动装配特性。</p><p>(2):优雅的替换自动装配</p><p>开发人员可在任意一处定义配置类,从而覆盖那些被自动装配的组件。<code>SpringBoot优先解析</code></p><p><code>自定义配置类。内建的配置类,一旦应用存在自定义实现，就不会再装配</code>。</p><p>(3):失效自动装配</p><p>SpringBoot提供两种失效手段</p><ul><li>代码配置方式<ul><li>配置类型安全属性方法:@EnableAutoConfiguration.exclude()</li><li>配置排除类名方式:@EnableAutoConfiguration.excludeName()</li></ul></li><li>外部化配置方式<ul><li>配置属性:spring.autoconfigure.exclude</li></ul></li></ul><h4 id="3-自动装配原理"><a href="#3-自动装配原理" class="headerlink" title="3:自动装配原理"></a>3:自动装配原理</h4><p>  依照@Enable模块驱动设计模式，@EnableAutoConguration必然是@Import 类ImportSelector</p><p>或者ImportBeanDefinitionRegistrar的实现类。</p><p><strong>AutoConfigurationImportSelector主要执行逻辑:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line"><span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line"><span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//读取自动装配元信息配置文件</span></span><br><span class="line">       <span class="comment">//"META-INF/"+ "spring-autoconfigure-metadata.properties"</span></span><br><span class="line">AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">.loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">       <span class="comment">//获取@EnableAutoConfiguration注解属性</span></span><br><span class="line">AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">       <span class="comment">//获取自动装配Class候选列表</span></span><br><span class="line">List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">attributes);</span><br><span class="line">       <span class="comment">//移除重复的自动装配类名</span></span><br><span class="line">configurations = removeDuplicates(configurations);</span><br><span class="line">       <span class="comment">//排除自动装配组件</span></span><br><span class="line">Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">       <span class="comment">//检查排除类名集合是否合法</span></span><br><span class="line">checkExcludedClasses(configurations, exclusions);</span><br><span class="line">configurations.removeAll(exclusions);</span><br><span class="line">       <span class="comment">//过滤候选自动装配组件集合中Class不存在成员</span></span><br><span class="line">configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">       <span class="comment">//触发自动装配导入事件</span></span><br><span class="line">fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line"><span class="keyword">return</span> StringUtils.toStringArray(configurations);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(1):读取候选装配组件</p><p>使用了Spring工厂加载类<code>SpringFactoriesLoader</code>。原理如下</p><ul><li><p>搜索指定ClassLoader下所有的META-INF/spring.factories资源内容。</p></li><li><p>将一个或者多个META-INF/spring.factories资源内容作为Properties文件读取,并合并为</p><p>一个Key为接口的全类限定名,Value是实现类的全类名列表的Map,作为返回值。</p></li><li><p>再从上一步返回Map中查找并返回方法指定类名所映射的实现类全类名列表。</p></li></ul><p>SpringBoot自动装配列表存在地方</p><ul><li>spring-boot-autoconfigure模块</li><li>spring-boot-actuator-autoconfigure模块</li><li>spring-boot-devtools模块(可选)</li></ul><p>由于@EnableAutoConfiguration配置可能存在配置组件类名重复定义情况,当获取所有候选类,</p><p>立即执行removeDuplicates(List)方法,利用Set不可重复性达到去重的目的。</p><p>(2):排除自动装配组件</p><p>当<code>getExclusions(AnnotationMetadata metadata,AnnotationAttributes attributes)</code></p><p>执行后,程序将获取到一个自动装配Class排除列表。随后检查排除类名集合是否合法。当排除类</p><p>存在于当前的ClassLoader但是不在自动装配名单中,将触发排除类非法异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkExcludedClasses</span><span class="params">(List&lt;String&gt; configurations,</span></span></span><br><span class="line"><span class="function"><span class="params">Set&lt;String&gt; exclusions)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; invalidExcludes = <span class="keyword">new</span> ArrayList&lt;&gt;(exclusions.size());</span><br><span class="line"><span class="keyword">for</span> (String exclusion : exclusions) &#123;</span><br><span class="line">           <span class="comment">//存在当前ClassLoader但是不在自动装配列表名单</span></span><br><span class="line"><span class="keyword">if</span> (ClassUtils.isPresent(exclusion, getClass().getClassLoader())</span><br><span class="line">&amp;&amp; !configurations.contains(exclusion)) &#123;</span><br><span class="line">invalidExcludes.add(exclusion);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!invalidExcludes.isEmpty()) &#123;</span><br><span class="line">handleInvalidExcludes(invalidExcludes);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3):过滤自动装配组件</p><p>移除排除类名单后Configurations配合AutoConfigurationMetadata对象执行过滤操作。</p><p>(4):@EnableAutoConfiguration自动装配事件</p><p> SpringBoot1.5开始引入<code>AutoConfigurationImportListener</code>接口,自定义Java EventListener</p><p>,仅监听AutoConfigurationImportEvent,然后实例同样被SpringFactoriesLoader加载。其中,</p><p><code>ConditionEvaluationReportAutoConfigurationImportListener</code>就是内建实现,用于</p><p>记录自动装配组件的条件评估详情。</p><p>(5):EnableAutoConfiguration自动装配生命周期</p><p><code>DeferredImportSelector</code>作为<code>ImportSelector</code>变种,它在@Configuration Bean处理完毕</p><p>后才运作。在<code>@Conditional</code>场景尤为有用，同时该实现类可通过Ordered接口或者@Order</p><p>方式调整其优先顺序。</p><p> 该接口提供两类方法: process()和selectImports()。前者二次处理selectImports()方法返回</p><p>的结果，后者负责决定本组应该导入的Configuration Class作为实际导入的结果。</p><p>(6):EnableAutoConfiguration排序自动装配组件</p><p> SpringBoot提供两种自动装配组件排序手段:</p><ul><li>绝对自动装配顺序:@AutoConfigurationOrder</li><li>相对自动装配顺序:@AutoConfigurationBefore和@AutoConfigurationAfter。(常用)</li></ul><p>(7):EnableAutoConfiguration自动装配BasePackages</p><p> SpringBoot1.3开始引用注解@AutoConfigurationPackage。</p><p> 该注解的实现类常常用于默认包获取。例如JPA实现获取默认包。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 自动配置原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>@Enable模块驱动原理</title>
      <link href="/2019/08/05/Enable%E6%A8%A1%E5%9D%97%E9%A9%B1%E5%8A%A8%E5%8E%9F%E7%90%86/"/>
      <url>/2019/08/05/Enable%E6%A8%A1%E5%9D%97%E9%A9%B1%E5%8A%A8%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Enable模块驱动原理"><a href="#Enable模块驱动原理" class="headerlink" title="@Enable模块驱动原理"></a>@Enable模块驱动原理</h2><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1:概述"></a>1:概述</h4><p><strong>@Enable模块驱动</strong>在<em>Spring3.1</em>后开始支持。这里的<em>模块指具备相同领域的功能组件集合,组合所形成的一个独立的单元</em>。例如Web MVC模块,AspectJ代理模块,Caching模块,JMX模块,Async模块等。通过@Enable模块驱动,可以开启响应的模块功能。</p><p>@Enable模块驱动可以分为”注解驱动”和”接口编程”两种实现方式。<strong>都需要配合@Import注解。</strong></p><blockquote><ul><li>注解驱动:通过@Configuration类和@Bean方法声明类。例如Web MVC模块实现,即@EnableWebMvc注解通过导入DelegatingWebMvcConfiguration来实现。</li><li>接口编程:ImportSelector和ImportBeanDefinitionRegistrar的实现类。例如Caching模块实现,即</li></ul><p>@EnableCaching注解通过导入CachingConfigurationSelector实现。</p></blockquote><h4 id="2-实现示例"><a href="#2-实现示例" class="headerlink" title="2:实现示例"></a>2:实现示例</h4><h5 id="1-注解驱动"><a href="#1-注解驱动" class="headerlink" title="(1):注解驱动"></a>(1):注解驱动</h5><p><strong>基于ImportSelector接口</strong></p><p>@EnableWebMvc模块实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(DelegatingWebMvcConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableWebMvc &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注解通过<em>@Import<em>导入一个配置类</em>DelegatingWebMvcConfiguration</em>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line">      ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该配置类又继承自<em>WebMvcConfigurationSupport</em>,里面定义一些Web Mvc必须Bean声明。</p><blockquote><p>所以，基于注解驱动的<code>@Enable</code>模块驱动其实就是通过<code>@Import</code>来导入一个配置类，以此实现相应模块的组件注册，当这些组件注册到IOC容器中，这个模块对应的功能也就可以使用了。</p></blockquote><h5 id="2-接口编程"><a href="#2-接口编程" class="headerlink" title="(2):接口编程"></a>(2):接口编程</h5><p>@EnableCaching模块实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(CachingConfigurationSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableCaching &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">AdviceMode <span class="title">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>@EnableCaching*注解通过</em>@Import<em>导入</em>CachingConfigurationSelector<em>类,该类间接实现了</em>ImportSelector*。</p><blockquote><p><strong>ImportSelector</strong>使用Spring<code>注解元信息抽象AnnotationMetadata</code>作为方法参数,该参数内容为导入ImportSelector实现的@Configuration类元信息,进而动态的选择一个或者多个其他@Configuration类进行导入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt; * Interface to be implemented by types that determine which @&#123;<span class="doctag">@link</span> Configuration&#125;</span></span><br><span class="line"><span class="comment">&gt; * class(es) should be imported based on a given selection criteria, usually one or more</span></span><br><span class="line"><span class="comment">&gt; * annotation attributes.</span></span><br><span class="line"><span class="comment">&gt; *</span></span><br><span class="line"><span class="comment">&gt; * &lt;p&gt;An &#123;<span class="doctag">@link</span> ImportSelector&#125; may implement any of the following</span></span><br><span class="line"><span class="comment">&gt; * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.Aware Aware&#125; interfaces, and their respective</span></span><br><span class="line"><span class="comment">&gt; * methods will be called prior to &#123;<span class="doctag">@link</span> #selectImports&#125;:</span></span><br><span class="line"><span class="comment">&gt; * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">&gt; * &lt;li&gt;&#123;<span class="doctag">@link</span> org.springframework.context.EnvironmentAware EnvironmentAware&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">&gt; * &lt;li&gt;&#123;<span class="doctag">@link</span> org.springframework.beans.factory.BeanFactoryAware BeanFactoryAware&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">&gt; * &lt;li&gt;&#123;<span class="doctag">@link</span> org.springframework.beans.factory.BeanClassLoaderAware BeanClassLoaderAware&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">&gt; * &lt;li&gt;&#123;<span class="doctag">@link</span> org.springframework.context.ResourceLoaderAware ResourceLoaderAware&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">&gt; * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">&gt; *</span></span><br><span class="line"><span class="comment">&gt; * &lt;p&gt;ImportSelectors are usually processed in the same way as regular &#123;<span class="doctag">@code</span> <span class="doctag">@Import</span>&#125;</span></span><br><span class="line"><span class="comment">&gt; * annotations, however, it is also possible to defer selection of imports until all</span></span><br><span class="line"><span class="comment">&gt; * &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; classes have been processed (see &#123;<span class="doctag">@link</span> DeferredImportSelector&#125;</span></span><br><span class="line"><span class="comment">&gt; * for details).</span></span><br><span class="line"><span class="comment">&gt; *</span></span><br><span class="line"><span class="comment">&gt; * <span class="doctag">@author</span> Chris Beams</span></span><br><span class="line"><span class="comment">&gt; * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment">&gt; * <span class="doctag">@see</span> DeferredImportSelector</span></span><br><span class="line"><span class="comment">&gt; * <span class="doctag">@see</span> Import</span></span><br><span class="line"><span class="comment">&gt; * <span class="doctag">@see</span> ImportBeanDefinitionRegistrar</span></span><br><span class="line"><span class="comment">&gt; * <span class="doctag">@see</span> Configuration</span></span><br><span class="line"><span class="comment">&gt; */</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;  * Select and return the names of which class(es) should be imported based on</span></span><br><span class="line"><span class="comment">&gt;  * the &#123;<span class="doctag">@link</span> AnnotationMetadata&#125; of the importing @&#123;<span class="doctag">@link</span> Configuration&#125; class.</span></span><br><span class="line"><span class="comment">&gt;  */</span></span><br><span class="line">&gt; String[] selectImports(AnnotationMetadata importingClassMetadata);</span><br><span class="line">&gt; </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>基于ImportBeanDefinitionRegistrar接口</strong></p><p>@MapperScan模块实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperScannerRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AnnotationAttributes annoAttrs = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));</span><br><span class="line">    ClassPathMapperScanner scanner = <span class="keyword">new</span> ClassPathMapperScanner(registry);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationClass = annoAttrs.getClass(<span class="string">"annotationClass"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!Annotation.class.equals(annotationClass)) &#123;</span><br><span class="line">      scanner.setAnnotationClass(annotationClass);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    scanner.registerFilters();</span><br><span class="line">    scanner.doScan(StringUtils.toStringArray(basePackages));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口的编程复杂度相比较于ImportSelector更高,接口将Bean定义的注册交给开发人员。常常配合<code>ClassPathBeanDefinitionScanner</code>类进行批量注册BeanDefinition。</p><blockquote><p><strong>ImportBeanDefinitionRegistrar</strong>:除注解元信息AnnotationMetadata作为入参外,接口将</p><p>Bean定义注册交给开发人员。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt; * Interface to be implemented by types that register additional bean definitions when</span></span><br><span class="line"><span class="comment">&gt; * processing @&#123;<span class="doctag">@link</span> Configuration&#125; classes. Useful when operating at the bean definition</span></span><br><span class="line"><span class="comment">&gt; * level (as opposed to &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; method/instance level) is desired or necessary.</span></span><br><span class="line"><span class="comment">&gt; *</span></span><br><span class="line"><span class="comment">&gt; * &lt;p&gt;Along with &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; and &#123;<span class="doctag">@link</span> ImportSelector&#125;, classes of this type</span></span><br><span class="line"><span class="comment">&gt; * may be provided to the @&#123;<span class="doctag">@link</span> Import&#125; annotation (or may also be returned from an</span></span><br><span class="line"><span class="comment">&gt; * &#123;<span class="doctag">@code</span> ImportSelector&#125;).</span></span><br><span class="line"><span class="comment">&gt; *</span></span><br><span class="line"><span class="comment">&gt; * &lt;p&gt;An &#123;<span class="doctag">@link</span> ImportBeanDefinitionRegistrar&#125; may implement any of the following</span></span><br><span class="line"><span class="comment">&gt; * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.Aware Aware&#125; interfaces, and their respective</span></span><br><span class="line"><span class="comment">&gt; * methods will be called prior to &#123;<span class="doctag">@link</span> #registerBeanDefinitions&#125;:</span></span><br><span class="line"><span class="comment">&gt; * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">&gt; * &lt;li&gt;&#123;<span class="doctag">@link</span> org.springframework.context.EnvironmentAware EnvironmentAware&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">&gt; * &lt;li&gt;&#123;<span class="doctag">@link</span> org.springframework.beans.factory.BeanFactoryAware BeanFactoryAware&#125;</span></span><br><span class="line"><span class="comment">&gt; * &lt;li&gt;&#123;<span class="doctag">@link</span> org.springframework.beans.factory.BeanClassLoaderAware BeanClassLoaderAware&#125;</span></span><br><span class="line"><span class="comment">&gt; * &lt;li&gt;&#123;<span class="doctag">@link</span> org.springframework.context.ResourceLoaderAware ResourceLoaderAware&#125;</span></span><br><span class="line"><span class="comment">&gt; * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">&gt; *</span></span><br><span class="line"><span class="comment">&gt; * &lt;p&gt;See implementations and associated unit tests for usage examples.</span></span><br><span class="line"><span class="comment">&gt; *</span></span><br><span class="line"><span class="comment">&gt; * <span class="doctag">@author</span> Chris Beams</span></span><br><span class="line"><span class="comment">&gt; * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment">&gt; * <span class="doctag">@see</span> Import</span></span><br><span class="line"><span class="comment">&gt; * <span class="doctag">@see</span> ImportSelector</span></span><br><span class="line"><span class="comment">&gt; * <span class="doctag">@see</span> Configuration</span></span><br><span class="line"><span class="comment">&gt; */</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;  * Register bean definitions as necessary based on the given annotation metadata of</span></span><br><span class="line"><span class="comment">&gt;  * the importing &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment">&gt;  * &lt;p&gt;Note that &#123;<span class="doctag">@link</span> BeanDefinitionRegistryPostProcessor&#125; types may &lt;em&gt;not&lt;/em&gt; be</span></span><br><span class="line"><span class="comment">&gt;  * registered here, due to lifecycle constraints related to &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125;</span></span><br><span class="line"><span class="comment">&gt;  * class processing.</span></span><br><span class="line"><span class="comment">&gt;  * <span class="doctag">@param</span> importingClassMetadata annotation metadata of the importing class</span></span><br><span class="line"><span class="comment">&gt;  * <span class="doctag">@param</span> registry current bean definition registry</span></span><br><span class="line"><span class="comment">&gt;  */</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">&gt; AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span></span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="3-Enable模块驱动原理"><a href="#3-Enable模块驱动原理" class="headerlink" title="3:@Enable模块驱动原理"></a>3:@Enable模块驱动原理</h4><p>1:概述</p><p>@Enable模块驱动,模块无论来自于Spring内建,还是自定义,均使用<code>@Import</code>实现,<strong>并且该注解的职责在于装载导入类,将其定义为Spring Bean。导入主要为@Configuration Class,ImportSelector实现及ImportBeanDefinitionRegistrar实现。</strong></p><p>2:源码实现</p><p>(1):装载@Configuration Class。</p><p>@Configuration从Spring3.0开始引入,<em>该版本还未引入@ComponentScan</em>。因此,开发人员经常看到XML元素&lt;context:component-scan/&gt;与&lt;context:annotation-config&gt;同时存在。根据Spring的”可扩展XML编写”特性,可以知道&lt;context:annotation-config&gt;所对应的BeanDefinitionParser实现为AnnotationConfigBeanDefinitionParser。</p><p>AnnotationConfigBeanDefinitionParser</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parser for the &amp;lt;context:annotation-config/&amp;gt; element.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mark Fisher</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Christian Dupuis</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> AnnotationConfigUtils</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationConfigBeanDefinitionParser</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">Object source = parserContext.extractSource(element);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Obtain bean definitions for all relevant BeanPostProcessors.</span></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; processorDefinitions =</span><br><span class="line">AnnotationConfigUtils.registerAnnotationConfigProcessors(parserContext.getRegistry(), source);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AnnotationConfigUtils在Spring3.0增加了@Configuration Class的处理实现ConfigurationClassPostProcessor:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class AnnotationConfigUtils &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The bean name of the internally managed Configuration annotation processor.</span><br><span class="line"> */</span><br><span class="line">public static final String CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME =</span><br><span class="line">&quot;org.springframework.context.annotation.internalConfigurationAnnotationProcessor&quot;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The bean name of the internally managed BeanNameGenerator for use when processing</span><br><span class="line"> * &#123;@link Configuration&#125; classes. Set by &#123;@link AnnotationConfigApplicationContext&#125;</span><br><span class="line"> * and &#123;@code AnnotationConfigWebApplicationContext&#125; during bootstrap in order to make</span><br><span class="line"> * any custom name generation strategy available to the underlying</span><br><span class="line"> * &#123;@link ConfigurationClassPostProcessor&#125;.</span><br><span class="line"> * @since 3.1.1</span><br><span class="line"> */</span><br><span class="line">public static final String CONFIGURATION_BEAN_NAME_GENERATOR =</span><br><span class="line">&quot;org.springframework.context.annotation.internalConfigurationBeanNameGenerator&quot;;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Register all relevant annotation post processors in the given registry.</span><br><span class="line"> * @param registry the registry to operate on</span><br><span class="line"> */</span><br><span class="line">public static void registerAnnotationConfigProcessors(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">registerAnnotationConfigProcessors(registry, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static Set&lt;BeanDefinitionHolder&gt; registerAnnotationConfigProcessors(</span><br><span class="line">BeanDefinitionRegistry registry, Object source) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; beanDefs = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(4);</span><br><span class="line"></span><br><span class="line">if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);</span><br><span class="line">def.setSource(source);</span><br><span class="line">beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">return beanDefs;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的说,ConfigurationClassPostProcessor无论实在XML配置驱动还是在注解驱动使用场景下,均通过AnnotationConfigUtils.registerAnnotationConfigProcessors(registry,source)方法执行得到装载,且为最高优先级。不但处理了@Configuration Class,也负责@Bean方法的Bean定义。</p><p>(2):ConfigurationClassPostProcessor处理</p><p>//主要处理方法落在processConfigBeanDefinitions(registry)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationClassPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>,</span></span><br><span class="line"><span class="class"><span class="title">PriorityOrdered</span>, <span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prepare the Configuration classes for servicing bean requests at runtime</span></span><br><span class="line"><span class="comment"> * by replacing them with CGLIB-enhanced subclasses.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> factoryId = System.identityHashCode(beanFactory);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.factoriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="string">"postProcessBeanFactory already called on this post-processor against "</span> + beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.factoriesPostProcessed.add(factoryId);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.registriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line"><span class="comment">// BeanDefinitionRegistryPostProcessor hook apparently not supported...</span></span><br><span class="line"><span class="comment">// Simply call processConfigurationClasses lazily at this point then.</span></span><br><span class="line">processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enhanceConfigurationClasses(beanFactory);</span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ImportAwareBeanPostProcessor(beanFactory));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Build and validate a configuration model based on the registry of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Configuration&#125; classes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> ArrayList&lt;BeanDefinitionHolder&gt;();</span><br><span class="line">String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">BeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class="line"><span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||</span><br><span class="line">ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) &#123;</span><br><span class="line">                ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">configCandidates.add(<span class="keyword">new</span> BeanDefinitionHolder(beanDef, beanName));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return immediately if no @Configuration classes were found</span></span><br><span class="line"><span class="keyword">if</span> (configCandidates.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort by previously determined @Order value, if applicable</span></span><br><span class="line">Collections.sort(configCandidates, <span class="keyword">new</span> Comparator&lt;BeanDefinitionHolder&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line"><span class="keyword">int</span> i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line"><span class="keyword">return</span> (i1 &lt; i2) ? -<span class="number">1</span> : (i1 &gt; i2) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detect any custom bean name generation strategy supplied through the enclosing application context</span></span><br><span class="line">SingletonBeanRegistry sbr = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) &#123;</span><br><span class="line">sbr = (SingletonBeanRegistry) registry;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.localBeanNameGeneratorSet &amp;&amp; sbr.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) &#123;</span><br><span class="line">BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line"><span class="keyword">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line"><span class="keyword">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parse each @Configuration class</span></span><br><span class="line">ConfigurationClassParser parser = <span class="keyword">new</span> ConfigurationClassParser(</span><br><span class="line"><span class="keyword">this</span>.metadataReaderFactory, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.environment,</span><br><span class="line"><span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinitionHolder&gt;(configCandidates);</span><br><span class="line">Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> HashSet&lt;ConfigurationClass&gt;(configCandidates.size());</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">parser.parse(candidates);</span><br><span class="line">parser.validate();</span><br><span class="line"></span><br><span class="line">Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> LinkedHashSet&lt;ConfigurationClass&gt;(parser.getConfigurationClasses());</span><br><span class="line">configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read the model and create bean definitions based on its content</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.reader == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.reader = <span class="keyword">new</span> ConfigurationClassBeanDefinitionReader(</span><br><span class="line">registry, <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.environment,</span><br><span class="line"><span class="keyword">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">alreadyParsed.addAll(configClasses);</span><br><span class="line"></span><br><span class="line">candidates.clear();</span><br><span class="line"><span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">Set&lt;String&gt; oldCandidateNames = <span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(candidateNames));</span><br><span class="line">Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"><span class="keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class="line">alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String candidateName : newCandidateNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line">BeanDefinition bd = registry.getBeanDefinition(candidateName);</span><br><span class="line"><span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="keyword">this</span>.metadataReaderFactory) &amp;&amp;</span><br><span class="line">!alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line">candidates.add(<span class="keyword">new</span> BeanDefinitionHolder(bd, candidateName));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">candidateNames = newCandidateNames;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span></span><br><span class="line"><span class="keyword">if</span> (sbr != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class="line">sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.metadataReaderFactory <span class="keyword">instanceof</span> CachingMetadataReaderFactory) &#123;</span><br><span class="line">((CachingMetadataReaderFactory) <span class="keyword">this</span>.metadataReaderFactory).clearCache();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Post-processes a BeanFactory in search of Configuration class BeanDefinitions;</span></span><br><span class="line"><span class="comment"> * any candidates are then enhanced by a &#123;<span class="doctag">@link</span> ConfigurationClassEnhancer&#125;.</span></span><br><span class="line"><span class="comment"> * Candidate status is determined by BeanDefinition attribute metadata.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurationClassEnhancer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enhanceConfigurationClasses</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = <span class="keyword">new</span> LinkedHashMap&lt;String, AbstractBeanDefinition&gt;();</span><br><span class="line"><span class="keyword">for</span> (String beanName : beanFactory.getBeanDefinitionNames()) &#123;</span><br><span class="line">BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);</span><br><span class="line"><span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(beanDef <span class="keyword">instanceof</span> AbstractBeanDefinition)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Cannot enhance @Configuration bean definition '"</span> +</span><br><span class="line">beanName + <span class="string">"' since it is not stored in an AbstractBeanDefinition subclass"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (configBeanDefs.isEmpty()) &#123;</span><br><span class="line"><span class="comment">// nothing to enhance -&gt; return immediately</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ConfigurationClassEnhancer enhancer = <span class="keyword">new</span> ConfigurationClassEnhancer();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) &#123;</span><br><span class="line">AbstractBeanDefinition beanDef = entry.getValue();</span><br><span class="line"><span class="comment">// If a @Configuration class gets proxied, always proxy the target class</span></span><br><span class="line">beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Set enhanced subclass of the user-specified bean class</span></span><br><span class="line">Class&lt;?&gt; configClass = beanDef.resolveBeanClass(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, <span class="keyword">this</span>.beanClassLoader);</span><br><span class="line"><span class="keyword">if</span> (configClass != enhancedClass) &#123;</span><br><span class="line">    ...</span><br><span class="line">beanDef.setBeanClass(enhancedClass);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行期间,最重要的组件莫过于ConfigurationClassParser</strong>,它将已注册的Spring BeanDefinition进行注解元信息解析,其中两个parse重载方法分别采用CGLIB实现的AnnotationMetadataReadingVisitor和Java反射实现的</p><p>StandardAnnotationMetadata。</p><p>ConfigurationClassParser</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigurationClassParser</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processConfigurationClass</span><span class="params">(ConfigurationClass configClass)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConfigurationClass existingClass = <span class="keyword">this</span>.configurationClasses.get(configClass);</span><br><span class="line"><span class="keyword">if</span> (existingClass != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line"><span class="keyword">if</span> (existingClass.isImported()) &#123;</span><br><span class="line">existingClass.mergeImportedBy(configClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Otherwise ignore new imported config class; existing non-imported class overrides it.</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Explicit bean definition found, probably replacing an import.</span></span><br><span class="line"><span class="comment">// Let's remove the old one and go with the new one.</span></span><br><span class="line"><span class="keyword">this</span>.configurationClasses.remove(configClass);</span><br><span class="line"><span class="keyword">for</span> (Iterator&lt;ConfigurationClass&gt; it = <span class="keyword">this</span>.knownSuperclasses.values().iterator(); it.hasNext();) &#123;</span><br><span class="line"><span class="keyword">if</span> (configClass.equals(it.next())) &#123;</span><br><span class="line">it.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Recursively process the configuration class and its superclass hierarchy.</span></span><br><span class="line">SourceClass sourceClass = asSourceClass(configClass);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">sourceClass = doProcessConfigurationClass(configClass, sourceClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (sourceClass != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doProcessConfigurationClass处理以下问题:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Recursively process any member (nested) classes first</span></span><br><span class="line">processMemberClasses(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process any @PropertySource annotations</span></span><br><span class="line"><span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">sourceClass.getMetadata(), PropertySources.class,</span><br><span class="line">org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">processPropertySource(propertySource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.warn(<span class="string">"Ignoring @PropertySource annotation on ["</span> + sourceClass.getMetadata().getClassName() +</span><br><span class="line"><span class="string">"]. Reason: Environment must implement ConfigurableEnvironment"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process any @ComponentScan annotations</span></span><br><span class="line">Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line"><span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">!<span class="keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line"><span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line"><span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line"><span class="keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line"><span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line"><span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line"><span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(</span><br><span class="line">holder.getBeanDefinition(), <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process any @Import annotations</span></span><br><span class="line">processImports(configClass, sourceClass, getImports(sourceClass), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process any @ImportResource annotations</span></span><br><span class="line"><span class="keyword">if</span> (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) &#123;</span><br><span class="line">AnnotationAttributes importResource =</span><br><span class="line">AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line">String[] resources = importResource.getStringArray(<span class="string">"locations"</span>);</span><br><span class="line">Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(<span class="string">"reader"</span>);</span><br><span class="line"><span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">String resolvedResource = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process individual @Bean methods</span></span><br><span class="line">Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line"><span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">configClass.addBeanMethod(<span class="keyword">new</span> BeanMethod(methodMetadata, configClass));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process default methods on interfaces</span></span><br><span class="line">processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process superclass, if any</span></span><br><span class="line"><span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">String superclass = sourceClass.getMetadata().getSuperClassName();</span><br><span class="line"><span class="keyword">if</span> (!superclass.startsWith(<span class="string">"java"</span>) &amp;&amp; !<span class="keyword">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line"><span class="keyword">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line"><span class="comment">// Superclass found, return its annotation metadata and recurse</span></span><br><span class="line"><span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No superclass -&gt; processing is complete</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理<strong>@PropertySource</strong>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processPropertySource</span><span class="params">(AnnotationAttributes propertySource)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">String name = propertySource.getString(<span class="string">"name"</span>);</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(name)) &#123;</span><br><span class="line">name = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">String encoding = propertySource.getString(<span class="string">"encoding"</span>);</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(encoding)) &#123;</span><br><span class="line">encoding = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">String[] locations = propertySource.getStringArray(<span class="string">"value"</span>);</span><br><span class="line">Assert.isTrue(locations.length &gt; <span class="number">0</span>, <span class="string">"At least one @PropertySource(value) location is required"</span>);</span><br><span class="line"><span class="keyword">boolean</span> ignoreResourceNotFound = propertySource.getBoolean(<span class="string">"ignoreResourceNotFound"</span>);</span><br><span class="line"></span><br><span class="line">Class&lt;? extends PropertySourceFactory&gt; factoryClass = propertySource.getClass(<span class="string">"factory"</span>);</span><br><span class="line">PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?</span><br><span class="line">DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String location : locations) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String resolvedLocation = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(location);</span><br><span class="line">Resource resource = <span class="keyword">this</span>.resourceLoader.getResource(resolvedLocation);</span><br><span class="line">addPropertySource(factory.createPropertySource(name, <span class="keyword">new</span> EncodedResource(resource, encoding)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line"><span class="comment">// Placeholders not resolvable</span></span><br><span class="line"><span class="keyword">if</span> (ignoreResourceNotFound) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Properties location ["</span> + location + <span class="string">"] not resolvable: "</span> + ex.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="comment">// Resource not found when trying to open it</span></span><br><span class="line"><span class="keyword">if</span> (ignoreResourceNotFound &amp;&amp;</span><br><span class="line">(ex <span class="keyword">instanceof</span> FileNotFoundException || ex <span class="keyword">instanceof</span> UnknownHostException)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Properties location ["</span> + location + <span class="string">"] not resolvable: "</span> + ex.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addPropertySource</span><span class="params">(PropertySource&lt;?&gt; propertySource)</span> </span>&#123;</span><br><span class="line">String name = propertySource.getName();</span><br><span class="line">MutablePropertySources propertySources = ((ConfigurableEnvironment) <span class="keyword">this</span>.environment).getPropertySources();</span><br><span class="line"><span class="keyword">if</span> (propertySources.contains(name) &amp;&amp; <span class="keyword">this</span>.propertySourceNames.contains(name)) &#123;</span><br><span class="line"><span class="comment">// We've already added a version, we need to extend it</span></span><br><span class="line">PropertySource&lt;?&gt; existing = propertySources.get(name);</span><br><span class="line">PropertySource&lt;?&gt; newSource = (propertySource <span class="keyword">instanceof</span> ResourcePropertySource ?</span><br><span class="line">((ResourcePropertySource) propertySource).withResourceName() : propertySource);</span><br><span class="line"><span class="keyword">if</span> (existing <span class="keyword">instanceof</span> CompositePropertySource) &#123;</span><br><span class="line">((CompositePropertySource) existing).addFirstPropertySource(newSource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (existing <span class="keyword">instanceof</span> ResourcePropertySource) &#123;</span><br><span class="line">existing = ((ResourcePropertySource) existing).withResourceName();</span><br><span class="line">&#125;</span><br><span class="line">CompositePropertySource composite = <span class="keyword">new</span> CompositePropertySource(name);</span><br><span class="line">composite.addPropertySource(newSource);</span><br><span class="line">composite.addPropertySource(existing);</span><br><span class="line">propertySources.replace(name, composite);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.propertySourceNames.isEmpty()) &#123;</span><br><span class="line">propertySources.addLast(propertySource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">String firstProcessed = <span class="keyword">this</span>.propertySourceNames.get(<span class="keyword">this</span>.propertySourceNames.size() - <span class="number">1</span>);</span><br><span class="line">propertySources.addBefore(firstProcessed, propertySource);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.propertySourceNames.add(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理<strong>@ComponentScan</strong>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Process any @ComponentScan annotations</span></span><br><span class="line">Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line"><span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">!<span class="keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line"><span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line"><span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line"><span class="keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line"><span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line"><span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line"><span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(</span><br><span class="line">holder.getBeanDefinition(), <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理@Import注解,@ImportResource,@Bean注解。其中@Import处理方法processImports与processConfigurationClass(ConfigurationClass configClass)形成递归调用。实现多层次@Import元标注的ConfigurationClass解析。解析后的ConfigurationClass将会被ConfigurationClassBeanDefinitionReader再次注册为SpringBean。ConfigurationClassBeanDefinitionReader将@Import,@ImportResource,@Bean所关联的Bean定义一并注册了。</p><p>(3):ConfigurationClassBeanDefinitionReader:将解析的Configuration Classs注册为Spring Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigurationClassBeanDefinitionReader</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(Set&lt;ConfigurationClass&gt; configurationModel)</span> </span>&#123;</span><br><span class="line">TrackedConditionEvaluator trackedConditionEvaluator = <span class="keyword">new</span> TrackedConditionEvaluator();</span><br><span class="line"><span class="keyword">for</span> (ConfigurationClass configClass : configurationModel) &#123;</span><br><span class="line">loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Read a particular &#123;<span class="doctag">@link</span> ConfigurationClass&#125;, registering bean definitions</span></span><br><span class="line"><span class="comment"> * for the class itself and all of its &#123;<span class="doctag">@link</span> Bean&#125; methods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitionsForConfigurationClass</span><span class="params">(ConfigurationClass configClass,</span></span></span><br><span class="line"><span class="function"><span class="params">TrackedConditionEvaluator trackedConditionEvaluator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">registerBeanDefinitionForImportedConfigurationClass(configClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (BeanMethod beanMethod : configClass.getBeanMethods()) &#123;</span><br><span class="line">loadBeanDefinitionsForBeanMethod(beanMethod);</span><br><span class="line">&#125;</span><br><span class="line">loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());</span><br><span class="line">loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register the &#123;<span class="doctag">@link</span> Configuration&#125; class itself as a bean definition.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitionForImportedConfigurationClass</span><span class="params">(ConfigurationClass configClass)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Read the given &#123;<span class="doctag">@link</span> BeanMethod&#125;, registering bean definitions</span></span><br><span class="line"><span class="comment"> * with the BeanDefinitionRegistry based on its contents.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitionsForBeanMethod</span><span class="params">(BeanMethod beanMethod)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitionsFromImportedResources</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Map&lt;String, Class&lt;? extends BeanDefinitionReader&gt;&gt; importedResources)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitionsFromRegistrars</span><span class="params">(Map&lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&gt; registrars)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&gt; entry : registrars.entrySet()) &#123;</span><br><span class="line">entry.getKey().registerBeanDefinitions(entry.getValue(), <span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4):ConfigurationClassUtils:判定Configuration Class的级别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationClassUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIGURATION_CLASS_FULL = <span class="string">"full"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIGURATION_CLASS_LITE = <span class="string">"lite"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIGURATION_CLASS_ATTRIBUTE =</span><br><span class="line">Conventions.getQualifiedAttributeName(ConfigurationClassPostProcessor.class, <span class="string">"configurationClass"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ORDER_ATTRIBUTE =</span><br><span class="line">Conventions.getQualifiedAttributeName(ConfigurationClassPostProcessor.class, <span class="string">"order"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(ConfigurationClassUtils.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; candidateIndicators = <span class="keyword">new</span> HashSet&lt;String&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">candidateIndicators.add(Component.class.getName());</span><br><span class="line">candidateIndicators.add(ComponentScan.class.getName());</span><br><span class="line">candidateIndicators.add(Import.class.getName());</span><br><span class="line">candidateIndicators.add(ImportResource.class.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check the given metadata for a configuration class candidate</span></span><br><span class="line"><span class="comment"> * (or nested component class declared within a configuration/component class).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> metadata the metadata of the annotated class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the given class is to be registered as a</span></span><br><span class="line"><span class="comment"> * reflection-detected bean definition; &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isConfigurationCandidate</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (isFullConfigurationCandidate(metadata) || isLiteConfigurationCandidate(metadata));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check the given metadata for a full configuration class candidate</span></span><br><span class="line"><span class="comment"> * (i.e. a class annotated with &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125;).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> metadata the metadata of the annotated class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the given class is to be processed as a full</span></span><br><span class="line"><span class="comment"> * configuration class, including cross-method call interception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFullConfigurationCandidate</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> metadata.isAnnotated(Configuration.class.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check the given metadata for a lite configuration class candidate</span></span><br><span class="line"><span class="comment"> * (e.g. a class annotated with &#123;<span class="doctag">@code</span> <span class="doctag">@Component</span>&#125; or just having</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Import</span>&#125; declarations or &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span> methods&#125;).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> metadata the metadata of the annotated class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the given class is to be processed as a lite</span></span><br><span class="line"><span class="comment"> * configuration class, just registering it and scanning it for &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; methods</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLiteConfigurationCandidate</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Do not consider an interface or an annotation...</span></span><br><span class="line"><span class="keyword">if</span> (metadata.isInterface()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Any of the typical annotations found?</span></span><br><span class="line"><span class="keyword">for</span> (String indicator : candidateIndicators) &#123;</span><br><span class="line"><span class="keyword">if</span> (metadata.isAnnotated(indicator)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally, let's look for @Bean methods...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> metadata.hasAnnotatedMethods(Bean.class.getName());</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine whether the given bean definition indicates a full &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125;</span></span><br><span class="line"><span class="comment"> * class, through checking &#123;<span class="doctag">@link</span> #checkConfigurationClassCandidate&#125;'s metadata marker.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFullConfigurationClass</span><span class="params">(BeanDefinition beanDef)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> CONFIGURATION_CLASS_FULL.equals(beanDef.getAttribute(CONFIGURATION_CLASS_ATTRIBUTE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine whether the given bean definition indicates a lite &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125;</span></span><br><span class="line"><span class="comment"> * class, through checking &#123;<span class="doctag">@link</span> #checkConfigurationClassCandidate&#125;'s metadata marker.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLiteConfigurationClass</span><span class="params">(BeanDefinition beanDef)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> CONFIGURATION_CLASS_LITE.equals(beanDef.getAttribute(CONFIGURATION_CLASS_ATTRIBUTE));</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Enable模块驱动 </tag>
            
            <tag> ImportSelector </tag>
            
            <tag> ImportBeanDefinitionRegistrar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事件监听机制</title>
      <link href="/2019/08/05/Spring%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/08/05/Spring%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring事件监听机制"><a href="#Spring事件监听机制" class="headerlink" title="Spring事件监听机制"></a>Spring事件监听机制</h2><h4 id="1-Spring事件监听基础"><a href="#1-Spring事件监听基础" class="headerlink" title="1:Spring事件监听基础"></a>1:Spring事件监听基础</h4><p>   Spring事件/监听机制属于<code>事件/监听器模式</code>,即<code>观察者模式扩展</code>。在Java中,事件源必须是java.util.</p><p><code>EventObject</code>对象。事件监听器必须是<code>java.util.EventListener</code>。通常<code>API</code>接口需要提供</p><p>监听接口的<code>适配器</code>实现,提供监听空实现的适配方法。当<code>Java8 interface的default方法</code>特性</p><p>能够解决以上问题。</p><p>​    Spring事件监听器,仅抽象出单一方法onApplicationEvent(ApplicationEvent),用于监听Spring事件</p><p>ApplicationEvent。</p><p>​    在Spring3.0之前的ApplicationListener基本无解,必须监听所有的ApplicationEvent,如果要过滤</p><p>不同类型的事件,需要借助instanceof方式进行筛选。从Spring3.0开始,支持泛型监听。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationListener</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handle an application event.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> event the event to respond to</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(E event)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  由于泛型参数的限制,泛型化的ApplicationListener无法监听不同类型的ApplicationEvent。为此,Spring3.0</p><p>引入了SmartApplicationListener接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmartApplicationListener</span> <span class="keyword">extends</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationEvent</span>&gt;, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine whether this listener actually supports the given event type.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> eventType the event type (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supportsEventType</span><span class="params">(Class&lt;? extends ApplicationEvent&gt; eventType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine whether this listener actually supports the given source type.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceType the source type, or &#123;<span class="doctag">@code</span> null&#125; if no source</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supportsSourceType</span><span class="params">(@Nullable Class&lt;?&gt; sourceType)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  例如SpringBoot外部化应用配置文件application.properties的事件监听器ConfigFileApplicationListener</p><p>实现,监听了ApplicationEnvironmentPreparedEvent和ApplicationPreparedEvent两个事件.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsEventType</span><span class="params">(Class&lt;? extends ApplicationEvent&gt; eventType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ApplicationEnvironmentPreparedEvent.class.isAssignableFrom(eventType)</span><br><span class="line">|| ApplicationPreparedEvent.class.isAssignableFrom(eventType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Spring事件发布"><a href="#2-Spring事件发布" class="headerlink" title="2:Spring事件发布"></a>2:Spring事件发布</h4><p>   <code>ApplicationEventMulticaster</code>主要承担两种职责,一是关联ApplicationListener,二是广播</p><p>ApplicationEvent。</p><p>   1):ApplicationEventMulticaster注册ApplicationListener</p><p>  AbstractApplicationEventMulticaster将ApplicationListener做了分类,再结合retrieverCache的定义,</p><p>它是一个ListenerCacheKey为key,ListenerRetriever为value的Map缓存。同时ListenerCacheKey</p><p><code>关联了事件类型和数据源类型</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cache key for ListenerRetrievers, based on event type and source type.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerCacheKey</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ListenerCacheKey</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ResolvableType eventType;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; sourceType;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ListenerCacheKey</span><span class="params">(ResolvableType eventType, @Nullable Class&lt;?&gt; sourceType)</span> </span>&#123;</span><br><span class="line">Assert.notNull(eventType, <span class="string">"Event type must not be null"</span>);</span><br><span class="line"><span class="keyword">this</span>.eventType = eventType;</span><br><span class="line"><span class="keyword">this</span>.sourceType = sourceType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == other) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">ListenerCacheKey otherKey = (ListenerCacheKey) other;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span>.eventType.equals(otherKey.eventType) &amp;&amp;</span><br><span class="line">ObjectUtils.nullSafeEquals(<span class="keyword">this</span>.sourceType, otherKey.sourceType));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.eventType.hashCode() * <span class="number">29</span> + ObjectUtils.nullSafeHashCode(<span class="keyword">this</span>.sourceType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"ListenerCacheKey [eventType = "</span> + <span class="keyword">this</span>.eventType + <span class="string">", sourceType = "</span> + <span class="keyword">this</span>.sourceType + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ListenerCacheKey other)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = <span class="keyword">this</span>.eventType.toString().compareTo(other.eventType.toString());</span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.sourceType == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (other.sourceType == <span class="keyword">null</span> ? <span class="number">0</span> : -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (other.sourceType == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">result = <span class="keyword">this</span>.sourceType.getName().compareTo(other.sourceType.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   实际上,AbstractApplicationEventMulticaster将ApplicationEvent和ApplicationListener集合进行关联。因此</p><p>AbstractApplicationEventMulticaster#getApplicationListeners()返回ApplicationEvent关联ApplicationListener集合。</p><p>   2)ApplicationEventMulticaster广播事件</p><p>​    广播事件在SimpleApplicationEventMulticaster中实现,也是Spring内建唯一实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, @Nullable ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">final</span> ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">Executor executor = getTaskExecutor();</span><br><span class="line"><span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">invokeListener(listener, event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//该方法从Spring4.2开始引入。尽管<code>ResolvableType</code>是从Spring4.0开始出现,它是Spring简化<code>Java反射</code></p><p><code>API而提供的组件,能够轻松的获取泛型类型等。</code></p><p>  3)ApplicationEventMulticaster和ApplicationContext之间关系</p><p>   开发人员可使用<code>ApplicationEventPublisher</code>发布ApplicationEvent。</p><p>   ApplicationEventPublisher接口被Spring上下文接口ApplicationContext扩展,因此,无论哪种Spring应用</p><p>上下文实例,均具备发布ApplicationEvent的能力。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring事件监听机制 </tag>
            
            <tag> 观察者模式 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义SpringBoot自动装配</title>
      <link href="/2019/08/05/%E8%87%AA%E5%AE%9A%E4%B9%89SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"/>
      <url>/2019/08/05/%E8%87%AA%E5%AE%9A%E4%B9%89SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="自定义SpringBoot自动装配"><a href="#自定义SpringBoot自动装配" class="headerlink" title="自定义SpringBoot自动装配"></a>自定义SpringBoot自动装配</h2><h3 id="1：自动装配Class命名规则"><a href="#1：自动装配Class命名规则" class="headerlink" title="1：自动装配Class命名规则"></a>1：自动装配Class命名规则</h3><p><em>AutoConfiguration，其中\</em>代表功能或者模块名。</p><h3 id="2：自动装配package命名规则"><a href="#2：自动装配package命名规则" class="headerlink" title="2：自动装配package命名规则"></a>2：自动装配package命名规则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$&#123;root-package&#125;</span><br><span class="line"> |- autoconfigure</span><br><span class="line">  |- $&#123;module-package&#125;</span><br><span class="line">   |- *AutoConfiguration</span><br><span class="line">    |- $&#123;sub-module-package&#125;</span><br><span class="line">     |- ...</span><br></pre></td></tr></table></figure><p>其中${root_package}是根模块，如com.ley。</p><p>${module_package}是功能模块，如web.servlet。</p><p>而${sub_module_package}是子模块，如error。</p><h3 id="3：自定义SpringBootStarter"><a href="#3：自定义SpringBootStarter" class="headerlink" title="3：自定义SpringBootStarter"></a>3：自定义SpringBootStarter</h3><p>官方建议将自动装配模块代码存放到autoconfigure模块中，starter模块依赖该模块，并且附加其他需要依赖。当然也可以将autoconfigure和stater合并到单模块。</p><p>(1)：Spring Boot Starter命名规则</p><p>开发人员将Starter发布为${module}-spring-boot-autoconfigure和${module}-spring-boot-starter两个jar文件。</p><p><strong>开发人员不要使用server,management,spring等作为配置Key命名空间。尽量采用独立的命名空间。</strong></p><p>(2)：实现Spring Boot Starter</p><p>(a)：新建Spring Boot Starter工程—–formatter-spring-boot-autoconfigure。</p><p>构建一个Maven功能，pom.xml如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Compile dependencies --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- @ConfigurationProperties annotation processing (metadata for IDEs) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(b)：实现DefaultFormatter自动装配—-FormatterAutoConfiguration</p><p>(c)：META-INF/spring.factories资源声明FormatterAutoConfiguration</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># FormatterAutoConfiguration 自动装配声明</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">  com.ley.formatter.autoconfigure.FormatterAutoConfiguration</span><br></pre></td></tr></table></figure><p>(d)：构建Spring Boot Starter—-formatter-spring-boot-starter</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--formatter spring boot autoconfigure--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.gitee.ley1996<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>formatter-spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--spring boot 基础依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            说明formatter-spring-boot-starter不应该</span></span><br><span class="line"><span class="comment">            传递spring-boot-starter依赖。</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在开发Spring Boot Starter的过程中，请保持spring-boot-starter等相关依赖声明为 、&lt;optional&gt;true&lt;/optional&gt;。</p><h3 id="4：Spring-Boot-提交化自动装配"><a href="#4：Spring-Boot-提交化自动装配" class="headerlink" title="4：Spring Boot 提交化自动装配"></a>4：Spring Boot 提交化自动装配</h3><p>条件注解总结：</p><ul><li>Class Conditions</li><li>Bean Conditions</li><li>Property Conditions</li><li>Resource Conditions</li><li>Web Application Conditions</li><li>SpEL Expression Conditions</li></ul><p>4.1：Class条件注解</p><ul><li>ConditionalOnClass：当指定类存在时，在Sprign Boot 1.0~2.0稳定。</li><li>ConditionalOnMissingClass：当指定类不存在时，从Spring Boot 1.4开始才保持稳定。推荐使用value()替代。当指定类不存在时，并不需要该类显示地依赖到当前工程或者Starter。</li></ul><p>4.2：Bean条件注解</p><ul><li>ConditionalOnBean：匹配BeanFactory中Bean的类型和名称。 其中Bean查找策略为SearchStrategy，包含当前，父类及所有。</li><li>ConditionalOnMissingBean：当指定Bean不存在时。从Spring Boot 1.2.5开始，增加ignored()和ignoredType()两个方法，用于忽略或者排除指定Bean。</li></ul><p>4.3：属性条件注解</p><p>  ConditionalOnProperty为属性条件注解，其属性来源于Spring Environment。其中Java系统属性(systemProperties)和环境变量(systemEnvironment)是典型的Spring Environment属性来源。在SpringBoot环境中，application.properties或者application.yml也是其中来源之一。</p><p> 当自动装配组件需要默认装配时，可以使用matchIfMissing()属性值调整为true。</p><p>4.4：Resource条件注解</p><p> ConditionOnResource为Resource条件注解。其中resources()指定只有资源必须存在方可成立。</p><p>4.5：Web应用条件注解。</p><ul><li>ConditionalOnWebApplication：判断当前应用是Web类型。</li><li>ConditionalOnNotWebApplication：当前应用不是Web类型。</li></ul><p>4.6：Spring表达式条件注解</p><p> ConditionalOnExpression，其中value()用于评估表达式的真伪。当表达多组配置属性时，可以使用@ConditionalOnExpression。例如${formatter.enabled:true}</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用Spring Boot提供的条件注解,以及自动装配顺序注解,实现自己的配置类,然后在META-INF/</p><p>spring.factories中声明该类即可。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># FormatterAutoConfiguration 自动装配声明</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">  com.ley.formatter.autoconfigure.FormatterAutoConfiguration</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> SpringBoot自动装配 </tag>
            
            <tag> 条件化注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring整合Mybatis原理探索</title>
      <link href="/2019/08/05/Spring%E6%95%B4%E5%90%88Mybatis%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/"/>
      <url>/2019/08/05/Spring%E6%95%B4%E5%90%88Mybatis%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring整合Mybatis原理探索"><a href="#Spring整合Mybatis原理探索" class="headerlink" title="Spring整合Mybatis原理探索"></a>Spring整合Mybatis原理探索</h2><p><code>@MapperScan</code>注解实现</p><p>1:<code>MapperScannerRegistrar</code>类</p><p>实现<code>ImportBeanDefinitionRegistrar</code>接口,注册默认<code>@Mapper</code>注解标注的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//获取@MapperScan注解上属性</span></span><br><span class="line">   AnnotationAttributes mapperScanAttrs = AnnotationAttributes</span><br><span class="line">       .fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));</span><br><span class="line">   <span class="keyword">if</span> (mapperScanAttrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">     registerBeanDefinitions(mapperScanAttrs, registry);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationAttributes annoAttrs, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">//扫描指定包下包含默认Mybatis注解@Mapper的接口,并注册到Spring Bean工厂中</span></span><br><span class="line">   ClassPathMapperScanner scanner = <span class="keyword">new</span> ClassPathMapperScanner(registry);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// this check is needed in Spring 3.1</span></span><br><span class="line">   Optional.ofNullable(resourceLoader).ifPresent(scanner::setResourceLoader);</span><br><span class="line"></span><br><span class="line">   Class&lt;? extends Annotation&gt; annotationClass = annoAttrs.getClass(<span class="string">"annotationClass"</span>);</span><br><span class="line">   <span class="keyword">if</span> (!Annotation.class.equals(annotationClass)) &#123;</span><br><span class="line">     scanner.setAnnotationClass(annotationClass);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Class&lt;?&gt; markerInterface = annoAttrs.getClass(<span class="string">"markerInterface"</span>);</span><br><span class="line">   <span class="keyword">if</span> (!Class.class.equals(markerInterface)) &#123;</span><br><span class="line">     scanner.setMarkerInterface(markerInterface);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Class&lt;? extends BeanNameGenerator&gt; generatorClass = annoAttrs.getClass(<span class="string">"nameGenerator"</span>);</span><br><span class="line">   <span class="keyword">if</span> (!BeanNameGenerator.class.equals(generatorClass)) &#123;</span><br><span class="line">     scanner.setBeanNameGenerator(BeanUtils.instantiateClass(generatorClass));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass = annoAttrs.getClass(<span class="string">"factoryBean"</span>);</span><br><span class="line">   <span class="keyword">if</span> (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) &#123;</span><br><span class="line">     scanner.setMapperFactoryBean(BeanUtils.instantiateClass(mapperFactoryBeanClass));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   scanner.setSqlSessionTemplateBeanName(annoAttrs.getString(<span class="string">"sqlSessionTemplateRef"</span>));</span><br><span class="line">   scanner.setSqlSessionFactoryBeanName(annoAttrs.getString(<span class="string">"sqlSessionFactoryRef"</span>));</span><br><span class="line"></span><br><span class="line">   List&lt;String&gt; basePackages = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   basePackages.addAll(</span><br><span class="line">       Arrays.stream(annoAttrs.getStringArray(<span class="string">"value"</span>))</span><br><span class="line">           .filter(StringUtils::hasText)</span><br><span class="line">           .collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">   basePackages.addAll(</span><br><span class="line">       Arrays.stream(annoAttrs.getStringArray(<span class="string">"basePackages"</span>))</span><br><span class="line">           .filter(StringUtils::hasText)</span><br><span class="line">           .collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">   basePackages.addAll(</span><br><span class="line">       Arrays.stream(annoAttrs.getClassArray(<span class="string">"basePackageClasses"</span>))</span><br><span class="line">           .map(ClassUtils::getPackageName)</span><br><span class="line">           .collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">   scanner.registerFilters();</span><br><span class="line">   scanner.doScan(StringUtils.toStringArray(basePackages));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>2:<code>ClassPathMapperScanner</code></p><p>继承了<code>ClassPathBeanDefinitionScanner</code>类,该类扫描指定包下的模式注解,并注册到Spring Bean工厂中。</p><p>实现主要方法研究</p><p><strong>注册BeanDefinition过滤接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Configures parent scanner to search for the right interfaces. It can search</span></span><br><span class="line"><span class="comment"> * for all interfaces or just for those that extends a markerInterface or/and</span></span><br><span class="line"><span class="comment"> * those annotated with the annotationClass</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerFilters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> acceptAllInterfaces = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if specified, use the given annotation and / or marker interface</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.annotationClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">    addIncludeFilter(<span class="keyword">new</span> AnnotationTypeFilter(<span class="keyword">this</span>.annotationClass));</span><br><span class="line">    acceptAllInterfaces = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// override AssignableTypeFilter to ignore matches on the actual marker interface</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.markerInterface != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//由于生成的BeanDefinition为MapperFactoryBean,所以BeanClass不是原来的类名</span></span><br><span class="line">    addIncludeFilter(<span class="keyword">new</span> AssignableTypeFilter(<span class="keyword">this</span>.markerInterface) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">matchClassName</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    acceptAllInterfaces = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (acceptAllInterfaces) &#123;</span><br><span class="line">    <span class="comment">// default include filter that accepts all classes</span></span><br><span class="line">    addIncludeFilter((metadataReader, metadataReaderFactory) -&gt; <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// exclude package-info.java</span></span><br><span class="line">  addExcludeFilter((metadataReader, metadataReaderFactory) -&gt; &#123;</span><br><span class="line">    String className = metadataReader.getClassMetadata().getClassName();</span><br><span class="line">    <span class="keyword">return</span> className.endsWith(<span class="string">"package-info"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注册MapperFactoryBean</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processBeanDefinitions</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; beanDefinitions)</span> </span>&#123;</span><br><span class="line">   GenericBeanDefinition definition;</span><br><span class="line">   <span class="keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">     definition = (GenericBeanDefinition) holder.getBeanDefinition();</span><br><span class="line">     String beanClassName = definition.getBeanClassName();</span><br><span class="line">     LOGGER.debug(() -&gt; <span class="string">"Creating MapperFactoryBean with name '"</span> + holder.getBeanName()</span><br><span class="line">         + <span class="string">"' and '"</span> + beanClassName + <span class="string">"' mapperInterface"</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// the mapper interface is the original class of the bean</span></span><br><span class="line">     <span class="comment">// but, the actual class of the bean is MapperFactoryBean</span></span><br><span class="line">     <span class="comment">//添加要与类型匹配的通用参数值注意：单个通用参数值将只使用一次*，而不是多次匹配。</span></span><br><span class="line">     <span class="comment">//MapperFactoryBean是个泛型类,泛型参数是Mybatis的DAO全类限定名</span></span><br><span class="line">     definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); /</span><br><span class="line">     definition.setBeanClass(<span class="keyword">this</span>.mapperFactoryBean.getClass());</span><br><span class="line"></span><br><span class="line">     definition.getPropertyValues().add(<span class="string">"addToConfig"</span>, <span class="keyword">this</span>.addToConfig);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">boolean</span> explicitFactoryUsed = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.sqlSessionFactoryBeanName)) &#123;</span><br><span class="line">       <span class="comment">//如果配置了SqlSesiionFactoryBean,获取运行期间的SqlSessionFactory Bean引用  </span></span><br><span class="line">       definition.getPropertyValues().add(<span class="string">"sqlSessionFactory"</span>, <span class="keyword">new</span> RuntimeBeanReference(<span class="keyword">this</span>.sqlSessionFactoryBeanName));</span><br><span class="line">       explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sqlSessionFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">       definition.getPropertyValues().add(<span class="string">"sqlSessionFactory"</span>, <span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">       explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.sqlSessionTemplateBeanName)) &#123;</span><br><span class="line">       <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">         LOGGER.warn(() -&gt; <span class="string">"Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored."</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       definition.getPropertyValues().add(<span class="string">"sqlSessionTemplate"</span>, <span class="keyword">new</span> RuntimeBeanReference(<span class="keyword">this</span>.sqlSessionTemplateBeanName));</span><br><span class="line">       explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sqlSessionTemplate != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">         LOGGER.warn(() -&gt; <span class="string">"Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored."</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       definition.getPropertyValues().add(<span class="string">"sqlSessionTemplate"</span>, <span class="keyword">this</span>.sqlSessionTemplate);</span><br><span class="line">       explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!explicitFactoryUsed) &#123;</span><br><span class="line">       LOGGER.debug(() -&gt; <span class="string">"Enabling autowire by type for MapperFactoryBean with name '"</span> + holder.getBeanName() + <span class="string">"'."</span>);</span><br><span class="line">       definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>设置候选BeanDefinition条件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断候选的BeanDefinition是否是接口和独立类</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(AnnotatedBeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> beanDefinition.getMetadata().isInterface() &amp;&amp; beanDefinition.getMetadata().isIndependent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>相关类</strong></p><ul><li><code>ClassPathMapperScanner</code>:扫描Bean并注册Bean工厂中</li><li><code>MapperFactoryBean</code>:Mapper Bean工程</li><li><code>MapperScannerRegistrar</code>:提供解析<code>MapperScan</code>注解和批量注册Bean</li><li><code>SqlSessionDaoSupport</code>:提供SqlSession</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>实现批量注册Bean时,提供<code>扫描包注解+标注候选注解+实现ImportBeanDefinitionRegistrar接口+</code></p><p><code>继承ClassPathBeanDefinitionScanner+实现FactoryBean接口</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
            <tag> Spring </tag>
            
            <tag> MapperScan注解实现原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Environment抽象</title>
      <link href="/2019/08/05/Spring%20Environment%E6%8A%BD%E8%B1%A1/"/>
      <url>/2019/08/05/Spring%20Environment%E6%8A%BD%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Environment抽象"><a href="#Spring-Environment抽象" class="headerlink" title="Spring Environment抽象"></a>Spring Environment抽象</h2><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1:概述"></a>1:概述</h4><p>Spring中<code>Environment</code>是<code>Spring3.1</code>版本引入的,是<code>Spring</code>核心框架定义的一个接口,用来<strong><code>表示整个应用运行时环境</code>。</strong>该环境模型只接受两种应用环境<strong><code>profiles(配置文件)</code>和<code>properties(属性)</code></strong>。<strong>与属性访问相关的方法通过<code>PropertyResolver</code>超接口访问。</strong></p><p><strong><code>建模关键</code></strong></p><p><code>profile(配置文件)</code></p><ul><li>一个<code>profile</code>是一组<code>Bean</code>定义的逻辑分组,只有当配置文件被激活的时候,才会将对应逻辑上组织的Bean定义注册到容器中。</li><li><code>Bean</code>添加到<code>profile</code>可以通过<code>XML或者Annotation</code>方式。</li><li><code>Environment</code>对象对于<code>profile</code>机制所扮演的角色是用来指定哪些<code>profile</code>是<code>当前活跃或者缺省活跃</code>。可以通过<code>getActiveProfiles</code>或者<code>getDefaultProfiles</code>获取。</li></ul><p><code>proprety(属性)</code></p><ul><li>一个应用属性有很多来源:属性文件(properties files),JVM系统属性(<code>getSystemProperties</code>),系统变量属性(<code>getSystemEnvironment</code>),<code>JNDI</code>,<code>servlet上下文参数</code>,<code>临时属性对象,Maps</code>等。</li><li><code>Environment</code>对于<code>property</code>所扮演的角色提供给使用一个方便服务接口用于<ul><li>配置属性源</li><li>从属性源解析和获取属性</li></ul></li></ul><p>容器上下文(<code>ApplicationContext</code>)所获取的<code>bean</code>,如果想直接使用<code>Environment</code>对象访问<code>profile</code>状态或者获取属性。有以下方式。</p><ul><li><code>EnvironmentAware</code>接口</li><li><code>@Inject</code> 或者 <code>@Autowired</code>注入一个 <code>Environment</code>对象</li></ul><p>绝大多数情况,bean都不需要直接访问<code>Environment</code>对象,而是通过类似<code>@Value</code>注解方式把属性值注入进来。</p><p>这个接口定义在包 <code>org.springframework.core.env</code> 中。下面是<code>Spring</code>围绕环境抽象<code>Environment</code>各个接口/类之间的继承关系: </p><p><img src="https://img-blog.csdnimg.cn/20181124170340612.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FuZHlfemhhbmcyMDA3,size_16,color_FFFFFF,t_70" alt="Spring Environment"> </p><h4 id="2-Environment接口相关类介绍"><a href="#2-Environment接口相关类介绍" class="headerlink" title="2:Environment接口相关类介绍"></a>2:<code>Environment</code>接口相关类介绍</h4><table><thead><tr><th align="center">接口|类</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center"><code>PropertyResolver</code></td><td align="center">接口,抽象对属性源的访问比如是否包含某个属性，读取属性，解析占位符，将读取到的属性转换成指定类型 (<code>提供读操作)默认实现PropertySourcesPropertyResolver</code></td></tr><tr><td align="center"><code>Environment</code></td><td align="center">接口,继承自<code>PropertyResolver</code>,对环境属性访问和<code>default/active profile</code>访问的抽象 。</td></tr><tr><td align="center"><code>ConfigurablePropertyResolver</code></td><td align="center">接口，为<code>PropertyResolver</code>接口抽象的属性源访问做了配置方面的增强。(<code>提供写操作。</code>)</td></tr><tr><td align="center"><code>ConfigurableEnvironment</code></td><td align="center">接口，在所继承的接口之上增加了设置<code>defaut/active profile</code>的能力，增加/删除环境对象中属性源的能力</td></tr><tr><td align="center"><code>ConfigurableWebEnvironment</code></td><td align="center">接口，向接口<code>ConfigurableEnvironment</code>增强了根据Servlet上下文/配置初始化属性源的能力</td></tr><tr><td align="center"><code>AbstractEnvironment</code></td><td align="center"><code>Environment</code>抽象基类，实现了<code>ConfigurableEnvironment</code></td></tr><tr><td align="center"><code>StandardEnvironment</code></td><td align="center">实现类,针对标准Spring应用(非Web应用)环境, 在<code>AbstractEnvironment</code>基础上提供了属性源<code>systemEnvironment</code>(来自<code>System.getenv()</code>)和<code>systemProperties</code>(来自<code>System.getProperties()</code>)</td></tr><tr><td align="center"><code>StandardServletEnvironment</code></td><td align="center">实现类,针对标准Spring Servlet Web应用的环境， 增加了<code>servletContextInitParams</code>/<code>servletConfigInitParams</code>/<code>jndiProperties</code></td></tr></tbody></table><h4 id="3-外部化配置抽象相关类"><a href="#3-外部化配置抽象相关类" class="headerlink" title="3:外部化配置抽象相关类"></a>3:<code>外部化配置抽象相关类</code></h4><table><thead><tr><th align="center">接口|类</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center"><code>PropertySource</code></td><td align="center"><code>用来抽象属性键值对(外部化配置,即属性源)配置基类</code>。例如<code>Map,Properties,ServletConfig,ServletContext</code></td></tr><tr><td align="center"><code>PropertySources</code></td><td align="center">对<code>PropertySource</code>抽象属性键值对外部化配置提供集合操作。</td></tr><tr><td align="center"><code>MutablePropertySources</code></td><td align="center"><code>PropertySources</code>默认实现。</td></tr><tr><td align="center"><code>MapPropertySource</code></td><td align="center"><code>Map对象中读取属性键值对</code></td></tr><tr><td align="center"><code>PropertiesPropertySource</code></td><td align="center"><code>Properties对象中读取属性键值对</code></td></tr><tr><td align="center"><code>ResourcePropertySource</code></td><td align="center"><code>Resource对象读取中读取属性键值对。只支持.xml和.properties文件。</code>底层实现使用了工具类<code>PropertiesLoaderUtils</code>。</td></tr><tr><td align="center"><code>CompositePropertySource</code></td><td align="center"><code>聚合一组PropertySource</code>。</td></tr><tr><td align="center">Web环境实现类和JNDI实现类和随机数实现类</td><td align="center"><code>ServletConfigPropertySource</code>,<code>ServletContextPropertySource</code>,  <code>JndiPropertySource</code>,<code>RandomValuePropertySource</code></td></tr><tr><td align="center">命令行参数实现类</td><td align="center"><code>CommandLinePropertySource</code></td></tr></tbody></table><h4 id="4-混淆定义"><a href="#4-混淆定义" class="headerlink" title="4:混淆定义"></a>4:混淆定义</h4><ul><li>上下文:用来处理分层传递抽象,代表着<code>应用</code>。</li><li>环境:<code>当前上下文运行环境</code>,存储各种<code>全局变量</code>。比如JDK信息,内存信息等等。</li></ul><h4 id="5-核心API"><a href="#5-核心API" class="headerlink" title="5:核心API"></a>5:核心API</h4><ul><li><strong>PropertySource:</strong>属性源。key-value属性对抽象</li><li><strong>PropertyResolver:</strong>属性解析器。用于解析相应key的value</li><li><strong>Profile:</strong>配置。<strong>只有激活的配置profile</strong>的组件/配置才会注册到Spring容器,类似于maven中profile。</li><li><strong>Environment:</strong>环境，本身也是个属性解析器<code>PropertyResolver</code>。 </li></ul><h4 id="6-属性解析器相关类详细介绍"><a href="#6-属性解析器相关类详细介绍" class="headerlink" title="6:属性解析器相关类详细介绍"></a>6:属性解析器相关类详细介绍</h4><h5 id="PropertySourcesPropertyResolver"><a href="#PropertySourcesPropertyResolver" class="headerlink" title="PropertySourcesPropertyResolver"></a><code>PropertySourcesPropertyResolver</code></h5><p>该类是Spring内建提供的<code>PropertyResolver</code>唯一实现类。环境抽象<code>Environment</code>属性解析委托给该类。包括对属性类型之间必要转换。<code>Converter</code>和<code>ConverterService</code>。实际的占位符解析委托给<code>PropertyPlaceholderHelper</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertySourcesPropertyResolver</span> <span class="keyword">extends</span> <span class="title">AbstractPropertyResolver</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PropertySources propertySources; <span class="comment">//内部持有一组PropertySource</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由此可以看出propertySources的顺序很重要~~~</span></span><br><span class="line"><span class="comment">// 并且还能处理占位符~~~~~ resolveNestedPlaceholders支持内嵌、嵌套占位符</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">getProperty</span><span class="params">(String key, Class&lt;T&gt; targetValueType, <span class="keyword">boolean</span> resolveNestedPlaceholders)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.propertySources != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (PropertySource&lt;?&gt; propertySource : <span class="keyword">this</span>.propertySources) &#123;</span><br><span class="line">Object value = propertySource.getProperty(key);</span><br><span class="line"><span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (resolveNestedPlaceholders &amp;&amp; value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">value = resolveNestedPlaceholders((String) value);</span><br><span class="line">&#125;</span><br><span class="line">logKeyFound(key, propertySource, value);</span><br><span class="line"><span class="keyword">return</span> convertValueIfNecessary(value, targetValueType);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPropertyResolver</span> <span class="keyword">implements</span> <span class="title">ConfigurablePropertyResolver</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ConfigurableConversionService conversionService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> PropertyPlaceholderHelper nonStrictHelper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> PropertyPlaceholderHelper strictHelper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> ignoreUnresolvableNestedPlaceholders = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String placeholderPrefix = SystemPropertyUtils.PLACEHOLDER_PREFIX;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String placeholderSuffix = SystemPropertyUtils.PLACEHOLDER_SUFFIX;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> String valueSeparator = SystemPropertyUtils.VALUE_SEPARATOR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; requiredProperties = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-应用环境抽象Environment"><a href="#7-应用环境抽象Environment" class="headerlink" title="7:应用环境抽象Environment"></a>7:应用环境抽象<code>Environment</code></h4><p><code>Environment</code>接口:环境的读操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Environment</span> <span class="keyword">extends</span> <span class="title">PropertyResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the set of profiles explicitly made active for this environment. Profiles</span></span><br><span class="line"><span class="comment"> * are used for creating logical groupings of bean definitions to be registered</span></span><br><span class="line"><span class="comment"> * conditionally, for example based on deployment environment.  Profiles can be</span></span><br><span class="line"><span class="comment"> * activated by setting &#123;<span class="doctag">@linkplain</span> AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME</span></span><br><span class="line"><span class="comment"> * "spring.profiles.active"&#125; as a system property or by calling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ConfigurableEnvironment#setActiveProfiles(String...)&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If no profiles have explicitly been specified as active, then any</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> #getDefaultProfiles() default profiles&#125; will automatically be activated.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getDefaultProfiles</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurableEnvironment#setActiveProfiles</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] getActiveProfiles();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the set of profiles to be active by default when no active profiles have</span></span><br><span class="line"><span class="comment"> * been set explicitly.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getActiveProfiles</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurableEnvironment#setDefaultProfiles</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> AbstractEnvironment#DEFAULT_PROFILES_PROPERTY_NAME</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] getDefaultProfiles();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return whether one or more of the given profiles is active or, in the case of no</span></span><br><span class="line"><span class="comment"> * explicit active profiles, whether one or more of the given profiles is included in</span></span><br><span class="line"><span class="comment"> * the set of default profiles. If a profile begins with '!' the logic is inverted,</span></span><br><span class="line"><span class="comment"> * i.e. the method will return true if the given profile is &lt;em&gt;not&lt;/em&gt; active.</span></span><br><span class="line"><span class="comment"> * For example, &lt;pre class="code"&gt;env.acceptsProfiles("p1", "!p2")&lt;/pre&gt; will</span></span><br><span class="line"><span class="comment"> * return &#123;<span class="doctag">@code</span> true&#125; if profile 'p1' is active or 'p2' is not active.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if called with zero arguments</span></span><br><span class="line"><span class="comment"> * or if any profile is &#123;<span class="doctag">@code</span> null&#125;, empty or whitespace-only</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getActiveProfiles</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getDefaultProfiles</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">acceptsProfiles</span><span class="params">(String... profiles)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConfigurableEnvironment</code>:增加环境的写操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurableEnvironment</span> <span class="keyword">extends</span> <span class="title">Environment</span>, <span class="title">ConfigurablePropertyResolver</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指定该环境下的 profile 集</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setActiveProfiles</span><span class="params">(String... profiles)</span></span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 增加此环境的 profile</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addActiveProfile</span><span class="params">(String profile)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置默认的 profile</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDefaultProfiles</span><span class="params">(String... profiles)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回此环境的 PropertySources</span></span><br><span class="line">    <span class="function">MutablePropertySources <span class="title">getPropertySources</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 尝试返回 System.getenv() 的值，若失败则返回通过 System.getenv(string) 的来访问各个键的映射</span></span><br><span class="line">    <span class="function">Map&lt;String, Object&gt; <span class="title">getSystemEnvironment</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 尝试返回 System.getProperties() 的值，若失败则返回通过 System.getProperties(string) 的来访问各个键的映射</span></span><br><span class="line">    <span class="function">Map&lt;String, Object&gt; <span class="title">getSystemProperties</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(ConfigurableEnvironment parent)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AbstractEnvironment</code>:作为环境接口抽象实现,主要实现了<code>profile</code>相关功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractEnvironment</span> <span class="keyword">implements</span> <span class="title">ConfigurableEnvironment</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String IGNORE_GETENV_PROPERTY_NAME = <span class="string">"spring.getenv.ignore"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请参考：ConfigurableEnvironment#setActiveProfiles</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACTIVE_PROFILES_PROPERTY_NAME = <span class="string">"spring.profiles.active"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请参考：ConfigurableEnvironment#setDefaultProfiles</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PROFILES_PROPERTY_NAME = <span class="string">"spring.profiles.default"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; defaultProfiles = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(getReservedDefaultProfiles());</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 默认的profile名称</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String RESERVED_DEFAULT_PROFILE_NAME = <span class="string">"default"</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;String&gt; <span class="title">doGetActiveProfiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.activeProfiles) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.activeProfiles.isEmpty()) &#123;</span><br><span class="line">String profiles = getProperty(ACTIVE_PROFILES_PROPERTY_NAME);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(profiles)) &#123;</span><br><span class="line">setActiveProfiles(StringUtils.commaDelimitedListToStringArray(</span><br><span class="line">StringUtils.trimAllWhitespace(profiles)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.activeProfiles;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>activeProfiles</code> 为空,则从 <code>Properties</code> 中获取 <code>spring.profiles.active</code> 配置;如果不为空，则调用 <code>setActiveProfiles()</code> 设置 profile,最后返回。 </p><blockquote><p>从这里可以知道，API设置的activeProfiles优先级第一，其次才是属性配置。</p></blockquote><h4 id="8-应用环境配置激活-Profile和ProfileCondition"><a href="#8-应用环境配置激活-Profile和ProfileCondition" class="headerlink" title="8:应用环境配置激活(@Profile和ProfileCondition)"></a>8:应用环境配置激活(@Profile和ProfileCondition)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Conditional</span>(ProfileCondition.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Profile &#123;</span><br><span class="line"></span><br><span class="line">String[] value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>从Spring4.0</code>开始提供<code>Conditional</code>接口,该注解实现原理基于<code>Condition</code>条件接口,<code>Condition</code>条件接口计算结果实现类为<code>ConditionEvaluator</code>,该类是个内部类。</p><p><code>ProfileCondition</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProfileCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 因为value值是个数组，所以此处有多个值 用的MultiValueMap</span></span><br><span class="line">MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());</span><br><span class="line"><span class="keyword">if</span> (attrs != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (Object value : attrs.get(<span class="string">"value"</span>)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个值中，但凡只要有一个acceptsProfiles了，那就返回true~</span></span><br><span class="line"><span class="keyword">if</span> (context.getEnvironment().acceptsProfiles(Profiles.of((String[]) value))) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Profile</code>的value可以指定多个值,并且只需要有一个值符合了条件,<code>@Profile</code>标注的方法、类就会生效，就会被加入到容器内。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Environment抽象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git分支的创建与合并</title>
      <link href="/2019/08/05/Git%E5%88%86%E6%94%AF%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6/"/>
      <url>/2019/08/05/Git%E5%88%86%E6%94%AF%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Git分支的创建与合并"><a href="#Git分支的创建与合并" class="headerlink" title="Git分支的创建与合并"></a>Git分支的创建与合并</h1><h2 id="Git管理项目代码，常见流程。"><a href="#Git管理项目代码，常见流程。" class="headerlink" title="Git管理项目代码，常见流程。"></a>Git管理项目代码，常见流程。</h2><p>1.开发公司网站。</p><p>2.为了开发某个新功能新建一个分支（假如叫develop），并在该分支上进行开发。</p><p>3.接到测试组的Bug反馈，返回主分支，新建一个新的分支（bugFix），在该分支上修复Bug，然后与主分支master合并。</p><p>4.将分支切换回develop，继续开发新功能，结束后和主分支master合并。</p><h2 id="分支的新建与切换"><a href="#分支的新建与切换" class="headerlink" title="分支的新建与切换"></a>分支的新建与切换</h2><p>假如公司网站项目已经开发了一段时间，并且使用Git提交了几次更新，提交历史如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1564850183032-b09e5025-ebca-4b9d-8c8d-7f15295b3874.png" alt="img"></p><p>为了开发新的功能，新建分支develop并切换到该分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch develop</span><br><span class="line"></span><br><span class="line">$ git checkout develop</span><br><span class="line">Switched to branch <span class="string">'develop'</span></span><br></pre></td></tr></table></figure><p>也可以使用命令 <strong><em>git checkout -b</em></strong> 直接新建并切换：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b develop</span><br><span class="line">Switched to a new branch <span class="string">'develop'</span></span><br></pre></td></tr></table></figure><p>执行完上述命令后，仓库历史大致如下所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1564850266347-b3a8d859-2863-491a-8a44-c312b6be87eb.png" alt="img"></p><p>Git新建了一个分支指针develop，然后将HEAD指向develop。</p><p>接下来在该分支上开心的开发新功能，比如新建了公司网站About页面，添加了内容然后提交了此次修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ vim About.html</span><br><span class="line"></span><br><span class="line">$ git add About.html</span><br><span class="line"></span><br><span class="line">$ git commit -a -m <span class="string">"add About.html page"</span></span><br><span class="line">[develop b462691] add About.html page</span><br><span class="line"> 1 file changed, 12 insertions(+)</span><br><span class="line"> create mode 100644 About.html</span><br></pre></td></tr></table></figure><p>此时，仓库历史如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1564850293014-6b3c4cd9-8af7-4c22-92d8-caa3f00fbe18.png" alt="img"></p><p>这时候接到测试组公司网站主页index.html的Bug反馈，于是将分支切换回主分支master，然后新建分支bugFix，修复Bug，并提交该修复：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line"></span><br><span class="line">$ git checkout -b <span class="string">"bugFix"</span></span><br><span class="line">Switched to a new branch <span class="string">'bugFix'</span></span><br><span class="line"></span><br><span class="line">$ vim index.html</span><br><span class="line"></span><br><span class="line">$ git  commit -a -m <span class="string">"update index.html page"</span></span><br><span class="line">[bugFix 11a3074] update index.html page</span><br><span class="line"> 1 file changed, 2 insertions(+), 2 deletions(-)</span><br></pre></td></tr></table></figure><p>此时，仓库历史如下图所示：</p><p>`<img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1564850338214-4d62fbb7-4fe4-4a46-b4ad-f07a6897274c.png" alt="img"></p><p>假如确定<strong>Bug</strong>修复后，可以切换回<strong>master</strong>分支，然后将<strong>bugFix</strong>和<strong>master</strong>分支合并：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge bugFix</span><br><span class="line">Updating e7ad858..11a3074</span><br><span class="line">Fast-forward</span><br><span class="line"> index.html | 4 ++--</span><br><span class="line"> 1 file changed, 2 insertions(+), 2 deletions(-)</span><br></pre></td></tr></table></figure><p>合并时出现了“<strong>Fast forward</strong>”的提示。如果顺着一个分支走下去可以到达另一个分支的话，那么Git在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（<strong>Fast forward</strong>）。</p><p>此时<strong>bugFix</strong>分支已经完成了历史使命，可以使用命令 <strong><em>git branch -d</em></strong> 将其删除：</p><p>合并<strong>master</strong>与<strong>bugFix</strong>，并删除<strong>bugFix</strong>分支后，仓库历史如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1564850437440-6d477607-a8df-4f3b-b8ac-30c16e876de8.png" alt="img"></p><p><strong>Bug</strong>修复后，切换回<strong>develop</strong>分支继续开发新的功能，并且提交：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1564850459181-df04d3be-ed07-4103-9a67-947f16c8b6b6.png" alt="img"></p><h2 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h2><p>和合并<strong>master</strong>分支与<strong>bugFix</strong>分支那样，合并<strong>master</strong>与<strong>develop</strong>分支过程也差不多：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line"></span><br><span class="line">$ git merge develop</span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> About.html | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>由于master指向的C4并不是develop指向C5的直接祖先C2，所以合并方式不是“Fast forward”，Git 会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算。</p><p>合并master和develop后，仓库历史如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/400057/1564850520992-d529f6e1-5437-4575-983d-dd1ade41518c.png" alt="img"></p><h2 id="解决合并冲突"><a href="#解决合并冲突" class="headerlink" title="解决合并冲突"></a>解决合并冲突</h2><p>假如在不同分支中都对同一个文件进行了修改，那么合并的时候就会发生冲突。比如在master分支和develop分支上都修改了About.html页面，然后进行分支合并：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge develop</span><br><span class="line">Auto-merging About.html</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> About.html</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure><p>Git作了合并，但没有提交，它会停下来等你解决冲突。</p><p>可是使用命令 <strong><em>git status</em></strong> 查看哪些文件存在冲突：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">"git commit"</span>)</span><br><span class="line">  (use <span class="string">"git merge --abort"</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to mark resolution)</span><br><span class="line"></span><br><span class="line">        both modified:   About.html</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><p>任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出。编辑About.html页面，可看到文件包含类似下面部分的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">  &lt;footer&gt;2016~2017 All Rights Reserved&lt;/footer&gt;</span><br><span class="line">=======</span><br><span class="line">  &lt;footer&gt;&amp;copy;2016~2017&lt;/footer&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; develop</span><br></pre></td></tr></table></figure><p>可以看到 ======= 隔开的上半部分，是<strong>HEAD</strong>（即 <strong>master</strong> 分支，<strong>在运行merge命令时所切换到的分支</strong>）中的内容，下半部分是在develop分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;footer&gt;&amp;copy; 2016~2017 All Rights Reserved&lt;/footer&gt;</span><br></pre></td></tr></table></figure><p><strong>转载</strong>:<a href="http://mrbird.cc/Git分支的创建与合并.html" target="_blank" rel="noopener">http://mrbird.cc/Git分支的创建与合并.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>@Component注解派生性原理</title>
      <link href="/2019/08/04/Component%E6%B3%A8%E8%A7%A3%E6%B4%BE%E7%94%9F%E6%80%A7%E5%8E%9F%E7%90%86/"/>
      <url>/2019/08/04/Component%E6%B3%A8%E8%A7%A3%E6%B4%BE%E7%94%9F%E6%80%A7%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Component注解的派生性原理"><a href="#Component注解的派生性原理" class="headerlink" title="@Component注解的派生性原理"></a>@Component注解的派生性原理</h2><h4 id="1-模式注解"><a href="#1-模式注解" class="headerlink" title="1:模式注解"></a>1:模式注解</h4><p><code>Stereotype Annotation</code>俗称为模式注解。Spring核心部分提供了几种内建的<code>模式注解</code>,如<em>@Component,@Repository,@Service,@Controller,@Configuration等</em>。这些注解均<code>派生于@Component</code>。</p><p>由于<em>Java语言规定,Annotation不允许继承,没有类派生子类的特性</em>,因此<em><code>Spring采用元标注的方式实现注解之间的派生</code></em>。</p><h4 id="2-Component派生性"><a href="#2-Component派生性" class="headerlink" title="2:@Component派生性"></a>2:@Component派生性</h4><p>@Component注解作为Spring容器托管的通用模式组件,<em>任何被@Component标注的组件均为组件扫描的候选对象。</em></p><blockquote><p>任何论证过程离不开所处的环境,需要开发人员具备一定工程意识,包括<strong>软件版本,特性范围,兼容情况等</strong>。因此,<em>论证过程从最低版本开始推导,逐步证明不同版本得提升和差异。</em></p></blockquote><h4 id="3-Component注解派生性原理"><a href="#3-Component注解派生性原理" class="headerlink" title="3:@Component注解派生性原理"></a>3:@Component注解派生性原理</h4><p>当<code>ClassPathBeanDefinitionScanner#doScan(String... basePackages)</code>调用时,它利用basePackages参数迭代执行的<code>findCandidateComponents(String basePackage)</code>,每次执行结果都生成候选的BeanDefinition集合,即candidates变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathBeanDefinitionScanner</span> <span class="keyword">extends</span> <span class="title">ClassPathScanningCandidateComponentProvider</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"> <span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">        <span class="comment">//获取候选的BeanDefinition集合</span></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinitionHolder&gt;();</span><br><span class="line"><span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;   </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而findCandidateComponents(String basePackage)从父类ClassPathScanningCandidateComponentProvider</p><p>中继承。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathScanningCandidateComponentProvider</span> <span class="keyword">implements</span> <span class="title">EnvironmentCapable</span>, <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"> <span class="function"><span class="keyword">public</span> Set&lt;BeanDefinition&gt; <span class="title">findCandidateComponents</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line">Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinition&gt;();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取查询的package,并处理占位符情况$&#123;...&#125;,转换为ClassLoader资源(.class)搜索路径</span></span><br><span class="line">String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class="line">resolveBasePackage(basePackage) + <span class="string">'/'</span> + <span class="keyword">this</span>.resourcePattern;</span><br><span class="line">Resource[] resources = <span class="keyword">this</span>.resourcePatternResolver.getResources(packageSearchPath);</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//resource迭代执行,当资源可读取时,获取该资源的MetadataReader对象</span></span><br><span class="line"><span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (resource.isReadable()) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//包含了类和注解元信息读取方法</span></span><br><span class="line">MetadataReader metadataReader = <span class="keyword">this</span>.metadataReaderFactory.getMetadataReader(resource);</span><br><span class="line">                        <span class="comment">//判断资源是否为候选的组件,通过excludeFilters和includeFilters进行判断</span></span><br><span class="line"><span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">                            <span class="comment">//基于ASM,支持AnnotatedBeanDefinition接口</span></span><br><span class="line">ScannedGenericBeanDefinition sbd = <span class="keyword">new</span> ScannedGenericBeanDefinition(metadataReader);</span><br><span class="line">sbd.setResource(resource);</span><br><span class="line">sbd.setSource(resource);</span><br><span class="line">                            <span class="comment">//判断BeanDefinition是否候选组件</span></span><br><span class="line"><span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line">...</span><br><span class="line">candidates.add(sbd);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> candidates;</span><br><span class="line">&#125;   </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine whether the given class does not match any exclude filter</span></span><br><span class="line"><span class="comment"> * and does match at least one include filter.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> metadataReader the ASM ClassReader for the class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> whether the class qualifies as a candidate component</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(MetadataReader metadataReader)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.excludeFilters) &#123;</span><br><span class="line"><span class="keyword">if</span> (tf.match(metadataReader, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.includeFilters) &#123;</span><br><span class="line"><span class="keyword">if</span> (tf.match(metadataReader, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line"><span class="keyword">return</span> isConditionMatch(metadataReader);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine whether the given bean definition qualifies as candidate.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The default implementation checks whether the class is not an interface</span></span><br><span class="line"><span class="comment"> * and not dependent on an enclosing class.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Can be overridden in subclasses.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanDefinition the bean definition to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> whether the bean definition qualifies as a candidate component</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(AnnotatedBeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">AnnotationMetadata metadata = beanDefinition.getMetadata();</span><br><span class="line"><span class="keyword">return</span> (metadata.isIndependent() &amp;&amp; (metadata.isConcrete() ||</span><br><span class="line">(metadata.isAbstract() &amp;&amp; metadata.hasAnnotatedMethods(Lookup.class.getName()))));</span><br><span class="line">&#125;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register the default filter for &#123;<span class="doctag">@link</span> Component <span class="doctag">@Component</span>&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This will implicitly register all annotations that have the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Component <span class="doctag">@Component</span>&#125; meta-annotation including the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Repository <span class="doctag">@Repository</span>&#125;, &#123;<span class="doctag">@link</span> Service <span class="doctag">@Service</span>&#125;, and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Controller <span class="doctag">@Controller</span>&#125; stereotype annotations.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Also supports Java EE 6's &#123;<span class="doctag">@link</span> javax.annotation.ManagedBean&#125; and</span></span><br><span class="line"><span class="comment"> * JSR-330's &#123;<span class="doctag">@link</span> javax.inject.Named&#125; annotations, if available.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerDefaultFilters</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(Component.class));</span><br><span class="line">ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">((Class&lt;? extends Annotation&gt;) ClassUtils.forName(<span class="string">"javax.annotation.ManagedBean"</span>, cl)), <span class="keyword">false</span>));</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">((Class&lt;? extends Annotation&gt;) ClassUtils.forName(<span class="string">"javax.inject.Named"</span>, cl)), <span class="keyword">false</span>));</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下,ClassPathScanningCandidateComponentProvider构造参数<code>useDefaultFilters为true</code>,并且显示传递给父类构造参数。该方法给属性<code>includeFilters</code>增添了<code>@Component</code>类型AnnotationTypeFilter的TypeFilter。</p><p>ClassPathBeanDefinitionScanner默认过滤器引入标注@Component,@Repository,@Service或者@Controller等类。<code>同理,它也能够标注所有@Component的&quot;派生&quot;注解。</code></p><blockquote><p><code>@Component</code>注解只包含一个value属性定义，所以其“派生”的注解也只能包含一个vlaue属性定义。 </p></blockquote><p>Dubbo实现<code>@Service</code>注解扫描实例:</p><blockquote><p><strong>ClassPathBeanDefinitionScanner</strong>允许自定义类型过滤规则。因此,Dubbo的@Service没有标注@Component情况下，通过scanner.addIncludeFilter(new AnnotationTypeFilter(Service.class))方式达到识别@Service标注类情况。但是没有使用<code>@Component</code>注解的派生性。</p></blockquote><p>Mybatis实现<code>@Mapper</code>注解扫描实例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathMapperScanner</span> <span class="keyword">extends</span> <span class="title">ClassPathBeanDefinitionScanner</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ClassPathMapperScanner</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(registry, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Configures parent scanner to search for the right interfaces. It can search</span></span><br><span class="line"><span class="comment">   * for all interfaces or just for those that extends a markerInterface or/and</span></span><br><span class="line"><span class="comment">   * those annotated with the annotationClass</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerFilters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> acceptAllInterfaces = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if specified, use the given annotation and / or marker interface</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.annotationClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">      addIncludeFilter(<span class="keyword">new</span> AnnotationTypeFilter(<span class="keyword">this</span>.annotationClass));</span><br><span class="line">      acceptAllInterfaces = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// override AssignableTypeFilter to ignore matches on the actual marker interface</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.markerInterface != <span class="keyword">null</span>) &#123;</span><br><span class="line">      addIncludeFilter(<span class="keyword">new</span> AssignableTypeFilter(<span class="keyword">this</span>.markerInterface) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">matchClassName</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      acceptAllInterfaces = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (acceptAllInterfaces) &#123;</span><br><span class="line">      <span class="comment">// default include filter that accepts all classes</span></span><br><span class="line">      addIncludeFilter(<span class="keyword">new</span> TypeFilter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exclude package-info.java</span></span><br><span class="line">    addExcludeFilter(<span class="keyword">new</span> TypeFilter() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String className = metadataReader.getClassMetadata().getClassName();</span><br><span class="line">        <span class="keyword">return</span> className.endsWith(<span class="string">"package-info"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(AnnotatedBeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> beanDefinition.getMetadata().isInterface() &amp;&amp; beanDefinition.getMetadata().isIndependent();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processBeanDefinitions</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; beanDefinitions)</span> </span>&#123;</span><br><span class="line">    GenericBeanDefinition definition;</span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">      definition = (GenericBeanDefinition) holder.getBeanDefinition();</span><br><span class="line">     </span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">      <span class="comment">//复杂对象构建考虑使用FactoryBean接口           </span></span><br><span class="line">      <span class="comment">// the mapper interface is the original class of the bean</span></span><br><span class="line">      <span class="comment">// but, the actual class of the bean is MapperFactoryBean</span></span><br><span class="line">     <span class="comment">//添加泛型参数         </span></span><br><span class="line">           definition.getConstructorArgumentValues().addGenericArgumentValue(definition.getBeanClassName());</span><br><span class="line">     <span class="comment">// issue #59</span></span><br><span class="line">      definition.setBeanClass(<span class="keyword">this</span>.mapperFactoryBean.getClass());</span><br><span class="line"></span><br><span class="line">      definition.getPropertyValues().add(<span class="string">"addToConfig"</span>, <span class="keyword">this</span>.addToConfig);</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-思考扩展"><a href="#4-思考扩展" class="headerlink" title="4:思考扩展"></a>4:思考扩展</h4><p>思考1:利用<code>ClassPathBeanDefinitionScanner</code>类配合<code>includeFilters</code>和<code>excludeFilters</code>定制化批量注册Bean到Spring容器中。常常可以通过注解方式来包含或者排除候选类。</p><p><em>TypeFilter常用实现</em></p><ul><li>AnnotationTypeFilter:注解类型过滤器</li><li>AssignableTypeFilter:确定此对象表示的类或者接口是否为给定类或者接口相同。</li><li>RegexPatternTypeFilter:判断给定的类名是否符合指定正则表达式。</li></ul><p>思考2:复杂对象构建考虑使用<code>FactoryBean</code>实现类。</p><p>思考3:如果是读取类和注解信息可以考虑基于ASM或者反射,使用方式往下可以获取。当获取已加载的类信息可以考虑反射(<code>反射大前提是被反射的Class被ClassLoader加载</code>),ASM用于不需要将类路径package下的Class全部加载,Spring应用指定Java package扫描Spring模式注解时,利用的就是基于ASM方式获取类或者注解信息。基于ASM获取会获得更大性能。</p><p>思考4:资源读取考虑使用<code>ResourcePatternResolver</code>,这个对象的获取可以通过Spring提供的工具类</p><p><code>ResourcePatternUtils.getResourcePatternResolver(resourceLoader)</code>。在使用的时候,考虑处理</p><p><code>占位符${...}</code>的情况,注意资源是否可读。</p><h4 id="5-多层次-Component派生性"><a href="#5-多层次-Component派生性" class="headerlink" title="5:多层次@Component派生性"></a>5:多层次@Component<code>派生性</code></h4><p>(1):具体发展过程不再细说,详解请看<code>SpringBoot编程思想这本书</code>。其多层次@Component注解派生性构建在<code>Spring4.x</code>。其核心处理类为<code>AnnotationMetadataReadingVisitor</code>,<code>其采用递归的方式查找元注解</code>。</p><p>(2):Spring中,MetadataReader接口唯一实现非公开类<code>SimpleMetadataReader</code>。可以通过<br><code>SimpleMetadataReaderFactory(ASM字节码操作)</code>和<code>CachingMetadataReaderFactory</code>获取。</p><p>其中在SimpleMetadataReader实现上看,<code>ClassMetadataReadingVisitor</code>和<code>AnnotationMetadataReadingVisitor</code>分别是<code>ClassMetadatta</code>和<code>AnnotationMetadata</code>实现类。</p><p>由于<code>ClassPathBeanDefinitionScanner</code>在寻找候选的BeanDefinition过程中,将指定basePackage参数下</p><p>的*.class资源进行元信息解析,也就是<code>ClassMetadata</code>和<code>AnnotationMetadata</code>对象。</p><p><code>AnnotationMetadataReadingVisitor</code>实现上使用了<code>AnnotationAttributesReadingVisitor</code>，该类主要实现方法是<code>visitEnd()</code>。<em>Spring2.5实现未采用层次递归获取Annotation[],所以仅支持单层次的@Component派生。Spring3.x实现仅两层@Component派生。Spring4.x开始采用递归方式查找元注解。</em></p><p>(3):<strong><code>思考扩展</code></strong></p><ul><li><code>考虑使用ASM的方式读取类或者注解相关信息。(不需要全部将指定路径下的类加载)</code><ul><li>MetadataReaderFactory:获取MetadataReader工厂<ul><li>SimpleMetadataReaderFactory:简单获取MetadataReader工厂实现<ul><li>ClassReader:基于ASM读取类相关信息,公开类,不建议单独使用。</li><li>AnnotationMetadataReadingVisitor:基于ASM读取注解元数据相关信息,不建议单独使用。</li><li>MethodMetadataReadingVisitor:基于ASM读取方法相关信息,不建议单独使用。</li></ul></li><li>CachingMetadataReaderFactory:继承SimpleMetadataReaderFactory,增加缓存MetadataReader资源功能。</li></ul></li><li>MetadataReader:获取访问类和注解相关信息。通过MetadataReaderFactory获取。<ul><li>Resource getResource():获取类文件资源引用</li><li>ClassMetadata getClassMetadata():读取基础类的基本元数据</li><li>AnnotationMetadata getAnnotationMetadata():读取底层类完整注解元数据,包含注解方法的注解元数据。</li></ul></li></ul></li><li><code>考虑使用反射的方式读取类或者注解相关信息(比较费时而且该类必须被ClassLoader加载)</code><ul><li>StandardClassMetadata:基于反射读取类元数据,可建议单独使用。</li><li>StandardAnnotationMetadata:基于反射读取注解元数据,可建议单独使用</li><li>StandardMethodMetadata:基于反射读取方法元数据,可建议单独使用</li></ul></li><li><code>考虑使用Spring内部支持的有用工具类</code>,都是来自于spring-core包中。<code>多使用spring内建API,学习他们的长处。</code><ul><li>ClassUtils:类工具类</li><li>CollectionUtils:集合工具类</li><li>NumberUtils:Number工具类</li><li>MimeTypeUtils:媒体类型工具类</li><li>IdGenerator:Id生成器</li><li>StringUtils:字符串工具类</li><li>ResourceUtils:资源工具类</li><li>ReflectionUtils:反射工具类</li><li>MethodIntrospector:方法自省工具类(EventListenerMethodProcessor#processBean中有使用)</li><li>PatternMatchUtils:正则资源匹配工具类</li><li>ObjectUtils:对象工具类</li></ul></li></ul><h5 id="3-组合注解"><a href="#3-组合注解" class="headerlink" title="3:组合注解"></a>3:组合注解</h5><p><code>组合注解</code>指某个注解”元标注”一个或多个其他注解，其目的在于将这些关联的注解行为组合成单个自定义注解。</p><p>Spring Framework的类加载通过ASM实现，如<code>ClassReader</code>。相对于ClassLoader体系，Spring ASM更为底层，读取的是<code>类资源</code>，直接操作其中的字节码，获取相关元信息。如<code>MetadataReader接口</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Simple facade for accessing class metadata,</span></span><br><span class="line"><span class="comment"> * as read by an ASM &#123;<span class="doctag">@link</span> org.springframework.asm.ClassReader&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MetadataReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the resource reference for the class file.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Resource <span class="title">getResource</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Read basic class metadata for the underlying class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ClassMetadata <span class="title">getClassMetadata</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Read full annotation metadata for the underlying class,</span></span><br><span class="line"><span class="comment"> * including metadata for annotated methods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">AnnotationMetadata <span class="title">getAnnotationMetadata</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AnnotationMetadataReadingVisitor</code>同时实现了ClassMetadata及AnnotationMetadata。因此，元注解的实现集中到<code>AnnotationMetadataReadingVisitor</code>和<code>AnnotationAttributesReadingVisitor</code>之中。</p><p><code>MetadataReader</code>对象通过<code>MetadataReaderFactory</code>对象获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Factory interface for &#123;<span class="doctag">@link</span> MetadataReader&#125; instances.</span></span><br><span class="line"><span class="comment"> * Allows for caching a MetadataReader per original resource.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> SimpleMetadataReaderFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> CachingMetadataReaderFactory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MetadataReaderFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Obtain a MetadataReader for the given class name.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> className the class name (to be resolved to a ".class" file)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a holder for the ClassReader instance (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException in case of I/O failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">MetadataReader <span class="title">getMetadataReader</span><span class="params">(String className)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Obtain a MetadataReader for the given resource.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resource the resource (pointing to a ".class" file)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a holder for the ClassReader instance (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException in case of I/O failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">MetadataReader <span class="title">getMetadataReader</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体某个注解的<code>元注解</code>信息则通过<code>getMetaAnnotationTypes(String)</code>方法查询。</p><p><code>AnnotationMetadata</code>实现<code>AnnotationMetadataReadingVisitor(ASM实现)</code>，<code>StandardAnnotationMetadata(反射)</code>。</p><ul><li>注解元信息抽象:<code>AnnotationMetadata</code><ul><li><code>AnnotationMetadataReadingVisitor</code><ul><li><code>AnnotationAttributesReadingVisitor</code>(递归查找元注解)</li></ul></li></ul></li><li>类元信息抽象:<code>ClassMetadata</code></li><li>方法元信息抽象:<code>MethodMetadata</code></li><li>注解属性抽象:<code>AnnotationAttributes</code></li><li>属性环境抽象:<code>Environment</code></li><li>属性文件抽象:<code>PropertySource</code></li><li>元信息读取抽象:<code>MetadataReader</code><ul><li>通过<code>MetadataReaderFactory</code>获取</li></ul></li></ul><p>方法内省:<code>MethodIntrospector</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Method, EventListener&gt; annotatedMethods = <span class="keyword">null</span>;</span><br><span class="line">   annotatedMethods = MethodIntrospector.selectMethods(targetType,</span><br><span class="line">(MethodIntrospector.MetadataLookup&lt;EventListener&gt;) method -&gt;</span><br><span class="line">AnnotatedElementUtils.findMergedAnnotation(method, EventListener.class));</span><br></pre></td></tr></table></figure><p>注解工具类:<code>AnnotationUtils</code></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring注解属性抽象AnnotationAttributes </tag>
            
            <tag> 模式注解 </tag>
            
            <tag> Component注解派生性原理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

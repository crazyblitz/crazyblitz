<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot自动配置原理]]></title>
    <url>%2F2019%2F08%2F05%2FSpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[SpringBoot自动配置原理1:产生背景 在Spring Framework时代,当Spring应用的@Component或者@Configuration Class需要被装配 时,应用需要借助@Import或者@ComponentScan的能力。由于应用依赖的Jar存在变化的可能, 因此其中的@Component或者@Configuration Class所在的包路径也会发生变化。 不鼓励开发人员通过@ComponentScan或者@SpringApplication注解方式扫描默认包。因为 它读取所有JAR中类,并且可能会造成默认Spring Boot错误 当Spring应用自动装配某些组件时,它需要一种综合性技术手段,重新深度结合Spring注解编程 模型,@Enable模块驱动和条件装配等Spring Framework原生特性,这种技术就是Spring Boot 自动装配。 2:理解Spring Boot自动装配(1):理解@EnableAutoConfiguration 用于激活Spring Boot自动装配特性。 (2):优雅的替换自动装配 开发人员可在任意一处定义配置类,从而覆盖那些被自动装配的组件。SpringBoot优先解析 自定义配置类。内建的配置类,一旦应用存在自定义实现，就不会再装配。 (3):失效自动装配 SpringBoot提供两种失效手段 代码配置方式 配置类型安全属性方法:@EnableAutoConfiguration.exclude() 配置排除类名方式:@EnableAutoConfiguration.excludeName() 外部化配置方式 配置属性:spring.autoconfigure.exclude 3:自动装配原理 依照@Enable模块驱动设计模式，@EnableAutoConguration必然是@Import 类ImportSelector 或者ImportBeanDefinitionRegistrar的实现类。 AutoConfigurationImportSelector主要执行逻辑: 1234567891011121314151617181920212223242526public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; //读取自动装配元信息配置文件 //"META-INF/"+ "spring-autoconfigure-metadata.properties" AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader .loadMetadata(this.beanClassLoader); //获取@EnableAutoConfiguration注解属性 AnnotationAttributes attributes = getAttributes(annotationMetadata); //获取自动装配Class候选列表 List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); //移除重复的自动装配类名 configurations = removeDuplicates(configurations); //排除自动装配组件 Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); //检查排除类名集合是否合法 checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); //过滤候选自动装配组件集合中Class不存在成员 configurations = filter(configurations, autoConfigurationMetadata); //触发自动装配导入事件 fireAutoConfigurationImportEvents(configurations, exclusions); return StringUtils.toStringArray(configurations);&#125; (1):读取候选装配组件 使用了Spring工厂加载类SpringFactoriesLoader。原理如下 搜索指定ClassLoader下所有的META-INF/spring.factories资源内容。 将一个或者多个META-INF/spring.factories资源内容作为Properties文件读取,并合并为 一个Key为接口的全类限定名,Value是实现类的全类名列表的Map,作为返回值。 再从上一步返回Map中查找并返回方法指定类名所映射的实现类全类名列表。 SpringBoot自动装配列表存在地方 spring-boot-autoconfigure模块 spring-boot-actuator-autoconfigure模块 spring-boot-devtools模块(可选) 由于@EnableAutoConfiguration配置可能存在配置组件类名重复定义情况,当获取所有候选类, 立即执行removeDuplicates(List)方法,利用Set不可重复性达到去重的目的。 (2):排除自动装配组件 当getExclusions(AnnotationMetadata metadata,AnnotationAttributes attributes) 执行后,程序将获取到一个自动装配Class排除列表。随后检查排除类名集合是否合法。当排除类 存在于当前的ClassLoader但是不在自动装配名单中,将触发排除类非法异常。 1234567891011121314private void checkExcludedClasses(List&lt;String&gt; configurations, Set&lt;String&gt; exclusions) &#123; List&lt;String&gt; invalidExcludes = new ArrayList&lt;&gt;(exclusions.size()); for (String exclusion : exclusions) &#123; //存在当前ClassLoader但是不在自动装配列表名单 if (ClassUtils.isPresent(exclusion, getClass().getClassLoader()) &amp;&amp; !configurations.contains(exclusion)) &#123; invalidExcludes.add(exclusion); &#125; &#125; if (!invalidExcludes.isEmpty()) &#123; handleInvalidExcludes(invalidExcludes); &#125;&#125; (3):过滤自动装配组件 移除排除类名单后Configurations配合AutoConfigurationMetadata对象执行过滤操作。 (4):@EnableAutoConfiguration自动装配事件 SpringBoot1.5开始引入AutoConfigurationImportListener接口,自定义Java EventListener ,仅监听AutoConfigurationImportEvent,然后实例同样被SpringFactoriesLoader加载。其中, ConditionEvaluationReportAutoConfigurationImportListener就是内建实现,用于 记录自动装配组件的条件评估详情。 (5):EnableAutoConfiguration自动装配生命周期 DeferredImportSelector作为ImportSelector变种,它在@Configuration Bean处理完毕 后才运作。在@Conditional场景尤为有用，同时该实现类可通过Ordered接口或者@Order 方式调整其优先顺序。 该接口提供两类方法: process()和selectImports()。前者二次处理selectImports()方法返回 的结果，后者负责决定本组应该导入的Configuration Class作为实际导入的结果。 (6):EnableAutoConfiguration排序自动装配组件 SpringBoot提供两种自动装配组件排序手段: 绝对自动装配顺序:@AutoConfigurationOrder 相对自动装配顺序:@AutoConfigurationBefore和@AutoConfigurationAfter。(常用) (7):EnableAutoConfiguration自动装配BasePackages SpringBoot1.3开始引用注解@AutoConfigurationPackage。 该注解的实现类常常用于默认包获取。例如JPA实现获取默认包。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>自动配置原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[@Enable模块驱动原理]]></title>
    <url>%2F2019%2F08%2F05%2FEnable%E6%A8%A1%E5%9D%97%E9%A9%B1%E5%8A%A8%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[@Enable模块驱动原理1:概述@Enable模块驱动在Spring3.1后开始支持。这里的模块指具备相同领域的功能组件集合,组合所形成的一个独立的单元。例如Web MVC模块,AspectJ代理模块,Caching模块,JMX模块,Async模块等。通过@Enable模块驱动,可以开启响应的模块功能。 @Enable模块驱动可以分为”注解驱动”和”接口编程”两种实现方式。都需要配合@Import注解。 注解驱动:通过@Configuration类和@Bean方法声明类。例如Web MVC模块实现,即@EnableWebMvc注解通过导入DelegatingWebMvcConfiguration来实现。 接口编程:ImportSelector和ImportBeanDefinitionRegistrar的实现类。例如Caching模块实现,即 @EnableCaching注解通过导入CachingConfigurationSelector实现。 2:实现示例(1):注解驱动基于ImportSelector接口 @EnableWebMvc模块实现: 123456@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Documented@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc &#123;&#125; 该注解通过@Import导入一个配置类DelegatingWebMvcConfiguration: 1234@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; ......&#125; 该配置类又继承自WebMvcConfigurationSupport,里面定义一些Web Mvc必须Bean声明。 所以，基于注解驱动的@Enable模块驱动其实就是通过@Import来导入一个配置类，以此实现相应模块的组件注册，当这些组件注册到IOC容器中，这个模块对应的功能也就可以使用了。 (2):接口编程@EnableCaching模块实现。 123456789101112131415@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(CachingConfigurationSelector.class)public @interface EnableCaching &#123; boolean proxyTargetClass() default false; AdviceMode mode() default AdviceMode.PROXY; int order() default Ordered.LOWEST_PRECEDENCE;&#125; @EnableCaching*注解通过@Import导入CachingConfigurationSelector类,该类间接实现了ImportSelector*。 ImportSelector使用Spring注解元信息抽象AnnotationMetadata作为方法参数,该参数内容为导入ImportSelector实现的@Configuration类元信息,进而动态的选择一个或者多个其他@Configuration类进行导入。 1234567891011121314151617181920212223242526272829303132333435363738&gt; /**&gt; * Interface to be implemented by types that determine which @&#123;@link Configuration&#125;&gt; * class(es) should be imported based on a given selection criteria, usually one or more&gt; * annotation attributes.&gt; *&gt; * &lt;p&gt;An &#123;@link ImportSelector&#125; may implement any of the following&gt; * &#123;@link org.springframework.beans.factory.Aware Aware&#125; interfaces, and their respective&gt; * methods will be called prior to &#123;@link #selectImports&#125;:&gt; * &lt;ul&gt;&gt; * &lt;li&gt;&#123;@link org.springframework.context.EnvironmentAware EnvironmentAware&#125;&lt;/li&gt;&gt; * &lt;li&gt;&#123;@link org.springframework.beans.factory.BeanFactoryAware BeanFactoryAware&#125;&lt;/li&gt;&gt; * &lt;li&gt;&#123;@link org.springframework.beans.factory.BeanClassLoaderAware BeanClassLoaderAware&#125;&lt;/li&gt;&gt; * &lt;li&gt;&#123;@link org.springframework.context.ResourceLoaderAware ResourceLoaderAware&#125;&lt;/li&gt;&gt; * &lt;/ul&gt;&gt; *&gt; * &lt;p&gt;ImportSelectors are usually processed in the same way as regular &#123;@code @Import&#125;&gt; * annotations, however, it is also possible to defer selection of imports until all&gt; * &#123;@code @Configuration&#125; classes have been processed (see &#123;@link DeferredImportSelector&#125;&gt; * for details).&gt; *&gt; * @author Chris Beams&gt; * @since 3.1&gt; * @see DeferredImportSelector&gt; * @see Import&gt; * @see ImportBeanDefinitionRegistrar&gt; * @see Configuration&gt; */&gt; public interface ImportSelector &#123;&gt; &gt; /**&gt; * Select and return the names of which class(es) should be imported based on&gt; * the &#123;@link AnnotationMetadata&#125; of the importing @&#123;@link Configuration&#125; class.&gt; */&gt; String[] selectImports(AnnotationMetadata importingClassMetadata);&gt; &gt; &#125;&gt; &gt; 基于ImportBeanDefinitionRegistrar接口 @MapperScan模块实现 12345678910111213141516171819202122232425public class MapperScannerRegistrar implements ImportBeanDefinitionRegistrar, ResourceLoaderAware &#123; private ResourceLoader resourceLoader; /** * &#123;@inheritDoc&#125; */ @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; AnnotationAttributes annoAttrs = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName())); ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry); ... Class&lt;? extends Annotation&gt; annotationClass = annoAttrs.getClass("annotationClass"); if (!Annotation.class.equals(annotationClass)) &#123; scanner.setAnnotationClass(annotationClass); &#125; ... scanner.registerFilters(); scanner.doScan(StringUtils.toStringArray(basePackages)); &#125; ....&#125; 该接口的编程复杂度相比较于ImportSelector更高,接口将Bean定义的注册交给开发人员。常常配合ClassPathBeanDefinitionScanner类进行批量注册BeanDefinition。 ImportBeanDefinitionRegistrar:除注解元信息AnnotationMetadata作为入参外,接口将 Bean定义注册交给开发人员。 12345678910111213141516171819202122232425262728293031323334353637383940414243&gt; /**&gt; * Interface to be implemented by types that register additional bean definitions when&gt; * processing @&#123;@link Configuration&#125; classes. Useful when operating at the bean definition&gt; * level (as opposed to &#123;@code @Bean&#125; method/instance level) is desired or necessary.&gt; *&gt; * &lt;p&gt;Along with &#123;@code @Configuration&#125; and &#123;@link ImportSelector&#125;, classes of this type&gt; * may be provided to the @&#123;@link Import&#125; annotation (or may also be returned from an&gt; * &#123;@code ImportSelector&#125;).&gt; *&gt; * &lt;p&gt;An &#123;@link ImportBeanDefinitionRegistrar&#125; may implement any of the following&gt; * &#123;@link org.springframework.beans.factory.Aware Aware&#125; interfaces, and their respective&gt; * methods will be called prior to &#123;@link #registerBeanDefinitions&#125;:&gt; * &lt;ul&gt;&gt; * &lt;li&gt;&#123;@link org.springframework.context.EnvironmentAware EnvironmentAware&#125;&lt;/li&gt;&gt; * &lt;li&gt;&#123;@link org.springframework.beans.factory.BeanFactoryAware BeanFactoryAware&#125;&gt; * &lt;li&gt;&#123;@link org.springframework.beans.factory.BeanClassLoaderAware BeanClassLoaderAware&#125;&gt; * &lt;li&gt;&#123;@link org.springframework.context.ResourceLoaderAware ResourceLoaderAware&#125;&gt; * &lt;/ul&gt;&gt; *&gt; * &lt;p&gt;See implementations and associated unit tests for usage examples.&gt; *&gt; * @author Chris Beams&gt; * @since 3.1&gt; * @see Import&gt; * @see ImportSelector&gt; * @see Configuration&gt; */&gt; public interface ImportBeanDefinitionRegistrar &#123;&gt; &gt; /**&gt; * Register bean definitions as necessary based on the given annotation metadata of&gt; * the importing &#123;@code @Configuration&#125; class.&gt; * &lt;p&gt;Note that &#123;@link BeanDefinitionRegistryPostProcessor&#125; types may &lt;em&gt;not&lt;/em&gt; be&gt; * registered here, due to lifecycle constraints related to &#123;@code @Configuration&#125;&gt; * class processing.&gt; * @param importingClassMetadata annotation metadata of the importing class&gt; * @param registry current bean definition registry&gt; */&gt; public void registerBeanDefinitions(&gt; AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry);&gt; &gt; &#125;&gt; 3:@Enable模块驱动原理1:概述 @Enable模块驱动,模块无论来自于Spring内建,还是自定义,均使用@Import实现,并且该注解的职责在于装载导入类,将其定义为Spring Bean。导入主要为@Configuration Class,ImportSelector实现及ImportBeanDefinitionRegistrar实现。 2:源码实现 (1):装载@Configuration Class。 @Configuration从Spring3.0开始引入,该版本还未引入@ComponentScan。因此,开发人员经常看到XML元素&lt;context:component-scan/&gt;与&lt;context:annotation-config&gt;同时存在。根据Spring的”可扩展XML编写”特性,可以知道&lt;context:annotation-config&gt;所对应的BeanDefinitionParser实现为AnnotationConfigBeanDefinitionParser。 AnnotationConfigBeanDefinitionParser 1234567891011121314151617181920212223/** * Parser for the &amp;lt;context:annotation-config/&amp;gt; element. * * @author Mark Fisher * @author Juergen Hoeller * @author Christian Dupuis * @since 2.5 * @see AnnotationConfigUtils */public class AnnotationConfigBeanDefinitionParser implements BeanDefinitionParser &#123; @Override public BeanDefinition parse(Element element, ParserContext parserContext) &#123; Object source = parserContext.extractSource(element); // Obtain bean definitions for all relevant BeanPostProcessors. Set&lt;BeanDefinitionHolder&gt; processorDefinitions = AnnotationConfigUtils.registerAnnotationConfigProcessors(parserContext.getRegistry(), source); ... return null; &#125;&#125; AnnotationConfigUtils在Spring3.0增加了@Configuration Class的处理实现ConfigurationClassPostProcessor: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class AnnotationConfigUtils &#123; /** * The bean name of the internally managed Configuration annotation processor. */ public static final String CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME = &quot;org.springframework.context.annotation.internalConfigurationAnnotationProcessor&quot;; /** * The bean name of the internally managed BeanNameGenerator for use when processing * &#123;@link Configuration&#125; classes. Set by &#123;@link AnnotationConfigApplicationContext&#125; * and &#123;@code AnnotationConfigWebApplicationContext&#125; during bootstrap in order to make * any custom name generation strategy available to the underlying * &#123;@link ConfigurationClassPostProcessor&#125;. * @since 3.1.1 */ public static final String CONFIGURATION_BEAN_NAME_GENERATOR = &quot;org.springframework.context.annotation.internalConfigurationBeanNameGenerator&quot;; ... /** * Register all relevant annotation post processors in the given registry. * @param registry the registry to operate on */ public static void registerAnnotationConfigProcessors(BeanDefinitionRegistry registry) &#123; registerAnnotationConfigProcessors(registry, null); &#125; public static Set&lt;BeanDefinitionHolder&gt; registerAnnotationConfigProcessors( BeanDefinitionRegistry registry, Object source) &#123; ... Set&lt;BeanDefinitionHolder&gt; beanDefs = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(4); if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; ... return beanDefs; &#125; ...&#125; 简单的说,ConfigurationClassPostProcessor无论实在XML配置驱动还是在注解驱动使用场景下,均通过AnnotationConfigUtils.registerAnnotationConfigProcessors(registry,source)方法执行得到装载,且为最高优先级。不但处理了@Configuration Class,也负责@Bean方法的Bean定义。 (2):ConfigurationClassPostProcessor处理 //主要处理方法落在processConfigBeanDefinitions(registry) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173public class ConfigurationClassPostProcessor implements BeanDefinitionRegistryPostProcessor, PriorityOrdered, ResourceLoaderAware, BeanClassLoaderAware, EnvironmentAware &#123; ... /** * Prepare the Configuration classes for servicing bean requests at runtime * by replacing them with CGLIB-enhanced subclasses. */ @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123; int factoryId = System.identityHashCode(beanFactory); if (this.factoriesPostProcessed.contains(factoryId)) &#123; throw new IllegalStateException( "postProcessBeanFactory already called on this post-processor against " + beanFactory); &#125; this.factoriesPostProcessed.add(factoryId); if (!this.registriesPostProcessed.contains(factoryId)) &#123; // BeanDefinitionRegistryPostProcessor hook apparently not supported... // Simply call processConfigurationClasses lazily at this point then. processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory); &#125; enhanceConfigurationClasses(beanFactory); beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory)); &#125; /** * Build and validate a configuration model based on the registry of * &#123;@link Configuration&#125; classes. */ public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) &#123; List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;BeanDefinitionHolder&gt;(); String[] candidateNames = registry.getBeanDefinitionNames(); for (String beanName : candidateNames) &#123; BeanDefinition beanDef = registry.getBeanDefinition(beanName); if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) &#123; ... &#125; else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) &#123; configCandidates.add(new BeanDefinitionHolder(beanDef, beanName)); &#125; &#125; // Return immediately if no @Configuration classes were found if (configCandidates.isEmpty()) &#123; return; &#125; // Sort by previously determined @Order value, if applicable Collections.sort(configCandidates, new Comparator&lt;BeanDefinitionHolder&gt;() &#123; @Override public int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) &#123; int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition()); int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition()); return (i1 &lt; i2) ? -1 : (i1 &gt; i2) ? 1 : 0; &#125; &#125;); // Detect any custom bean name generation strategy supplied through the enclosing application context SingletonBeanRegistry sbr = null; if (registry instanceof SingletonBeanRegistry) &#123; sbr = (SingletonBeanRegistry) registry; if (!this.localBeanNameGeneratorSet &amp;&amp; sbr.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) &#123; BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR); this.componentScanBeanNameGenerator = generator; this.importBeanNameGenerator = generator; &#125; &#125; // Parse each @Configuration class ConfigurationClassParser parser = new ConfigurationClassParser( this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry); Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(configCandidates); Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;ConfigurationClass&gt;(configCandidates.size()); do &#123; parser.parse(candidates); parser.validate(); Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;ConfigurationClass&gt;(parser.getConfigurationClasses()); configClasses.removeAll(alreadyParsed); // Read the model and create bean definitions based on its content if (this.reader == null) &#123; this.reader = new ConfigurationClassBeanDefinitionReader( registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry()); &#125; this.reader.loadBeanDefinitions(configClasses); alreadyParsed.addAll(configClasses); candidates.clear(); if (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123; String[] newCandidateNames = registry.getBeanDefinitionNames(); Set&lt;String&gt; oldCandidateNames = new HashSet&lt;String&gt;(Arrays.asList(candidateNames)); Set&lt;String&gt; alreadyParsedClasses = new HashSet&lt;String&gt;(); for (ConfigurationClass configurationClass : alreadyParsed) &#123; alreadyParsedClasses.add(configurationClass.getMetadata().getClassName()); &#125; for (String candidateName : newCandidateNames) &#123; if (!oldCandidateNames.contains(candidateName)) &#123; BeanDefinition bd = registry.getBeanDefinition(candidateName); if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;&amp; !alreadyParsedClasses.contains(bd.getBeanClassName())) &#123; candidates.add(new BeanDefinitionHolder(bd, candidateName)); &#125; &#125; &#125; candidateNames = newCandidateNames; &#125; &#125; while (!candidates.isEmpty()); // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes if (sbr != null) &#123; if (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123; sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry()); &#125; &#125; if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) &#123; ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache(); &#125; &#125; /** * Post-processes a BeanFactory in search of Configuration class BeanDefinitions; * any candidates are then enhanced by a &#123;@link ConfigurationClassEnhancer&#125;. * Candidate status is determined by BeanDefinition attribute metadata. * @see ConfigurationClassEnhancer */ public void enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) &#123; Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = new LinkedHashMap&lt;String, AbstractBeanDefinition&gt;(); for (String beanName : beanFactory.getBeanDefinitionNames()) &#123; BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName); if (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) &#123; if (!(beanDef instanceof AbstractBeanDefinition)) &#123; throw new BeanDefinitionStoreException("Cannot enhance @Configuration bean definition '" + beanName + "' since it is not stored in an AbstractBeanDefinition subclass"); &#125; ... configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef); &#125; &#125; if (configBeanDefs.isEmpty()) &#123; // nothing to enhance -&gt; return immediately return; &#125; ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer(); for (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) &#123; AbstractBeanDefinition beanDef = entry.getValue(); // If a @Configuration class gets proxied, always proxy the target class beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE); try &#123; // Set enhanced subclass of the user-specified bean class Class&lt;?&gt; configClass = beanDef.resolveBeanClass(this.beanClassLoader); Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, this.beanClassLoader); if (configClass != enhancedClass) &#123; ... beanDef.setBeanClass(enhancedClass); &#125; &#125; ... &#125; &#125; &#125; ...&#125; 执行期间,最重要的组件莫过于ConfigurationClassParser,它将已注册的Spring BeanDefinition进行注解元信息解析,其中两个parse重载方法分别采用CGLIB实现的AnnotationMetadataReadingVisitor和Java反射实现的 StandardAnnotationMetadata。 ConfigurationClassParser 1234567891011121314151617181920212223242526272829303132333435363738class ConfigurationClassParser&#123; protected void processConfigurationClass(ConfigurationClass configClass) throws IOException &#123; if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123; return; &#125; ConfigurationClass existingClass = this.configurationClasses.get(configClass); if (existingClass != null) &#123; if (configClass.isImported()) &#123; if (existingClass.isImported()) &#123; existingClass.mergeImportedBy(configClass); &#125; // Otherwise ignore new imported config class; existing non-imported class overrides it. return; &#125; else &#123; // Explicit bean definition found, probably replacing an import. // Let's remove the old one and go with the new one. this.configurationClasses.remove(configClass); for (Iterator&lt;ConfigurationClass&gt; it = this.knownSuperclasses.values().iterator(); it.hasNext();) &#123; if (configClass.equals(it.next())) &#123; it.remove(); &#125; &#125; &#125; &#125; // Recursively process the configuration class and its superclass hierarchy. SourceClass sourceClass = asSourceClass(configClass); do &#123; sourceClass = doProcessConfigurationClass(configClass, sourceClass); &#125; while (sourceClass != null); ... &#125;&#125; doProcessConfigurationClass处理以下问题: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException &#123; // Recursively process any member (nested) classes first processMemberClasses(configClass, sourceClass); // Process any @PropertySource annotations for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable( sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) &#123; if (this.environment instanceof ConfigurableEnvironment) &#123; processPropertySource(propertySource); &#125; else &#123; logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() + "]. Reason: Environment must implement ConfigurableEnvironment"); &#125; &#125; // Process any @ComponentScan annotations Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable( sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class); if (!componentScans.isEmpty() &amp;&amp; !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123; for (AnnotationAttributes componentScan : componentScans) &#123; // The config class is annotated with @ComponentScan -&gt; perform the scan immediately Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName()); // Check the set of scanned definitions for any further config classes and parse recursively if needed for (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123; if (ConfigurationClassUtils.checkConfigurationClassCandidate( holder.getBeanDefinition(), this.metadataReaderFactory)) &#123; parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName()); &#125; &#125; &#125; &#125; // Process any @Import annotations processImports(configClass, sourceClass, getImports(sourceClass), true); // Process any @ImportResource annotations if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) &#123; AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class); String[] resources = importResource.getStringArray("locations"); Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass("reader"); for (String resource : resources) &#123; String resolvedResource = this.environment.resolveRequiredPlaceholders(resource); configClass.addImportedResource(resolvedResource, readerClass); &#125; &#125; // Process individual @Bean methods Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass); for (MethodMetadata methodMetadata : beanMethods) &#123; configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass)); &#125; // Process default methods on interfaces processInterfaces(configClass, sourceClass); // Process superclass, if any if (sourceClass.getMetadata().hasSuperClass()) &#123; String superclass = sourceClass.getMetadata().getSuperClassName(); if (!superclass.startsWith("java") &amp;&amp; !this.knownSuperclasses.containsKey(superclass)) &#123; this.knownSuperclasses.put(superclass, configClass); // Superclass found, return its annotation metadata and recurse return sourceClass.getSuperClass(); &#125; &#125; // No superclass -&gt; processing is complete return null; &#125; 处理@PropertySource注解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081private void processPropertySource(AnnotationAttributes propertySource) throws IOException &#123; String name = propertySource.getString("name"); if (!StringUtils.hasLength(name)) &#123; name = null; &#125; String encoding = propertySource.getString("encoding"); if (!StringUtils.hasLength(encoding)) &#123; encoding = null; &#125; String[] locations = propertySource.getStringArray("value"); Assert.isTrue(locations.length &gt; 0, "At least one @PropertySource(value) location is required"); boolean ignoreResourceNotFound = propertySource.getBoolean("ignoreResourceNotFound"); Class&lt;? extends PropertySourceFactory&gt; factoryClass = propertySource.getClass("factory"); PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ? DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass)); for (String location : locations) &#123; try &#123; String resolvedLocation = this.environment.resolveRequiredPlaceholders(location); Resource resource = this.resourceLoader.getResource(resolvedLocation); addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding))); &#125; catch (IllegalArgumentException ex) &#123; // Placeholders not resolvable if (ignoreResourceNotFound) &#123; if (logger.isInfoEnabled()) &#123; logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage()); &#125; &#125; else &#123; throw ex; &#125; &#125; catch (IOException ex) &#123; // Resource not found when trying to open it if (ignoreResourceNotFound &amp;&amp; (ex instanceof FileNotFoundException || ex instanceof UnknownHostException)) &#123; if (logger.isInfoEnabled()) &#123; logger.info("Properties location [" + location + "] not resolvable: " + ex.getMessage()); &#125; &#125; else &#123; throw ex; &#125; &#125; &#125; &#125; private void addPropertySource(PropertySource&lt;?&gt; propertySource) &#123; String name = propertySource.getName(); MutablePropertySources propertySources = ((ConfigurableEnvironment) this.environment).getPropertySources(); if (propertySources.contains(name) &amp;&amp; this.propertySourceNames.contains(name)) &#123; // We've already added a version, we need to extend it PropertySource&lt;?&gt; existing = propertySources.get(name); PropertySource&lt;?&gt; newSource = (propertySource instanceof ResourcePropertySource ? ((ResourcePropertySource) propertySource).withResourceName() : propertySource); if (existing instanceof CompositePropertySource) &#123; ((CompositePropertySource) existing).addFirstPropertySource(newSource); &#125; else &#123; if (existing instanceof ResourcePropertySource) &#123; existing = ((ResourcePropertySource) existing).withResourceName(); &#125; CompositePropertySource composite = new CompositePropertySource(name); composite.addPropertySource(newSource); composite.addPropertySource(existing); propertySources.replace(name, composite); &#125; &#125; else &#123; if (this.propertySourceNames.isEmpty()) &#123; propertySources.addLast(propertySource); &#125; else &#123; String firstProcessed = this.propertySourceNames.get(this.propertySourceNames.size() - 1); propertySources.addBefore(firstProcessed, propertySource); &#125; &#125; this.propertySourceNames.add(name); &#125; 处理@ComponentScan注解 123456789101112131415161718// Process any @ComponentScan annotationsSet&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable( sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);if (!componentScans.isEmpty() &amp;&amp; !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123; for (AnnotationAttributes componentScan : componentScans) &#123; // The config class is annotated with @ComponentScan -&gt; perform the scan immediately Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName()); // Check the set of scanned definitions for any further config classes and parse recursively if needed for (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123; if (ConfigurationClassUtils.checkConfigurationClassCandidate( holder.getBeanDefinition(), this.metadataReaderFactory)) &#123; parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName()); &#125; &#125; &#125;&#125; 处理@Import注解,@ImportResource,@Bean注解。其中@Import处理方法processImports与processConfigurationClass(ConfigurationClass configClass)形成递归调用。实现多层次@Import元标注的ConfigurationClass解析。解析后的ConfigurationClass将会被ConfigurationClassBeanDefinitionReader再次注册为SpringBean。ConfigurationClassBeanDefinitionReader将@Import,@ImportResource,@Bean所关联的Bean定义一并注册了。 (3):ConfigurationClassBeanDefinitionReader:将解析的Configuration Classs注册为Spring Bean。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class ConfigurationClassBeanDefinitionReader&#123; ... public void loadBeanDefinitions(Set&lt;ConfigurationClass&gt; configurationModel) &#123; TrackedConditionEvaluator trackedConditionEvaluator = new TrackedConditionEvaluator(); for (ConfigurationClass configClass : configurationModel) &#123; loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator); &#125; &#125; /** * Read a particular &#123;@link ConfigurationClass&#125;, registering bean definitions * for the class itself and all of its &#123;@link Bean&#125; methods. */ private void loadBeanDefinitionsForConfigurationClass(ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) &#123; ... if (configClass.isImported()) &#123; registerBeanDefinitionForImportedConfigurationClass(configClass); &#125; for (BeanMethod beanMethod : configClass.getBeanMethods()) &#123; loadBeanDefinitionsForBeanMethod(beanMethod); &#125; loadBeanDefinitionsFromImportedResources(configClass.getImportedResources()); loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars()); &#125; /** * Register the &#123;@link Configuration&#125; class itself as a bean definition. */ private void registerBeanDefinitionForImportedConfigurationClass(ConfigurationClass configClass) &#123; ... &#125; /** * Read the given &#123;@link BeanMethod&#125;, registering bean definitions * with the BeanDefinitionRegistry based on its contents. */ private void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) &#123; ... &#125; private void loadBeanDefinitionsFromImportedResources( Map&lt;String, Class&lt;? extends BeanDefinitionReader&gt;&gt; importedResources) &#123; ... &#125; private void loadBeanDefinitionsFromRegistrars(Map&lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&gt; registrars) &#123; for (Map.Entry&lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&gt; entry : registrars.entrySet()) &#123; entry.getKey().registerBeanDefinitions(entry.getValue(), this.registry); &#125; &#125;&#125; (4):ConfigurationClassUtils:判定Configuration Class的级别 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596abstract class ConfigurationClassUtils &#123; private static final String CONFIGURATION_CLASS_FULL = "full"; private static final String CONFIGURATION_CLASS_LITE = "lite"; private static final String CONFIGURATION_CLASS_ATTRIBUTE = Conventions.getQualifiedAttributeName(ConfigurationClassPostProcessor.class, "configurationClass"); private static final String ORDER_ATTRIBUTE = Conventions.getQualifiedAttributeName(ConfigurationClassPostProcessor.class, "order"); private static final Log logger = LogFactory.getLog(ConfigurationClassUtils.class); private static final Set&lt;String&gt; candidateIndicators = new HashSet&lt;String&gt;(4); static &#123; candidateIndicators.add(Component.class.getName()); candidateIndicators.add(ComponentScan.class.getName()); candidateIndicators.add(Import.class.getName()); candidateIndicators.add(ImportResource.class.getName()); &#125; ... /** * Check the given metadata for a configuration class candidate * (or nested component class declared within a configuration/component class). * @param metadata the metadata of the annotated class * @return &#123;@code true&#125; if the given class is to be registered as a * reflection-detected bean definition; &#123;@code false&#125; otherwise */ public static boolean isConfigurationCandidate(AnnotationMetadata metadata) &#123; return (isFullConfigurationCandidate(metadata) || isLiteConfigurationCandidate(metadata)); &#125; /** * Check the given metadata for a full configuration class candidate * (i.e. a class annotated with &#123;@code @Configuration&#125;). * @param metadata the metadata of the annotated class * @return &#123;@code true&#125; if the given class is to be processed as a full * configuration class, including cross-method call interception */ public static boolean isFullConfigurationCandidate(AnnotationMetadata metadata) &#123; return metadata.isAnnotated(Configuration.class.getName()); &#125; /** * Check the given metadata for a lite configuration class candidate * (e.g. a class annotated with &#123;@code @Component&#125; or just having * &#123;@code @Import&#125; declarations or &#123;@code @Bean methods&#125;). * @param metadata the metadata of the annotated class * @return &#123;@code true&#125; if the given class is to be processed as a lite * configuration class, just registering it and scanning it for &#123;@code @Bean&#125; methods */ public static boolean isLiteConfigurationCandidate(AnnotationMetadata metadata) &#123; // Do not consider an interface or an annotation... if (metadata.isInterface()) &#123; return false; &#125; // Any of the typical annotations found? for (String indicator : candidateIndicators) &#123; if (metadata.isAnnotated(indicator)) &#123; return true; &#125; &#125; // Finally, let's look for @Bean methods... try &#123; return metadata.hasAnnotatedMethods(Bean.class.getName()); &#125; ... &#125; /** * Determine whether the given bean definition indicates a full &#123;@code @Configuration&#125; * class, through checking &#123;@link #checkConfigurationClassCandidate&#125;'s metadata marker. */ public static boolean isFullConfigurationClass(BeanDefinition beanDef) &#123; return CONFIGURATION_CLASS_FULL.equals(beanDef.getAttribute(CONFIGURATION_CLASS_ATTRIBUTE)); &#125; /** * Determine whether the given bean definition indicates a lite &#123;@code @Configuration&#125; * class, through checking &#123;@link #checkConfigurationClassCandidate&#125;'s metadata marker. */ public static boolean isLiteConfigurationClass(BeanDefinition beanDef) &#123; return CONFIGURATION_CLASS_LITE.equals(beanDef.getAttribute(CONFIGURATION_CLASS_ATTRIBUTE)); &#125; ...&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Enable模块驱动</tag>
        <tag>ImportSelector</tag>
        <tag>ImportBeanDefinitionRegistrar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring事件监听机制]]></title>
    <url>%2F2019%2F08%2F05%2FSpring%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Spring事件监听机制1:Spring事件监听基础 Spring事件/监听机制属于事件/监听器模式,即观察者模式扩展。在Java中,事件源必须是java.util. EventObject对象。事件监听器必须是java.util.EventListener。通常API接口需要提供 监听接口的适配器实现,提供监听空实现的适配方法。当Java8 interface的default方法特性 能够解决以上问题。 ​ Spring事件监听器,仅抽象出单一方法onApplicationEvent(ApplicationEvent),用于监听Spring事件 ApplicationEvent。 ​ 在Spring3.0之前的ApplicationListener基本无解,必须监听所有的ApplicationEvent,如果要过滤 不同类型的事件,需要借助instanceof方式进行筛选。从Spring3.0开始,支持泛型监听。 12345678910@FunctionalInterfacepublic interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener &#123; /** * Handle an application event. * @param event the event to respond to */ void onApplicationEvent(E event);&#125; 由于泛型参数的限制,泛型化的ApplicationListener无法监听不同类型的ApplicationEvent。为此,Spring3.0 引入了SmartApplicationListener接口: 123456789101112131415public interface SmartApplicationListener extends ApplicationListener&lt;ApplicationEvent&gt;, Ordered &#123; /** * Determine whether this listener actually supports the given event type. * @param eventType the event type (never &#123;@code null&#125;) */ boolean supportsEventType(Class&lt;? extends ApplicationEvent&gt; eventType); /** * Determine whether this listener actually supports the given source type. * @param sourceType the source type, or &#123;@code null&#125; if no source */ boolean supportsSourceType(@Nullable Class&lt;?&gt; sourceType);&#125; 例如SpringBoot外部化应用配置文件application.properties的事件监听器ConfigFileApplicationListener 实现,监听了ApplicationEnvironmentPreparedEvent和ApplicationPreparedEvent两个事件. 12345@Overridepublic boolean supportsEventType(Class&lt;? extends ApplicationEvent&gt; eventType) &#123; return ApplicationEnvironmentPreparedEvent.class.isAssignableFrom(eventType) || ApplicationPreparedEvent.class.isAssignableFrom(eventType);&#125; 2:Spring事件发布 ApplicationEventMulticaster主要承担两种职责,一是关联ApplicationListener,二是广播 ApplicationEvent。 1):ApplicationEventMulticaster注册ApplicationListener AbstractApplicationEventMulticaster将ApplicationListener做了分类,再结合retrieverCache的定义, 它是一个ListenerCacheKey为key,ListenerRetriever为value的Map缓存。同时ListenerCacheKey 关联了事件类型和数据源类型。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Cache key for ListenerRetrievers, based on event type and source type. */private static final class ListenerCacheKey implements Comparable&lt;ListenerCacheKey&gt; &#123; private final ResolvableType eventType; @Nullable private final Class&lt;?&gt; sourceType; public ListenerCacheKey(ResolvableType eventType, @Nullable Class&lt;?&gt; sourceType) &#123; Assert.notNull(eventType, "Event type must not be null"); this.eventType = eventType; this.sourceType = sourceType; &#125; @Override public boolean equals(Object other) &#123; if (this == other) &#123; return true; &#125; ListenerCacheKey otherKey = (ListenerCacheKey) other; return (this.eventType.equals(otherKey.eventType) &amp;&amp; ObjectUtils.nullSafeEquals(this.sourceType, otherKey.sourceType)); &#125; @Override public int hashCode() &#123; return this.eventType.hashCode() * 29 + ObjectUtils.nullSafeHashCode(this.sourceType); &#125; @Override public String toString() &#123; return "ListenerCacheKey [eventType = " + this.eventType + ", sourceType = " + this.sourceType + "]"; &#125; @Override public int compareTo(ListenerCacheKey other) &#123; int result = this.eventType.toString().compareTo(other.eventType.toString()); if (result == 0) &#123; if (this.sourceType == null) &#123; return (other.sourceType == null ? 0 : -1); &#125; if (other.sourceType == null) &#123; return 1; &#125; result = this.sourceType.getName().compareTo(other.sourceType.getName()); &#125; return result; &#125;&#125; 实际上,AbstractApplicationEventMulticaster将ApplicationEvent和ApplicationListener集合进行关联。因此 AbstractApplicationEventMulticaster#getApplicationListeners()返回ApplicationEvent关联ApplicationListener集合。 2)ApplicationEventMulticaster广播事件 ​ 广播事件在SimpleApplicationEventMulticaster中实现,也是Spring内建唯一实现。 12345678910111213@Overridepublic void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) &#123; ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event)); for (final ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123; Executor executor = getTaskExecutor(); if (executor != null) &#123; executor.execute(() -&gt; invokeListener(listener, event)); &#125; else &#123; invokeListener(listener, event); &#125; &#125;&#125; //该方法从Spring4.2开始引入。尽管ResolvableType是从Spring4.0开始出现,它是Spring简化Java反射 API而提供的组件,能够轻松的获取泛型类型等。 3)ApplicationEventMulticaster和ApplicationContext之间关系 开发人员可使用ApplicationEventPublisher发布ApplicationEvent。 ApplicationEventPublisher接口被Spring上下文接口ApplicationContext扩展,因此,无论哪种Spring应用 上下文实例,均具备发布ApplicationEvent的能力。]]></content>
      <categories>
        <category>Spring,设计模式</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring事件监听机制</tag>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义SpringBoot自动装配]]></title>
    <url>%2F2019%2F08%2F05%2F%E8%87%AA%E5%AE%9A%E4%B9%89SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%2F</url>
    <content type="text"><![CDATA[自定义SpringBoot自动装配1：自动装配Class命名规则AutoConfiguration，其中\代表功能或者模块名。 2：自动装配package命名规则123456$&#123;root-package&#125; |- autoconfigure |- $&#123;module-package&#125; |- *AutoConfiguration |- $&#123;sub-module-package&#125; |- ... 其中${root_package}是根模块，如com.ley。 ${module_package}是功能模块，如web.servlet。 而${sub_module_package}是子模块，如error。 3：自定义SpringBootStarter官方建议将自动装配模块代码存放到autoconfigure模块中，starter模块依赖该模块，并且附加其他需要依赖。当然也可以将autoconfigure和stater合并到单模块。 (1)：Spring Boot Starter命名规则 开发人员将Starter发布为${module}-spring-boot-autoconfigure和${module}-spring-boot-starter两个jar文件。 开发人员不要使用server,management,spring等作为配置Key命名空间。尽量采用独立的命名空间。 (2)：实现Spring Boot Starter (a)：新建Spring Boot Starter工程—–formatter-spring-boot-autoconfigure。 构建一个Maven功能，pom.xml如下。 123456789101112131415161718192021&lt;dependencies&gt; &lt;!-- Compile dependencies --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- @ConfigurationProperties annotation processing (metadata for IDEs) --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; (b)：实现DefaultFormatter自动装配—-FormatterAutoConfiguration (c)：META-INF/spring.factories资源声明FormatterAutoConfiguration 123# FormatterAutoConfiguration 自动装配声明org.springframework.boot.autoconfigure.EnableAutoConfiguration=\ com.ley.formatter.autoconfigure.FormatterAutoConfiguration (d)：构建Spring Boot Starter—-formatter-spring-boot-starter 1234567891011121314151617181920&lt;dependencies&gt; &lt;!--formatter spring boot autoconfigure--&gt; &lt;dependency&gt; &lt;groupId&gt;com.gitee.ley1996&lt;/groupId&gt; &lt;artifactId&gt;formatter-spring-boot-autoconfigure&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring boot 基础依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;!-- 说明formatter-spring-boot-starter不应该 传递spring-boot-starter依赖。 --&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在开发Spring Boot Starter的过程中，请保持spring-boot-starter等相关依赖声明为 、&lt;optional&gt;true&lt;/optional&gt;。 4：Spring Boot 提交化自动装配条件注解总结： Class Conditions Bean Conditions Property Conditions Resource Conditions Web Application Conditions SpEL Expression Conditions 4.1：Class条件注解 ConditionalOnClass：当指定类存在时，在Sprign Boot 1.0~2.0稳定。 ConditionalOnMissingClass：当指定类不存在时，从Spring Boot 1.4开始才保持稳定。推荐使用value()替代。当指定类不存在时，并不需要该类显示地依赖到当前工程或者Starter。 4.2：Bean条件注解 ConditionalOnBean：匹配BeanFactory中Bean的类型和名称。 其中Bean查找策略为SearchStrategy，包含当前，父类及所有。 ConditionalOnMissingBean：当指定Bean不存在时。从Spring Boot 1.2.5开始，增加ignored()和ignoredType()两个方法，用于忽略或者排除指定Bean。 4.3：属性条件注解 ConditionalOnProperty为属性条件注解，其属性来源于Spring Environment。其中Java系统属性(systemProperties)和环境变量(systemEnvironment)是典型的Spring Environment属性来源。在SpringBoot环境中，application.properties或者application.yml也是其中来源之一。 当自动装配组件需要默认装配时，可以使用matchIfMissing()属性值调整为true。 4.4：Resource条件注解 ConditionOnResource为Resource条件注解。其中resources()指定只有资源必须存在方可成立。 4.5：Web应用条件注解。 ConditionalOnWebApplication：判断当前应用是Web类型。 ConditionalOnNotWebApplication：当前应用不是Web类型。 4.6：Spring表达式条件注解 ConditionalOnExpression，其中value()用于评估表达式的真伪。当表达多组配置属性时，可以使用@ConditionalOnExpression。例如${formatter.enabled:true} 总结使用Spring Boot提供的条件注解,以及自动装配顺序注解,实现自己的配置类,然后在META-INF/ spring.factories中声明该类即可。如下所示： 123# FormatterAutoConfiguration 自动装配声明org.springframework.boot.autoconfigure.EnableAutoConfiguration=\ com.ley.formatter.autoconfigure.FormatterAutoConfiguration]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>SpringBoot自动装配</tag>
        <tag>条件化注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring整合Mybatis原理探索]]></title>
    <url>%2F2019%2F08%2F05%2FSpring%E6%95%B4%E5%90%88Mybatis%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[Spring整合Mybatis原理探索@MapperScan注解实现 1:MapperScannerRegistrar类 实现ImportBeanDefinitionRegistrar接口,注册默认@Mapper注解标注的接口。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; //获取@MapperScan注解上属性 AnnotationAttributes mapperScanAttrs = AnnotationAttributes .fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName())); if (mapperScanAttrs != null) &#123; registerBeanDefinitions(mapperScanAttrs, registry); &#125; &#125; void registerBeanDefinitions(AnnotationAttributes annoAttrs, BeanDefinitionRegistry registry) &#123;//扫描指定包下包含默认Mybatis注解@Mapper的接口,并注册到Spring Bean工厂中 ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry); // this check is needed in Spring 3.1 Optional.ofNullable(resourceLoader).ifPresent(scanner::setResourceLoader); Class&lt;? extends Annotation&gt; annotationClass = annoAttrs.getClass("annotationClass"); if (!Annotation.class.equals(annotationClass)) &#123; scanner.setAnnotationClass(annotationClass); &#125; Class&lt;?&gt; markerInterface = annoAttrs.getClass("markerInterface"); if (!Class.class.equals(markerInterface)) &#123; scanner.setMarkerInterface(markerInterface); &#125; Class&lt;? extends BeanNameGenerator&gt; generatorClass = annoAttrs.getClass("nameGenerator"); if (!BeanNameGenerator.class.equals(generatorClass)) &#123; scanner.setBeanNameGenerator(BeanUtils.instantiateClass(generatorClass)); &#125; Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass = annoAttrs.getClass("factoryBean"); if (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) &#123; scanner.setMapperFactoryBean(BeanUtils.instantiateClass(mapperFactoryBeanClass)); &#125; scanner.setSqlSessionTemplateBeanName(annoAttrs.getString("sqlSessionTemplateRef")); scanner.setSqlSessionFactoryBeanName(annoAttrs.getString("sqlSessionFactoryRef")); List&lt;String&gt; basePackages = new ArrayList&lt;&gt;(); basePackages.addAll( Arrays.stream(annoAttrs.getStringArray("value")) .filter(StringUtils::hasText) .collect(Collectors.toList())); basePackages.addAll( Arrays.stream(annoAttrs.getStringArray("basePackages")) .filter(StringUtils::hasText) .collect(Collectors.toList())); basePackages.addAll( Arrays.stream(annoAttrs.getClassArray("basePackageClasses")) .map(ClassUtils::getPackageName) .collect(Collectors.toList())); scanner.registerFilters(); scanner.doScan(StringUtils.toStringArray(basePackages)); &#125; 2:ClassPathMapperScanner 继承了ClassPathBeanDefinitionScanner类,该类扫描指定包下的模式注解,并注册到Spring Bean工厂中。 实现主要方法研究 注册BeanDefinition过滤接口 12345678910111213141516171819202122232425262728293031323334353637/** * Configures parent scanner to search for the right interfaces. It can search * for all interfaces or just for those that extends a markerInterface or/and * those annotated with the annotationClass */public void registerFilters() &#123; boolean acceptAllInterfaces = true; // if specified, use the given annotation and / or marker interface if (this.annotationClass != null) &#123; addIncludeFilter(new AnnotationTypeFilter(this.annotationClass)); acceptAllInterfaces = false; &#125; // override AssignableTypeFilter to ignore matches on the actual marker interface if (this.markerInterface != null) &#123; //由于生成的BeanDefinition为MapperFactoryBean,所以BeanClass不是原来的类名 addIncludeFilter(new AssignableTypeFilter(this.markerInterface) &#123; @Override protected boolean matchClassName(String className) &#123; return false; &#125; &#125;); acceptAllInterfaces = false; &#125; if (acceptAllInterfaces) &#123; // default include filter that accepts all classes addIncludeFilter((metadataReader, metadataReaderFactory) -&gt; true); &#125; // exclude package-info.java addExcludeFilter((metadataReader, metadataReaderFactory) -&gt; &#123; String className = metadataReader.getClassMetadata().getClassName(); return className.endsWith("package-info"); &#125;);&#125; 注册MapperFactoryBean 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private void processBeanDefinitions(Set&lt;BeanDefinitionHolder&gt; beanDefinitions) &#123; GenericBeanDefinition definition; for (BeanDefinitionHolder holder : beanDefinitions) &#123; definition = (GenericBeanDefinition) holder.getBeanDefinition(); String beanClassName = definition.getBeanClassName(); LOGGER.debug(() -&gt; "Creating MapperFactoryBean with name '" + holder.getBeanName() + "' and '" + beanClassName + "' mapperInterface"); // the mapper interface is the original class of the bean // but, the actual class of the bean is MapperFactoryBean //添加要与类型匹配的通用参数值注意：单个通用参数值将只使用一次*，而不是多次匹配。 //MapperFactoryBean是个泛型类,泛型参数是Mybatis的DAO全类限定名 definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); / definition.setBeanClass(this.mapperFactoryBean.getClass()); definition.getPropertyValues().add("addToConfig", this.addToConfig); boolean explicitFactoryUsed = false; if (StringUtils.hasText(this.sqlSessionFactoryBeanName)) &#123; //如果配置了SqlSesiionFactoryBean,获取运行期间的SqlSessionFactory Bean引用 definition.getPropertyValues().add("sqlSessionFactory", new RuntimeBeanReference(this.sqlSessionFactoryBeanName)); explicitFactoryUsed = true; &#125; else if (this.sqlSessionFactory != null) &#123; definition.getPropertyValues().add("sqlSessionFactory", this.sqlSessionFactory); explicitFactoryUsed = true; &#125; if (StringUtils.hasText(this.sqlSessionTemplateBeanName)) &#123; if (explicitFactoryUsed) &#123; LOGGER.warn(() -&gt; "Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored."); &#125; definition.getPropertyValues().add("sqlSessionTemplate", new RuntimeBeanReference(this.sqlSessionTemplateBeanName)); explicitFactoryUsed = true; &#125; else if (this.sqlSessionTemplate != null) &#123; if (explicitFactoryUsed) &#123; LOGGER.warn(() -&gt; "Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored."); &#125; definition.getPropertyValues().add("sqlSessionTemplate", this.sqlSessionTemplate); explicitFactoryUsed = true; &#125; if (!explicitFactoryUsed) &#123; LOGGER.debug(() -&gt; "Enabling autowire by type for MapperFactoryBean with name '" + holder.getBeanName() + "'."); definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE); &#125; &#125; &#125; 设置候选BeanDefinition条件 12345//判断候选的BeanDefinition是否是接口和独立类@Overrideprotected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) &#123; return beanDefinition.getMetadata().isInterface() &amp;&amp; beanDefinition.getMetadata().isIndependent();&#125; 相关类 ClassPathMapperScanner:扫描Bean并注册Bean工厂中 MapperFactoryBean:Mapper Bean工程 MapperScannerRegistrar:提供解析MapperScan注解和批量注册Bean SqlSessionDaoSupport:提供SqlSession 总结实现批量注册Bean时,提供扫描包注解+标注候选注解+实现ImportBeanDefinitionRegistrar接口+ 继承ClassPathBeanDefinitionScanner+实现FactoryBean接口。]]></content>
      <categories>
        <category>Spring,Mybatis</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Mybatis</tag>
        <tag>MapperScan注解实现原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Environment抽象]]></title>
    <url>%2F2019%2F08%2F05%2FSpring%20Environment%E6%8A%BD%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Spring Environment抽象1:概述Spring中Environment是Spring3.1版本引入的,是Spring核心框架定义的一个接口,用来表示整个应用运行时环境。该环境模型只接受两种应用环境profiles(配置文件)和properties(属性)。与属性访问相关的方法通过PropertyResolver超接口访问。 建模关键 profile(配置文件) 一个profile是一组Bean定义的逻辑分组,只有当配置文件被激活的时候,才会将对应逻辑上组织的Bean定义注册到容器中。 Bean添加到profile可以通过XML或者Annotation方式。 Environment对象对于profile机制所扮演的角色是用来指定哪些profile是当前活跃或者缺省活跃。可以通过getActiveProfiles或者getDefaultProfiles获取。 proprety(属性) 一个应用属性有很多来源:属性文件(properties files),JVM系统属性(getSystemProperties),系统变量属性(getSystemEnvironment),JNDI,servlet上下文参数,临时属性对象,Maps等。 Environment对于property所扮演的角色提供给使用一个方便服务接口用于 配置属性源 从属性源解析和获取属性 容器上下文(ApplicationContext)所获取的bean,如果想直接使用Environment对象访问profile状态或者获取属性。有以下方式。 EnvironmentAware接口 @Inject 或者 @Autowired注入一个 Environment对象 绝大多数情况,bean都不需要直接访问Environment对象,而是通过类似@Value注解方式把属性值注入进来。 这个接口定义在包 org.springframework.core.env 中。下面是Spring围绕环境抽象Environment各个接口/类之间的继承关系: 2:Environment接口相关类介绍 接口|类 介绍 PropertyResolver 接口,抽象对属性源的访问比如是否包含某个属性，读取属性，解析占位符，将读取到的属性转换成指定类型 (提供读操作)默认实现PropertySourcesPropertyResolver Environment 接口,继承自PropertyResolver,对环境属性访问和default/active profile访问的抽象 。 ConfigurablePropertyResolver 接口，为PropertyResolver接口抽象的属性源访问做了配置方面的增强。(提供写操作。) ConfigurableEnvironment 接口，在所继承的接口之上增加了设置defaut/active profile的能力，增加/删除环境对象中属性源的能力 ConfigurableWebEnvironment 接口，向接口ConfigurableEnvironment增强了根据Servlet上下文/配置初始化属性源的能力 AbstractEnvironment Environment抽象基类，实现了ConfigurableEnvironment StandardEnvironment 实现类,针对标准Spring应用(非Web应用)环境, 在AbstractEnvironment基础上提供了属性源systemEnvironment(来自System.getenv())和systemProperties(来自System.getProperties()) StandardServletEnvironment 实现类,针对标准Spring Servlet Web应用的环境， 增加了servletContextInitParams/servletConfigInitParams/jndiProperties 3:外部化配置抽象相关类 接口|类 介绍 PropertySource 用来抽象属性键值对(外部化配置,即属性源)配置基类。例如Map,Properties,ServletConfig,ServletContext PropertySources 对PropertySource抽象属性键值对外部化配置提供集合操作。 MutablePropertySources PropertySources默认实现。 MapPropertySource Map对象中读取属性键值对 PropertiesPropertySource Properties对象中读取属性键值对 ResourcePropertySource Resource对象读取中读取属性键值对。只支持.xml和.properties文件。底层实现使用了工具类PropertiesLoaderUtils。 CompositePropertySource 聚合一组PropertySource。 Web环境实现类和JNDI实现类和随机数实现类 ServletConfigPropertySource,ServletContextPropertySource, JndiPropertySource,RandomValuePropertySource 命令行参数实现类 CommandLinePropertySource 4:混淆定义 上下文:用来处理分层传递抽象,代表着应用。 环境:当前上下文运行环境,存储各种全局变量。比如JDK信息,内存信息等等。 5:核心API PropertySource:属性源。key-value属性对抽象 PropertyResolver:属性解析器。用于解析相应key的value Profile:配置。只有激活的配置profile的组件/配置才会注册到Spring容器,类似于maven中profile。 Environment:环境，本身也是个属性解析器PropertyResolver。 6:属性解析器相关类详细介绍PropertySourcesPropertyResolver该类是Spring内建提供的PropertyResolver唯一实现类。环境抽象Environment属性解析委托给该类。包括对属性类型之间必要转换。Converter和ConverterService。实际的占位符解析委托给PropertyPlaceholderHelper。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class PropertySourcesPropertyResolver extends AbstractPropertyResolver &#123; ... @Nullable private final PropertySources propertySources; //内部持有一组PropertySource // 由此可以看出propertySources的顺序很重要~~~ // 并且还能处理占位符~~~~~ resolveNestedPlaceholders支持内嵌、嵌套占位符 @Nullable protected &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetValueType, boolean resolveNestedPlaceholders) &#123; if (this.propertySources != null) &#123; for (PropertySource&lt;?&gt; propertySource : this.propertySources) &#123; Object value = propertySource.getProperty(key); if (value != null) &#123; if (resolveNestedPlaceholders &amp;&amp; value instanceof String) &#123; value = resolveNestedPlaceholders((String) value); &#125; logKeyFound(key, propertySource, value); return convertValueIfNecessary(value, targetValueType); &#125; &#125; &#125; return null; &#125; ...&#125;public abstract class AbstractPropertyResolver implements ConfigurablePropertyResolver &#123; ... @Nullable private volatile ConfigurableConversionService conversionService; @Nullable private PropertyPlaceholderHelper nonStrictHelper; @Nullable private PropertyPlaceholderHelper strictHelper; private boolean ignoreUnresolvableNestedPlaceholders = false; private String placeholderPrefix = SystemPropertyUtils.PLACEHOLDER_PREFIX; private String placeholderSuffix = SystemPropertyUtils.PLACEHOLDER_SUFFIX; @Nullable private String valueSeparator = SystemPropertyUtils.VALUE_SEPARATOR; private final Set&lt;String&gt; requiredProperties = new LinkedHashSet&lt;&gt;(); ...&#125; 7:应用环境抽象EnvironmentEnvironment接口:环境的读操作 1234567891011121314151617181920212223242526272829303132333435363738394041public interface Environment extends PropertyResolver &#123; /** * Return the set of profiles explicitly made active for this environment. Profiles * are used for creating logical groupings of bean definitions to be registered * conditionally, for example based on deployment environment. Profiles can be * activated by setting &#123;@linkplain AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME * "spring.profiles.active"&#125; as a system property or by calling * &#123;@link ConfigurableEnvironment#setActiveProfiles(String...)&#125;. * &lt;p&gt;If no profiles have explicitly been specified as active, then any * &#123;@linkplain #getDefaultProfiles() default profiles&#125; will automatically be activated. * @see #getDefaultProfiles * @see ConfigurableEnvironment#setActiveProfiles * @see AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME */ String[] getActiveProfiles(); /** * Return the set of profiles to be active by default when no active profiles have * been set explicitly. * @see #getActiveProfiles * @see ConfigurableEnvironment#setDefaultProfiles * @see AbstractEnvironment#DEFAULT_PROFILES_PROPERTY_NAME */ String[] getDefaultProfiles(); /** * Return whether one or more of the given profiles is active or, in the case of no * explicit active profiles, whether one or more of the given profiles is included in * the set of default profiles. If a profile begins with '!' the logic is inverted, * i.e. the method will return true if the given profile is &lt;em&gt;not&lt;/em&gt; active. * For example, &lt;pre class="code"&gt;env.acceptsProfiles("p1", "!p2")&lt;/pre&gt; will * return &#123;@code true&#125; if profile 'p1' is active or 'p2' is not active. * @throws IllegalArgumentException if called with zero arguments * or if any profile is &#123;@code null&#125;, empty or whitespace-only * @see #getActiveProfiles * @see #getDefaultProfiles */ boolean acceptsProfiles(String... profiles);&#125; ConfigurableEnvironment:增加环境的写操作 1234567891011121314151617181920public interface ConfigurableEnvironment extends Environment, ConfigurablePropertyResolver &#123; // 指定该环境下的 profile 集 void setActiveProfiles(String... profiles); // 增加此环境的 profile void addActiveProfile(String profile); // 设置默认的 profile void setDefaultProfiles(String... profiles); // 返回此环境的 PropertySources MutablePropertySources getPropertySources(); // 尝试返回 System.getenv() 的值，若失败则返回通过 System.getenv(string) 的来访问各个键的映射 Map&lt;String, Object&gt; getSystemEnvironment(); // 尝试返回 System.getProperties() 的值，若失败则返回通过 System.getProperties(string) 的来访问各个键的映射 Map&lt;String, Object&gt; getSystemProperties(); void merge(ConfigurableEnvironment parent);&#125; AbstractEnvironment:作为环境接口抽象实现,主要实现了profile相关功能 12345678910111213141516171819202122232425262728293031public abstract class AbstractEnvironment implements ConfigurableEnvironment &#123; public static final String IGNORE_GETENV_PROPERTY_NAME = "spring.getenv.ignore"; // 请参考：ConfigurableEnvironment#setActiveProfiles public static final String ACTIVE_PROFILES_PROPERTY_NAME = "spring.profiles.active"; // 请参考：ConfigurableEnvironment#setDefaultProfiles public static final String DEFAULT_PROFILES_PROPERTY_NAME = "spring.profiles.default"; private final Set&lt;String&gt; defaultProfiles = new LinkedHashSet&lt;&gt;(getReservedDefaultProfiles()); // 默认的profile名称 protected static final String RESERVED_DEFAULT_PROFILE_NAME = "default"; ... protected Set&lt;String&gt; doGetActiveProfiles() &#123; synchronized (this.activeProfiles) &#123; if (this.activeProfiles.isEmpty()) &#123; String profiles = getProperty(ACTIVE_PROFILES_PROPERTY_NAME); if (StringUtils.hasText(profiles)) &#123; setActiveProfiles(StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(profiles))); &#125; &#125; return this.activeProfiles; &#125; &#125; ...&#125; 如果 activeProfiles 为空,则从 Properties 中获取 spring.profiles.active 配置;如果不为空，则调用 setActiveProfiles() 设置 profile,最后返回。 从这里可以知道，API设置的activeProfiles优先级第一，其次才是属性配置。 8:应用环境配置激活(@Profile和ProfileCondition)123456789@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Conditional(ProfileCondition.class)public @interface Profile &#123; String[] value();&#125; 从Spring4.0开始提供Conditional接口,该注解实现原理基于Condition条件接口,Condition条件接口计算结果实现类为ConditionEvaluator,该类是个内部类。 ProfileCondition 1234567891011121314151617181920class ProfileCondition implements Condition &#123; @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; // 因为value值是个数组，所以此处有多个值 用的MultiValueMap MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName()); if (attrs != null) &#123; for (Object value : attrs.get("value")) &#123; // 多个值中，但凡只要有一个acceptsProfiles了，那就返回true~ if (context.getEnvironment().acceptsProfiles(Profiles.of((String[]) value))) &#123; return true; &#125; &#125; return false; &#125; return true; &#125;&#125; @Profile的value可以指定多个值,并且只需要有一个值符合了条件,@Profile标注的方法、类就会生效，就会被加入到容器内。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Environment抽象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git分支的创建与合并]]></title>
    <url>%2F2019%2F08%2F05%2FGit%E5%88%86%E6%94%AF%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[Git分支的创建与合并Git管理项目代码，常见流程。1.开发公司网站。 2.为了开发某个新功能新建一个分支（假如叫develop），并在该分支上进行开发。 3.接到测试组的Bug反馈，返回主分支，新建一个新的分支（bugFix），在该分支上修复Bug，然后与主分支master合并。 4.将分支切换回develop，继续开发新功能，结束后和主分支master合并。 分支的新建与切换假如公司网站项目已经开发了一段时间，并且使用Git提交了几次更新，提交历史如下图所示： 为了开发新的功能，新建分支develop并切换到该分支： 1234$ git branch develop$ git checkout developSwitched to branch 'develop' 也可以使用命令 git checkout -b 直接新建并切换： 12$ git checkout -b developSwitched to a new branch 'develop' 执行完上述命令后，仓库历史大致如下所示： Git新建了一个分支指针develop，然后将HEAD指向develop。 接下来在该分支上开心的开发新功能，比如新建了公司网站About页面，添加了内容然后提交了此次修改： 12345678$ vim About.html$ git add About.html$ git commit -a -m "add About.html page"[develop b462691] add About.html page 1 file changed, 12 insertions(+) create mode 100644 About.html 此时，仓库历史如下图所示： 这时候接到测试组公司网站主页index.html的Bug反馈，于是将分支切换回主分支master，然后新建分支bugFix，修复Bug，并提交该修复： 1234567891011$ git checkout masterSwitched to branch 'master'$ git checkout -b "bugFix"Switched to a new branch 'bugFix'$ vim index.html$ git commit -a -m "update index.html page"[bugFix 11a3074] update index.html page 1 file changed, 2 insertions(+), 2 deletions(-) 此时，仓库历史如下图所示： ` 假如确定Bug修复后，可以切换回master分支，然后将bugFix和master分支合并： 12345$ git merge bugFixUpdating e7ad858..11a3074Fast-forward index.html | 4 ++-- 1 file changed, 2 insertions(+), 2 deletions(-) 合并时出现了“Fast forward”的提示。如果顺着一个分支走下去可以到达另一个分支的话，那么Git在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。 此时bugFix分支已经完成了历史使命，可以使用命令 git branch -d 将其删除： 合并master与bugFix，并删除bugFix分支后，仓库历史如下图所示： Bug修复后，切换回develop分支继续开发新的功能，并且提交： 分支合并和合并master分支与bugFix分支那样，合并master与develop分支过程也差不多： 1234567$ git checkout masterSwitched to branch 'master'$ git merge developMerge made by the 'recursive' strategy. About.html | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) 由于master指向的C4并不是develop指向C5的直接祖先C2，所以合并方式不是“Fast forward”，Git 会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算。 合并master和develop后，仓库历史如下图所示： 解决合并冲突假如在不同分支中都对同一个文件进行了修改，那么合并的时候就会发生冲突。比如在master分支和develop分支上都修改了About.html页面，然后进行分支合并： 1234$ git merge developAuto-merging About.htmlCONFLICT (content): Merge conflict in About.htmlAutomatic merge failed; fix conflicts and then commit the result. Git作了合并，但没有提交，它会停下来等你解决冲突。 可是使用命令 git status 查看哪些文件存在冲突： 123456789101112$ git statusOn branch masterYou have unmerged paths. (fix conflicts and run "git commit") (use "git merge --abort" to abort the merge)Unmerged paths: (use "git add &lt;file&gt;..." to mark resolution) both modified: About.htmlno changes added to commit (use "git add" and/or "git commit -a") 任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出。编辑About.html页面，可看到文件包含类似下面部分的内容： 123456&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD &lt;footer&gt;2016~2017 All Rights Reserved&lt;/footer&gt;======= &lt;footer&gt;&amp;copy;2016~2017&lt;/footer&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; develop 可以看到 ======= 隔开的上半部分，是HEAD（即 master 分支，在运行merge命令时所切换到的分支）中的内容，下半部分是在develop分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。 1&lt;footer&gt;&amp;copy; 2016~2017 All Rights Reserved&lt;/footer&gt; 转载:http://mrbird.cc/Git分支的创建与合并.html]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[@Enable模块驱动]]></title>
    <url>%2F2019%2F08%2F04%2FEnable%E6%A8%A1%E5%9D%97%E9%A9%B1%E5%8A%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[@Component注解派生性原理]]></title>
    <url>%2F2019%2F08%2F04%2FComponent%E6%B3%A8%E8%A7%A3%E6%B4%BE%E7%94%9F%E6%80%A7%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[@Component注解的派生性原理1:模式注解Stereotype Annotation俗称为模式注解。Spring核心部分提供了几种内建的模式注解,如@Component,@Repository,@Service,@Controller,@Configuration等。这些注解均派生于@Component。 由于Java语言规定,Annotation不允许继承,没有类派生子类的特性,因此Spring采用元标注的方式实现注解之间的派生。 2:@Component派生性@Component注解作为Spring容器托管的通用模式组件,任何被@Component标注的组件均为组件扫描的候选对象。 任何论证过程离不开所处的环境,需要开发人员具备一定工程意识,包括软件版本,特性范围,兼容情况等。因此,论证过程从最低版本开始推导,逐步证明不同版本得提升和差异。 3:@Component注解派生性原理当ClassPathBeanDefinitionScanner#doScan(String... basePackages)调用时,它利用basePackages参数迭代执行的findCandidateComponents(String basePackage),每次执行结果都生成候选的BeanDefinition集合,即candidates变量。 123456789101112131415 public class ClassPathBeanDefinitionScanner extends ClassPathScanningCandidateComponentProvider&#123; ... protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123; Assert.notEmpty(basePackages, "At least one base package must be specified"); //获取候选的BeanDefinition集合 Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(); for (String basePackage : basePackages) &#123; Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage); ... &#125; return beanDefinitions; &#125; ...&#125; 而findCandidateComponents(String basePackage)从父类ClassPathScanningCandidateComponentProvider 中继承。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100public class ClassPathScanningCandidateComponentProvider implements EnvironmentCapable, ResourceLoaderAware &#123; ... public Set&lt;BeanDefinition&gt; findCandidateComponents(String basePackage) &#123; Set&lt;BeanDefinition&gt; candidates = new LinkedHashSet&lt;BeanDefinition&gt;(); try &#123; //获取查询的package,并处理占位符情况$&#123;...&#125;,转换为ClassLoader资源(.class)搜索路径 String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + '/' + this.resourcePattern; Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath); ... //resource迭代执行,当资源可读取时,获取该资源的MetadataReader对象 for (Resource resource : resources) &#123; ... if (resource.isReadable()) &#123; try &#123; //包含了类和注解元信息读取方法 MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource); //判断资源是否为候选的组件,通过excludeFilters和includeFilters进行判断 if (isCandidateComponent(metadataReader)) &#123; //基于ASM,支持AnnotatedBeanDefinition接口 ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setResource(resource); sbd.setSource(resource); //判断BeanDefinition是否候选组件 if (isCandidateComponent(sbd)) &#123; ... candidates.add(sbd); &#125; ... &#125; &#125; ... return candidates; &#125; ... /** * Determine whether the given class does not match any exclude filter * and does match at least one include filter. * @param metadataReader the ASM ClassReader for the class * @return whether the class qualifies as a candidate component */ protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException&#123; for (TypeFilter tf : this.excludeFilters) &#123; if (tf.match(metadataReader, this.metadataReaderFactory)) &#123; return false; &#125; &#125; for (TypeFilter tf : this.includeFilters) &#123; if (tf.match(metadataReader, this.metadataReaderFactory)) &#123; return isConditionMatch(metadataReader); &#125; &#125; return false; &#125; /** * Determine whether the given bean definition qualifies as candidate. * &lt;p&gt;The default implementation checks whether the class is not an interface * and not dependent on an enclosing class. * &lt;p&gt;Can be overridden in subclasses. * @param beanDefinition the bean definition to check * @return whether the bean definition qualifies as a candidate component */ protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) &#123; AnnotationMetadata metadata = beanDefinition.getMetadata(); return (metadata.isIndependent() &amp;&amp; (metadata.isConcrete() || (metadata.isAbstract() &amp;&amp; metadata.hasAnnotatedMethods(Lookup.class.getName())))); &#125; /** * Register the default filter for &#123;@link Component @Component&#125;. * &lt;p&gt;This will implicitly register all annotations that have the * &#123;@link Component @Component&#125; meta-annotation including the * &#123;@link Repository @Repository&#125;, &#123;@link Service @Service&#125;, and * &#123;@link Controller @Controller&#125; stereotype annotations. * &lt;p&gt;Also supports Java EE 6's &#123;@link javax.annotation.ManagedBean&#125; and * JSR-330's &#123;@link javax.inject.Named&#125; annotations, if available. * */ @SuppressWarnings("unchecked") protected void registerDefaultFilters() &#123; this.includeFilters.add(new AnnotationTypeFilter(Component.class)); ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader(); try &#123; this.includeFilters.add(new AnnotationTypeFilter( ((Class&lt;? extends Annotation&gt;) ClassUtils.forName("javax.annotation.ManagedBean", cl)), false)); ... &#125; try &#123; this.includeFilters.add(new AnnotationTypeFilter( ((Class&lt;? extends Annotation&gt;) ClassUtils.forName("javax.inject.Named", cl)), false)); ... &#125; &#125;&#125; 默认情况下,ClassPathScanningCandidateComponentProvider构造参数useDefaultFilters为true,并且显示传递给父类构造参数。该方法给属性includeFilters增添了@Component类型AnnotationTypeFilter的TypeFilter。 ClassPathBeanDefinitionScanner默认过滤器引入标注@Component,@Repository,@Service或者@Controller等类。同理,它也能够标注所有@Component的&quot;派生&quot;注解。 @Component注解只包含一个value属性定义，所以其“派生”的注解也只能包含一个vlaue属性定义。 Dubbo实现@Service注解扫描实例: ClassPathBeanDefinitionScanner允许自定义类型过滤规则。因此,Dubbo的@Service没有标注@Component情况下，通过scanner.addIncludeFilter(new AnnotationTypeFilter(Service.class))方式达到识别@Service标注类情况。但是没有使用@Component注解的派生性。 Mybatis实现@Mapper注解扫描实例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class ClassPathMapperScanner extends ClassPathBeanDefinitionScanner&#123; ... public ClassPathMapperScanner(BeanDefinitionRegistry registry) &#123; super(registry, false); &#125; /** * Configures parent scanner to search for the right interfaces. It can search * for all interfaces or just for those that extends a markerInterface or/and * those annotated with the annotationClass */ public void registerFilters() &#123; boolean acceptAllInterfaces = true; // if specified, use the given annotation and / or marker interface if (this.annotationClass != null) &#123; addIncludeFilter(new AnnotationTypeFilter(this.annotationClass)); acceptAllInterfaces = false; &#125; // override AssignableTypeFilter to ignore matches on the actual marker interface if (this.markerInterface != null) &#123; addIncludeFilter(new AssignableTypeFilter(this.markerInterface) &#123; @Override protected boolean matchClassName(String className) &#123; return false; &#125; &#125;); acceptAllInterfaces = false; &#125; if (acceptAllInterfaces) &#123; // default include filter that accepts all classes addIncludeFilter(new TypeFilter() &#123; @Override public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123; return true; &#125; &#125;); &#125; // exclude package-info.java addExcludeFilter(new TypeFilter() &#123; @Override public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123; String className = metadataReader.getClassMetadata().getClassName(); return className.endsWith("package-info"); &#125; &#125;); &#125; /** * &#123;@inheritDoc&#125; */ @Override protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) &#123; return beanDefinition.getMetadata().isInterface() &amp;&amp; beanDefinition.getMetadata().isIndependent(); &#125; private void processBeanDefinitions(Set&lt;BeanDefinitionHolder&gt; beanDefinitions) &#123; GenericBeanDefinition definition; for (BeanDefinitionHolder holder : beanDefinitions) &#123; definition = (GenericBeanDefinition) holder.getBeanDefinition(); ... //复杂对象构建考虑使用FactoryBean接口 // the mapper interface is the original class of the bean // but, the actual class of the bean is MapperFactoryBean //添加泛型参数 definition.getConstructorArgumentValues().addGenericArgumentValue(definition.getBeanClassName()); // issue #59 definition.setBeanClass(this.mapperFactoryBean.getClass()); definition.getPropertyValues().add("addToConfig", this.addToConfig); ... &#125; &#125; ...&#125; 4:思考扩展思考1:利用ClassPathBeanDefinitionScanner类配合includeFilters和excludeFilters定制化批量注册Bean到Spring容器中。常常可以通过注解方式来包含或者排除候选类。 TypeFilter常用实现 AnnotationTypeFilter:注解类型过滤器 AssignableTypeFilter:确定此对象表示的类或者接口是否为给定类或者接口相同。 RegexPatternTypeFilter:判断给定的类名是否符合指定正则表达式。 思考2:复杂对象构建考虑使用FactoryBean实现类。 思考3:如果是读取类和注解信息可以考虑基于ASM或者反射,使用方式往下可以获取。当获取已加载的类信息可以考虑反射(反射大前提是被反射的Class被ClassLoader加载),ASM用于不需要将类路径package下的Class全部加载,Spring应用指定Java package扫描Spring模式注解时,利用的就是基于ASM方式获取类或者注解信息。基于ASM获取会获得更大性能。 思考4:资源读取考虑使用ResourcePatternResolver,这个对象的获取可以通过Spring提供的工具类 ResourcePatternUtils.getResourcePatternResolver(resourceLoader)。在使用的时候,考虑处理 占位符${...}的情况,注意资源是否可读。 5:多层次@Component派生性(1):具体发展过程不再细说,详解请看SpringBoot编程思想这本书。其多层次@Component注解派生性构建在Spring4.x。其核心处理类为AnnotationMetadataReadingVisitor,其采用递归的方式查找元注解。 (2):Spring中,MetadataReader接口唯一实现非公开类SimpleMetadataReader。可以通过SimpleMetadataReaderFactory(ASM字节码操作)和CachingMetadataReaderFactory获取。 其中在SimpleMetadataReader实现上看,ClassMetadataReadingVisitor和AnnotationMetadataReadingVisitor分别是ClassMetadatta和AnnotationMetadata实现类。 由于ClassPathBeanDefinitionScanner在寻找候选的BeanDefinition过程中,将指定basePackage参数下 的*.class资源进行元信息解析,也就是ClassMetadata和AnnotationMetadata对象。 AnnotationMetadataReadingVisitor实现上使用了AnnotationAttributesReadingVisitor，该类主要实现方法是visitEnd()。Spring2.5实现未采用层次递归获取Annotation[],所以仅支持单层次的@Component派生。Spring3.x实现仅两层@Component派生。Spring4.x开始采用递归方式查找元注解。 (3):思考扩展 考虑使用ASM的方式读取类或者注解相关信息。(不需要全部将指定路径下的类加载) MetadataReaderFactory:获取MetadataReader工厂 SimpleMetadataReaderFactory:简单获取MetadataReader工厂实现 ClassReader:基于ASM读取类相关信息,公开类,不建议单独使用。 AnnotationMetadataReadingVisitor:基于ASM读取注解元数据相关信息,不建议单独使用。 MethodMetadataReadingVisitor:基于ASM读取方法相关信息,不建议单独使用。 CachingMetadataReaderFactory:继承SimpleMetadataReaderFactory,增加缓存MetadataReader资源功能。 MetadataReader:获取访问类和注解相关信息。通过MetadataReaderFactory获取。 Resource getResource():获取类文件资源引用 ClassMetadata getClassMetadata():读取基础类的基本元数据 AnnotationMetadata getAnnotationMetadata():读取底层类完整注解元数据,包含注解方法的注解元数据。 考虑使用反射的方式读取类或者注解相关信息(比较费时而且该类必须被ClassLoader加载) StandardClassMetadata:基于反射读取类元数据,可建议单独使用。 StandardAnnotationMetadata:基于反射读取注解元数据,可建议单独使用 StandardMethodMetadata:基于反射读取方法元数据,可建议单独使用 考虑使用Spring内部支持的有用工具类,都是来自于spring-core包中。多使用spring内建API,学习他们的长处。 ClassUtils:类工具类 CollectionUtils:集合工具类 NumberUtils:Number工具类 MimeTypeUtils:媒体类型工具类 IdGenerator:Id生成器 StringUtils:字符串工具类 ResourceUtils:资源工具类 ReflectionUtils:反射工具类 MethodIntrospector:方法自省工具类(EventListenerMethodProcessor#processBean中有使用) PatternMatchUtils:正则资源匹配工具类 ObjectUtils:对象工具类 3:组合注解组合注解指某个注解”元标注”一个或多个其他注解，其目的在于将这些关联的注解行为组合成单个自定义注解。 Spring Framework的类加载通过ASM实现，如ClassReader。相对于ClassLoader体系，Spring ASM更为底层，读取的是类资源，直接操作其中的字节码，获取相关元信息。如MetadataReader接口。 1234567891011121314151617181920212223242526/** * Simple facade for accessing class metadata, * as read by an ASM &#123;@link org.springframework.asm.ClassReader&#125;. * * @author Juergen Hoeller * @since 2.5 */public interface MetadataReader &#123; /** * Return the resource reference for the class file. */ Resource getResource(); /** * Read basic class metadata for the underlying class. */ ClassMetadata getClassMetadata(); /** * Read full annotation metadata for the underlying class, * including metadata for annotated methods. */ AnnotationMetadata getAnnotationMetadata();&#125; AnnotationMetadataReadingVisitor同时实现了ClassMetadata及AnnotationMetadata。因此，元注解的实现集中到AnnotationMetadataReadingVisitor和AnnotationAttributesReadingVisitor之中。 MetadataReader对象通过MetadataReaderFactory对象获取。 12345678910111213141516171819202122232425262728/** * Factory interface for &#123;@link MetadataReader&#125; instances. * Allows for caching a MetadataReader per original resource. * * @author Juergen Hoeller * @since 2.5 * @see SimpleMetadataReaderFactory * @see CachingMetadataReaderFactory */public interface MetadataReaderFactory &#123; /** * Obtain a MetadataReader for the given class name. * @param className the class name (to be resolved to a ".class" file) * @return a holder for the ClassReader instance (never &#123;@code null&#125;) * @throws IOException in case of I/O failure */ MetadataReader getMetadataReader(String className) throws IOException; /** * Obtain a MetadataReader for the given resource. * @param resource the resource (pointing to a ".class" file) * @return a holder for the ClassReader instance (never &#123;@code null&#125;) * @throws IOException in case of I/O failure */ MetadataReader getMetadataReader(Resource resource) throws IOException;&#125; 具体某个注解的元注解信息则通过getMetaAnnotationTypes(String)方法查询。 AnnotationMetadata实现AnnotationMetadataReadingVisitor(ASM实现)，StandardAnnotationMetadata(反射)。 注解元信息抽象:AnnotationMetadata AnnotationMetadataReadingVisitor AnnotationAttributesReadingVisitor(递归查找元注解) 类元信息抽象:ClassMetadata 方法元信息抽象:MethodMetadata 注解属性抽象:AnnotationAttributes 属性环境抽象:Environment 属性文件抽象:PropertySource 元信息读取抽象:MetadataReader 通过MetadataReaderFactory获取 方法内省:MethodIntrospector 1234Map&lt;Method, EventListener&gt; annotatedMethods = null; annotatedMethods = MethodIntrospector.selectMethods(targetType, (MethodIntrospector.MetadataLookup&lt;EventListener&gt;) method -&gt; AnnotatedElementUtils.findMergedAnnotation(method, EventListener.class)); 注解工具类:AnnotationUtils]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring注解属性抽象AnnotationAttributes</tag>
        <tag>模式注解</tag>
        <tag>Component注解派生性原理</tag>
      </tags>
  </entry>
</search>

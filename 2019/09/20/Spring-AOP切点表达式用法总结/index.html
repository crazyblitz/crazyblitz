<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Spring AOP切点表达式用法总结"><meta name="keywords" content="Spring AOP"><meta name="author" content="知源"><meta name="copyright" content="知源"><title>Spring AOP切点表达式用法总结 | 知源博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?628e2ee31ce5c6697d1f5b263b262108";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"QSYLR3XYSH","apiKey":"1b2fe15d5912eb0d3de39fd5574cc460","indexName":"zhiyuan","hits":{"per_page":8},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">知源</div><div class="author-info__description text-center">一个程序员成长之路</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">117</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">88</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">22</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">知源博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Spring AOP切点表达式用法总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-20</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Spring/">Spring</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>切点决定感兴趣的连接点。<strong>Spring框架通常最小粒度支持方法级别执行Spring Beans连接点通知(即作用于方法)，引介通知可以支持到字段级别的。</strong></p>
<ol>
<li><code>execution</code>:用于匹配方法连接点,是Spring AOP使用<strong><code>主要切入点指示符</code></strong>。支持<code>Ant表达式</code>风格。</li>
</ol>
<p><strong><code>execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)</code></strong></p>
<ul>
<li>modifiers-pattern：方法的可见性。如public,protected。</li>
<li>ret-type-pattern：方法的返回值类型。如int,void等。</li>
<li>declaring-type-pattern：方法所在类的全路径名。如com.spring.Aspect。</li>
<li>name-pattern:方法名类型。如buisinessService()。</li>
<li>param-pattern:方法的参数类型。如java.lang.String。</li>
<li>throws-pattern:方法抛出的异常类型,如java.lang.Exception。</li>
</ul>
<p>通配符:</p>
<ul>
<li><p><code>*</code>通配符：表示匹配单个任意单词。</p>
</li>
<li><p><code>..</code>通配符：表示匹配0个或者多个项。<code>主要用于declaring-type-pattern和param-pattern中</code>,如果用于<code>declaring-type-pattern中,则表示匹配当前包及其子包,如果用于param-pattern中</code>,<code>则表示匹配0个或多个参数.</code>  </p>
</li>
<li><blockquote>
<p>常用示例:execution(* com.ley.springboot.aop.service..*.*(..))</p>
</blockquote>
</li>
</ul>
<ol start="2">
<li><strong><code>within</code>:表达式的粒度为类,其参数为全路径的类名(可使用通配符)。只能指定类级别。</strong></li>
</ol>
<p><code>within(declaring-type-pattern)</code>。</p>
<blockquote>
<ul>
<li>within(com.spring.service.BusinessObject)：匹配BusinessObject下所有方法。</li>
<li>within(com.spring.service.*)：匹配com.spring.service下所有类，不包含子包中的类。</li>
<li>within(com.spring.service..*)：匹配com.spring.service及其子包下所有类。</li>
</ul>
</blockquote>
<ol start="3">
<li><strong><code>args</code>:匹配指定参数类型和指定参数数量的方法，无论其类路径或者方法名是什么。<code>args指定的参数必须是全路径的</code>。</strong>个人觉得不是很常用。</li>
</ol>
<p><code>args(param-pattern)</code>。参数表达式可以使用通配符<code>..</code>，不能使用<code>*</code>。</p>
<blockquote>
<p>args(java.lang.String,..,java.lang.Integer)：匹配第一个参数为java.lang.String，最后一个参数为java.lang.Integer，中间参数任意个数和类型。</p>
</blockquote>
<ol start="4">
<li><strong><code>this和target</code></strong></li>
</ol>
<p>this和target表达式<code>都只能指定类或者接口</code>。<code>this</code>表示匹配<code>当前切点表达式所指代方法对象</code>,<code>target</code>匹配</p>
<p><code>表达式指定类型的对象</code>。</p>
<p>Spring中,对<code>this</code>语义是<code>如果当前对象生成代理对象符合this指定类型</code>,将其织入切面逻辑<strong>。<code>this</code>匹配代理</strong></p>
<p><strong>对象为指定类型的类。<code>target</code>匹配业务对象为指定类型的类。</strong></p>
<ul>
<li>如果目标对象被代理的方法是实现某个接口方法,将默认被JDK代理生成代理对象。此时代理对象和目标</li>
</ul>
<p>对象是两个对象,并且都实现了该接口。</p>
<ul>
<li>如果目标对象是一个类,并且其没有实现任意接口,那么将会使用Cglib代理生成代理对象,并且只会生成一个对象,即Cglib生成的代理类的对象。</li>
</ul>
<p><strong><code>this</code>和<code>target</code>区别:</strong></p>
<ul>
<li>this(SomeInterface)或target(SomeInterface)：这种情况下，无论是对于Jdk代理还是Cglib代理，其目标对象和代理对象都是实现SomeInterface接口的（Cglib生成的目标对象的子类也是实现了SomeInterface接口的），因而this和target语义都是符合的，此时这两个表达式的效果一样；</li>
<li>this(SomeObject)或target(SomeObject)，这里SomeObject没实现任何接口：这种情况下，Spring会使用Cglib代理生成SomeObject的代理类对象，由于代理类是SomeObject的子类，子类的对象也是符合SomeObject类型的，因而this将会被匹配，而对于target，由于目标对象本身就是SomeObject类型，因而这两个表达式的效果一样；</li>
<li>this(SomeObject)或target(SomeObject)，这里SomeObject实现了某个接口：对于这种情况，虽然表达式中指定的是一种具体的对象类型，但由于其实现了某个接口，因而Spring默认会使用Jdk代理为其生成代理对象，Jdk代理生成的代理对象与目标对象实现的是同一个接口，但代理对象与目标对象还是不同的对象，由于代理对象不是SomeObject类型的，因而此时是不符合this语义的，而由于目标对象就是SomeObject类型，因而target语义是符合的，此时this和target的效果就产生了区别；这里如果强制Spring使用Cglib代理，因而生成的代理对象都是SomeObject子类的对象，其是SomeObject类型的，因而this和target的语义都符合，其效果就是一致的。</li>
</ul>
<ol start="5">
<li><strong><code>@annotation:表示匹配使用@annotation指定注解标注的方法将会环绕。</code></strong></li>
</ol>
<p><code>@annotation(annotation-type)</code></p>
<ol start="6">
<li><strong><code>@within:匹配带有指定注解的类。</code></strong></li>
</ol>
<p><code>@within(annotation-type)</code></p>
<ol start="7">
<li><p><strong><code>@args:表示使用指定注解标注的类作为某个方法的参数时该方法将会被匹配</code></strong></p>
<p><code>@args(annotation-type)</code></p>
</li>
<li><p><code>@DeclareParents</code>：引介增强，表示为指定的目标类引入新的属性和方法。</p>
</li>
</ol>
<p><strong>注意:</strong></p>
<p>由于Spring AOP框架基于代理模式设计的,<code>对于JDK代理,仅public interface方法会被代理拦截</code>。对于CGLIB,</p>
<p><code>仅public和protected方法会被代理拦截</code>。<code>目标对象方法调用的自身方法默认不会被拦截</code>,需要声明<code>exposeProxy=true，借助AopContext进行实现</code>。</p>
<p>Spring AOP支持额外的<code>Bean PCD</code>(?PCD是什么)。<code>Bean PCD可以使用&amp;&amp;,||,!</code>操作符。</p>
<blockquote>
<p>Bean PCD仅在Spring AOP中受支持，而在本机AspectJ编织中不受支持。 它是AspectJ定义的标准PCD的Spring特定扩展，因此不适用于@Aspect模型中声明的方面。</p>
<p>bean PCD在实例级别（基于Spring bean名称概念）而不是仅在类型级别（基于编织的AOP受限）上运行。 基于实例的切入点指示符是Spring基于代理的AOP框架的一种特殊功能，它与Spring bean工厂紧密集成，通过名称可以自然而直接地识别特定的bean。</p>
</blockquote>
<p><strong>切点书写规则</strong></p>
<blockquote>
<p>切点指示符包含:类型,范围,上下文。</p>
<ul>
<li>类型指示符:<code>execution</code>, <code>get</code>, <code>set</code>, <code>call</code>, and <code>handler</code>. </li>
<li>范围指示符:<code>within</code> and <code>withincode</code> </li>
<li>上下文指示符:<code>this</code>, <code>target</code>, and <code>@annotation</code> </li>
</ul>
<p><code>一个写得很好的切入点应至少包括前两种类型（kinded和scoping)。您可以包含上下文指示符以基于连接点上下文进行匹配，或者绑定该上下文以在建议中使用。</code></p>
</blockquote>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">知源</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://crazyblitz.github.io/2019/09/20/Spring-AOP切点表达式用法总结/">https://crazyblitz.github.io/2019/09/20/Spring-AOP切点表达式用法总结/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://crazyblitz.github.io">知源博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring-AOP/">Spring AOP</a></div><div class="social-share" data-disabled="google,facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/09/20/面对对象思想/"><i class="fa fa-chevron-left">  </i><span>面对对象思想</span></a></div><div class="next-post pull-right"><a href="/2019/09/17/Java集合详解/"><span>Java集合详解</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC80NTc5Ny8yMjMwOA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By 知源</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>
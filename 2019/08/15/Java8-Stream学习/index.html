<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java8 Stream学习"><meta name="keywords" content="Lamdba,Java8 Stream"><meta name="author" content="知源"><meta name="copyright" content="知源"><title>Java8 Stream学习 | 知源博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?628e2ee31ce5c6697d1f5b263b262108";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"QSYLR3XYSH","apiKey":"1b2fe15d5912eb0d3de39fd5574cc460","indexName":"zhiyuan","hits":{"per_page":8},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java8-Stream学习"><span class="toc-number">1.</span> <span class="toc-text">Java8 Stream学习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#初探Stream"><span class="toc-number">1.1.</span> <span class="toc-text">初探Stream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中间操作"><span class="toc-number">1.2.</span> <span class="toc-text">中间操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#filter"><span class="toc-number">1.2.1.</span> <span class="toc-text">filter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#distinct"><span class="toc-number">1.2.2.</span> <span class="toc-text">distinct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#skip"><span class="toc-number">1.2.3.</span> <span class="toc-text">skip</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#limit"><span class="toc-number">1.2.4.</span> <span class="toc-text">limit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map"><span class="toc-number">1.2.5.</span> <span class="toc-text">map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#flatMap"><span class="toc-number">1.2.6.</span> <span class="toc-text">flatMap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#终端操作"><span class="toc-number">1.3.</span> <span class="toc-text">终端操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#anyMatch"><span class="toc-number">1.3.1.</span> <span class="toc-text">anyMatch</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#allMatch"><span class="toc-number">1.4.</span> <span class="toc-text">allMatch</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#noneMatch"><span class="toc-number">1.4.1.</span> <span class="toc-text">noneMatch</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#findAny"><span class="toc-number">1.5.</span> <span class="toc-text">findAny</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#findFirst"><span class="toc-number">1.6.</span> <span class="toc-text">findFirst</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reduce"><span class="toc-number">1.7.</span> <span class="toc-text">reduce</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forEach"><span class="toc-number">1.8.</span> <span class="toc-text">forEach</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#count"><span class="toc-number">1.9.</span> <span class="toc-text">count</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#collect"><span class="toc-number">1.10.</span> <span class="toc-text">collect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#流的构建"><span class="toc-number">1.11.</span> <span class="toc-text">流的构建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数值范围构建"><span class="toc-number">1.11.1.</span> <span class="toc-text">数值范围构建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#由值构建"><span class="toc-number">1.11.2.</span> <span class="toc-text">由值构建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#由数组构建"><span class="toc-number">1.11.3.</span> <span class="toc-text">由数组构建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#由文件生成流"><span class="toc-number">1.11.4.</span> <span class="toc-text">由文件生成流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#由函数构造"><span class="toc-number">1.11.5.</span> <span class="toc-text">由函数构造</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转载-https-mrbird-cc-java8stream1-html"><span class="toc-number">1.12.</span> <span class="toc-text">转载:https://mrbird.cc/java8stream1.html</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">知源</div><div class="author-info__description text-center">一个程序员成长之路</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">100</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">81</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">17</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">知源博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Java8 Stream学习</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-15</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java基础/">Java基础</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="Java8-Stream学习"><a href="#Java8-Stream学习" class="headerlink" title="Java8 Stream学习"></a>Java8 Stream学习</h2><p>   Java 8 中的 Stream 俗称为流，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。Stream 用于<code>对集合对象进行各种非常便利、高效的聚合操作，或者大批量数据操作</code>。Stream API 借助于Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势。通过下面的例子我们可以初步体会到使用 Stream 处理集合的便利性。</p>
<h3 id="初探Stream"><a href="#初探Stream" class="headerlink" title="初探Stream"></a>初探Stream</h3><p>有如下一个List，现要从中筛选出以<code>J</code>开头的元素，然后转换为大写，最后输出结果。Java 8之前我们是这样做的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"Java"</span>, <span class="string">"JavaScript"</span>, <span class="string">"python"</span>, <span class="string">"PHP"</span>, <span class="string">"C#"</span>, <span class="string">"Golang"</span>, <span class="string">"Swift"</span>);</span><br><span class="line">List&lt;String&gt; filterList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str.startsWith(<span class="string">"J"</span>)) &#123;</span><br><span class="line">        filterList.add(str.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String str : filterList) &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了筛选集合我们进行了两次外部迭代，并且还创建了一个用来临时存放筛选元素的集合对象。借助Java 8中的Stream我们可以极大的简化这个处理过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"Java"</span>, <span class="string">"JavaScript"</span>, <span class="string">"python"</span>, <span class="string">"PHP"</span>, <span class="string">"C#"</span>, <span class="string">"Golang"</span>, <span class="string">"Swift"</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .filter(s -&gt; s.startsWith(<span class="string">"J"</span>))</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p> 上面的例子中，集合使用<code>stream</code>方法创建了一个流，然后使用<code>filter</code>和<code>map</code>方法来处理这个集合，它们统称为<strong>中间操作</strong>。中间操作都会返回另一个流，以便于将各种对集合的操作连接起来形成一条流水线。最后我们使用了<code>forEach</code>方法迭代筛选结果，这种位于流的末端，对流进行处理并且生成结果的方法称为<strong>终端操作</strong>。</p>
<p>总而言之，流的使用一般包括三件事情：</p>
<ol>
<li>一个<strong>数据源</strong>（如集合）来执行一个查询；</li>
<li>一个<strong>中间操作</strong>链，形成一条流的流水线；</li>
<li>一个<strong>终端操作</strong>，执行流水线，并能生成结果。</li>
</ol>
<p>下表列出了流中常见的中间操作和终端操作：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">操作</td>
<td align="left">类型</td>
<td align="left">返回类型</td>
<td align="left">使用的类型/函数式接口</td>
<td align="left">函数描述符</td>
</tr>
<tr>
<td align="left">filter</td>
<td align="left">中间</td>
<td align="left"><code>Stream&lt;T&gt;</code></td>
<td align="left"><code>Predicate&lt;T&gt;</code></td>
<td align="left"><code>T -&gt; boolean</code></td>
</tr>
<tr>
<td align="left">distinct</td>
<td align="left">中间</td>
<td align="left"><code>Stream&lt;T&gt;</code></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">skip</td>
<td align="left">中间</td>
<td align="left"><code>Stream&lt;T&gt;</code></td>
<td align="left"><code>long</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">limit</td>
<td align="left">中间</td>
<td align="left"><code>Stream&lt;T&gt;</code></td>
<td align="left"><code>long</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">map</td>
<td align="left">中间</td>
<td align="left"><code>Stream&lt;R&gt;</code></td>
<td align="left"><code>Function&lt;T, R&gt;</code></td>
<td align="left"><code>T -&gt; R</code></td>
</tr>
<tr>
<td align="left">flatMap</td>
<td align="left">中间</td>
<td align="left"><code>Stream&lt;R&gt;</code></td>
<td align="left"><code>Function&lt;T, Stream&lt;R&gt;&gt;</code></td>
<td align="left"><code>T -&gt; Stream&lt;R&gt;</code></td>
</tr>
<tr>
<td align="left">sorted</td>
<td align="left">中间</td>
<td align="left"><code>Stream&lt;T&gt;</code></td>
<td align="left"><code>Comparator&lt;T&gt;</code></td>
<td align="left"><code>(T, T) -&gt; int</code></td>
</tr>
<tr>
<td align="left">anyMatch</td>
<td align="left">终端</td>
<td align="left"><code>boolean</code></td>
<td align="left"><code>Predicate&lt;T&gt;</code></td>
<td align="left"><code>T -&gt; boolean</code></td>
</tr>
<tr>
<td align="left">noneMatch</td>
<td align="left">终端</td>
<td align="left"><code>boolean</code></td>
<td align="left"><code>Predicate&lt;T&gt;</code></td>
<td align="left"><code>T -&gt; boolean</code></td>
</tr>
<tr>
<td align="left">allMatch</td>
<td align="left">终端</td>
<td align="left"><code>boolean</code></td>
<td align="left"><code>Predicate&lt;T&gt;</code></td>
<td align="left"><code>T -&gt; boolean</code></td>
</tr>
<tr>
<td align="left">findAny</td>
<td align="left">终端</td>
<td align="left"><code>Optional&lt;T&gt;</code></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">findFirst</td>
<td align="left">终端</td>
<td align="left"><code>Optional&lt;T&gt;</code></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">forEach</td>
<td align="left">终端</td>
<td align="left"><code>void</code></td>
<td align="left"><code>Consumer&lt;T&gt;</code></td>
<td align="left"><code>T -&gt; void</code></td>
</tr>
<tr>
<td align="left">collect</td>
<td align="left">终端</td>
<td align="left"><code>R</code></td>
<td align="left"><code>Collector&lt;T, A, R&gt;</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">reduce</td>
<td align="left">终端</td>
<td align="left"><code>Optional&lt;T&gt;</code></td>
<td align="left"><code>BinaryOperator&lt;T&gt;</code></td>
<td align="left"><code>(T, T) -&gt; T</code></td>
</tr>
<tr>
<td align="left">count</td>
<td align="left">终端</td>
<td align="left"><code>long</code></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>下面详细介绍这些操作的使用。除了特殊说明，默认使用下面这个集合作为演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"Java"</span>, <span class="string">"JavaScript"</span>, <span class="string">"python"</span>, <span class="string">"PHP"</span>, <span class="string">"C#"</span>, <span class="string">"Golang"</span>, <span class="string">"Swift"</span>, <span class="string">"C++"</span>, <span class="string">"Ruby"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>Streams接口支持·<code>filter</code>方法，该方法接收一个<code>Predicate&lt;T&gt;</code>，函数描述符为<code>T -&gt; boolean</code>，用于对集合进行筛选，返回所有满足的元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().filter(s -&gt; s.contains(<span class="string">"#"</span>))    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>结果输出<code>C#</code>。</p>
<h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h4><p><code>distinct</code>方法用于<code>排除流中重复的元素</code>，类似于SQL中的distinct操作。比如筛选中集合中所有的偶数，并排除重复的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">numbers.stream()</span><br><span class="line">       .filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">       .distinct()</span><br><span class="line">       .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>结果输出<code>2 4</code>。</p>
<h4 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h4><p><code>skip(n)</code>方法用于跳过流中的前n个元素，如果集合元素小于n，则返回空流。比如筛选出以<code>J</code>开头的元素，并排除第一个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .filter(s -&gt; s.startsWith(<span class="string">"J"</span>))</span><br><span class="line">    .skip(<span class="number">1</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>结果输出<code>JavaScript</code>。</p>
<h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p><code>limit(n)</code>方法返回一个长度不超过n的流，比如下面的例子将输出<code>Java JavaScript python</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .limit(<span class="number">3</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p><code>map</code>方法接收一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .map(String::length)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>结果输出<code>4 10 6 3 2 6 5 3 4</code>。</p>
<p><code>map</code>还支持将流特化为指定原始类型的流，如通过<code>mapToInt</code>，<code>mapToDouble</code>和<code>mapToLong</code>方法，可以将流转换为<code>IntStream</code>，<code>DoubleStream</code>和<code>LongStream</code>。特化后的流支持<code>sum</code>，<code>min</code>和<code>max</code>方法来对流中的元素进行计算。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">IntStream intStream = numbers.stream().mapToInt(a -&gt; a);</span><br><span class="line">System.out.println(intStream.sum()); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure>

<p>也可以通过下面的方法，将<code>IntStream</code>转换为<code>Stream</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; s = intStream.boxed();</span><br></pre></td></tr></table></figure>

<h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h4><p><code>flatMap</code>用于将多个流合并成一个流，俗称流的扁平化。这么说有点抽象，举个例子，比如现在需要将list中的各个元素拆分为一个个字母，并过滤掉重复的结果，你可能会这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">   .map(s -&gt; s.split(<span class="string">""</span>))</span><br><span class="line">   .distinct()</span><br><span class="line">   .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Ljava.lang.String;<span class="meta">@e</span>9e54c2</span><br><span class="line">[Ljava.lang.String;@<span class="number">65</span>ab7765</span><br><span class="line">[Ljava.lang.String;@<span class="number">1</span>b28cdfa</span><br><span class="line">[Ljava.lang.String;<span class="meta">@eed</span>1f14</span><br><span class="line">[Ljava.lang.String;@<span class="number">7229724f</span></span><br><span class="line">[Ljava.lang.String;@<span class="number">4</span>c873330</span><br><span class="line">[Ljava.lang.String;@<span class="number">119</span>d7047</span><br><span class="line">[Ljava.lang.String;@<span class="number">776</span>ec8df</span><br><span class="line">[Ljava.lang.String;@<span class="number">4</span>eec7777</span><br></pre></td></tr></table></figure>

<p>这明显不符合我们的预期。实际上在<code>map(s -&gt; s.split(&quot;&quot;))</code>操作后，返回了一个<code>Stream&lt;String[]&gt;</code>类型的流，所以输出结果为每个数组对象的句柄，而我们真正想要的结果是<code>Stream&lt;String&gt;</code>。在Stream中，可以使用<code>Arrays.stream()</code>方法来将数组转换为流，改造上面的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .map(s -&gt; s.split(<span class="string">""</span>))</span><br><span class="line">    .map(Arrays::stream)</span><br><span class="line">    .distinct()</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.util.stream.ReferencePipeline$Head<span class="meta">@eed</span>1f14</span><br><span class="line">java.util.stream.ReferencePipeline$Head@<span class="number">7229724f</span></span><br><span class="line">java.util.stream.ReferencePipeline$Head@<span class="number">4</span>c873330</span><br><span class="line">java.util.stream.ReferencePipeline$Head@<span class="number">119</span>d7047</span><br><span class="line">java.util.stream.ReferencePipeline$Head@<span class="number">776</span>ec8df</span><br><span class="line">java.util.stream.ReferencePipeline$Head@<span class="number">4</span>eec7777</span><br><span class="line">java.util.stream.ReferencePipeline$Head@<span class="number">3</span>b07d329</span><br><span class="line">java.util.stream.ReferencePipeline$Head@<span class="number">41629346</span></span><br><span class="line">java.util.stream.ReferencePipeline$Head@<span class="number">404</span>b9385</span><br></pre></td></tr></table></figure>

<p>因为上面的流经过<code>map(Arrays::stream)</code>处理后，将每个数组变成了一个新的流，返回结果为流的数组<code>Stream&lt;String&gt;[]</code>，所以输出是各个流的句柄。我们还需将这些新的流连接成一个流，使用<code>flatMap</code>来改写上面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .map(s -&gt; s.split(<span class="string">""</span>))</span><br><span class="line">    .flatMap(Arrays::stream)</span><br><span class="line">    .distinct()</span><br><span class="line">    .forEach(s -&gt; System.out.print(s + <span class="string">" "</span>));</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">J a v S c r i p t y h o n P H C # G l g w f + R u b</span><br></pre></td></tr></table></figure>

<p>和<code>map</code>类似，<code>flatMap</code>方法也有相应的原始类型特化方法，如<code>flatMapToInt</code>等。</p>
<h3 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h3><h4 id="anyMatch"><a href="#anyMatch" class="headerlink" title="anyMatch"></a>anyMatch</h4><p><code>anyMatch</code>方法用于判断流中是否有符合判断条件的元素，返回值为boolean类型。比如判断list中是否含有<code>SQL</code>元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .anyMatch(s -&gt; <span class="string">"SQL"</span>.equals(s)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="allMatch"><a href="#allMatch" class="headerlink" title="allMatch"></a>allMatch</h3><p><code>allMatch</code>方法用于判断流中是否所有元素都满足给定的判断条件，返回值为boolean类型。比如判断list中是否所有元素长度都不大于10：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .allMatch(s -&gt; s.length() &lt;= <span class="number">10</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="noneMatch"><a href="#noneMatch" class="headerlink" title="noneMatch"></a>noneMatch</h4><p><code>noneMatch</code>方法用于判断流中是否所有元素都不满足给定的判断条件，返回值为boolean类型。比如判断list中不存在长度大于10的元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .noneMatch(s -&gt; s.length() &gt; <span class="number">10</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="findAny"><a href="#findAny" class="headerlink" title="findAny"></a>findAny</h3><p><code>findAny</code>方法用于返回流中的任意元素的Optional类型，例如筛选出list中任意一个以<code>J</code>开头的元素，如果存在，则输出它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().filter(s -&gt; s.startsWith(<span class="string">"J"</span>)).findAny().ifPresent(System.out::println); <span class="comment">// Java</span></span><br></pre></td></tr></table></figure>

<h3 id="findFirst"><a href="#findFirst" class="headerlink" title="findFirst"></a>findFirst</h3><p><code>findFirst</code>方法用于返回流中的第一个元素的Optional类型，例如筛选出list中长度大于5的元素，如果存在，则输出第一个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .filter(s -&gt; s.length() &gt; 5)</span><br><span class="line">    .findFirst()</span><br><span class="line">    .ifPresent(System.out::println); // JavaScript</span><br></pre></td></tr></table></figure>

<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p><code>reduce</code>函数从字面上来看就是压缩，缩减的意思，它可以用于数字类型的流的求和，求最大值和最小值。如对numbers中的元素求和：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">numbers.stream()</span><br><span class="line">       .reduce(<span class="number">0</span>, Integer::sum); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure>

<p><code>reduce</code>函数也可以不指定初始值，但这时候将返回一个Optional对象，比如求最大值和最小值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numbers.stream().reduce(Integer::max.ifPresent(System.out::println); <span class="comment">// 4</span></span><br><span class="line">numbers.stream().reduce(Integer::min).ifPresent(System.out::println); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p><code>forEach</code>用于迭代流中的每个元素，最为常见的就是迭代输出，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p><code>count</code>方法用于统计流中元素的个数，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().count(); // 9</span><br></pre></td></tr></table></figure>

<h3 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h3><p><code>collect</code>方法用于收集流中的元素，并放到不同类型的结果中，比如<code>List</code>、<code>Set</code>或者<code>Map</code>。举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; filterList = list.stream().filter(s -&gt; s.startsWith(<span class="string">"J"</span>)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>如果需要以<code>Set</code>来替代<code>List</code>，只需要使用<code>Collectors.toSet()</code>就好了。</p>
<h3 id="流的构建"><a href="#流的构建" class="headerlink" title="流的构建"></a>流的构建</h3><p>除了使用集合对象的<code>stream</code>方法构建流之外，我们可以手动构建一些流。</p>
<h4 id="数值范围构建"><a href="#数值范围构建" class="headerlink" title="数值范围构建"></a>数值范围构建</h4><p><code>IntStream</code>和<code>LongStream</code>对象支持<code>range</code>和<code>rangeClosed</code>方法来构建数值流。这两个方法都是第一个参数接受起始值，第二个参数接受结束值。但range是不包含结束值的，而rangeClosed则包含结束值。比如对1到100的整数求和：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream.rangeClosed(1, 100).sum(); // 5050</span><br></pre></td></tr></table></figure>

<h4 id="由值构建"><a href="#由值构建" class="headerlink" title="由值构建"></a>由值构建</h4><p>静态方法<code>Stream.of</code>可以显式值创建一个流。它可以接受任意数量的参数。例如，以下代码直接使用<code>Stream.of</code>创建了一个字符串流:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; s = Stream.of(<span class="string">"Java"</span>, <span class="string">"JavaScript"</span>, <span class="string">"C++"</span>, <span class="string">"Ruby"</span>);</span><br></pre></td></tr></table></figure>

<p>也可以使用<code>Stream.empty()</code>构建一个空流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Object&gt; emptyStream = Stream.empty();</span><br></pre></td></tr></table></figure>

<h4 id="由数组构建"><a href="#由数组构建" class="headerlink" title="由数组构建"></a>由数组构建</h4><p>静态方法<code>Arrays.stream</code>可以通过数组创建一个流。它接受一个数组作为参数。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">IntStream intStream = Arrays.stream(arr);</span><br></pre></td></tr></table></figure>

<h4 id="由文件生成流"><a href="#由文件生成流" class="headerlink" title="由文件生成流"></a>由文件生成流</h4><p><code>java.nio.file.Files</code>中的很多静态方法都会返回一个流。例如<code>Files.lines</code>方法会返回一个由指定文件中的各行构成的字符串流。比如统计一个文件中共有多少个字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> wordCout = <span class="number">0L</span>;</span><br><span class="line"><span class="keyword">try</span> (Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="string">"file.txt"</span>), Charset.defaultCharset())) &#123;</span><br><span class="line">    wordCout = lines.map(l -&gt; l.split(<span class="string">""</span>))</span><br><span class="line">                    .flatMap(Arrays::stream)</span><br><span class="line">                    .count();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ignore) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="由函数构造"><a href="#由函数构造" class="headerlink" title="由函数构造"></a>由函数构造</h4><p>Stream API提供了两个静态方法来从函数生成流：<code>Stream.iterate</code>和<code>Stream.generate</code>。这两个操作可以创建所谓的无限流。比如下面的例子构建了10个偶数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p><code>iterate</code>方法接受一个初始值（在这里是0），还有一个依次应用在每个产生的新值上的Lambda（UnaryOperator类型）。这里，我们使用Lambda <code>n -&gt; n + 2</code>，返回的是前一个元 素加上2。因此，<code>iterate</code>方法生成了一个所有正偶数的流：流的第一个元素是初始值0。然后加上2来生成新的值2，再加上2来得到新的值4，以此类推。</p>
<p>与<code>iterate</code>方法类似，<code>generate</code>方法也可让你按需生成一个无限流。但<code>generate</code>不是依次对每个新生成的值应用函数，比如下面的例子生成了5个0到1之间的随机双精度数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.generate(Math::random).limit(<span class="number">5</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.6334646850587863</span></span><br><span class="line"><span class="number">0.4190147641834009</span></span><br><span class="line"><span class="number">0.4361968394515475</span></span><br><span class="line"><span class="number">0.6911796456838655</span></span><br><span class="line"><span class="number">0.08156838267267075</span></span><br></pre></td></tr></table></figure>

<h3 id="转载-https-mrbird-cc-java8stream1-html"><a href="#转载-https-mrbird-cc-java8stream1-html" class="headerlink" title="转载:https://mrbird.cc/java8stream1.html"></a>转载:<a href="https://mrbird.cc/java8stream1.html" target="_blank" rel="noopener">https://mrbird.cc/java8stream1.html</a></h3></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">知源</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://crazyblitz.github.io/2019/08/15/Java8-Stream学习/">https://crazyblitz.github.io/2019/08/15/Java8-Stream学习/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://crazyblitz.github.io">知源博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Lamdba/">Lamdba</a><a class="post-meta__tags" href="/tags/Java8-Stream/">Java8 Stream</a></div><div class="social-share" data-disabled="google,facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/08/16/Mybatis使用接口访问数据库原理/"><i class="fa fa-chevron-left">  </i><span>Mybatis使用接口访问数据库原理</span></a></div><div class="next-post pull-right"><a href="/2019/08/11/Servlet状态管理/"><span>Servlet状态管理</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC80NTc5Ny8yMjMwOA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By 知源</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>
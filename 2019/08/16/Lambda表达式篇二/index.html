<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Lambda表达式篇二"><meta name="keywords" content="Java8,Lambda"><meta name="author" content="知源"><meta name="copyright" content="知源"><title>Lambda表达式篇二 | 知源博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?628e2ee31ce5c6697d1f5b263b262108";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"QSYLR3XYSH","apiKey":"1b2fe15d5912eb0d3de39fd5574cc460","indexName":"zhiyuan","hits":{"per_page":8},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda表达式篇二"><span class="toc-number">1.</span> <span class="toc-text">Lambda表达式篇二</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java8中的函数式接口"><span class="toc-number">1.1.</span> <span class="toc-text">Java8中的函数式接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Predicate"><span class="toc-number">1.2.</span> <span class="toc-text">Predicate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Consumer"><span class="toc-number">1.3.</span> <span class="toc-text">Consumer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Supplier"><span class="toc-number">1.4.</span> <span class="toc-text">Supplier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Functions"><span class="toc-number">1.5.</span> <span class="toc-text">Functions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原始类型特化"><span class="toc-number">1.6.</span> <span class="toc-text">原始类型特化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java8中增强的Comparator"><span class="toc-number">1.7.</span> <span class="toc-text">Java8中增强的Comparator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转载-https-mrbird-cc-java8lambda2-html"><span class="toc-number">1.8.</span> <span class="toc-text">转载:https://mrbird.cc/java8lambda2.html</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">知源</div><div class="author-info__description text-center">一个程序员成长之路</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">100</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">83</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">18</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">知源博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Lambda表达式篇二</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-16</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java基础/">Java基础</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="Lambda表达式篇二"><a href="#Lambda表达式篇二" class="headerlink" title="Lambda表达式篇二"></a>Lambda表达式篇二</h2><p>   Java 8已经给我们提供了一套能够描述常见函数描述符的函数式接口。比如<code>Predicate&lt;T&gt;</code>、<code>Consumer&lt;T&gt;</code>、<code>Function&lt;T,R&gt;</code>、<code>Supplier&lt;T&gt;</code>等，这些函数式接口位于<code>java.util.function</code>包。这一节主要记录这些函数式接口的应用。</p>
<h3 id="Java8中的函数式接口"><a href="#Java8中的函数式接口" class="headerlink" title="Java8中的函数式接口"></a>Java8中的函数式接口</h3><p>下表列出了Java8中常见的函数式接口：</p>
<table>
<thead>
<tr>
<th align="left">函数式接口</th>
<th align="left">函数描述符</th>
<th align="left">原始类型特化</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Predicate(过滤)</td>
<td align="left">T-&gt;boolean</td>
<td align="left">IntPredicate,LongPredicate, DoublePredicate</td>
</tr>
<tr>
<td align="left">Consumer(消费者)</td>
<td align="left">T-&gt;void</td>
<td align="left">IntConsumer,LongConsumer, DoubleConsumer</td>
</tr>
<tr>
<td align="left">Function&lt;T,R&gt;</td>
<td align="left">T-&gt;R</td>
<td align="left">IntFunction, IntToDoubleFunction, IntToLongFunction, LongFunction, LongToDoubleFunction, LongToIntFunction, DoubleFunction, ToIntFunction, ToDoubleFunction, ToLongFunction</td>
</tr>
<tr>
<td align="left">Supplier(生产者)</td>
<td align="left">()-&gt;T</td>
<td align="left">BooleanSupplier,IntSupplier, LongSupplier, DoubleSupplier</td>
</tr>
<tr>
<td align="left">UnaryOperator</td>
<td align="left">T-&gt;T</td>
<td align="left">IntUnaryOperator, LongUnaryOperator, DoubleUnaryOperator</td>
</tr>
<tr>
<td align="left">BinaryOperator</td>
<td align="left">(T,T)-&gt;T</td>
<td align="left">IntBinaryOperator, LongBinaryOperator, DoubleBinaryOperator</td>
</tr>
<tr>
<td align="left">BiPredicate&lt;L,R&gt;</td>
<td align="left">(L,R)-&gt;boolean</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">BiConsumer&lt;T,U&gt;</td>
<td align="left">(T,U)-&gt;void</td>
<td align="left">ObjIntConsumer, ObjLongConsumer, ObjDoubleConsumer</td>
</tr>
<tr>
<td align="left">BiFunction&lt;T,U,R&gt;</td>
<td align="left">(T,U)-&gt;R</td>
<td align="left">ToIntBiFunction&lt;T,U&gt;, ToLongBiFunction&lt;T,U&gt;, ToDoubleBiFunction&lt;T,U&gt;</td>
</tr>
</tbody></table>
<h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><p>predicate:断言。从接口的名称就可以推断出这个函数式接口的主要作用就是用于判断作用，Predicate源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">negate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">or</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">isEqual</span><span class="params">(Object targetRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">null</span> == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可看到<code>java.util.function.Predicate&lt;T&gt;</code>接口定义了一个名叫<code>test</code>的抽象方法，它接受泛型<code>T</code>对象，并返回一个<code>boolean</code>，函数描述符为<code>(T) -&gt; boolean</code>举几个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 偶数判断</span></span><br><span class="line">Predicate&lt;Integer&gt; isEven = (in) -&gt; in % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">isEven.test(<span class="number">17</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字符串的长度是否为0</span></span><br><span class="line">Predicate&lt;String&gt; isEmptyString = String::isEmpty;</span><br><span class="line">isEmptyString.test(<span class="string">""</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>除了抽象方法外，<code>java.util.function.Predicate&lt;T&gt;</code>接口还定义了三个默认方法：<code>and</code>，<code>negate</code>和<code>or</code>，对应“与”，“非”和“或”操作，这样我们便可以复合Lambda表达式了，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是偶数，并且大于30</span></span><br><span class="line">Predicate&lt;Integer&gt; isEven = (in) -&gt; in % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">isEven.and((in) -&gt; in &gt; <span class="number">30</span>).test(<span class="number">40</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 奇数判断</span></span><br><span class="line">Predicate&lt;Integer&gt; isEven = (in) -&gt; in % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">Predicate&lt;Integer&gt; isOdd = isEven.negate();</span><br><span class="line">isOdd.test(<span class="number">17</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>消费者。该函数式接口用于消费一个对象，即接收一个对象，对其执行某些操作，然后没有返回值。Consumer源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可看到<code>java.util.function.Consumer&lt;T&gt;</code>定义了一个名叫<code>accept</code>的抽象方法，它接受泛型<code>T</code>的对象，没有返回(<code>void</code>)，函数描述符为<code>(T) -&gt; void</code>。其还提供了一个默认方法<code>andThen</code>。举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;Apple&gt; printAppleColor = (a)-&gt; System.out.println(a.getColor());</span><br><span class="line">printAppleColor.accept(<span class="keyword">new</span> Apple(<span class="string">"red"</span>,<span class="number">17</span>)); <span class="comment">// red</span></span><br><span class="line"></span><br><span class="line">printAppleColor.andThen((a) -&gt; System.out.println(a.getWeight())).accept(<span class="keyword">new</span> Apple(<span class="string">"red"</span>, <span class="number">17</span>)); <span class="comment">// red 17.0</span></span><br></pre></td></tr></table></figure>

<h3 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h3><p>供应商;供应者;供给者。其源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可看到<code>java.util.function.Supplier&lt;T&gt;</code>定义了一个名叫<code>get</code>的抽象方法，它不接收参数，返回泛型<code>T</code>的对象，函数描述符为<code>() -&gt; T</code>。举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Person&gt; personSupplier = Person::<span class="keyword">new</span>;</span><br><span class="line">personSupplier.get();   <span class="comment">// new Person</span></span><br></pre></td></tr></table></figure>

<h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><p>Functions源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;V, R&gt; <span class="title">compose</span><span class="params">(Function&lt;? <span class="keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Function&lt;T, T&gt; <span class="title">identity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>java.util.function.Function&lt;T, R&gt;</code>接口定义了一个叫作<code>apply</code>的方法，它接受一个泛型<code>T</code>的对象，并返回一个泛型<code>R</code>的对象，函数描述符为<code>(T) -&gt; R</code>。举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Apple, Double&gt; getAppleWeight = (a) -&gt; &#123;    return a.getWeight();&#125;;getAppleWeight.apply(new Apple(17)); // 17.0</span><br></pre></td></tr></table></figure>

<p>Functions接口还提供了两个抽象方法<code>compose</code>和<code>andThen</code>，从源码可以看出两者的根本区别。举个<code>compose</code>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Apple, Double&gt; getAppleWeight = (a) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> a.getWeight();</span><br><span class="line">&#125;;</span><br><span class="line">getAppleWeight.apply(<span class="keyword">new</span> Apple(<span class="number">17</span>)); <span class="comment">// 17.0</span></span><br></pre></td></tr></table></figure>

<p>过程为：<code>f(g(2))</code>，也就是<code>1+(2*2)</code>。</p>
<p>举个andThen的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; f = (x) -&gt; x + <span class="number">1</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; g = (x) -&gt; x * <span class="number">2</span>;</span><br><span class="line">f.compose(g).apply(<span class="number">2</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>过程为：<code>g(f(2))</code>，也就是<code>(2+1)*2</code>。</p>
<h3 id="原始类型特化"><a href="#原始类型特化" class="headerlink" title="原始类型特化"></a>原始类型特化</h3><p>在学习Function接口的时候，我们定义了<code>f</code>函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; f = (x) -&gt; x + 1;</span><br></pre></td></tr></table></figure>

<p>x的类型为Integer类型，1为int类型，返回值为Integer类型，整个过程实际上为<code>Integer.valueOf(x.intValue() + 1)</code>。虽然编译器可以自动帮我们完成拆装箱，但这会造成不必要的性能消耗。考虑到了这一点，Java8为我们提供了int类型的Function接口：IntFunction:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntFunction</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以<code>f</code>最好重构为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntFunction&lt;Integer&gt; f = (x) -&gt; x + 1;</span><br></pre></td></tr></table></figure>

<p>剩余的原始类型特化函数式接口可参考上面的表格。</p>
<h3 id="Java8中增强的Comparator"><a href="#Java8中增强的Comparator" class="headerlink" title="Java8中增强的Comparator"></a>Java8中增强的Comparator</h3><p>在Java8之前，Comparator接口用于实现简单的比较排序算法。比如有如下List：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Double&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">12.3</span>);</span><br><span class="line">list.add(<span class="number">100.2</span>);</span><br><span class="line">list.add(<span class="number">3.14</span>);</span><br><span class="line">list.add(<span class="number">27.7</span>);</span><br><span class="line">list.add(-<span class="number">9.8</span>);</span><br></pre></td></tr></table></figure>

<p>使用Comparator接口对其从小到大排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Double&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Double o1, Double o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Comparator接口也是一个函数式接口，函数描述符为<code>(T,T) -&gt; int</code>，Java8中可以使用Lambda改造上面的排序方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, (o1, o2) -&gt; o1.compareTo(o2));</span><br></pre></td></tr></table></figure>

<p>Java8对List提供了<code>sort</code>方法，可以替代<code>Collections.sort</code>，所以上面的代码可以简化为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.sort((o1, o2) -&gt; o1.compareTo(o2));</span><br></pre></td></tr></table></figure>

<p>使用方法的引用来进一步简化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.sort(Double::compareTo);</span><br></pre></td></tr></table></figure>

<p>Java8对Comparator进行了增强，加入了一些实用的默认方法，比如对排序结果反转：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Double&gt; comparator = Double::compareTo;</span><br><span class="line">list.sort(comparator.reversed());</span><br></pre></td></tr></table></figure>

<p>更多方法可以参考Comparator接口的JavaDoc。</p>
<blockquote>
<p>查看Comparator的时候发现其虽然是函数式接口，但是却包含了<code>compare</code>和<code>equals</code>这两个抽象方法，顿时有点懵逼，函数式接口不是只能有一个抽象方法么？查找资料后发现：函数式接口中可以额外定义多个抽象方法，但这些抽象方法签名必须和Object的public方法一样，接口最终有确定的类实现，而类的最终父类是Object。因此函数式接口可以定义Object的public方法。</p>
</blockquote>
<h3 id="转载-https-mrbird-cc-java8lambda2-html"><a href="#转载-https-mrbird-cc-java8lambda2-html" class="headerlink" title="转载:https://mrbird.cc/java8lambda2.html"></a>转载:<a href="https://mrbird.cc/java8lambda2.html" target="_blank" rel="noopener">https://mrbird.cc/java8lambda2.html</a></h3></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">知源</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://crazyblitz.github.io/2019/08/16/Lambda表达式篇二/">https://crazyblitz.github.io/2019/08/16/Lambda表达式篇二/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://crazyblitz.github.io">知源博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java8/">Java8</a><a class="post-meta__tags" href="/tags/Lambda/">Lambda</a></div><div class="social-share" data-disabled="google,facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/08/16/使用Stream收集数据/"><i class="fa fa-chevron-left">  </i><span>使用Stream收集数据</span></a></div><div class="next-post pull-right"><a href="/2019/08/16/Sql-Or-NoSql-选型方案及比较/"><span>Sql Or NoSql 选型方案及比较</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC80NTc5Ny8yMjMwOA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By 知源</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>
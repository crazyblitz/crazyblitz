<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="BeanPostProcessor加载次序及其对Bean造成的影响"><meta name="keywords" content="Spring,BeanPostProcessor"><meta name="author" content="知源"><meta name="copyright" content="知源"><title>BeanPostProcessor加载次序及其对Bean造成的影响 | 知源博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?628e2ee31ce5c6697d1f5b263b262108";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"QSYLR3XYSH","apiKey":"1b2fe15d5912eb0d3de39fd5574cc460","indexName":"zhiyuan","hits":{"per_page":8},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1：前言"><span class="toc-number">1.</span> <span class="toc-text">1：前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2：问题场景"><span class="toc-number">2.</span> <span class="toc-text">2：问题场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3：问题查找"><span class="toc-number">3.</span> <span class="toc-text">3：问题查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1：Spring-cache失效的表象原因"><span class="toc-number">3.1.</span> <span class="toc-text">3-1：Spring cache失效的表象原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2：Spring-cache集成机制分析深层次原因"><span class="toc-number">3.2.</span> <span class="toc-text">3-2：Spring cache集成机制分析深层次原因</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4：BeanPostProcessor启动阶段对其依赖Bean造成影响"><span class="toc-number">4.</span> <span class="toc-text">4：BeanPostProcessor启动阶段对其依赖Bean造成影响</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1：-BeanPostProcessor在进行依赖的Bean注入时，根据Bean名称进行类型检查时导致的“误伤”"><span class="toc-number">4.1.</span> <span class="toc-text">4-1： BeanPostProcessor在进行依赖的Bean注入时，根据Bean名称进行类型检查时导致的“误伤”</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5：总结"><span class="toc-number">5.</span> <span class="toc-text">5：总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1：BeanPostProcessor启动顺序，以及其对于依赖的Bean的影响"><span class="toc-number">5.1.</span> <span class="toc-text">5-1：BeanPostProcessor启动顺序，以及其对于依赖的Bean的影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2：注意避免BeanPostProcessor启动时的“误伤”陷阱"><span class="toc-number">5.2.</span> <span class="toc-text">5-2：注意避免BeanPostProcessor启动时的“误伤”陷阱</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">知源</div><div class="author-info__description text-center">一个程序员成长之路</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">100</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">83</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">18</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">知源博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">BeanPostProcessor加载次序及其对Bean造成的影响</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-24</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Spring/">Spring</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h3 id="1：前言"><a href="#1：前言" class="headerlink" title="1：前言"></a>1：前言</h3><p><code>BeanPostProcessor</code>是一个工厂钩子，<code>允许Spring框架在新创建Bean实例时对其进行定制化修改</code>。例如：通过检查其标注的接口或者使用代理对其进行包裹。应用上下文会从Bean定义中自动检测出BeanPostProcessor并将它们应用到随后创建的任何Bean上。</p>
<p>普通Bean对象的工厂允许在程序中注册post-processors，应用到随后在本工厂中创建的所有Bean上。典型的场景如：</p>
<ul>
<li>通过<code>标记接口等填充bean</code>后置处理器通常会实现postProcessBeforeInitialization</li>
<li>而<code>使用代理包装bean</code>的后置处理器通常会实现则一般使用postProcessAfterInitialization</li>
</ul>
<p>BeanPostProcessor本身也是一个Bean，一般而言其实例化时机要早过普通的Bean，但是BeanPostProcessor也会依赖一些Bean，这就导致了一些Bean的实例化早于BeanPostProcessor，由此会导致一些问题。最近在处理shiro和spring cache整合时就碰到了，导致的结果就是spring cache不起作用。现将问题场景、查找历程及解决方法展现一下。</p>
<h3 id="2：问题场景"><a href="#2：问题场景" class="headerlink" title="2：问题场景"></a>2：问题场景</h3><p>打算在项目中将shiro与spring cache整合，使用spring cache统一管理缓存，也包括shiro认证时的用户信息查询。<code>项目中将service分层，outter层负责权限和session，inner层主打事务和缓存并与DAO交互，两层之间也可以较容易的扩展为RPC或微服务模式</code>。因此在shiro的authRealm中依赖了innerUserService，并在innerUserService中配置了spring cache的标注，使用cache进行缓存。配置如下（摘录重要部分）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 配置shiro secuirty manager</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"securityManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SecurityManager <span class="title">securityManager</span><span class="params">(@Qualifier(<span class="string">"authRealm"</span>)</span> TourismAuthorizingRealm authRealm, @<span class="title">Qualifier</span><span class="params">(<span class="string">"cookieRememberMeManager"</span>)</span> CookieRememberMeManager cookieRememberMeManager) </span>&#123;</span><br><span class="line">        log.info(<span class="string">"securityManager()"</span>);</span><br><span class="line">        DefaultWebSecurityManager securityManager = <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置rememberMe管理器</span></span><br><span class="line">        securityManager.setRememberMeManager(cookieRememberMeManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置realm,解决doGetAuthorizationInfo方法没有调用问题</span></span><br><span class="line">        securityManager.setRealm(authRealm);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置自定义权限登录器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"authRealm"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TourismAuthorizingRealm <span class="title">tourismAuthorizingRealm</span><span class="params">(@Qualifier(<span class="string">"hashedCredentialsMatcher"</span>)</span> HashedCredentialsMatcher matcher) </span>&#123;</span><br><span class="line">        log.info(<span class="string">"tourismAuthorizingRealm bean"</span>);</span><br><span class="line">        TourismAuthorizingRealm myAuthorizingRealm = <span class="keyword">new</span> TourismAuthorizingRealm();</span><br><span class="line">        <span class="comment">// 设置密码凭证匹配器</span></span><br><span class="line">        myAuthorizingRealm.setCredentialsMatcher(matcher);</span><br><span class="line">        <span class="keyword">return</span> myAuthorizingRealm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开启shiro aop注解支持.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 使用代理方式;所以需要开启代码支持;</span></span><br><span class="line"><span class="comment">     * Controller才能使用<span class="doctag">@RequiresPermissions</span></span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> securityManager</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthorizationAttributeSourceAdvisor <span class="title">authorizationAttributeSourceAdvisor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @Qualifier(<span class="string">"securityManager"</span>)</span> SecurityManager securityManager) </span>&#123;</span><br><span class="line">        AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = <span class="keyword">new</span> AuthorizationAttributeSourceAdvisor();</span><br><span class="line">        authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);</span><br><span class="line">        <span class="keyword">return</span> authorizationAttributeSourceAdvisor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置 shiro filter factory</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">shiroFilter</span><span class="params">(@Qualifier(<span class="string">"securityManager"</span>)</span> SecurityManager securityManager) </span>&#123;</span><br><span class="line">        ShiroFilterFactoryBean shiroFilterFactoryBean = <span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">        <span class="comment">// 必须设置 SecurityManager</span></span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line">        <span class="keyword">return</span> shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 配置shiro生命周期</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"lifecycleBeanPostProcessor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> LifecycleBeanPostProcessor <span class="title">lifecycleBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"lifecycleBeanPostProcessor bean"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LifecycleBeanPostProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中TourismAuthorizingRealm是自定义的shiro authorizingRealm，<code>用于执行认证和授权</code>。其实现依赖userService从库中查找用户信息，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TourismAuthorizingRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"userService"</span>)</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * shiro的权限配置方法</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"权限配置--&gt;doGetAuthorizationInfo"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        SimpleAuthorizationInfo authorizationInfo = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line">        logger.info(<span class="string">"-----------------------------&gt;"</span> + principals.getPrimaryPrincipal());</span><br><span class="line"></span><br><span class="line">        User user = (User) principals.getPrimaryPrincipal();</span><br><span class="line">        logger.info(<span class="string">"doGetAuthorizationInfo() user: &#123;&#125;"</span>, user);</span><br><span class="line">        List&lt;Role&gt; roles = userService.getRoles(user.getUserId());</span><br><span class="line">        <span class="keyword">for</span> (Role role : roles) &#123;</span><br><span class="line"></span><br><span class="line">            authorizationInfo.addRole(role.getRoleName());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果有权限，应该增加所有角色对应的权限</span></span><br><span class="line">            <span class="comment">// authorizationInfo.addStringPermission()</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"用户: &#123;&#125;,具有的角色: &#123;&#125;"</span>, user.getUserName(), authorizationInfo.getRoles());</span><br><span class="line">        logger.info(<span class="string">"用户: &#123;&#125;,具有的权限: &#123;&#125;"</span>, user.getUserName(), authorizationInfo.getStringPermissions());</span><br><span class="line">        <span class="keyword">return</span> authorizationInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * shiro的身份验证方法</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"正在验证身份..."</span>);</span><br><span class="line">        SimpleAuthenticationInfo info;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将token转换成UsernamePasswordToken</span></span><br><span class="line">        UsernamePasswordToken upToken = (UsernamePasswordToken) token;</span><br><span class="line">        <span class="comment">//从转换后的token中获取用户名</span></span><br><span class="line">        String username = upToken.getUsername();</span><br><span class="line">        <span class="comment">//查询数据库，得到用户</span></span><br><span class="line">        User user = userService.getOne(<span class="keyword">new</span> QueryWrapper&lt;User&gt;().lambda().eq(User::getUserName, username));</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.info(<span class="string">"没有用户: &#123;&#125;"</span>, username);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到加密密码的盐值</span></span><br><span class="line">        ByteSource salt = ByteSource.Util.bytes(user.getUserSalt());</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"加密密码的盐: &#123;&#125;"</span>, salt);</span><br><span class="line">        <span class="comment">//得到盐值加密后的密码: 只用于方便数据库测试,后期不会用到。</span></span><br><span class="line">        Object md = <span class="keyword">new</span> SimpleHash(PasswordUtils.ALGORITHM_NAME, upToken.getPassword(), salt, PasswordUtils.HASH_ITERATIONS);</span><br><span class="line">        logger.info(<span class="string">"盐值加密后的密码: &#123;&#125;"</span>, md);</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> 用户名;用户密码;加密盐;realm name</span></span><br><span class="line">        info = <span class="keyword">new</span> SimpleAuthenticationInfo(user, user.getUserPassword(), salt, getName());</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在UserService中配置了spring cache标注,代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Cacheable</span>(value = <span class="string">"user-cache"</span>, key = <span class="string">"#username"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">findByUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">		User user = userMapper.findByUsername(username);</span><br><span class="line">		logger.info(<span class="string">"Real execute find from database, username:&#123;&#125;"</span>, username);</span><br><span class="line">		<span class="keyword">return</span> user;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并在配置文件上标注了<code>@EnableCaching(mode=AdviceMode.PROXY)以启动spring cache</code>。这里不过多解释具体shiro和spring cache的使用，有兴趣的同学请自行搜索相关资料。</p>
<p>按道理这样的配置在认证的时候可以直接使用userService中配置的spring cache缓存。但是，在具体的场景时，当authRealm依赖了userService以后,spring cache失效了。。而authRealm不依赖userService的时候，cache却正常运行。</p>
<h3 id="3：问题查找"><a href="#3：问题查找" class="headerlink" title="3：问题查找"></a>3：问题查找</h3><h4 id="3-1：Spring-cache失效的表象原因"><a href="#3-1：Spring-cache失效的表象原因" class="headerlink" title="3-1：Spring cache失效的表象原因"></a>3-1：Spring cache失效的表象原因</h4><p>首先,<code>spring cache的实现是基于Spring AOP和拦截器的方式拦截定义的特定缓存注解</code>，然后执行特定逻辑。因此其实现依赖于动态代理机制auto-proxy，而经过初步调试发现，当被authRealm依赖以后，userService就不会被代理了，因此无从进入AOP的pointcut，也就是说AOP切面失效了！</p>
<h4 id="3-2：Spring-cache集成机制分析深层次原因"><a href="#3-2：Spring-cache集成机制分析深层次原因" class="headerlink" title="3-2：Spring cache集成机制分析深层次原因"></a>3-2：Spring cache集成机制分析深层次原因</h4><p> 为何没有被代理呢，我们先来确认一下正常情况下什么时候进行代理封装，这时关于BeanPostProcessor的定义浮现脑海，据文档记载BeanPostProcessor允许在Bean实例化的前后对其做一些猥琐的事情，比如代理。我们在BeanPostProcessor的实现类有<code>AbstractAutoProxyCreator,InfrastructureAdvisorAutoProxyCreator</code></p>
<p> 这一脉。而反观@EnableCaching标注在启动的时候会导入 CachingConfigurationSelector，其selectImports方法会返回AutoProxyRegistrar和ProxyCachingConfiguration的全类名（我们定义了mode=AdviceMode.PROXY），也就是加载这两个类。第一个的作用就是注册InfrastructureAdvisorAutoProxyCreator到BeanDefinitionRegistry中。第二个的作用就是注册了BeanFactoryCacheOperationSourceAdvisor和CacheInterceptor。</p>
<p> 因此，当正常情况下，一个添加了spring cache相关标注的bean会在创建后被<code>InfrastructureAdvisorAutoProxyCreator</code>基于advisor进行代理增强，代理后便可在拦截器<code>CacheInterceptor</code>中对其方法进行拦截，然后执行cache相关逻辑。</p>
<p>所以通过以上的分析，<code>userSerivcce并没有经过Spring AOP代理增强。</code>经测试发现，当被authRealm依赖的情况下在userSevice的Bean实例化时，用于处理该Bean的PostBeanProcessor明显比没被authRealm依赖时少，并且不含有InfrastructureAdvisorAutoProxyCreator。而且控制台会多打印出来一行信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...................</span><br><span class="line">Bean <span class="string">'UserServiceImpl'</span> of type [shiro.web.inner.service.impl.UserServiceImpl] <span class="function">is not eligible <span class="keyword">for</span> getting processed by all <span class="title">BeanPostProcessors</span> <span class="params">(<span class="keyword">for</span> example: not eligible <span class="keyword">for</span> auto-proxying)</span></span></span><br><span class="line"><span class="function">...................</span></span><br></pre></td></tr></table></figure>

<p>据此可以推断，可能由于UserService实例化时机过早，导致后面那些BeanPostProcessor还未来得及实例化和注册。</p>
<h3 id="4：BeanPostProcessor启动阶段对其依赖Bean造成影响"><a href="#4：BeanPostProcessor启动阶段对其依赖Bean造成影响" class="headerlink" title="4：BeanPostProcessor启动阶段对其依赖Bean造成影响"></a>4：BeanPostProcessor启动阶段对其依赖Bean造成影响</h3><p>首先确认了authRealm也是受害者，因为shiroFilter-&gt;SecurityManager-&gt;authRealm的依赖关系导致其不得不提前实例化。表面上的罪魁祸首是shiroFilter，但是到底是谁导致的shiroFilter预料之外的提前启动呢。shiroFilter与InfrastructureAdvisorAutoProxyCreator的具体启动时机到底是什么时候呢。经过调试后发现，了解到BeanPostProcessor的启动时机。在AbstractBeanFactory中维护了BeanPostProcessor的列表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;BeanPostProcessor&gt; beanPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanPostProcessor&gt;();</span><br></pre></td></tr></table></figure>

<p>并实现了ConfigurableBeanFactory定义的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addBeanPostProcessor</span><span class="params">(BeanPostProcessor beanPostProcessor)</span></span>;</span><br></pre></td></tr></table></figure>

<p>因此首先监控<code>AbstractBeanFactory.addBeanPostProcessor()</code>，看看启动过程中谁调用了该方法来注册BeanPostProcessor。发现实例化及注册PostBeanFactory的阶段分为四个：</p>
<ul>
<li><p>第一个阶段是在启动时由<code>AbstractApplicationContext.refresh()</code>，其中的prepareBeanFactory方法中注册了ApplicationContextAwareProcessor、ApplicationListenerDetector：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">	beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后是<code>ServletWebServerApplicationContext</code>中<code>postProcessBeanFactory</code>注册<code>WebApplicationContextServletContextAwareProcessor</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register ServletContextAwareProcessor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ServletContextAwareProcessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">	beanFactory.addBeanPostProcessor(</span><br><span class="line">			<span class="keyword">new</span> WebApplicationContextServletContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">	beanFactory.ignoreDependencyInterface(ServletContextAware.class);</span><br><span class="line">	registerWebApplicationScopes();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后在<code>AbstractApplicationContext#refresh#invokeBeanFactoryPostProcessors</code>方法调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate and invoke all registered BeanFactoryPostProcessor beans,</span></span><br><span class="line"><span class="comment"> * respecting explicit order if given.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Must be called before singleton instantiation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 其中PostProcessorRegistrationDelegate是处理BeanPostProcessor的代理类</span></span><br><span class="line">	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line">       ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后是处理@Configuration注解的<code>ConfigurationClassPostProcessor</code>,实现BeanFactoryPostProcessorr</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ImportAwareBeanPostProcessor(beanFactory));</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后在<code>AbstractApplicationContext#refresh#registerBeanPostProcessors</code>方法调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate and register all BeanPostProcessor beans,</span></span><br><span class="line"><span class="comment"> * respecting explicit order if given.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Must be called before any instantiation of application beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">	PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>PostProcessorRegistrationDelegate.registerBeanPostProcessors</code>，首选注册了BeanPostProcessorChecker：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>其中BeanPostProcessorChecker类在Bean创建完，它会在Bean创建完后检查可在当前Bean上起作用的BeanPostProcessor个数与总的BeanPostProcessor个数，如果起作用的个数少于总数，则报出上面那句info信息。</p>
<p>在<code>PostProcessorRegistrationDelegate.registerBeanPostProcessors</code>分为四个阶段依次实例化并注册实现了PriorityOrdered的BeanPostProcessor、实现了Ordered的BeanPostProcessor、没实现Ordered的BeanPostProcessor，内部的BeanPostProcessors，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">       <span class="comment">// 从bean工厂获取postProcessorNames</span></span><br><span class="line">	String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register BeanPostProcessorChecker that logs an info message when</span></span><br><span class="line">	<span class="comment">// a bean is created during BeanPostProcessor instantiation, i.e. when</span></span><br><span class="line">	<span class="comment">// a bean is not eligible for getting processed by all BeanPostProcessors.</span></span><br><span class="line">       ...</span><br><span class="line">       beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">	sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">	registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></span><br><span class="line">	List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">           <span class="comment">// BeanPostProcessor早于一般bean实例化</span></span><br><span class="line">		BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">		orderedPostProcessors.add(pp);</span><br><span class="line">		<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">			internalPostProcessors.add(pp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">	registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now, register all regular BeanPostProcessors.</span></span><br><span class="line">	List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">		BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">		nonOrderedPostProcessors.add(pp);</span><br><span class="line">		<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">			internalPostProcessors.add(pp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></span><br><span class="line">	sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">	registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span></span><br><span class="line">	<span class="comment">// moving it to the end of the processor chain (for picking up proxies etc).</span></span><br><span class="line">	beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>需要注意的是，除了第一个阶段，其他阶段同一个阶段的BeanPostProcessor是在全部实例化完成以后才会统一注册到beanFactory的</code>，因此，<code>同一个阶段的BeanPostProcessor及其依赖的Bean在实例化的时候是无法享受到相同阶段先实例化的BeanPostProcessor的“服务”的，因为它们还没有注册</code>。</p>
<p>从上面调试与源代码分析，BeanPostProcessor的实例化与注册分为四个阶段，第一阶段applicationContext内置阶段、第二阶段priorityOrdered阶段、第三阶段Ordered阶段、第四阶段nonOrdered阶段。而BeanPostProcessor同时也是Bean，其注册之前一定先实例化。而且是分批实例化和注册，也就是属于同一批的BeanPostProcesser全部实例化完成后，再全部注册，不存在先实例化先注册的问题。而在实例化的时候其依赖的Bean同样要先实例化。<br><strong>因此导致一个结果就是，被PriorityOrdered BeanPostProcessor所依赖的Bean其初始化时无法享受到PriorityOrdered、Ordered、和nonOrdered BeanPostProcessor的服务。而被Ordered BeanPostProcessor所依赖的Bean无法享受Ordered、和nonOrdered的BeanPostProcessor的服务。最后被nonOrdered BeanPostProcessor所依赖的Bean无法享受到nonOrdered BeanPostProcessor的服务。</strong></p>
<p>由于InfrastructureAdvisorAutoProxyCreator的启动阶段是Ordered，因此我们需要确保没有任何priorityOrdered和Ordered的BeanPostProcessor直接或间接的依赖到shiroFilter，也就是依赖到我们的userService。</p>
<p>同时在PriorityOrdered接口的注解中也提到了该情况：</p>
<blockquote>
<p>注意：{@code PriorityOrdered}后处理器bean在<em>特殊阶段初始化，优于其他后处理器bean。这种巧妙的*会影响它们的自动装配行为：它们只会针对</em> bean自动装配，这些bean不需要急切初始化类型匹配。</p>
</blockquote>
<h4 id="4-1：-BeanPostProcessor在进行依赖的Bean注入时，根据Bean名称进行类型检查时导致的“误伤”"><a href="#4-1：-BeanPostProcessor在进行依赖的Bean注入时，根据Bean名称进行类型检查时导致的“误伤”" class="headerlink" title="4-1： BeanPostProcessor在进行依赖的Bean注入时，根据Bean名称进行类型检查时导致的“误伤”"></a>4-1： BeanPostProcessor在进行依赖的Bean注入时，根据Bean名称进行类型检查时导致的“误伤”</h4><p>问题貌似已查明，修改Configuration中所有PriorityOrdered和Ordered类型的PostBeanProcessor的Bean配置，使其不再依赖shiroFilter。再次启动，却发现仍然提前启动了shiroFilter-&gt;SecurityManager-&gt;authRealm-&gt;userService。</p>
<p>继续进行调试，查找shiroFilter具体的启动时机。发现在一个叫做dataSourceInitializerPostProcessor的BeanPostProcessor实例化的时候，在根据类型获得其依赖的参数时，对shiroFilter执行了初始化。导致后续SecurityManager-&gt;authRealm-&gt;userService统统提前初始化。但是在dataSourceInitializerPostProcessor之前的BeanPostProcessor却没有。经调试它们是否会导致shiroFilter初始化的区别在调用AbstractBeanFactory.isTypeMatch方法时出现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>&#123;</span><br><span class="line">	.....................</span><br><span class="line">	<span class="comment">// Check bean class whether we're dealing with a FactoryBean.</span></span><br><span class="line">	<span class="keyword">if</span> (FactoryBean.class.isAssignableFrom(beanType)) &#123;		<span class="comment">//判断名称对应的Bean是否是一个FactoryBean,若是FactoryBean才执行本句</span></span><br><span class="line">		<span class="keyword">if</span> (!BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">			<span class="comment">// If it's a FactoryBean, we want to look at what it creates, not the factory class.</span></span><br><span class="line">			beanType = getTypeForFactoryBean(beanName, mbd);</span><br><span class="line">			<span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;  </span><br><span class="line">	.....................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后进入AbstractAutowireCapableBeanFactory.getTypeForFactoryBean方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getTypeForFactoryBean(String beanName, RootBeanDefinition mbd) &#123;</span><br><span class="line">  ...</span><br><span class="line">		<span class="comment">// If not resolvable above and the referenced factory bean doesn't exist yet,</span></span><br><span class="line">		<span class="comment">// exit here - we don't want to force the creation of another bean just to</span></span><br><span class="line">		<span class="comment">// obtain a FactoryBean's object type...</span></span><br><span class="line">		<span class="keyword">if</span> (!isBeanEligibleForMetadataCaching(factoryBeanName)) &#123;			<span class="comment">//判断该bean对应的factoryBeanName是否已经初始化了,如果没有,就返回.如果有,则继续</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解说的很明确，如果名字对应的factoryBean所在的factoryBean工厂尚未解析并实例化，那就直接退出，不会强制创建该facotryBean工厂，也就是Configuration对应的Bean。再次调试，果然发现，在先前的<strong>BeanPostProcessor和DataSourceInitializerPostProcessor之间，存在一个lifecycleBeanPostProcessor，而LifecycleBeanPostProcessor是在我们的Configuration中显示定义的，因此，当lifecycleBeanPostProcessor启动时会导致Configuration实例化。</strong></p>
<p><strong>最终隐藏大BOSS查明，解决方案就简单了，将lifecycleBeanPostProcessor移出到一个单独的Configuration就好了。</strong></p>
<h3 id="5：总结"><a href="#5：总结" class="headerlink" title="5：总结"></a>5：总结</h3><h4 id="5-1：BeanPostProcessor启动顺序，以及其对于依赖的Bean的影响"><a href="#5-1：BeanPostProcessor启动顺序，以及其对于依赖的Bean的影响" class="headerlink" title="5-1：BeanPostProcessor启动顺序，以及其对于依赖的Bean的影响"></a>5-1：BeanPostProcessor启动顺序，以及其对于依赖的Bean的影响</h4><p><em>BeanPostProcessor的启动时机。分为四个阶段，第一阶段ApplicationContext内置阶段、第二阶段priorityOrdered阶段、第三阶段Ordered阶段、第四阶段nonOrdered阶段。</em></p>
<p><em>而BeanPostProcessor同时也是Bean，其注册之前一定先实例化。而且是分批实例化和注册，也就是属于同一批的BeanPostProcesser全部实例化完成后，再全部注册，不存在先实例化先注册的问题。而在实例化的时候其依赖的Bean同样要先实例化。</em></p>
<p><em>因此导致一个结果就是，被PriorityOrderedBeanPostProcessor所依赖的Bean其初始化以后无法享受到PriorityOrdered、Ordered、和nonOrdered的BeanPostProcessor的服务。而被OrderedBeanPostProcessor所依赖的Bean无法享受Ordered、和nonOrdered的BeanPostProcessor的服务。最后被nonOrderedBeanPostProcessor所依赖的Bean无法享受到nonOrderedBeanPostProcessor的服务。</em></p>
<h4 id="5-2：注意避免BeanPostProcessor启动时的“误伤”陷阱"><a href="#5-2：注意避免BeanPostProcessor启动时的“误伤”陷阱" class="headerlink" title="5-2：注意避免BeanPostProcessor启动时的“误伤”陷阱"></a>5-2：注意避免BeanPostProcessor启动时的“误伤”陷阱</h4><p><strong><code>BeanPostProcessor实例化时，自动依赖注入根据类型获得需要注入的Bean时，会将某些符合条件的Bean（FactoryBean并且其FactoryBeanFactory已经实例化的）先实例化，如果此FacotryBean又依赖其他普通Bean，会导致该Bean提前启动，造成误伤（无法享受部分BeanPostProcessor的后处理，例如典型的auto-proxy）。</code></strong></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">知源</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://crazyblitz.github.io/2019/08/24/BeanPostProcessor加载次序及其对Bean造成的影响/">https://crazyblitz.github.io/2019/08/24/BeanPostProcessor加载次序及其对Bean造成的影响/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://crazyblitz.github.io">知源博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring/">Spring</a><a class="post-meta__tags" href="/tags/BeanPostProcessor/">BeanPostProcessor</a></div><div class="social-share" data-disabled="google,facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/08/25/MySQL数据库SQL性能分析/"><i class="fa fa-chevron-left">  </i><span>MySQL数据库SQL性能分析</span></a></div><div class="next-post pull-right"><a href="/2019/08/22/Jackson常用注解学习/"><span>Jackson常用注解学习</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC80NTc5Ny8yMjMwOA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By 知源</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>
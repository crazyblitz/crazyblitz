<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="@Component注解派生性原理"><meta name="keywords" content="Spring,Spring注解属性抽象AnnotationAttributes,模式注解,Component注解派生性原理"><meta name="author" content="知源"><meta name="copyright" content="知源"><title>@Component注解派生性原理 | 知源博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?628e2ee31ce5c6697d1f5b263b262108";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"QSYLR3XYSH","apiKey":"1b2fe15d5912eb0d3de39fd5574cc460","indexName":"zhiyuan","hits":{"per_page":8},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Component注解的派生性原理"><span class="toc-number">1.</span> <span class="toc-text">@Component注解的派生性原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-模式注解"><span class="toc-number">1.0.1.</span> <span class="toc-text">1:模式注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Component派生性"><span class="toc-number">1.0.2.</span> <span class="toc-text">2:@Component派生性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Component注解派生性原理"><span class="toc-number">1.0.3.</span> <span class="toc-text">3:@Component注解派生性原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-思考扩展"><span class="toc-number">1.0.4.</span> <span class="toc-text">4:思考扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-多层次-Component派生性"><span class="toc-number">1.0.5.</span> <span class="toc-text">5:多层次@Component派生性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-组合注解"><span class="toc-number">1.0.5.1.</span> <span class="toc-text">3:组合注解</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">知源</div><div class="author-info__description text-center">一个程序员成长之路</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">111</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">87</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">21</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">知源博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">@Component注解派生性原理</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-04</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Spring/">Spring</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="Component注解的派生性原理"><a href="#Component注解的派生性原理" class="headerlink" title="@Component注解的派生性原理"></a>@Component注解的派生性原理</h2><h4 id="1-模式注解"><a href="#1-模式注解" class="headerlink" title="1:模式注解"></a>1:模式注解</h4><p><code>Stereotype Annotation</code>俗称为模式注解。Spring核心部分提供了几种内建的<code>模式注解</code>,如<em>@Component,@Repository,@Service,@Controller,@Configuration等</em>。这些注解均<code>派生于@Component</code>。</p>
<p>由于<em>Java语言规定,Annotation不允许继承,没有类派生子类的特性</em>,因此<em><code>Spring采用元标注的方式实现注解之间的派生</code></em>。</p>
<h4 id="2-Component派生性"><a href="#2-Component派生性" class="headerlink" title="2:@Component派生性"></a>2:@Component派生性</h4><p>@Component注解作为Spring容器托管的通用模式组件,<em>任何被@Component标注的组件均为组件扫描的候选对象。</em></p>
<blockquote>
<p>任何论证过程离不开所处的环境,需要开发人员具备一定工程意识,包括<strong>软件版本,特性范围,兼容情况等</strong>。因此,<em>论证过程从最低版本开始推导,逐步证明不同版本得提升和差异。</em></p>
</blockquote>
<h4 id="3-Component注解派生性原理"><a href="#3-Component注解派生性原理" class="headerlink" title="3:@Component注解派生性原理"></a>3:@Component注解派生性原理</h4><p>当<code>ClassPathBeanDefinitionScanner#doScan(String... basePackages)</code>调用时,它利用basePackages参数迭代执行的<code>findCandidateComponents(String basePackage)</code>,每次执行结果都生成候选的BeanDefinition集合,即candidates变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathBeanDefinitionScanner</span> <span class="keyword">extends</span> <span class="title">ClassPathScanningCandidateComponentProvider</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"> <span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">		Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">        <span class="comment">//获取候选的BeanDefinition集合</span></span><br><span class="line">		Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinitionHolder&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">			Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> beanDefinitions;</span><br><span class="line">	&#125;   </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而findCandidateComponents(String basePackage)从父类ClassPathScanningCandidateComponentProvider</p>
<p>中继承。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathScanningCandidateComponentProvider</span> <span class="keyword">implements</span> <span class="title">EnvironmentCapable</span>, <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"> <span class="function"><span class="keyword">public</span> Set&lt;BeanDefinition&gt; <span class="title">findCandidateComponents</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line">		Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinition&gt;();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取查询的package,并处理占位符情况$&#123;...&#125;,转换为ClassLoader资源(.class)搜索路径</span></span><br><span class="line">			String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class="line">					resolveBasePackage(basePackage) + <span class="string">'/'</span> + <span class="keyword">this</span>.resourcePattern;</span><br><span class="line">			Resource[] resources = <span class="keyword">this</span>.resourcePatternResolver.getResources(packageSearchPath);</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//resource迭代执行,当资源可读取时,获取该资源的MetadataReader对象</span></span><br><span class="line">			<span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">				...</span><br><span class="line">				<span class="keyword">if</span> (resource.isReadable()) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//包含了类和注解元信息读取方法</span></span><br><span class="line">						MetadataReader metadataReader = <span class="keyword">this</span>.metadataReaderFactory.getMetadataReader(resource);</span><br><span class="line">                        <span class="comment">//判断资源是否为候选的组件,通过excludeFilters和includeFilters进行判断</span></span><br><span class="line">						<span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">                            <span class="comment">//基于ASM,支持AnnotatedBeanDefinition接口</span></span><br><span class="line">							ScannedGenericBeanDefinition sbd = <span class="keyword">new</span> ScannedGenericBeanDefinition(metadataReader);</span><br><span class="line">							sbd.setResource(resource);</span><br><span class="line">							sbd.setSource(resource);</span><br><span class="line">                            <span class="comment">//判断BeanDefinition是否候选组件</span></span><br><span class="line">							<span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line">								...</span><br><span class="line">								candidates.add(sbd);</span><br><span class="line">							&#125;</span><br><span class="line">							...</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">return</span> candidates;</span><br><span class="line">	&#125;   </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine whether the given class does not match any exclude filter</span></span><br><span class="line"><span class="comment">	 * and does match at least one include filter.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> metadataReader the ASM ClassReader for the class</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> whether the class qualifies as a candidate component</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(MetadataReader metadataReader)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.excludeFilters) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tf.match(metadataReader, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.includeFilters) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tf.match(metadataReader, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">				<span class="keyword">return</span> isConditionMatch(metadataReader);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">     	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine whether the given bean definition qualifies as candidate.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;The default implementation checks whether the class is not an interface</span></span><br><span class="line"><span class="comment">	 * and not dependent on an enclosing class.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Can be overridden in subclasses.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanDefinition the bean definition to check</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> whether the bean definition qualifies as a candidate component</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(AnnotatedBeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">		AnnotationMetadata metadata = beanDefinition.getMetadata();</span><br><span class="line">		<span class="keyword">return</span> (metadata.isIndependent() &amp;&amp; (metadata.isConcrete() ||</span><br><span class="line">				(metadata.isAbstract() &amp;&amp; metadata.hasAnnotatedMethods(Lookup.class.getName()))));</span><br><span class="line">	&#125;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Register the default filter for &#123;<span class="doctag">@link</span> Component <span class="doctag">@Component</span>&#125;.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;This will implicitly register all annotations that have the</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> Component <span class="doctag">@Component</span>&#125; meta-annotation including the</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> Repository <span class="doctag">@Repository</span>&#125;, &#123;<span class="doctag">@link</span> Service <span class="doctag">@Service</span>&#125;, and</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> Controller <span class="doctag">@Controller</span>&#125; stereotype annotations.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Also supports Java EE 6's &#123;<span class="doctag">@link</span> javax.annotation.ManagedBean&#125; and</span></span><br><span class="line"><span class="comment">	 * JSR-330's &#123;<span class="doctag">@link</span> javax.inject.Named&#125; annotations, if available.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerDefaultFilters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(Component.class));</span><br><span class="line">		ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">					((Class&lt;? extends Annotation&gt;) ClassUtils.forName(<span class="string">"javax.annotation.ManagedBean"</span>, cl)), <span class="keyword">false</span>));</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">					((Class&lt;? extends Annotation&gt;) ClassUtils.forName(<span class="string">"javax.inject.Named"</span>, cl)), <span class="keyword">false</span>));</span><br><span class="line">		...</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下,ClassPathScanningCandidateComponentProvider构造参数<code>useDefaultFilters为true</code>,并且显示传递给父类构造参数。该方法给属性<code>includeFilters</code>增添了<code>@Component</code>类型AnnotationTypeFilter的TypeFilter。</p>
<p>ClassPathBeanDefinitionScanner默认过滤器引入标注@Component,@Repository,@Service或者@Controller等类。<code>同理,它也能够标注所有@Component的&quot;派生&quot;注解。</code></p>
<blockquote>
<p><code>@Component</code>注解只包含一个value属性定义，所以其“派生”的注解也只能包含一个vlaue属性定义。 </p>
</blockquote>
<p>Dubbo实现<code>@Service</code>注解扫描实例:</p>
<blockquote>
<p><strong>ClassPathBeanDefinitionScanner</strong>允许自定义类型过滤规则。因此,Dubbo的@Service没有标注@Component情况下，通过scanner.addIncludeFilter(new AnnotationTypeFilter(Service.class))方式达到识别@Service标注类情况。但是没有使用<code>@Component</code>注解的派生性。</p>
</blockquote>
<p>Mybatis实现<code>@Mapper</code>注解扫描实例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathMapperScanner</span> <span class="keyword">extends</span> <span class="title">ClassPathBeanDefinitionScanner</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ClassPathMapperScanner</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(registry, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Configures parent scanner to search for the right interfaces. It can search</span></span><br><span class="line"><span class="comment">   * for all interfaces or just for those that extends a markerInterface or/and</span></span><br><span class="line"><span class="comment">   * those annotated with the annotationClass</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerFilters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> acceptAllInterfaces = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if specified, use the given annotation and / or marker interface</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.annotationClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">      addIncludeFilter(<span class="keyword">new</span> AnnotationTypeFilter(<span class="keyword">this</span>.annotationClass));</span><br><span class="line">      acceptAllInterfaces = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// override AssignableTypeFilter to ignore matches on the actual marker interface</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.markerInterface != <span class="keyword">null</span>) &#123;</span><br><span class="line">      addIncludeFilter(<span class="keyword">new</span> AssignableTypeFilter(<span class="keyword">this</span>.markerInterface) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">matchClassName</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      acceptAllInterfaces = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (acceptAllInterfaces) &#123;</span><br><span class="line">      <span class="comment">// default include filter that accepts all classes</span></span><br><span class="line">      addIncludeFilter(<span class="keyword">new</span> TypeFilter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exclude package-info.java</span></span><br><span class="line">    addExcludeFilter(<span class="keyword">new</span> TypeFilter() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String className = metadataReader.getClassMetadata().getClassName();</span><br><span class="line">        <span class="keyword">return</span> className.endsWith(<span class="string">"package-info"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(AnnotatedBeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> beanDefinition.getMetadata().isInterface() &amp;&amp; beanDefinition.getMetadata().isIndependent();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processBeanDefinitions</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; beanDefinitions)</span> </span>&#123;</span><br><span class="line">    GenericBeanDefinition definition;</span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">      definition = (GenericBeanDefinition) holder.getBeanDefinition();</span><br><span class="line">     </span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">      <span class="comment">//复杂对象构建考虑使用FactoryBean接口           </span></span><br><span class="line">      <span class="comment">// the mapper interface is the original class of the bean</span></span><br><span class="line">      <span class="comment">// but, the actual class of the bean is MapperFactoryBean</span></span><br><span class="line">     <span class="comment">//添加泛型参数         </span></span><br><span class="line">           definition.getConstructorArgumentValues().addGenericArgumentValue(definition.getBeanClassName());</span><br><span class="line">     <span class="comment">// issue #59</span></span><br><span class="line">      definition.setBeanClass(<span class="keyword">this</span>.mapperFactoryBean.getClass());</span><br><span class="line"></span><br><span class="line">      definition.getPropertyValues().add(<span class="string">"addToConfig"</span>, <span class="keyword">this</span>.addToConfig);</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-思考扩展"><a href="#4-思考扩展" class="headerlink" title="4:思考扩展"></a>4:思考扩展</h4><p>思考1:利用<code>ClassPathBeanDefinitionScanner</code>类配合<code>includeFilters</code>和<code>excludeFilters</code>定制化批量注册Bean到Spring容器中。常常可以通过注解方式来包含或者排除候选类。</p>
<p><em>TypeFilter常用实现</em></p>
<ul>
<li>AnnotationTypeFilter:注解类型过滤器</li>
<li>AssignableTypeFilter:确定此对象表示的类或者接口是否为给定类或者接口相同。</li>
<li>RegexPatternTypeFilter:判断给定的类名是否符合指定正则表达式。</li>
</ul>
<p>思考2:复杂对象构建考虑使用<code>FactoryBean</code>实现类。</p>
<p>思考3:如果是读取类和注解信息可以考虑基于ASM或者反射,使用方式往下可以获取。当获取已加载的类信息可以考虑反射(<code>反射大前提是被反射的Class被ClassLoader加载</code>),ASM用于不需要将类路径package下的Class全部加载,Spring应用指定Java package扫描Spring模式注解时,利用的就是基于ASM方式获取类或者注解信息。基于ASM获取会获得更大性能。</p>
<p>思考4:资源读取考虑使用<code>ResourcePatternResolver</code>,这个对象的获取可以通过Spring提供的工具类</p>
<p><code>ResourcePatternUtils.getResourcePatternResolver(resourceLoader)</code>。在使用的时候,考虑处理</p>
<p><code>占位符${...}</code>的情况,注意资源是否可读。</p>
<h4 id="5-多层次-Component派生性"><a href="#5-多层次-Component派生性" class="headerlink" title="5:多层次@Component派生性"></a>5:多层次@Component<code>派生性</code></h4><p>(1):具体发展过程不再细说,详解请看<code>SpringBoot编程思想这本书</code>。其多层次@Component注解派生性构建在<code>Spring4.x</code>。其核心处理类为<code>AnnotationMetadataReadingVisitor</code>,<code>其采用递归的方式查找元注解</code>。</p>
<p>(2):Spring中,MetadataReader接口唯一实现非公开类<code>SimpleMetadataReader</code>。可以通过<br><code>SimpleMetadataReaderFactory(ASM字节码操作)</code>和<code>CachingMetadataReaderFactory</code>获取。</p>
<p>其中在SimpleMetadataReader实现上看,<code>ClassMetadataReadingVisitor</code>和<code>AnnotationMetadataReadingVisitor</code>分别是<code>ClassMetadatta</code>和<code>AnnotationMetadata</code>实现类。</p>
<p>由于<code>ClassPathBeanDefinitionScanner</code>在寻找候选的BeanDefinition过程中,将指定basePackage参数下</p>
<p>的*.class资源进行元信息解析,也就是<code>ClassMetadata</code>和<code>AnnotationMetadata</code>对象。</p>
<p><code>AnnotationMetadataReadingVisitor</code>实现上使用了<code>AnnotationAttributesReadingVisitor</code>，该类主要实现方法是<code>visitEnd()</code>。<em>Spring2.5实现未采用层次递归获取Annotation[],所以仅支持单层次的@Component派生。Spring3.x实现仅两层@Component派生。Spring4.x开始采用递归方式查找元注解。</em></p>
<p>(3):<strong><code>思考扩展</code></strong></p>
<ul>
<li><code>考虑使用ASM的方式读取类或者注解相关信息。(不需要全部将指定路径下的类加载)</code><ul>
<li>MetadataReaderFactory:获取MetadataReader工厂<ul>
<li>SimpleMetadataReaderFactory:简单获取MetadataReader工厂实现<ul>
<li>ClassReader:基于ASM读取类相关信息,公开类,不建议单独使用。</li>
<li>AnnotationMetadataReadingVisitor:基于ASM读取注解元数据相关信息,不建议单独使用。</li>
<li>MethodMetadataReadingVisitor:基于ASM读取方法相关信息,不建议单独使用。</li>
</ul>
</li>
<li>CachingMetadataReaderFactory:继承SimpleMetadataReaderFactory,增加缓存MetadataReader资源功能。</li>
</ul>
</li>
<li>MetadataReader:获取访问类和注解相关信息。通过MetadataReaderFactory获取。<ul>
<li>Resource getResource():获取类文件资源引用</li>
<li>ClassMetadata getClassMetadata():读取基础类的基本元数据</li>
<li>AnnotationMetadata getAnnotationMetadata():读取底层类完整注解元数据,包含注解方法的注解元数据。</li>
</ul>
</li>
</ul>
</li>
<li><code>考虑使用反射的方式读取类或者注解相关信息(比较费时而且该类必须被ClassLoader加载)</code><ul>
<li>StandardClassMetadata:基于反射读取类元数据,可建议单独使用。</li>
<li>StandardAnnotationMetadata:基于反射读取注解元数据,可建议单独使用</li>
<li>StandardMethodMetadata:基于反射读取方法元数据,可建议单独使用</li>
</ul>
</li>
<li><code>考虑使用Spring内部支持的有用工具类</code>,都是来自于spring-core包中。<code>多使用spring内建API,学习他们的长处。</code><ul>
<li>ClassUtils:类工具类</li>
<li>CollectionUtils:集合工具类</li>
<li>NumberUtils:Number工具类</li>
<li>MimeTypeUtils:媒体类型工具类</li>
<li>IdGenerator:Id生成器</li>
<li>StringUtils:字符串工具类</li>
<li>ResourceUtils:资源工具类</li>
<li>ReflectionUtils:反射工具类</li>
<li>MethodIntrospector:方法自省工具类(EventListenerMethodProcessor#processBean中有使用)</li>
<li>PatternMatchUtils:正则资源匹配工具类</li>
<li>ObjectUtils:对象工具类</li>
</ul>
</li>
</ul>
<h5 id="3-组合注解"><a href="#3-组合注解" class="headerlink" title="3:组合注解"></a>3:组合注解</h5><p><code>组合注解</code>指某个注解”元标注”一个或多个其他注解，其目的在于将这些关联的注解行为组合成单个自定义注解。</p>
<p>Spring Framework的类加载通过ASM实现，如<code>ClassReader</code>。相对于ClassLoader体系，Spring ASM更为底层，读取的是<code>类资源</code>，直接操作其中的字节码，获取相关元信息。如<code>MetadataReader接口</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Simple facade for accessing class metadata,</span></span><br><span class="line"><span class="comment"> * as read by an ASM &#123;<span class="doctag">@link</span> org.springframework.asm.ClassReader&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MetadataReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the resource reference for the class file.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Resource <span class="title">getResource</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Read basic class metadata for the underlying class.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">ClassMetadata <span class="title">getClassMetadata</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Read full annotation metadata for the underlying class,</span></span><br><span class="line"><span class="comment">	 * including metadata for annotated methods.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">AnnotationMetadata <span class="title">getAnnotationMetadata</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AnnotationMetadataReadingVisitor</code>同时实现了ClassMetadata及AnnotationMetadata。因此，元注解的实现集中到<code>AnnotationMetadataReadingVisitor</code>和<code>AnnotationAttributesReadingVisitor</code>之中。</p>
<p><code>MetadataReader</code>对象通过<code>MetadataReaderFactory</code>对象获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Factory interface for &#123;<span class="doctag">@link</span> MetadataReader&#125; instances.</span></span><br><span class="line"><span class="comment"> * Allows for caching a MetadataReader per original resource.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> SimpleMetadataReaderFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> CachingMetadataReaderFactory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MetadataReaderFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Obtain a MetadataReader for the given class name.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> className the class name (to be resolved to a ".class" file)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> a holder for the ClassReader instance (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> IOException in case of I/O failure</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">MetadataReader <span class="title">getMetadataReader</span><span class="params">(String className)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Obtain a MetadataReader for the given resource.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> resource the resource (pointing to a ".class" file)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> a holder for the ClassReader instance (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> IOException in case of I/O failure</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">MetadataReader <span class="title">getMetadataReader</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体某个注解的<code>元注解</code>信息则通过<code>getMetaAnnotationTypes(String)</code>方法查询。</p>
<p><code>AnnotationMetadata</code>实现<code>AnnotationMetadataReadingVisitor(ASM实现)</code>，<code>StandardAnnotationMetadata(反射)</code>。</p>
<ul>
<li>注解元信息抽象:<code>AnnotationMetadata</code><ul>
<li><code>AnnotationMetadataReadingVisitor</code><ul>
<li><code>AnnotationAttributesReadingVisitor</code>(递归查找元注解)</li>
</ul>
</li>
</ul>
</li>
<li>类元信息抽象:<code>ClassMetadata</code></li>
<li>方法元信息抽象:<code>MethodMetadata</code></li>
<li>注解属性抽象:<code>AnnotationAttributes</code></li>
<li>属性环境抽象:<code>Environment</code></li>
<li>属性文件抽象:<code>PropertySource</code></li>
<li>元信息读取抽象:<code>MetadataReader</code><ul>
<li>通过<code>MetadataReaderFactory</code>获取</li>
</ul>
</li>
</ul>
<p>方法内省:<code>MethodIntrospector</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Method, EventListener&gt; annotatedMethods = <span class="keyword">null</span>;</span><br><span class="line">   annotatedMethods = MethodIntrospector.selectMethods(targetType,</span><br><span class="line">			(MethodIntrospector.MetadataLookup&lt;EventListener&gt;) method -&gt;</span><br><span class="line">					AnnotatedElementUtils.findMergedAnnotation(method, EventListener.class));</span><br></pre></td></tr></table></figure>

<p>注解工具类:<code>AnnotationUtils</code></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">知源</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://crazyblitz.github.io/2019/08/04/Component注解派生性原理/">https://crazyblitz.github.io/2019/08/04/Component注解派生性原理/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://crazyblitz.github.io">知源博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring/">Spring</a><a class="post-meta__tags" href="/tags/Spring注解属性抽象AnnotationAttributes/">Spring注解属性抽象AnnotationAttributes</a><a class="post-meta__tags" href="/tags/模式注解/">模式注解</a><a class="post-meta__tags" href="/tags/Component注解派生性原理/">Component注解派生性原理</a></div><div class="social-share" data-disabled="google,facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/08/05/Git分支的创建与合并/"><i class="fa fa-chevron-left">  </i><span>Git分支的创建与合并</span></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC80NTc5Ny8yMjMwOA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By 知源</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>